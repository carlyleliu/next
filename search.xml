<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPUIdle</title>
      <link href="/next/2024/Debug/LinuxCpuIdle/"/>
      <url>/next/2024/Debug/LinuxCpuIdle/</url>
      
        <content type="html"><![CDATA[<h1 id="cpu-idle实现原理">cpu idle实现原理</h1><p>通过wfi或wfe指令进入low-power-state。在low-power-state下cpu core保持上电状态，但其大部分时钟停止或者进入时钟门限。这意味着core的绝大部分都处于static state，唯一消耗的功率是用于寻找中断唤醒条件的泄漏电流和少量逻辑时钟。进入low-power-state后将暂停当前的工作直到某个中断或event事件发生会退出low-power-state进入正常运行state。</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d340abd8310.png" alt="cpuidle1.png"><figcaption>cpuidle1.png</figcaption></figure><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d340d3ac355.png" alt="cpuidle2.png"><figcaption>cpuidle2.png</figcaption></figure><p>其唤醒wfi或wfe的interrupt或者event请参考《The AArch64 System Level Programmers’ Model 》D1.6 Mechanisms for entering a low-power state</p><p><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d3410fd3e5d.png"></p><span id="more"></span><h1 id="cpu-idle代价">cpu idle代价</h1><p>cpu的状态被称为C状态，不同的C状态功耗不同，其中C0是normal state，正常运行状态就是C0状态，其他各state退出到C0状态所需的时间也不同，以下是一个笔记本的CPU各C状态的功耗和退出latency。</p><table><thead><tr class="header"><th></th><th>C1</th><th>C2</th><th>C3</th></tr></thead><tbody><tr class="odd"><td>Exit latency (µs)</td><td>1</td><td>1</td><td>57</td></tr><tr class="even"><td>Power consumption (mW)</td><td>1000</td><td>500</td><td>100</td></tr></tbody></table><p>cpu idle的设计目的是降低功耗，但是进入cpu idle是有代价的，这里面会涉及entry_latency以及对应的能量消耗，退出low-power-state也需要时间exit_latency以及对应的能量消耗，如果cpu待在low_power_state的时间很短那么可能进入和退出的能量消耗比cpu空转都高，而且这期间还导致cpu无法处理其他事情，导致系统性能下降。</p><p>这里的代价主要是两个指标：</p><ul><li>功耗</li><li>latency</li></ul><p>要求功耗越低那么就需要idle深度越深（关闭的额模块越多）那么从low_power_state到nomal state所花的时间就越久，也就是功耗和latency是互相矛盾的。</p><p>在Linux系统中，cpuidle 子系统提供了多种策略来平衡功耗和延迟的选择，我们在使用中只要关注这些策略的倾向以及参数设计即可。</p><h1 id="linux-cpuidle子系统">Linux cpuidle子系统</h1><h2 id="框架">框架</h2><p><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d3414c8ed42.png"></p><ul><li>scheduler模块：位于kernel.c中，负责实现idle状态的选择、idle的进入等等</li><li>cpuidle core模块：cpuidle core抽象出cpuidle device、cpuidle driver、cpuidle governor三个实体<ul><li>以<span class="exturl" data-url="aHR0cHM6Ly96aGlkYS56aGlodS5jb20vc2VhcmNoP3E9JUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JnpoaWRhX3NvdXJjZT1lbnRpdHkmaXNfcHJldmlldz0x">函数调用<i class="fa fa-external-link-alt"></i></span>的形式，向上层sched模块提供接口</li><li>以sysfs的形式，向用户空间提供接口</li><li>向下层的cpuidle drivers模块，提供统一的driver注册和管理接口</li><li>向下层的cpuidle governors模块，提供统一的governor注册和管理接口</li></ul></li><li>puidle governors模块：提供多种idle的策略，比如menu/ladder/teo/haltpoll。位于governors/目录下</li><li>cpuidle drivers模块：负责idle机制的实现，即：如何进入idle状态，什么条件下会退出</li></ul><h2 id="cpu-idle策略">CPU Idle策略</h2><p>其实idle策略的基本原则很简单就是在系统容忍的最大latency内选择休眠最深的即可，但是实际上这是很难准确评估的，系统中大量的中断、event、timer各种不确定的事件随时可能到来，接下来cpu要进入idle状态多长时间很难评估出来。</p><p>governors模块提供了四种策略，分别是menu、ladder、teo和haltpoll。</p><ul><li>menu<ul><li><p>任务1，menu governor从如下几个方面去达成：</p><p>menu governor用于tickless system，简化处理，menu将“距离下一个tick来临的时间（由next timer event测量，简称next_timer_us）”作为基础的predicted_us。</p><p>当然，这个基础的predicted_us是不准确的，因为在这段时间内，随时都可能产生除next timer event之外的其它wakeup event。为了使预测更准确，有必要加入一个校正因子（correction factor），该校正因子基于过去的实际predicted_us和next_timer_us之间的比率，例如，如果wakeup event都是在预测的next timer event时间的一半时产生，则factor为0.5。另外，为了更精确，menu使用动态平均的factor。</p><p>另外，对不同范围的next_timer_us，correction factor的影响程度是不一样的。例如期望50ms和500ms的next timer event时，都是在10ms时产生了wakeup event，显然对500ms的影响比较大。如果计算平均值时将它们混在一起，就会对预测的准确性产生影响，所以计算correction factor的数据时，需要区分不同级别的next_timer_us。同时，系统是否存在io wait，对factor的敏感度也不同。基于这些考虑，menu使用了一组factor（12个），分别用于不同next_timer_us、不同io wait的场景下的的校正。</p><p>最后，在有些场合下，next_timer_us的预测是完全不正确的，如存在固定周期的中断时（音频等）。这时menu采用另一种不同的预测方式：统计过去8次停留时间的标准差（stand deviation），如果小于一定的门限值，则使用这8个停留时间的平均值，作为预测值。</p></li><li><p>任务2，延迟容忍度（latency_req）的估算，menu综合考虑了两种因素，如下：</p><p>由pm qos获得的，系统期望的CPU和DMA的延迟需求。这是一个硬性指标。</p><p>基于这样一个经验法则：越忙的系统，对系统延迟的要求越高，结合任务1中预测到的停留时间（predicted_us），以及当前系统的CPU平均负荷和iowaiters的个数（get_iowait_load函数获得），算出另一个延迟容忍度，计算公式（这是一个经验公式）为： predicted_us / (1 + 2 * loadavg +10 * iowaiters) 这个公式反映的是退出延迟和预期停留时间之间的比例，loadavg和iowaiters越大，对退出延迟的要求就越高奥。</p><p>最后，latency_req的值取上面两个估值的最小值。</p></li></ul></li><li><p>TEO（Timer Events Oriented）</p><p>面向计时器事件 (TEO) 的governor 是tickless systems的替代governor ，它遵循与menu调度器相同的基本策略：始终尝试找到适合当前条件的最深空闲状态。然而，它采用了一种不同的方法来解决这个问题。</p><p>首先，它不使用睡眠时间修正因子，而是尝试将观察到的空闲持续时间值与可用的空闲状态进行关联，并利用这些信息选择最有可能“匹配”即将到来的CPU空闲间隔的空闲状态。其次，它完全不考虑过去在给定CPU上运行的任务，这些任务现在正在等待一些I/O操作完成（没有保证它们在重新变为可运行状态时会在同一CPU上运行），而且其中的模式检测代码避免了计时器唤醒的影响。它还仅使用小于当前时间与最近计时器（不包括调度器滴答）之间的时间间隔的空闲持续时间值。</p><p>具体算法比较复杂请参考《https://docs.kernel.org/admin-guide/pm/cpuidle.html》，，，略</p></li><li><p>haltpoll</p><p>适用于虚拟机系统，略</p></li><li><p>ladder</p><p>是一种更为简单的调度策略，它通过一个类似阶梯的机制来选择 CPU 的空闲状态。CPU 会按顺序尝试不同的空闲状态，从最浅的状态到最深的状态。</p></li></ul><h2 id="pm-qos">PM QoS</h2><h3 id="pm-qos有哪些指标">PM QoS有哪些指标</h3><p>针对这个指标PM QoS有一个专门的名词：constraint(约束)，其实也比较好理解，可以看做其他模块对PM的诉求和限制，目前PM QoS针对这些指标分为两类：一类是系统级的，包括：cpu&amp;dma latency、network latency、network throughput和memory bandwidth，定义在kernel/power/qos.c中（在最新的kernel-5.4版本中，这一类constraint从4个缩减到只有cpu&amp;dma latency这一个，同时增加了一类cpufreq的constraint）</p><h3 id="这些指标该如何去满足呢">这些指标该如何去满足呢</h3><ul><li>需求方：如进程、drivers等，它们根据自身的特性提出一系列需求（如cpu&amp;dma latency等）</li><li>框架层：PM QoS framework对这些需求进行汇总，根据实际情况，计算出来极值（比如cpu&amp;dma的latency不能小于xx等）</li><li>执行方：执行方需要确保自身的行为可以满足这些需求，这里的执行方很容易想到都是电源管理相关的，比如cpuidle，需要确保cpuidle等级满足cpu&amp;dma latency的最低要求等等，可以参考下第三章的实例</li></ul><p><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d341981433b.png"></p><h1 id="相关参数说明">相关参数说明</h1><p>先确认当前系统采用的governors：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/devices/system/cpu</span><br><span class="line"><span class="comment"># cat cpuidle/current_driver</span></span><br><span class="line">psci_idle</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cat cpuidle/current_governor_ro</span></span><br><span class="line">menu</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>当前采用的governors是menu调度。</p><h2 id="dts里的参数">dts里的参数</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">idle-states {</span><br><span class="line">entry-method = <span class="string">"arm,psci-0.2"</span>;</span><br><span class="line">CPU_SLEEP_0: cpu-sleep-0 {</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = &lt;0x0010000&gt;;</span><br><span class="line">local-timer-stop;</span><br><span class="line">entry-latency-us = &lt;5000&gt;;</span><br><span class="line">exit-latency-us = &lt;5000&gt;;</span><br><span class="line">min-residency-us = &lt;15000&gt;;</span><br><span class="line">};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>entry-latency-us是进入cpuidle需要的时间</li><li>exit-latency-us是离开cpuidle所需的时间</li><li>min-residency-us：这个是idle指定cpu进入idle的最小时间，当小于这个时间则不划算，linux cpuidle子系统的menu、teo等算法要参考此参数来决定cpu要不要进入idle状态的。</li><li>local-timer-stop：指示在进入cpuidle时是否关闭本地timer</li><li>psci-suspend-param：PSCI传递参数，存储了power_state信息，对于cpuidle来说bit24用于区分哪种掉电方式</li></ul><p>cpu进入idle后需要不定期通过tick进行唤醒，但是如果在idle-state节点中定义了local-timer-stop属性就会导致cpu本地的timer被关闭，出现没有外部中断来临就无法退出中断的情况，这种情况下就需要将一个timer变为broadcast-timer，用来一段时间后让cpu退出idle状态。</p><h2 id="sysfs文件节点">sysfs文件节点</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/</span></span><br><span class="line">driver/  state0/  state1/</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/</span></span><br><span class="line">above      desc       latency    power      s2idle/    usage</span><br><span class="line">below      <span class="built_in">disable</span>    name       residency  time</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/above</span></span><br><span class="line">43482</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/below</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/desc</span></span><br><span class="line">cpu-sleep-0</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/disable</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/latency</span></span><br><span class="line">10000</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/name</span></span><br><span class="line">cpu-sleep-0</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/power</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/residency</span></span><br><span class="line">25000</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/time</span></span><br><span class="line">61705105</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/usage</span></span><br><span class="line">48089</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/usage</span></span><br><span class="line">48415</span><br><span class="line"><span class="comment"># cat sys/devices/system/cpu/cpu0/cpuidle/state1/usage</span></span><br><span class="line">48643</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><ul><li>above, below ：cpuidle未满足期望休眠的次数，如提前唤醒</li><li>desc, name：cpuidle的名称</li><li>latency : 进入和退出idle的总时间，由DTS中 entry-latency-us和exit-latency-us相加得来</li><li>residency ：最小驻留时间， 由DTS中的min-residency-us解析而来</li><li>time：停留cpuidle state中的累计时间</li><li>usage：停留在cpuidle state中的累计次数</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2NwdWlkbGVfb3ZlcnZpZXcuaHRtbA==">http://www.wowotech.net/pm_subsystem/cpuidle_overview.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2NwdWlkbGVfY29yZS5odG1s">http://www.wowotech.net/pm_subsystem/cpuidle_core.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2NwdWlkbGVfYXJtNjQuaHRtbA==">http://www.wowotech.net/pm_subsystem/cpuidle_arm64.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2NwdWlkbGVfbWVudV9nb3Zlcm5vci5odG1s">http://www.wowotech.net/pm_subsystem/cpuidle_menu_governor.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次UAC 丢包问题分析过程</title>
      <link href="/next/2024/Debug/LinuxperfdebugExample/"/>
      <url>/next/2024/Debug/LinuxperfdebugExample/</url>
      
        <content type="html"><![CDATA[<h1 id="实验">实验</h1><p>测试发现period_size=512或者256时均不发生丢包，于是做以下实验：</p><table><thead><tr class="header"><th>sampling rate</th><th>channel</th><th>bit depth</th><th>period_size</th><th>package size</th><th>是否丢包</th></tr></thead><tbody><tr class="odd"><td>48k</td><td>2</td><td>16bit</td><td>1024</td><td>4096Byte</td><td>丢包</td></tr><tr class="even"><td>48k</td><td>1</td><td>16bit</td><td>1024</td><td>2048Byte</td><td>丢包</td></tr><tr class="odd"><td>48k</td><td>2</td><td>16bit</td><td>512</td><td>2048Byte</td><td>不丢包</td></tr><tr class="even"><td>48k</td><td>4</td><td>16bit</td><td>512</td><td>4096Byte</td><td>不丢包</td></tr></tbody></table><p>通过实验发现，丢包与period_size相关与package size无关。</p><span id="more"></span><h1 id="通过perf-top分析">通过perf top分析</h1><p>通过perf top查看系统和aplay中哪些函数占比高:</p><p><img src="https://lsky.carlyleliu.vip/i/2024/08/31/66d33d376e043.png"></p><p>这里可以看到有大量的spin_lock函数占用比较高的cpu时间。猜测系统哪里可能有自旋锁使用不当。但是这里无法看到函数调用栈，不知道哪里调用的spinlock占用cpu资源多。</p><h1 id="通过火焰图分析">通过火焰图分析</h1><p>查看ftrace </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /sys/kernel/debug/</span><br><span class="line"><span class="built_in">cd</span> /sys/kernel/debug/tracing/</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on</span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> _raw_spin_unlock_irq &gt; set_ftrace_filter</span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer </span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> 1 &gt; options/func_stack_trace</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 过滤下pid, 因为调用_raw_spin_unlock_irq 的线程比较多</span></span><br><span class="line"><span class="built_in">echo</span> &lt;pid&gt; &gt; set_ftrace_pid</span><br><span class="line"> </span><br><span class="line">&gt; trace <span class="comment">#清除 trace 内容</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; tracing_on &amp;&amp; <span class="built_in">sleep</span> 1 &amp;&amp; <span class="built_in">echo</span> 0 &gt; tracing_on</span><br><span class="line"><span class="built_in">cat</span> trace</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="使用function_graph功能">使用function_graph功能</h2><p>需要内核开启FUNCYTION_PROFILER选项。 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;  ./function_profile_enabled</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 等过2分钟再查看统计 </span></span><br><span class="line"><span class="built_in">cat</span> ./trace_stat/function0 | <span class="built_in">head</span> -100</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="使用火焰图分析">使用火焰图分析</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">perf record -F 5000 -p &lt;pid&gt; -g -- <span class="built_in">sleep</span> 60</span><br><span class="line"></span><br><span class="line">record：表示采集系统事件，没有采用 -e 执行采集事件，则默认采集 cycles（即 CPU clock 周期）。</span><br><span class="line"> </span><br><span class="line">-F 5000：指定采样频率为 5000Hz（每秒5000次），如果 5000次都返回同一个函数名, 那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。</span><br><span class="line"> </span><br><span class="line">-p &lt;pid&gt;：指定进程号，对某一个进程分析。</span><br><span class="line"> </span><br><span class="line">-g：表示记录调用栈。</span><br><span class="line"> </span><br><span class="line"><span class="built_in">sleep</span> 60：表示持续 60 秒</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用下面命令来简单查看 perf.data内容</span></span><br><span class="line">perf report -n --stdio</span><br></pre></td></tr></tbody></table></figure><p>生成火焰图：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成折叠后的调用栈</span></span><br><span class="line">perf script -i perf.data &amp;&gt; perf.unfold</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将perf.unfold 用adb pull出来，在服务器上生成火焰图</span></span><br><span class="line"><span class="comment"># 生成火焰图</span></span><br><span class="line">./FlameGraph/stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 生成svg</span></span><br><span class="line">./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d33e3f4374a.png"></p><p>这里可以看到__snd_pcm_lib_xfer这个函数里的spinlock占用比较高的cpu资源。</p><h2 id="通过打印时间戳分析">通过打印时间戳分析</h2><p>前面发现__snd_pcm_lib_xfer这个函数耗时很久于是打印这个函数的耗时信息：</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d33ee199eea.png" alt="perf3.png"><figcaption>perf3.png</figcaption></figure><p>蓝色为period_size=1024时__snd_pcm_lib_xfer函数运行时间单位为ns，平均下来就是一个period_size间隔时间为1024 * 1000 / 48000 = 21ms</p><p>橙色为period_size=512时__snd_pcm_lib_xfer函数运行时间单位为ns，平均下来就是一个period_size间隔时间为512* 1000 / 48000 = 11ms</p><p>__snd_pcm_lib_xfer这个函数里有多段自旋锁，逐个打印看是否有不合理的值，最终发现大部分sleep都在schedule_timeout这个函数里，schedule_timeout的sleep的时间计算方式有问题，对比kernel6.6已经修复了sleep时间的计算方式，但是这里也不会导致丢包因为schedule_timeout函数的sleep会被各种event打断，这里代码中是sleep 10s，但是实际sleep 20ms（对于period_size=1024情况下）就被uac里的signal打断返回而提前结束。</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d33f2d34516.png" alt="perf4.png"><figcaption>perf4.png</figcaption></figure><p>schedule_timeout函数运行时间为：</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d33f75357dd.png" alt="perf5.png"><figcaption>perf5.png</figcaption></figure><p>__snd_pcm_lib_xfer函数执行时间21ms其中20多ms都在schedule_timeout（没有在自旋锁内）里。到这里基本上看不出spinlock有什么问题。对比period_size=512差别只是schedule_timeout中sleep的时间长短不一致。同时根据perf top中的耗时函数看，耗时最长的是cpuidle_enter_state这个函数，怀疑是跟cpuidle相关。</p><h1 id="cpuidle">cpuidle</h1><h2 id="关闭cpuidle">关闭cpuidle</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/devices/system/cpu/cpu0/cpuidle/state1/disable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/devices/system/cpu/cpu1/cpuidle/state1/disable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/devices/system/cpu/cpu2/cpuidle/state1/disable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/devices/system/cpu/cpu3/cpuidle/state1/disable</span><br></pre></td></tr></tbody></table></figure><p>测试发现period_size=1024也不丢包了。</p><h2 id="修改cpuidle参数">修改cpuidle参数</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">idle-states {</span><br><span class="line">entry-method = <span class="string">"arm,psci-0.2"</span>;</span><br><span class="line">CPU_SLEEP_0: cpu-sleep-0 {</span><br><span class="line">compatible = <span class="string">"arm,idle-state"</span>;</span><br><span class="line">arm,psci-suspend-param = &lt;0x0010000&gt;;</span><br><span class="line">local-timer-stop;</span><br><span class="line">entry-latency-us = &lt;5000&gt;;</span><br><span class="line">exit-latency-us = &lt;5000&gt;;</span><br><span class="line">min-residency-us = &lt;15000&gt;;</span><br><span class="line">};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>entry-latency-us为进入cpuidle需要耗时的时间，axg上写的是5ms，这个值一看就不对，不可能耗时这么久，这个值要根据实际测试值来填写的</li><li>exit-latency-us为退出cpuidle需要耗时的时间，同样这里也是5ms，这个值肯定不是真实的值</li><li>min-residency-us为cpu至少要保持cpuidle状态的时间，也就是至少保持15ms，进入cpuidle才划算</li></ul><p>我们period_size=1024的时候会sleep20多ms那么这期间就大概率会触发cpuidle进入休眠，尝试将其改成30ms，发现丢包率降低，但还是会丢包（实际查看发现cpu仍然在进入cpuidle状态）。查询cpuidle相关实现<a href="http"></a>这些值是算法中的一个参数，详细的算法没去研究比较复杂，但是大致知道里面有一些权重因子，驱动不会严格按照min-residency-us来决定是否进入cpuidle而是会作用到一个权重因子，同时参考其他信息，有pm qos、以及中断、timer等相关信息来决定是否进入cpuidle状态。</p><p>这里将min-residency-us改成一个远大于period_size的值发现usb不丢包了。</p><p>反向验证下，为什么period_size=256或者512不丢包呢，查看cpuidle状态可以看到period_size=256或者512时不会进入cpuidle状态。</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d33fe0f2988.png" alt="perf6.png"><figcaption>perf6.png</figcaption></figure><p>schedule_timeout这里sleep的时间短，不足以触发进入cpuidle的条件。</p><h2 id="pm-qos">pm qos</h2><p>前面直接通过关闭cpuidle或者修改min-residency-us都是不合理的，min-residency-us参数正确的计算方法是cpu进入cpuidle和退出cpuidle是需要额外功耗的，那么就必须保证待在cpuidle里的时间要足够久至少为min-residency-us才能保证进入cpuidle是划算的（如果进入cpuidle后立马退出那么功耗不仅不能降低还会增加，期间还disabled cpu irq）。</p><p>更合理的做法是各driver对cpuidle模块提出要求，比如这里的uac，要通过pm qos对cpuidle提出要求我的传输包间隔是period size间隔时间，期间你不能进入休眠。追查代码发现实际上我们系统里有调用pm qos接口：</p><figure><img src="https://lsky.carlyleliu.vip/i/2024/09/01/66d3402a4c773.png" alt="perf7.png"><figcaption>perf7.png</figcaption></figure><p>但是实际测试发现cpu仍然不停的进入cpuidle，可能是多核smp导致的，跑arecord aplay的cpu核可以满足条件，但是其他核还是可以休眠，如果关闭其他核，cpu0就不进入cpuidle了，当前也不好做验证。</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encryption Algorithm</title>
      <link href="/next/2024/Embedded/EncryptionAlgorithm/"/>
      <url>/next/2024/Embedded/EncryptionAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="aes">AES</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUFCJTk4JUU3JUJBJUE3JUU1JThBJUEwJUU1JUFGJTg2JUU2JUEwJTg3JUU1JTg3JTg2">AES（Advanced Encryption Standard）<i class="fa fa-external-link-alt"></i></span>，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES。其密钥长度则可以是128，192或256比特。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/aes1.png"></p><span id="more"></span><ol type="1"><li><strong>SubBytes</strong>：通过一个非线性的替换函数，用查找表(S-Box)的方式把每个字节替换成对应的字节。</li><li><strong>ShiftRows</strong>：将矩阵中的每个横列进行循环式移位。</li><li><strong>MixColumns</strong>：每一列的四个字节通过线性变换互相结合得到新的4字节值.</li><li><strong>AddRoundKey</strong>：将输入与<strong>轮密钥</strong>进行XOR。</li></ol><p>以上就是AES加密中的一轮，不同密钥长度进行的轮数不同，128位10轮，192位12轮，256位14轮。</p><p>下面具体分析每一步</p><p><strong>SubBytes</strong></p><p>从一张拥有256个值的替换表(S-Box)中找出对应的值替换。S-Box是固定的，查找公式也是固定。具体可参见<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmlqbmRhZWxfUy1ib3g=">Rijndael S-box<i class="fa fa-external-link-alt"></i></span>。用此步骤混淆了输入内容。</p><p><strong>ShiftRows</strong></p><p>上一步处理后将16个字节分为4组，每组4字节。以字节位单位进行乱序处理，这种打乱是有规律的。如上图中输入第一组第一个字节移动到输出第一组第一个字节，输入第一组第二个字节移动到输入第二组第二个字节，输入第一组第三个字节移动到输出第三组第三个字节。</p><p><strong>MixColumns</strong></p><p>可以理解为采用固定的公式，将每组4个字节做运算得出另外4个字节。具体可参见<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmlqbmRhZWxfbWl4X2NvbHVtbnM=">Rijndael mix columns<i class="fa fa-external-link-alt"></i></span>。</p><p><strong>AddRoundKey</strong></p><p>与轮密钥做异或。</p><p><strong>轮密钥</strong></p><p>轮密钥是通过密钥编排得到：将原始输入的密钥（128位、192位、256位）作为输入，得到子密钥。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/aes2.png"></p><h1 id="rsa"><strong>RSA</strong></h1><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUlNBJUU1JThBJUEwJUU1JUFGJTg2JUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1">RSA加密算法<i class="fa fa-external-link-alt"></i></span>是一种非对称加密算法，是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。</p><p>RSA基于一个数学难题：</p><blockquote><p>对两个质数相乘容易，而将其合数分解很难的这个特点进行的加密算法。 n=p1*p2，已知p1、p2求n简单，已知n求p1、p2困难。</p></blockquote><p>例如很快就能算出53*61=3233, 但已知3233算出53和61恐怕得一会。目前已经算出最长RSA密钥长度为768位，目前使用的密钥长度一般为1024或2048位。</p><h2 id="密钥生成"><strong>密钥生成</strong></h2><p>RSA密钥由一对公私钥组成，这对密钥如何生成，里头都包含什么？密钥生成过程：</p><ol type="1"><li>随机选择两个不相等的质数p和q，N = pq</li><li>φ(n) = (p-1)(q-1)</li><li>随机选择一个整数E，条件是1&lt; E &lt; φ(n)，且E与φ(n) 互质</li><li>ED MOD φ(n) = 1 (扩展欧几里得算法)</li><li>将N和E封装成公钥，N和D封装成私钥</li></ol><table><thead><tr class="header"><th><strong>公钥</strong></th><th><strong>E 和 N</strong></th></tr></thead><tbody><tr class="odd"><td>私钥</td><td>D 和 N</td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td>加密</td><td>密文=明文^E % N</td></tr><tr class="even"><td>解密</td><td>明文=密文^D % N</td></tr></tbody></table><p>假设攻击者获取到公钥和密文，明文=密文^D % N。N=pq，由于大整数因数分解很难，所以攻击者无法获取到pq，同理也无法获取到D，如果有一天找到有效的方法计算出N=pq，那么RSA算法就被破解了。</p><h1 id="数字证书">数字证书</h1><ul><li><p>公钥加密，私钥解密——用于加密信息</p><p>如果你想把某个消息秘密的发给某人，那你就可以用他的公钥加密。因为只有他知道他的私钥，所以这消息也就只有他本人能解开，于是你就达到了你的目的。</p></li><li><p>私钥加密，公钥解密——用于数字签名</p><p>严格来说，这里说的私钥加密是用私钥对摘要进行加密，接收方可以用公钥解密，解密成功则可验证信息的发送者是私钥的拥有人。因为公钥是公开的，所以起不了保密信息的作用。</p><p>如果你想发布一个公告，需要一个手段来证明这确实是你本人发的，而不是其他人冒名顶替的。那你可以在你的公告开头或者结尾附上一段用你的私钥加密的内容，那所有其他人都可以用你的公钥来解密，看看解出来的内容是不是相符的。如果是的话，那就说明这公告确实是你发的—因为只有你的公钥才能解开你的私钥加密的内容，而其他人是拿不到你的私钥的。</p><p>但这仅仅做到了数字签名的第一部分：证明这消息是你发的。数字签名还有第二部分：证明这消息内容确实是完整的—也就是没有经过任何形式的篡改（包括替换、缺少、新增）。</p><p>要做到数字签名的第二部分，需要做的是：把你公告的原文做一次哈希（md5或者sha1都行），然后用你的私钥加密这段哈希作为签名，并一起公布出去。当别人收到你的公告时，他可以用你的公钥解密你的签名，如果解密成功，并且解密出来的哈希值确实和你的公告原文一致，那么他就证明了两点：这消息确实是你发的，而且内容是完整的。</p></li><li><p>对公钥进行认证——数字证书</p><p>究竟什么叫认证，说白了，就是对公钥做签名，</p><p>黑客可以替换你的公钥，然后用他的私钥做数字签名给你发信息，而你用黑客伪造的公钥能成功验证，会让你误认为消息来源没变。</p><p>这种情况下需要CA(证书中心certificate authority)对公钥进行认证。证书中心用自己的私钥，对信息发送者的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p></li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sMnguZ2l0Ym9va3MuaW8vdW5kZXJzdGFuZGluZy1jcnlwdG9ncmFwaHkvY29udGVudC9kb2NzL2NoYXB0ZXItMS9hZXMuaHRtbA==">https://l2x.gitbooks.io/understanding-cryptography/content/docs/chapter-1/aes.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sMnguZ2l0Ym9va3MuaW8vdW5kZXJzdGFuZGluZy1jcnlwdG9ncmFwaHkvY29udGVudC9kb2NzL2NoYXB0ZXItMy9yc2EuaHRtbA==">https://l2x.gitbooks.io/understanding-cryptography/content/docs/chapter-3/rsa.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FsaW1pbmdoL2FydGljbGUvZGV0YWlscy8xMDU1ODE2NTY=">https://blog.csdn.net/alimingh/article/details/105581656<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDExLzA4L3doYXRfaXNfYV9kaWdpdGFsX3NpZ25hdHVyZS5odG1s">https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> TEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Secure Boot</title>
      <link href="/next/2024/Embedded/SecureBoot/"/>
      <url>/next/2024/Embedded/SecureBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="目的">目的</h1><p>安全启动的根本目的是为了防止消费者从软硬件层面对产品的部分关键系统进行读写、调试等高权限的操作。以限制消费者的能力，来达到保护产品的商业机密、知识产权等厂家权益的目的。当然，厂家是不会这样宣传 Secure Boot 的。他们的文案通常都是通过这项技术保护用户的隐私，防止恶意软件修改系统软硬件等等。</p><p>可以说，<strong>Secure Boot</strong>&nbsp;的安全模型建立在消费者是攻击者这一假设上。消费者在物理上拥有产品硬件，可以对产品进行物理连接、拆机、改装等等物理上的操作，比较专业的消费者甚至可以使用数字示波器监听 CPU 和 RAM 、eMMC 之间的数据传输来读取非常底层的数据传输。可以说跟传统的安全模型中的攻击者相比根本不在一个层面上。</p><p>消费者作为攻击者的目的，一般常见的有刷机安装自定义的操作系统（Mod）、绕过厂家封闭的支付平台（IAP）和应用商城安装自定义的应用程序、绕过版权保护系统（DRM）达到复制厂家保护的数字产品内容等等。这些操作往往都会直接影响厂家的利益，因此需要一种能抵抗消费者攻击的安全机制。</p><p>而且像 eMMC 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 eMMC 编程工具来读写上面的内容。</p><p>Secure Boot 安全机制的原理，就是将最为核心的安全机制整合到最关键的主 CPU 中。因此就算攻击者可以监听电路板上的线路，甚至拆装个别芯片单独调试，也无法破坏 Secure Boot 的安全机制。</p><h1 id="ta的安全性">TA的安全性</h1><p>保证TA的安全需要做到三点：</p><ul><li>唯一性：由设备厂商发布，确保是由设备厂商自己发布的，而不是经过客户自己替换的</li><li>完整性：除了要保证TA是由设备厂商发布外还需要确保其内容没有经过改动，被用户修改了TA里面的内容</li><li>保密性：内容经过加密，别人从系统中导出TA固件也无法获取真实的信息，无法解密</li></ul><span id="more"></span><h2 id="唯一性通过签名解决rsa">唯一性（通过签名解决RSA）</h2><p>有两种实现方式：</p><ul><li>root key由设备厂商自己持有，也就是说rsa的pub key和 priv key都由设备厂商自己持有，那么别人自然无法获取key，pub key packing到bl32中，只要能正确解密就能保证是设备厂商发布的</li><li>ic厂默认做了一级签名，也就是root key由ic厂持有，这个时候客户就需要将自己的pub key 加密后packing到TA中，但是这存在一个问题就是BL32如何解密设备厂商加密后的pub key，这就涉及到证书了，设备厂商需要向ic厂商申请数字证书（ic厂商用root priv key对客户的pub key加密），这样BL32里本身持有IC的Root pub key就可以通过数字证书获得设备厂商 pub key，然后验证TA的唯一性，并通过AES解密获得TA内容。</li></ul><h2 id="完整性对ta的hash值进行校验">完整性（对TA的hash值进行校验）</h2><p>对TA进行hash运算生成摘要信息，然后将hash值加密后添加到TA头中，BL32读取并解密该hash值并且自己再算一遍TA程序的hash值，两个值一样则说明TA是完整的，没有经过修改的。</p><h2 id="保密性加密aes">保密性（加密AES）</h2><p>由AES加密和解密，其key也需要经过RSA加密保护。</p><p>这里有一点非常关键就是BL32里的root pub key不能被篡改，或者说BL32不能被串改，BLx的安全性由<strong>Secure Boot</strong>来保证。<strong>Secure Boot</strong>保证启动的每一级都是安全的不会被篡改，任何一级被串改都将导致系统启动失败。而Secure Boot的安全性是由OTP/eFuse保证的，只要这里面的内容不被破解那么后续的每一级启动都需要上一级的key来验证，BL1的启动由OTP或efuse里的key来验证，每一级都经过设备厂商的签名认证保证启动的每一个环节都是安全的。当然如果OTP/eFuse被破解了那就不能保证安全了。</p><h1 id="atf启动流程">ATF启动流程</h1><p>restart--冷启动</p><p>reset--热启动</p><p>ATF冷启动实现分为5个步骤：</p><ul><li>BL1 - AP Trusted ROM，一般为BootRom。</li><li>BL2 - Trusted Boot Firmware，一般为Trusted Bootloader。</li><li>BL31 - EL3 Runtime Firmware，一般为SML，管理SMC执行处理和中断，运行在secure monitor中。</li><li>BL32 - Secure-EL1 Payload，一般为TEE OS Image。</li><li>BL33 - Non-Trusted Firmware，一般为uboot、linux kernel。</li></ul><p>ATF输出BL1、BL2、BL31，提供BL32和BL33接口。</p><p>启动流程如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/secureboot1.png"></p><h2 id="bl1"><strong>BL1</strong></h2><p>BL1位于ROM中，在EL3下从reset vector处开始运行。（bootrom就是芯片上电运行的（chip-rom的作用就是跳转到bootrom））</p><p>BL1做的工作主要有：</p><ul><li>决定启动路径：冷启动还是热启动</li><li>架构初始化：异常向量、CPU复位处理函数配置、控制寄存器设置(SCRLR_EL3/SCR_EL3/CPTR_EL3/DAIF)</li><li>平台初始化：使能Trusted Watchdog、初始化控制台、配置硬件一致性互联、配置MMU、初始化相关存储设备</li><li>加载 Secure Boot Key 等密钥</li><li>从 eMMC 加载并验证 First Stage Bootloader（FSBL）</li><li>固件更新处理</li><li>BL2镜像加载和执行</li><li>BL1输出“Booting Trusted Firmware"</li><li>BL1加载BL2到SRAM；如果SRAM不够或者BL2镜像错误，输出“Failed to load BL2 firmware.”</li><li>BL1切换到Secure EL1并将执行权交给BL2</li></ul><h2 id="bl2"><strong>BL2</strong></h2><p>BL2运行于SRAM中，运行在Secure EL1主要工作有：</p><ul><li>架构初始化：EL1/EL0使能浮点单元和ASMID</li><li>平台初始化：控制台初始化、相关存储设备初始化、MMU、相关设备安全配</li><li>SCP_BL2：系统控制核镜像加载，单独核处理系统功耗、时钟、复位等控制</li><li>加载BL31镜像：BL2将控制权交给BL1；BL1关闭MMU并关cache；BL1将控制权交给BL31</li><li>加载BL32镜像：BL32运行在安全世界，BL2依赖BL31将控制权交给BL32。SPSR通过Secure-EL1 Payload Dispatcher进行初始化</li><li>加载BL33镜像：BL2依赖BL31将控制权交给BL33</li></ul><h2 id="bl31"><strong>BL31</strong></h2><p>BL31位于SRAM中，EL3模式。除了做架构初始化和平台初始化外，还做了如下工作：</p><ul><li>PSCI服务初始化，后续提供CPU功耗管理操作</li><li>BL32镜像运行初始化，处于Secure EL1模式</li><li>初始化非安全EL2或EL1，跳转到BL33执行</li><li>负责安全非安全世界切换</li><li>进行安全服务请求的分发</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/secureboot2.png"></p><p>每个镜像都经公钥验证，公钥存储在已签名的证书中，并可追溯到存储在 SoC 上的一次性可编程 (OTP) 存储器中或 ROM 中的根密钥。</p><h1 id="armv8安全引导的过程"><strong>ARMv8安全引导的过程</strong></h1><p>ARMv8架构之后ARM提供了ATF, BootLoader、TEE镜像文件、Linux内核镜像文件、recovery镜像文件都是由ATF来进行引导和加载而不是由ChipRom来完成的。</p><p><strong>ChipRom只会去验证ATF中bl1的合法性</strong>，后续引导过程同样也是按照链式验签的方式进行，符合TBBR规范。读者可使用git命令从gitHub上获取ATF的所有源代在ARMv8架构中整个安全引导的流程如图下所示。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/secureboot3.png"></p><p>ARMv8架构中引入了ATF，<strong>同时在ATF中提供了安全引导的功能，BootLoader镜像、Linux内核、recovery镜像和TEE OS镜像文件的签名方式都由ATF决定</strong>。当然开发者也可以对ATF进行定制化，修改ATF中的验签过程，但是修改后的验签方案需要符合TBBR规范。</p><p>通过Secure Boot来保证BL32的安全性，然后由BL32来保证TA的安全性，这样就实现了TEE的安全操作环境。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWV0LWNoaW5hLmNvbS9tcC9hMzI5OTY4Lmh0bWw=">https://www.eet-china.com/mp/a329968.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjY3ODM5MTYzNTAyNzM5NTEx">https://juejin.cn/post/7267839163502739511<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> TEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEE 软件交互流程</title>
      <link href="/next/2024/Embedded/TEESoftPipeLine/"/>
      <url>/next/2024/Embedded/TEESoftPipeLine/</url>
      
        <content type="html"><![CDATA[<h1 id="tee软件框架">TEE软件框架</h1><p>TEE 系统软件从整体上包含 REE 和 TEE 两部分，各自对应的基础组件如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft1.png"></p><ul><li>REE 部分 Client Applications（CA） 一般是指指纹录入，支付应用等上层应用，其通过调用 TEE Client API 接口来与 TEE 环境的 Trusted OS 进行交互，这里的 TEE Client API 包括 TEE 厂商自定义的一些接口或 GlobalPlatform（GP） 全球组织定义的通用 API，其目的是制定一套标准的编程接口，方便开发者在不同软硬件平台下使用同一套代码实现其功能。</li><li>TEE Client API 通过 ioctl 系统调用对 TEE Driver 进行操作，TEE Driver 是沟通 REE 和 TEE 的桥梁，其通过 SMC 指令，实现将上层的 OpenSession，InvokeCommand，CloseSession 等标准调用的请求转发到 TEE 环境，同时其也会处理来自 TEE 的请求，将请求转发到 TEE Helper Daemon 让其处理。</li><li>TEE Helper Daemon 是一个辅助进程，用于 TEE 请求 REE 的资源。 一般来说，TEE 需要获得存储在 EMMC 的数据文件（例如安全加密文件，TA 可执行镜像文件等），而读写 EMMC 操作需要复杂的内核驱动的支持，显然如果把读写 EMMC 的驱动放到 TEE 侧运行会使软件复杂度会变得很高，因此 REE 需要一个可以访问这些资源的辅助进程支持，这就是 TEE Helper Daemon 的基本功能。TEE Helper Daemon 在软件逻辑实现上比较简单，以 OP-TEE 的 tee-supplicant 辅助进程为例，整体上是一个循环流程: 其首先通过 ioctl 接口查询是否有来自 TEE 的请求，如果没有，则进入睡眠等待状态，等待 TEE Driver 的唤醒信号，当 TEE Driver 收到来自 TEE 的请求后，会唤醒 tee-supplicant 辅助进程，然后根据请求号进行相应处理（读写数据文件，读写 EMMC 设备分区等），最后返回结果到 TEE Driver，完成一次循环，具体实现可参照《OP-TEE 中 tee-supplicant 执行流程》</li></ul><span id="more"></span><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft2.png"></p><ul><li>TEE 侧的 Secure Monitor 的主要作用是实现 REE 和 TEE 环境的切换，转发请求到 Trusted OS。当 Secure Monitor 收到 TEE Driver 的 SMC 请求后，会将 CPU 切换到 Secure 状态，然后转发请求到 Trusted OS 来处理，Trusted OS 会找到请求对应的 Trusted App（TA） 去处理请求，具体逻辑流程会在下一节中详细说明。 另外 Secure Monitor 还用于开机时候 Trusted OS 的引导工作，此内容不在本文的叙述范围，读者可以参看: 《Secure-EL1 Payloads and Dispatchers》</li><li>Trusted OS 是运行在 TEE 侧的小型操作系统，简单来说，其作用是:<ul><li>构建满足 TA 运行的安全运行环境</li><li>提供安全外设（SPI，I2C，Timer 等）的驱动程序</li><li>根据 REE 的请求，调度相应 TA 处理请求</li><li>提供 TA 运行所需要的加解密，随机数生成，证书生成校验等通用函数库</li></ul></li><li>上文提到 GlobalPlatform（GP） 全球组织定义的通用 API，TEE Client API 供 REE 侧的 CA 使用，TEE Internal API 则是供 TA 调用 Trusted OS 资源的标准 API，同样是用于方便 TA 开发者在不同软硬件平台进行开发。</li></ul><h1 id="tee-软件交互流程">TEE 软件交互流程</h1><p>上文对 REE 调用 TEE 软件交互所需要的基础组件及其基本作用进行了介绍，下面将对各个组件的交互流程进行介绍。</p><p>在 GP 标准中，CA 要与 TA 进行通信，需要建立如图2所示的软件逻辑流程:</p><ol type="1"><li>首先 CA 需要与 Trusted OS 之间建立一个 Context（InitializeContext），以后此 CA 与 TEE 环境的所有通信均基于此 Context。</li><li>然后 CA 会向 Trusted OS 申请与请求的 TA 建立一个 Session（OpenSession）。</li><li>CA 与 TA 之间的 Session 建立完成后，CA 就可以向 TA 发送 Command（InvokeCommand）。</li><li>Command 及其参数会通过共享内存的方式传递，TA 从共享内存中获取到 CA 的请求以及请求参数。</li><li>TA 在 TEE 环境下执行处理，得到的处理结果重新填充到共享内存中，CA 通过共享内存就可以获取到处理结果。</li><li>获得处理结果后，如不需要进一步请求，则由 CA 发起关闭 Session 的请求（CloseSession），Trusted OS 回收 TA 相关资源，最后 CA 发起销毁 Context 的请求（FinalizeContext），完成一次完整交互。</li></ol><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft3.png"> 从以上流程可以看到，整个交互流程主要涉及 InitializeContext，OpenSession，InvokeCommand，CloseSession 和 FinalizeContext 5个操作。 InitializeContext 用于 Trusted OS 分配 TA 运行需要的安全内存，FinalizeContext 则是销毁相应内存，具体流程分别与 OpenSession 和 CloseSession 类似，本文将不对这两个操作赘述。 下面看看 OpenSession，InvokeCommand 和 CloseSession 这几个操作下，各个基础组件的交互时序。</p><p>OpenSession 时序如图3所示，操作步骤如下: <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft4.png"></p><ol type="1"><li>CA 经过 TEE Client API 向 TEE Driver 发送 OpenSession 请求。</li><li>TEE Driver 发送 OpenSession SMC 请求到 Trusted OS，此请求中包含要请求 TA 的唯一标识号（UUID）。</li><li>Trusted OS 会根据 TA 的 UUID 查找 TA 是否已经加载了，如果已经加载了，则执行步骤6，否则执行步骤4。</li><li>若请求的 TA 未加载，则 Trusted OS 会向 TEE Helper Daemon 进程发送 Load TA 命令请求，TEE Helper Daemon 收到请求后，会根据要加载的 TA 的 UUID，从文件系统指定路径下找到 TA 镜像文件，并将其加载到预先分配的共享内存中，最后将共享内存的地址回传给 Trusted OS（这次地址回传实际需要经过 TEE Driver 进行虚拟地址与物理地址转换）。</li><li>Trusted OS 从回传的共享地址拷贝 TA 镜像到安全内存中，然后对安全内存中的 TA 镜像的 ELF 格式头，签名信息进行校验，校验通过则加载成功，否则返回错误信息给 CA。</li><li>TA 加载成功后，Trusted OS 分配一个 Session 操作句柄，并定位到已加载镜像的 TA_OpenSessionEntryPoint 函数入口执行。</li><li>最后，Trusted OS 将分配的 Session 句柄逐级返回，最终 CA 拿到 Session 句柄，以后的 InvokeCommand 将需要依赖此句柄进行调用。</li></ol><p>InvokeCommand 和 CloseSession 的流程与 OpenSession 流程相似，差别在于少了 load TA 的流程，时序图如图4和图5所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft5.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft6.png"></p><h1 id="tee-example">TEE Example</h1><p>参考https://github.com/linaro-swg/optee_examples</p><h1 id="tee应用举例">TEE应用举例</h1><h2 id="指纹软件框架">指纹软件框架</h2><p>如下图是Android上的指纹软件框架，REE环境下主要分为APP，Framework，HAL和linux kernel。APP主要负责指纹录入解锁调用逻辑，Framework主要负责回调HAL层相关函数，HAl层负责和硬件以及指纹TA交互。而TEE主要是指纹TA，指纹TA负责控制指纹sensor和执行指纹算法相关函数。</p><ul><li>Fingerprint TA:主要进行基本操作，比如控制finger sensor采图，特征提取，指纹算法处理等操作。</li><li>finger CA:负责与Fingerprint TA进行通信，发送指令，向Fingerprint HAL提供REE与TEE的通信接口。</li><li>Secure SPI driver：TEE与指纹sensor通信的SPI安全驱动</li><li>finger lib:指纹算法库，主要是对指纹图像特征提取比对等算法实现</li><li>Fingerprint HAL:指纹hal，调用CA的接口向TA下发指令，同时通过Fingerprint Device Driver实现对GPIO,Power，INT等管脚和功能控制。</li><li>Fingerprint service:指纹framework，回调hal层相关函数，控制指纹录入解锁等流程</li><li>App：指纹最上层的代码，主要是负责指纹录入解锁调用逻辑</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft7.png"></p><h2 id="指纹录入流程">指纹录入流程</h2><p>Hal中指纹的录入流程为：指纹sensor初始化（begin enroll）-&gt;采图(do capture)-&gt;录入（do enroll)-&gt;结束录入(do enroll)-&gt;指纹模板存储（store template）。对应TA的录入流程为：指纹sensor init（begin enroll）-&gt;采图（capture image）-&gt;将采集的指纹数据传输回TA-&gt;录入(do enroll)-&gt;结束录入(end enroll)-&gt;模板加密存储到secure memory（encrypt）。</p><p>HAL中主要进行的是与TA交互，给TA发送指令，同时还会对指纹硬件进行操作，比如指纹sensor上下电等。TA收到CA的command，则需要处理敏感数据和一些安全性要求高的动作，如TA通过secure spi控制指纹sensor采图，图像传输，图像处理，图像比对，模板存储等。这些都是在TEE环境下进行操作的，所以指纹解锁是一种相对比较安全的解锁方式。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee_soft8.png"></p><h1 id="qa">QA</h1><p><strong>optee是否是多线程的？</strong></p><p>optee支持多核SMP，optee里的线程数是通过静态定义的（一个数组，数组大小决定了线程数量），但是如果cpu是单核那么就只支持单线程，optee的线程不支持时间片轮转，一个cpu核不能通过时间片轮转处理多个TA应用。但是如果是多核cpu，例如4核cpu那么optee最多可以4核同时处理4个TA应用。由于TA里涉及很多加解密操作可能会很耗时导致Linux端出现性能问题（optee在运行的时候，该cpu核无法运行Linux程序）。optee运行期间只有中断可以打断其运行。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwubWVpenUuY29tLzIwMTcvMTIvMjcvL3RlZS5odG1s">https://kernel.meizu.com/2017/12/27//tee.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kZWVwaW5vdXQuY29tL2FuZHJvaWQtc3lzdGVtLWFuYWx5c2lzL2FuZHJvaWQtc2VjdXJpdHktcmVsYXRlZC9lYXN5LXRvLXVuZGVyc3RhbmQtdGVlLmh0bWw=">https://deepinout.com/android-system-analysis/android-security-related/easy-to-understand-tee.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodWFpZmVuZ3l1bi9hcnRpY2xlL2RldGFpbHMvNzI5MTIyMzg=">https://blog.csdn.net/shuaifengyun/article/details/72912238<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> TEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPMB 简介</title>
      <link href="/next/2024/Embedded/RPMB/"/>
      <url>/next/2024/Embedded/RPMB/</url>
      
        <content type="html"><![CDATA[<h1 id="信息安全">信息安全</h1><p>信息安全的三个基本目标是机密性，完整性和可用性。</p><ul><li>机密性意味着只有授权实体才能阅读和理解保密的信息。没有访问权限的其他人无法阅读或理解机密信息；</li><li>完整性意味着能够确保信息受到保护，以防止未经授权的更改，修改或删除。信息的完整性包括使用识别和认证等方法的起源，完整性和正确性；</li><li>可用性意味着信息始终可供授权用户使用。</li></ul><span id="more"></span><h1 id="rpmb简介">RPMB简介</h1><p>RPMB是Replay Protected Memory Block(重放保护内存块)的简称，是eMMC中的一个具有安全特性的分区。此功能使设备能够将数据存储在经过身份验证并防止重放攻击的小型特定区域(通常是4M Bytes)中。这里涉及一个概念Replay Attack和Replay Protected。</p><h2 id="replay-attack重放攻击">Replay Attack(重放攻击)</h2><p>A向B请求服务(比如说登录某个网站)，A将密码hash化传给B。但是在这中间，E抓取到该hash值。此后，E冒充A向B发送同样的hash值来获取服务。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee20.png"></p><h2 id="replay-protected重放保护">Replay Protected(重放保护)</h2><ul><li>加随机数。该方法优点是认证双方不需要时间同步，双方记住使用过的随机数，如发现报文中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。</li><li>加时间戳。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易。</li><li>加流水号。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。缺点是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</li><li>一次性口令。</li></ul><h1 id="rpmb认证">RPMB认证</h1><p>RPMB使用对称秘钥身份认证，也就是host和device使用相同的身份验证秘钥，此秘钥称之为认证秘钥(AuthKey)也可称为RPMB Key，工作方式如下：</p><ul><li>AuthKey通过host写入到eMMC中(在安全的环境中写入)的OTP区域中</li><li>host和device在读写RPMB区域的时候需要签名和验证</li><li>对消息进行签名涉及消息身份验证代码(Message Authentication Code)MAC，MAC是hash值，MAC是由通过AuthKey对Message + Write Counter使用HMAC SHA-256算法签名后得到</li><li>发送的消息为MAC + Message + Write Counter</li></ul><p>HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 保护RPMB数据的关键就是保护AuthKey，因此在读写RPMB的时候，需要在TEE的环境中，因为在访问RPMB，需要显式的使用AuthKey（如果不在TEE环境中，可以对AuthKey进行加密，然后使用解密模块去操作）。 另外，AuthKey最好也是独一无二的，也就是与Soc UID相关的，形成自己独一无二的Key。</p><h1 id="rpmb是怎么实现重放保护">RPMB是怎么实现重放保护</h1><p>重放保护最基本的就是要保证每个消息是独一无二的，RPMB分别加入2个因子进去：</p><ul><li>在写操作的时候，使用Write Counter(32Bytes)来实现重放保护。Write Counter是由Device管理的，该计数器在每次有效的验证写入消息后递增，其新值将包含在要发送的下一个身份验证代码MAC的计算中；</li><li>在读操作的时候，使用随机数Nonce(16Bytes)来实现重放保护。Nonce是由Host产生。</li></ul><p>一个访问RPMB命令通过HMAC SHA-256计算进行验证，以下几项做为该计算的输入：</p><ul><li>身份验证的秘钥AuthKey；</li><li>消息，包括命令或返回的值；</li><li>写计数器，也就是总的写RPMB的次数，存放计数器的值为32bit，当写入次数达到0xFFFFFFFF的时候，RPMB就变为只读；</li><li>一个随机数，它是为每个read命令随机生成的数字(Read的时候才用到)。 具体的RPMB命令格式如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee21.png"></li></ul><h1 id="从rpmb读数据">从RPMB读数据</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee22.png"></p><ul><li>在Host端，发送读请求以及一个16Bytes随机数Nonce给Device端</li><li>在Device端(eMMC)，将请求的数据从RPMB取出来，通过AuthKey对Data + 随机数使用HMAC SHA-256算法签名后得到MAC，与Data + 随机数一起发送给Host端</li><li>在Host端收到Devcie发送过来的数据， 首先比较随机数是否与自己一致，如果一致，在Host端使用自己的AuthKey对接收到的Data + 随机数使用HMAC SHA-256算法签名后得到MAC1，比较自己生成的MAC1与接收到的MAC是否一致。如果一致，Host端就可以确定该Data是从RPMB读取到的，没有被修改过，而不是攻击者伪造的数据。</li></ul><h1 id="写数据到rpmb">写数据到RPMB</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee23.png"></p><h2 id="在-host-soc端">在 Host Soc端：</h2><ul><li>Host端使用AuthKey对Message(Data + Metadata) + Write Counter 使用HMAC SHA-256算法签名后得到MAC</li><li>Host端将MAC + Message + Write Counter传给Device</li></ul><h2 id="在devices端emmcufs">在Devices端(eMMC/UFS)：</h2><ul><li>Device接受到Host传送过来的MAC + Message + Write Counter</li><li>Device端比较接收到的Write Counter是否与自己的一致</li><li>Devices将接受到的Message + Write Counter + devcies端的AuthKey 经过SHA-256生成MAC1</li><li>将Devices端生成的MAC1与接收到的MAC进行比较，如果两者一致，就将Data写入到RPMB中</li></ul><p>通过上述的写入流程，可以保证 RPMB 不会被非法篡改。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee24.png"></p><h1 id="使用mmc命令访问rpmb">使用mmc命令访问RPMB</h1><p>使用mmc命令可以访问RPMB，查看访问RPMB相关的用法如下： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb write-key &lt;rpmb device&gt; &lt;key file&gt;</span><br><span class="line">        Program authentication key <span class="built_in">which</span> is 32 bytes length and stored</span><br><span class="line">        <span class="keyword">in</span> the specified file. Also you can specify <span class="string">'-'</span> instead of</span><br><span class="line">        key file path to <span class="built_in">read</span> the key from stdin.</span><br><span class="line">        NOTE!  This is a one-time programmable (unreversible) change.</span><br><span class="line">        Example:</span><br><span class="line">          $ <span class="built_in">echo</span> -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH | \</span><br><span class="line">            mmc rpmb write-key /dev/mmcblk0rpmb -</span><br><span class="line">mmc rpmb read-counter &lt;rpmb device&gt;</span><br><span class="line">        Counter value <span class="keyword">for</span> the &lt;rpmb device&gt; will be <span class="built_in">read</span> to stdout.</span><br><span class="line">mmc rpmb read-block &lt;rpmb device&gt; &lt;address&gt; &lt;blocks count&gt; &lt;output file&gt; [key file]</span><br><span class="line">        Blocks of 256 bytes will be <span class="built_in">read</span> from &lt;rpmb device&gt; to output</span><br><span class="line">        file or stdout <span class="keyword">if</span> <span class="string">'-'</span> is specified. If key is specified - <span class="built_in">read</span></span><br><span class="line">        data will be verified. Instead of regular path you can specify</span><br><span class="line">        <span class="string">'-'</span> to <span class="built_in">read</span> key from stdin.</span><br><span class="line">        Example:</span><br><span class="line">          $ <span class="built_in">echo</span> -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH | \</span><br><span class="line">            mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block -</span><br><span class="line">        or <span class="built_in">read</span> two blocks without verification</span><br><span class="line">          $ mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block</span><br><span class="line">mmc rpmb write-block &lt;rpmb device&gt; &lt;address&gt; &lt;256 byte data file&gt; &lt;key file&gt;</span><br><span class="line">        Block of 256 bytes will be written from data file to</span><br><span class="line">        &lt;rpmb device&gt;. Also you can specify <span class="string">'-'</span> instead of key</span><br><span class="line">        file path or data file to <span class="built_in">read</span> the data from stdin.</span><br><span class="line">        Example:</span><br><span class="line">          $ (awk <span class="string">'BEGIN {while (c++&lt;256) printf "a"}'</span> | \</span><br><span class="line">            <span class="built_in">echo</span> -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH) | \</span><br><span class="line">            mmc rpmb write-block /dev/mmcblk0rpmb 0x02 - -</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li><p>创建AuthKey和WrongAuthKey </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH"</span> &gt; AuthKey</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"11112222333344445555666677778888"</span> &gt; WrongAuthKey</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>将AuthKey写入到eMMC的OTP中 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb write-key /dev/block/mmcblk0rpmb AuthKey</span><br></pre></td></tr></tbody></table></figure><p></p></li><li>创建一个256Bytes的数据 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef.123456789abcdef."</span> &gt; Data</span><br></pre></td></tr></tbody></table></figure> 之所以要创建256Bytes的数据，是因为mmc规定要写256Bytes：mmc rpmb write-block <rpmb device=""><address><p>&lt;256 byte data file&gt; <key file=""></key></p></address></rpmb></li><li><p>用正确的AuthKey往RPMB写入数据 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb write-block /dev/block/mmcblk0rpmb 0 Data AuthKey</span><br></pre></td></tr></tbody></table></figure> 在这个步骤中，没有看到有读取Write Counter的动作，这是因为mmc命令已经在write-block中首先实现了读取Write Counter，详见mmc源码do_rpmb_write_block()函数，该函数会调用rpmb_read_counter()获取Write Counter。<p></p></li><li><p>用错误的AuthKey往RPMB写入数据 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb write-block /dev/block/mmcblk0rpmb 0 Data WrongAuthKey</span><br></pre></td></tr></tbody></table></figure> 这时候会提示RPMB operation failed, retcode 0x0002的错误，表示验证失败。<p></p></li><li><p>不用AuthKey读取RPMB数据 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb read-block /dev/block/mmcblk0rpmb 0 1 out.txt</span><br></pre></td></tr></tbody></table></figure> 这个结果能读取到数据，但是并不能保证这个数据没有被修改过。<p></p></li><li><p>用正确的AuthKey读取RPMB数据 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb read-block /dev/block/mmcblk0rpmb 0 1 out1.txt AuthKey</span><br></pre></td></tr></tbody></table></figure> 这个结果能读取到数据，并且能保证这个数据没有被修改过，而不是攻击者伪造的数据。<p></p></li><li><p>用错误的AuthKey读取RPMB数据 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmc rpmb read-block /dev/block/mmcblk0rpmb 0 1 out2.txt WrongAuthKey</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><p>提示RPMB MAC missmatch的错误，无法读取到数据。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93b3dvdGhpbmsuY29tLzhjYTc4ZmQ4Lw==">https://wowothink.com/8ca78fd8/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Njc1NzMxL2FydGljbGUvZGV0YWlscy8xMDEwMTc4NDE=">https://blog.csdn.net/qq_35675731/article/details/101017841<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> TEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEE 实现原理</title>
      <link href="/next/2024/Embedded/TEEImplementationPrinciple/"/>
      <url>/next/2024/Embedded/TEEImplementationPrinciple/</url>
      
        <content type="html"><![CDATA[<h1 id="trustzone">TrustZone</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee1.png"></p><h2 id="如何区分当前访问状态是安全状态下的访问还是非安全状态下的访问">如何区分当前访问状态是安全状态下的访问还是非安全状态下的访问？</h2><p>CPU发出的地址都是虚拟地址，需要经过页表转换才能得到物理地址，其中在pte页表中低12bit（针对4k大小的页表）为控制位，用来控制页表的访问属性，也就是说在页表建立的时候就确定了访问状态是安全状态还是非安全状态，其pte低12bit如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee2.png"></p><span id="more"></span><p>这里的bit 5 NS bit（Non-secure bit）：用来指定访问的内存地址是安全映射的还是非安全映射的。</p><p>只有当ARM核处于安全状态（NS bit=0）时发送到系统总线（AXI）上的读写操作才会被识别为安全读写操作，对应TEE侧的数据资源才能被访问。反之，当ARM核处于非安全状态（NS bit=1）时，ARM核发送到系统总线上的读写操作请求会被作为非安全读写操作，<strong>安全组件会根据对资源的访问权限配置来决定是否响应该访问请求</strong>。</p><p>💡 NS bit的设置是通过SMC指令触发异常进入EL3安全监视器中设置的，即Normal World通过SMC调用进入Security World，将NS bit置0，Security World通过SMC指令进入Normal World，安全监视器将NS bit置1</p><h2 id="如何划分安全区域和非安全区域以及如何拦截非安全状态下的安全地址访问">如何划分安全区域和非安全区域以及如何拦截非安全状态下的安全地址访问？</h2><h3 id="ddrtzasc">DDR（TZASC）：</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee3.png"></p><p>TrustZone地址空间控制组件（TrustZone Address Space Controller，TZASC）是AXI总线上的一个主设备，<strong>TZASC能够将从设备全部的地址空间分割成一系列的不同地址范围</strong>。在安全状态下， 通过编程TZASC能够将这一系列分割后的地址区域设定成安全空间或者是非安全空间。被配置成安全属性的区域将会拒绝非安全的访问请求。</p><p>使用TZASC主要是将一个AXI从设备分割成几个安全设备，例如off-Soc、DRAM等。ARM的动态内存控制器（Dynamic Memory Controller，DMC） 并不支持安全和非安全分区的功能。如果将DMC接到TZASC上，就能实现DRAM支持安全区域和非安全区域访问的功能。需要注意的是，<strong>TZASC组件只支持存储映射设备对安全和非安全区域的划分与扩展</strong>，但不支持对块设备（如EMMC、NAND flash 等）的安全和非安全区域的划分与扩展</p><p>一个完整的系统必然会有片外RAM，对片外 RAM的隔离是通过TZASC组件实现的，ARM本身的DMC可以将DRAM分割成不同的区域，这些区域是没有安全和非安全分类。将DMC与TZASC相连 后再挂到总线上，通过对TZASC组件进行编程可以将DRAM划分成安全区域和非安全区域。当主设备 访问DRAM时，除需要提供物理地址之外，还会发送PROT信号。TZASC组件首先会判定主设备需要访问的DARM地址是属于安全区域还是非安全区域，然后再结合接收到的PROT信号来判定该次访问是否有效。如果PROT信号为非安全访问操作， 且访问的DRAM地址属于安全区域，则TZASC就不会响应这次访问操作，这样就能实现DRAM中安全区域和非安全区域的隔离。</p><h3 id="sram和romtzma">SRAM和ROM（TZMA）：</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee4.png"></p><p>TrustZone内存适配器组件（TrustZone Memory Adapter，TZMA）允许对片上静态内存（on-SoC Static Memory）或者片上ROM进行安全区域和非安全区域的划分（仅有安全访问可以配置TZASC的寄存器）。TZMA支持最大2MB空间的片上静态RAM的划分，可以将2MB空间划分成两个部 分，高地址部分为非安全区域，低地址部分为安全区域，两个区域必须按照4KB进行对齐。分区的具体大小通过TZMA的输入信号R0SIZE来控制，该信号来自TZPC的输出信号TZPCR0SIZE。即通过编程TZPC可以动态地配置片上静态RAM或者ROM的大小。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee5.png"></p><h3 id="外设地址apb-to-axi桥">外设地址（APB-to-AXI桥）：</h3><p>TrustZone同样能够保护外围设备的安全，例如：中断控制、时钟、I/O设备，因此Trust-Zone架构还 能用来解决更加广泛的安全问题。比如一个安全中断控制器和安全时钟允许一个非中断的安全任务来监控系统，能够为DRM提供可靠的时钟，能够为用户提供一个安全的输入设备从而保证用户密码数据不会被恶意软件窃取。</p><p>AMBA3规范包含了一个低门数、低带宽的外设总线，被称作外设总线（Advanced Peripheral Bus，APB），APB通过AXI-to-APB桥连接到系统总线上。而APB总线并不具有安全状态位，<strong>为实现 APB外设与TrustZone技术相兼容，APB-to-AXI桥将负责管理APB总线上设备的安全</strong>。APB-to-AXI桥会拒绝不匹配的安全事务设置，并且不会将该事务请求发送给外设。</p><p>TrustZone保护控制器组件（TrustZone Protection Controller，TZPC）是用来设定 TZPC DECPORT信号和TZPC R0SIZE等相关控制信号的。<strong>这些信号用来告知APB-to-AXI对应的外设是安全设备还是非安全设备，而TZPCR0SIZE信号用来控制TZMA对片上RAM或片上ROM安全区域大小的划分</strong>。</p><p>TZPC包含三组通用寄存器 TZPCDECPROT[2：0]，每组通用寄存器可以产生8 种TZPCDECPROT信号，也就是TZPC最多可以将 24个外设设定成安全外设。TZPC组件还包含一个TZPCROSIZE寄存器，该寄存器用来为TZMA提供分区大小信息。TZPC组件的接口示意如图所示</p><h2 id="axi-访问流程">AXI 访问流程</h2><p>cpu发出了虚拟地址访问，这个地址要经过AXI总线到达外设地址，但是这个地址访问仍然是没有安全状态的，<strong>TZASC或者TZMA或者APB-to-AXI桥</strong>是如何判断访问级别的呢？</p><p>TrustZone技术通过对总线进行扩展增加安全位读写信号线来实现。除了对总线进行扩展还需要对MMU、Cache、TLB以及其他组件进行扩展都是增加了安全bit。</p><p><strong>AXI总线上安全状态位的扩展</strong></p><p>AXI写数据的过程如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee6.png"></p><p>地址通道携带描述被传输数据性质的控制信息。</p><p>读数据的过程如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee7.png"></p><p>每一个通道都拥有自己的VALID与READY信号用于实现握手，其中VALID信号表示通道的地址、数据或控制信息已经可用，而READY信号则表示接收方已准备好接收信息。</p><p><strong>AXI信号描述</strong></p><p>写地址通道信号：</p><table><thead><tr class="header"><th>信号名</th><th>来源</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>AWID</td><td>主设备</td><td>写地址ID，该信号用于标识写地址组</td></tr><tr class="even"><td>AWADDR</td><td>主设备</td><td>写地址，写突发操作中第一次数据传输的地址</td></tr><tr class="odd"><td>AWLEN</td><td>主设备</td><td>突发长度，这个字段标识每次突发传输的传输次数</td></tr><tr class="even"><td>AWSIZE</td><td>主设备</td><td>突发大小，这个字段表示每次突发传输的大小</td></tr><tr class="odd"><td>AWBURST</td><td>主设备</td><td>突发类型，包括突发类型和突发大小信息，该字段决定了每次突发传输时地址的计算方法</td></tr><tr class="even"><td>AWLOCK</td><td>主设备</td><td>锁定类型，提供关于传输时原子特性的额外信息</td></tr><tr class="odd"><td>AWCACHE</td><td>主设备</td><td>存储器类型</td></tr><tr class="even"><td>AWPROT</td><td>主设备</td><td>保护类型</td></tr><tr class="odd"><td>AWQOS</td><td>主设备</td><td>服务质量，即每次写传输的QoS标识符，仅AXI4支持</td></tr><tr class="even"><td>AWREGION</td><td>主设备</td><td>区域标识符，允许一个从设备的单个物理接口用作多个逻辑接口，仅AXI4支持</td></tr><tr class="odd"><td>AWUSER</td><td>主设备</td><td>用户定义信号，可选</td></tr><tr class="even"><td>AWVALID</td><td>主设备</td><td>主设备给出的地址和相关控制信号有效</td></tr><tr class="odd"><td>AWREADY</td><td>从设备</td><td>从设备已准备好接收地址和相关的控制信号</td></tr></tbody></table><p><strong>读地址通道信号：</strong></p><table><thead><tr class="header"><th>信号名</th><th>来源</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>ARID</td><td>主设备</td><td>读地址ID，该信号用于标识读地址组</td></tr><tr class="even"><td>ARADDR</td><td>主设备</td><td>读地址，读突发操作中第一次数据传输的地址</td></tr><tr class="odd"><td>ARLEN</td><td>主设备</td><td>突发长度，这个字段标识每次突发传输的传输次数</td></tr><tr class="even"><td>ARSIZE</td><td>主设备</td><td>突发大小，这个字段表示每次突发传输的大小</td></tr><tr class="odd"><td>ARBURST</td><td>主设备</td><td>突发类型，包括突发类型和突发大小信息，该字段决定了每次突发传输时地址的计算方法</td></tr><tr class="even"><td>ARLOCK</td><td>主设备</td><td>锁定类型，提供关于传输时原子特性的额外信息</td></tr><tr class="odd"><td>ARCACHE</td><td>主设备</td><td>存储器类型</td></tr><tr class="even"><td>ARPROT</td><td>主设备</td><td>保护类型</td></tr><tr class="odd"><td>ARQOS</td><td>主设备</td><td>服务质量，即每次读传输的QoS标识符，仅AXI4支持</td></tr><tr class="even"><td>ARREGION</td><td>主设备</td><td>区域标识符，允许一个从设备的单个物理接口用作多个逻辑接口，仅AXI4支持</td></tr><tr class="odd"><td>ARUSER</td><td>主设备</td><td>用户定义信号，可选</td></tr><tr class="even"><td>ARVALID</td><td>主设备</td><td>主设备给出的地址和相关控制信号有效</td></tr><tr class="odd"><td>ARREADY</td><td>从设备</td><td>从设备已准备好接收地址和相关的控制信号</td></tr></tbody></table><p>以上只列出了部分<strong>读地址通道信号和写地址通道信号。</strong></p><p>而我们关心的是AWPROT和ARPROT信号。</p><ul><li>ARPROT[2:0]定义了读访问的访问权限。</li><li>AWPROT[2:0]定义了写访问的访问权限。</li></ul><p>其中，信号定义如下：</p><table><thead><tr class="header"><th>AxPROT</th><th>值</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>[0]</td><td>0/1</td><td>非特权访问/特权访问</td></tr><tr class="even"><td>[1]</td><td>0/1</td><td>安全访问/不安全访问</td></tr><tr class="odd"><td>[2]</td><td>0/1</td><td>数据访问/指令访问</td></tr></tbody></table><p>这里又多了一个特权访问和非特权访问？官方手册是这么描述的：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee8.png"></p><p>AXI提供特权访问还是非特权访问的信息，但是具体怎么用，看各控制器的设计了。没有查到更多信息，暂时先不管这个特权访问了。</p><p>详细可参考： https://www.lzrnote.cn/2021/10/08/axi总线总结/</p><p>http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf</p><h1 id="atfarm-trusted-firmware">ATF（ARM Trusted Firmware）</h1><p>该固件统一了ARM底层接口标准，如电源状态控制接口（Power Status Control Interface，PSCI）、安全启 动需求（Trusted Board Boot Requirements， TBBR）、安全世界状态（SWS）与正常世界状态 （NWS）切换的安全监控模式调用（secure monitor call，smc）操作等。ATF旨在将ARM底层的操作统一使代码能够重用和便于移植。</p><h2 id="atf启动流程">ATF启动流程：</h2><p>ATF的源代码共分为bl1、bl2、bl31、bl32、 bl33部分，其中bl1、bl2、bl31部分属于固定的固件，bl32和bl33分别用于加载TEE OS和REE侧的镜像。整个加载过程可配置成安全启动的方式，每一个镜像文件在被加载之前都会验证镜像文件的电子签名是否合法。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee9.png"></p><h2 id="atf主要完成的功能如下">ATF主要完成的功能如下：</h2><ul><li>初始化安全世界状态运行环境、异常向量、 控制寄存器、中断控制器、配置平台的中断。</li><li>初始化ARM通用中断控制器（General Interrupt Controller，GIC）2.0版本和3.0版本的驱动初始化。</li><li>执行ARM系统IP的标准初始化操作以及安全扩展组件的基本配置。</li><li>安全监控模式调用（Secure Monitor Call， SMC）请求的逻辑处理代码（Monitor模式/EL3）。</li><li>实现可信板级引导功能，对引导过程中加载的镜像文件进行电子签名检查。</li><li>支持自有固件的引导，开发者可根据具体需求将自有固件添加到ATF的引导流程中。</li></ul><p>Trusted Firmware提供了满足ARM安全规格的参考代码，包括TBBR(Trusted Board&nbsp; Boot Requirements)和SMCC。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee10.png"></p><p>SMC Dispatcher：处理非安全世界的SMC请求，决定哪些SMC由Trusted Firmware在EL3处理，哪些转发给TEE进行处理。</p><p>Trusted Firmware处理PSCI任务、或者SOC相关工作。一个典型的基于TrustZone系统软件调用栈关系图：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee11.png"></p><ul><li>安全世界的Trusted OS提供一系列安全服务，比如key管理或DRM。非安全世界应用需要使用这些服务，但是又无法直接使用。通过使用一些库中API来获取这些能力，比如libDRM.so。</li><li>这些库和Trusted service之间通信往往通过message queue或者Mailbox。他们之间通信所用内存往往被称为WSM(World Shared Memory)。这些内存必须能够被Trusted service和库访问，这就意味着这些内存是非安全内存。</li><li>应用通过库发送一个请求到Mailbox或message queue，然后触发内核中TrustZone驱动。</li><li>TrustZone驱动负责和TEE部分交互，包括为message queue申请内存和注册这些内存。由于安全和非安全运行在两个虚拟地址空间，所以无法通过虚拟地址进行通信。</li><li>TrustZone驱动通过调用SMC进入安全状态，控制权通过EL3的Secure Monitor传递到TEE中的TEEOS。TEEOS从message queue内存中获取内容由Trusted service进行处理。<ul><li><strong>Trusting the message</strong>：由于message是从非安全世界传递的，所以需要安全世界对这些内容进行一些认证。</li><li><strong>Scheduling</strong>：对于PSCI类型快速处理并且不频繁请求，进入EL3处理完成后退出到非安全状态。对于一些需要TOS处理的任务，不能被非安全中断打断，避免造成安全服务不可用。</li><li><strong>OP-TEE</strong>：OP-TEE内核运行在S.EL1，可信应用运行在S.EL0。</li></ul></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/TEE/tee12.png"></p><h1 id="op-tee">OP-TEE</h1><p>OP-TEE 是依靠 Arm TrustZone 技术作为底层硬件隔离机制而实现的一种TEE OS。</p><h2 id="tee-os功能">TEE OS功能</h2><ul><li>进程管理</li><li>内存管理</li><li>安全存储<ul><li>RPMB File System</li><li>REE File System</li></ul></li><li>加密引擎<ul><li>对称加密（AES，DES）</li><li>非对称加密（RSA，ECC）</li><li>摘要（MD5，HASH，HMAC）</li></ul></li><li>软件隔离<ul><li>进程隔离</li><li>内存隔离</li><li>数据隔离</li></ul></li><li>真随机数</li><li>安全时钟</li><li>硬件秘钥及派生</li><li>...</li></ul><h2 id="tee应用">TEE应用</h2><ul><li>DRM<ul><li>Widevine</li><li>PlayReady</li><li>Netflix</li></ul></li><li>CAS<ul><li>Nagra</li><li>Verimatrix</li><li>Irdeto</li><li>NSK</li><li>VO</li></ul></li><li>秘钥烧录</li><li>无线显示</li><li>生物识别</li><li>移动支付</li><li>飞控系统</li><li>重置保护</li><li>...</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmxvc2NuL2Jsb2cvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k">https://github.com/carloscn/blog/blob/master/README.md<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VjcnNzLmNvbS9hcnRpY2xlcy8xNDE4Nw==">物联网终端应用TEE的一些思考<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> TEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog 搭建</title>
      <link href="/next/2024/Tools/HexoNextUsage/"/>
      <url>/next/2024/Tools/HexoNextUsage/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-hexo">安装 hexo</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure><h1 id="安装依赖">安装依赖</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 pandoc 渲染器</span></span><br><span class="line">npm un hexo-renderer-marked</span><br><span class="line">npm i hexo-renderer-pandoc</span><br><span class="line"></span><br><span class="line">npm un hexo-renderer-pandoc</span><br><span class="line">npm i hexo-renderer-markdown-it-plus</span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git</span><br><span class="line">sudo apt-get install pandoc</span><br><span class="line"></span><br><span class="line">npm install prism</span><br><span class="line"></span><br><span class="line"><span class="comment"># rss</span></span><br><span class="line">npm install hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="comment"># butterfly</span></span><br><span class="line">npm install badge-maker</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">npm install hexo-butterfly-footer-beautify --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 页面加密</span></span><br><span class="line">npm install --save hexo-blog-encrypt</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>卸载 hexo 默认 markdown 渲染器，安装 pandoc markdown 渲染器。hexo 默认的 markdown 渲染器不支持 Mathjax，不支持插件扩展，不支持 emoji 表情。pandoc markdown 渲染器支持 Mathjax 语法，不仅可以渲染 markdown，还支持 textile，reStructedText 和许多其他格式，仍然不支持 emoji 表情。</p><p>此外还有其他 markdown 渲染器，hexo-renderer-markdown-it 支持 Mathjax 语法（支持不太好），支持 Markdown 以及 CommonMark 语法，渲染速度比 hexo-renderer-marked 快，支持插件配置，支持标题带安全的 id 信息，支持脚注（上标，下标，下划线）。 hexo-renderer-markdown-it-plus 支持 Katex 插件并默认启用，默认启用插件列表：markdown-it-emoji，markdown-it-sub，markdown-it-sup，markdown-it-deflist，markdown-it-abbr，markdown-it-footnote，markdown-it-ins，markdown-it-mark，<span class="citation" data-cites="iktakahiro/markdown-it-katex">@iktakahiro/markdown-it-katex</span>，markdown-it-toc-and-anchor。</p><p>这里要吐槽一下各版本的 markdown 渲染器，对 latex 语法的支持真是一言难尽，pandoc 用了一段时间发现某些特性不支持打算换一个，然后 latex 公式各种崩，😔毁灭吧。</p><span id="more"></span><h1 id="plugin">Plugin</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line">npm i --save hexo-wordcount</span><br><span class="line">npm install hexo-word-counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 emoji 表情支持</span></span><br><span class="line">npm install hexo-filter-github-emojis</span><br><span class="line"></span><br><span class="line">npm i remark-prism</span><br></pre></td></tr></tbody></table></figure><h1 id="文章加密">文章加密</h1><h2 id="安装-hexo-blog-encrypt-插件">安装 hexo-blog-encrypt 插件</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-blog-encrypt</span><br></pre></td></tr></tbody></table></figure><h2 id="用法">用法</h2><h3 id="基本用法">基本用法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="built_in">date</span>: 2016-03-30 21:18:02</span><br><span class="line">password: hello</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><h3 id="高级设置">高级设置</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"><span class="built_in">date</span>: 2016-03-30 21:12:21</span><br><span class="line">password: hello</span><br><span class="line">abstract: Here<span class="string">'s something encrypted, password is required to continue reading.</span></span><br><span class="line"><span class="string">message: Hey, password is required here.</span></span><br><span class="line"><span class="string">wrong_pass_message: Oh, this is an invalid password. Check and try again, please.</span></span><br><span class="line"><span class="string">---</span></span><br></pre></td></tr></tbody></table></figure><ul><li>abstract：用于设置加密文章显示的摘要</li><li>message：输入密码提示</li><li>wrong_pass_message: 输入错误提示</li></ul><h1 id="如果-deploy-失败则">如果 deploy 失败则</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .deploy_git</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><h1 id="如何写-blog">如何写 Blog</h1><h2 id="分类">分类</h2><p>最大的问题是一篇文章只能处于一个分类，但是我的一篇 ISP 文章既属于驱动又属于 Image，还属于算法目录，这个时候这篇文章到底该放到哪里？ 为此我花了大量时间来重新分类，但是有些东西始终有交叉，我是既要又要，emm！！！为此我找到了 MECE 分类法： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Share/blog1.png"></p><h2 id="标签">标签</h2><p>标签相比于分类最大的不同是，一个事物可以有多个标签。在<strong>合理使用标签</strong>之前一直觉得标签是零散的，没有体系，但实际上标签可以比分类更体系。只要标签做好管理这就是一个快速索引，且是一个网状组织，顺着这个标签找到同一片文章的其他标签顺着这个标签再找到其他文章这种网站组织形式是非常高效的。</p><p>刚才说到合理使用标签，如果不合理使用就会造成很多若关联性，例如某篇 USB 文章提到硬 circuit、提到 phy、提到 OTG、提到 Controller；但是通篇主要是讲 phy，那 circuit、otg、controller 要不要打上标签呢？打上可能会大量孤立标签，可能 otg 这个标签只会有这一篇对应的文章，而这一篇又不是专门写 otg 的，倘若这样的标签对应很多文章，每一篇都不是主要的文章那是不是在检索的时候就很抓狂呢。</p><p>标签还有另一个问题，就是当文章数量达到几百篇的时候，标签的数量本身可能非常庞大、可能存在大量标签只对应非常少的文章或者只有一篇文章的情况，或者一个标签对应几十甚至上百篇的文章。</p><h2 id="思路">思路</h2><p>我的做法很简单，将之前的目录前部标签化，对于纠结一篇文章该放到哪个目录下这个难题，直接打上两个标签。 分类可以让你对知识体系有一个整体的认识，他一定程度上代表了你的思考过程，我甚至有过一个极端的想法去掉分类，因为我曾经真的在给文章分类上睡不着觉的，但是我也经历过了标签满天飞的的窘境，最终还是打算保留分类。</p><h2 id="思考">思考</h2><p>我认为标签优于分类的点在于，标签可以是多维度的扁平化分类，类如我之前写的一篇关于 IMU 的文章，对于分类，你可以置于算法目录下，这个是在编程、算法这个维度下的，也纠结于放在 Sensor 目录下，IMU 属于一个传感器，这个是放到 Sensor、MCU、MPU 这些具象实物维度下的分类，他还可以放在防抖目录下，在防抖的事件里他是至关重要的一个角色，这个是放到图像、音频、网络这些学科领域分类维度下的。因此分类还是必须的，但是不必是唯一的了，也就是在你心中依然是存在分类的，而且不是一个分类，是从多维度进行分类，一篇文章同时存在不同维度的不同分类下。而这些不同维度下的目录就是标签，这样标签不会出现爆炸，也不会出现同一个标签却写了不同名字的问题，例如 RTOS 标签被打成 UCOS、RT-Thread、Zephyr 等不同形式的标签。</p><p>回过头来看，分类是劝退写文章的障碍吗，我觉得未必，标签本质上也是需要建立目录的，而且是更多维度上的分类，其实标签比分类更难，分类做不好顶多是存在一些歧义问题，文章没有挂到某些应该被挂到的目录下，因为他只能在分类中出现一次。</p><h2 id="关于双链">关于双链</h2><p>...</p><h1 id="参考文章">参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9idWd3ei5jb20vMjAxOS8wOS8xNy9oZXhvLW1hcmtkb3duLXJlbmRlcmVyLyMxLTQlRTMlODAlODFoZXhvLXJlbmRlcmVyLW1hcmtkb3duLWl0">https://bugwz.com/2019/09/17/hexo-markdown-renderer/#1-4%E3%80%81hexo-renderer-markdown-it<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAS 有趣的 Docker 推荐</title>
      <link href="/next/2024/Tools/NasDockerUsage/"/>
      <url>/next/2024/Tools/NasDockerUsage/</url>
      
        <content type="html"><![CDATA[<p>已迁移到notion page，请访问:<span class="exturl" data-url="aHR0cHM6Ly9jYXJseWxlbGl1Lm5vdGlvbi5zaXRlL0RvY2tlci1WaWV3LTBkYjhmNmM0YzU3MjQxYjJhYjdlOThhN2M5ODY2MGE3">NAS 有趣的 Docker 推荐<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（九）UAC 常见问题</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACCommonIssue/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACCommonIssue/</url>
      
        <content type="html"><![CDATA[<h1 id="修改uac配置参数后无法正常通信">修改UAC配置参数后无法正常通信</h1><p>如果修改了UAC的配置后出现UAC无法正常通信的问题，可以通过修改设备的idVendor和idProduct来解决，只有设备的idVendor和idProduct发生改变Windows才会重新读取设备的配置描述符。</p><span id="more"></span><h1 id="kernel-5.4内核配置某些参数后uac通信异常">Kernel 5.4内核配置某些参数后UAC通信异常</h1><p>例如在44100采样率、4channel、32bit参数下Device到Host端通信异常，而Host端到Device端通信正常。 问题的原因是由于Linux的UAC驱动计算的每次传输的usb包大小不正确，导致USB传输格式不匹配出现了通信异常。详细原因如下：</p><ul><li>该参数下每秒钟的数据量为44100 * 4 * 4 = 705600</li><li>USB每秒传输一千个包，则每个包的大小为 705600 / 1000 = 705.6</li><li>Linux下UAC驱动的做法是每次传输705字节数据，当余数足够多的时候传输705+16=721字节，然后依次循环下去。但是这种方式存在一个问题就是705不是frames大小的整数倍，即705 / (4 * 4) = 44.0625,那么USB每次传输的数据不能完全送到声卡，要等下一次的数据到来后拼成一个完整的frame才能送到声卡，这样显然是非常麻烦的，且会造成更大的延迟</li><li>Windows的做法是每次传输704字节，然后剩余的数据积攒到一帧的数据量后下次传输704 + （4 * 4）= 720字节</li><li>可以看到Linux和Windows每次传输和接收的大小都不一样，导致了两则无法正常通信，显然Linux的计算方法是错误的，Linux驱动中也没有自己拼接数据的逻辑，这个就是Linux下计算usb包大小的一个Bug。</li></ul><p>Linux上游社区已经发现并解决了这个Bug，最终计算到的大小与Windows的大小相同，计算方法如下：</p><p><span class="math display">\[pkt\_size = frame\_size * \frac{sampling\_rate}{1000} \]</span></p><p>即如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkt_size = frame_size * (sampling_rate / <span class="number">1000</span>) <span class="comment">// 704 = 16 * (44100 / 1000) = 16 * 44</span></span><br></pre></td></tr></tbody></table></figure><h1 id="uac1-无法支持48k4channel32bit问题">UAC1 无法支持48K、4channel、32bit问题</h1><p>drivers/usb/gadget/function/u_uac1.h：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define UAC1_OUT_EP_MAX_PACKET_SIZE200</span></span><br></pre></td></tr></tbody></table></figure><p>这里闲置了usb每个包的大小不能超过200字节，我们可以计算一下数据量：</p><p>对于48K、4channel、32bit每秒钟的数据量为：48000_4_4 = 768,000Byte</p><p>USB每秒发送1000次数据，每次最大3个数据包，则每个包大小需要768000 / 1000 / 3 = 256。这里的宏定义将每个包的大小限制在200了，则带宽不够，需要放开这个限制，将宏大小改为1023就可以了。</p><p>💡 驱动中为什么默认设置为200呢，其实是为了保证usb低速设备可以正常使用才设置这么低的，对于usb低速设备1.5Mbit/s = 1.5 * 1024 *1024 / 8 / 1000 = 196.如果usb支持全速或者高速可以将这个限制放开。</p><h1 id="uac2无法支持大于192k4channel32bit参数问题">UAC2无法支持大于192K、4channel、32bit参数问题</h1><p>drivers/usb/gadget/function/f_uac2.c:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static struct usb_endpoint_descriptor hs_epout_desc = {</span><br><span class="line">.bLength = USB_DT_ENDPOINT_SIZE,</span><br><span class="line">.bDescriptorType = USB_DT_ENDPOINT,</span><br><span class="line">.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE,</span><br><span class="line">/* .wMaxPacketSize = DYNAMIC */</span><br><span class="line">.bInterval = 4,</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line">static struct usb_endpoint_descriptor hs_epin_desc = {</span><br><span class="line">.bLength = USB_DT_ENDPOINT_SIZE,</span><br><span class="line">.bDescriptorType = USB_DT_ENDPOINT,</span><br><span class="line">.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_SYNC,</span><br><span class="line">/* .wMaxPacketSize = DYNAMIC */</span><br><span class="line">.bInterval = 4,</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里bInterval是控制UAC发包频率的，USB全速总线1ms发送一次数据，USB高速总线可以125us发送一次数据，这里的bInterval就是用来控制UAC多久发送一次数据的，如果bInterval=1，则UAC数据包的间隔就是<span class="math inline">\(125us * 2^{1-1}\)</span>如果bInterval=4则UAC发送间隔为<span class="math inline">\(125us * 2^{4-1}=1ms\)</span>。驱动中默认是1ms发送一次数据，则最大的数据量就是1000 * 1024 * 3 = 3072000 = 192K * 4channel * 4Byte。</p><p>要解决这个问题只需要将bInterval改为1即可。</p><p>💡 bInterval=1具有更低的延迟，更大的带宽，但是对于大部分场景没必要设置这么高的频率，1ms就可以满足要求。</p><h1 id="各系统uac音量调节支持情况">各系统UAC音量调节支持情况</h1><table><thead><tr class="header"><th></th><th>Windows10/11</th><th>Android 11（基于一加6）</th><th>ios</th><th>Macos</th></tr></thead><tbody><tr class="odd"><td>UAC1 Disable FU</td><td>通过调节音频数据幅值调节音量</td><td>通过调节音频数据幅值调节音量</td><td>不支持调节音量（音量滑块变灰不可拖动）</td><td>同ios（未做验证）</td></tr><tr class="even"><td>UAC1 Enable FU</td><td>支持控制音量；不支持同步设备音量</td><td>通过调节音频数据幅值调节音量</td><td>支持控制音量；支持同步设备音量</td><td>同ios（未做验证）</td></tr><tr class="odd"><td>UAC2 Disable FU</td><td>通过调节音频数据幅值调节音量</td><td>通过调节音频数据幅值调节音量</td><td>不支持调节音量（音量滑块变灰不可拖动）</td><td>同ios（未做验证）</td></tr><tr class="even"><td>UAC2 Enable FU</td><td>支持控制音量；支持同步设备音量</td><td>通过调节音频数据幅值调节音量</td><td>支持控制音量；支持同步设备音量</td><td>同ios（未做验证）</td></tr></tbody></table><p>💡 1. 网上查到的信息是Android 14支持Feature Unit，但是在我的一加6（Android11）上验证是不支持FU的 2. macos应该与ios一致，未作验证</p><h1 id="关于windows系统uac1对fu支持情况的疑问">关于windows系统UAC1对FU支持情况的疑问</h1><p>Windows 的UAC2对Function的支持情况有明确说明：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uac1.png"></p><p>UAC2的Feature Unit是明确支持Interrupt的。但是没有查到UAC1对Function的支持情况。实际测试发现Windows是可以正确识别Feature unit端点描述符的，如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uac2.png"></p><p>这里面的信息与Spec里都能一一对应上，端点描述符没有任何问题，但是测试发现Windows不会去读取Interrupt端点数据，抓包发现没有任何该端点的读取操作，那么实测得到的UAC1对Feature支持情况是：</p><ul><li>支持：<ul><li>GET CUR</li><li>SET CUR</li><li>GET RANGE</li></ul></li><li>不支持：<ul><li>Interrupt</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（八）PPM 评估</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACASYNCPPM/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACASYNCPPM/</url>
      
        <content type="html"><![CDATA[<h1 id="usb-sof统计方法">USB sof统计方法</h1><h2 id="打时间戳方式">打时间戳方式</h2><ol type="1"><li><strong>ktime_get_raw_ns()</strong> Linux标准接口。</li><li><strong>meson_timestamp()</strong> Amlogic实现的硬件定时器接口。</li></ol><h2 id="sof打时间戳的时机">sof打时间戳的时机</h2><ol type="1"><li>直接在SOF中断handle里打时间戳，然后将其保存到一个fifo里。</li><li>通过一个hrtimer，主动查询SOF中断寄存器查看是否有SOF包，如果有SOF包则打上时间戳保存到fifo里。</li></ol><h2 id="sof时间戳导出到应用层">sof时间戳导出到应用层</h2><p>通过seq file创建一个proc（/proc/sof_ts）文件，应用通过读取该文件来获取sof时间戳。</p><span id="more"></span><h1 id="usb-sof统计数据方案验证">USB sof统计数据方案验证</h1><h2 id="中断handle里用ktime_get_raw_ns打时间戳统计数据">中断handle里用ktime_get_raw_ns()打时间戳统计数据</h2><p><strong>数据：</strong><br>| 样本数量 | 平均值（ns） | 最小值（ns） | 最大值（ns） | 方差 | 标准差 | | --- | --- | --- | --- | --- | --- | | 8192 | 125001.0327 | 94125 | 156125 | 2281694.791 | 1510.5279 |</p><p><strong>sof间隔图表：</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof1.png"></p><p><strong>统计直方图(124-126us)：</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof2.png"></p><p>上图在124us-126us之间的概率分布，两头分别是低于124us和高于126us的概率。低于124us的概率为3.0%，高于126us的概率为2.8%.</p><p><strong>统计直方图(120-130us)：</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof3.png"></p><p>上图将直方图统计口径放大到120us-130us，那么低于120us的概率为1.1%，高于130us的概率为1.2%.</p><p>通过以上数据来看，没有使用hrtimer捕获sof的必要，直接在中断handler里捕获得到的数据精度完全足够评估ppm了，整体数据分布符合高斯噪声分布曲线，可以配合一定的消除高斯噪声的滤波算法得到更为稳定的数据。</p><h2 id="中断handle里用meson_timestamp打时间戳统计数据">中断handle里用meson_timestamp()打时间戳统计数据</h2><p><strong>数据：</strong></p><table><thead><tr class="header"><th>样本数量</th><th>平均值（ns）</th><th>最小值（ns）</th><th>最大值（ns）</th><th>方差</th><th>标准差</th></tr></thead><tbody><tr class="odd"><td>8192</td><td>125000.8546</td><td>111000</td><td>141000</td><td>1501036.994</td><td>1225.168</td></tr></tbody></table><p><strong>sof间隔图表</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof4.png"></p><p><strong>sof直方图：</strong></p><p>由于meson_timestamp的精度只到us，因此只统计120us-130us之间的概率：如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof5.png"></p><p>其中低于120us的概率为1.2%，高于130us的概率为0.78%。</p><h2 id="结论">结论</h2><ul><li>统计方式可以直接在中断handle里打印时间戳</li><li>获取时间戳接口meson_timestamp()数据更稳定一些，但差别不大，这里直接采用Linux标准函数ktime_get_raw_ns()获取时间戳</li></ul><h1 id="滤波">滤波</h1><p>前面确定了在sof中断handle里通过ktime_get_raw_ns()获取sof时间戳，然后将其保存到fifo里，应用层通过/proc/sof_ts文件读取fifo里的时间戳。下面是对数据进行处理的方法：</p><p><strong>实验一：无中值滤波，卡尔曼滤波器err_integral与kalman_filter_err_integral对比，kalman参数Q=0.01，R=1</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof6.png"></p><p><strong>放大细节</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof7.png"></p><p>滤波后数据仍然存在较大的波动，这个波动主要是由一些突变很大的值引入的，想要得到更加平滑的数据，可以先用中值滤波器将这些极值率除掉。</p><p><strong>实验二：加入中值滤波器（err_integral与kalman_filter_err_integral和kalman_filter_err_integral对比，中值滤波窗口大小100个sample，kalman参数Q=0.01，R=1）</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof8.png"></p><p><strong>放大看细节</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof9.png"></p><p>可以看到经过中值滤波器后毛刺基本上都去掉了，但是数据还是不够平滑，再加入karman滤波器后数据就很平滑了.</p><p>如下图所示是经过kalman滤波后得到的ppm值： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof10.png"></p><p>范围在7.56-7.64ppm，在经过一定的时间后kalman系数基本收敛完毕，数据量也累计到一定程度后ppm基本稳定在7.6-7.62ppm之间。</p><h1 id="issue">Issue</h1><p>测试中发现一个问题，我们的USB一般跑在高速模式下，在高速模式下是每125us一个sof中断，也就是在开启sof中断后arm core会每秒多接收8000次usb控制器发来的中断，这个中断是非常频繁的，会频繁触发usb中断过于频繁的check的。 可以尝试在ISO传输的数据中断中打印时间戳，理论上这种方式存在更大的波动性，需要验证数据是否可用。</p><h1 id="iso中断统计">ISO中断统计</h1><p>下图是以1ms为基准统计的iso中断累计误差： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof11.png"></p><p>下图是通过上图的kalman滤波曲线计算的ppm曲线：范围在6.1-6.5之间，其中波动最大的在于有一段连续时间的偏差游走，但是经过滤波后造成ppm的偏差也在0.5pp以内。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof13.png"></p><p>滤波和未滤波ppm值对比： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof14.png"></p><p>其实在这里可以看到，将统计时长拉到足够长，不采用滤波也是可以的，比如将统计时长拉长到10分钟以上，误差也基本上不会很大。采用滤波的算法的好处是基本上2分钟以内就可以得到很高精度的值了。</p><p><strong>结论</strong><br>在sof中断里获取时间戳pipeline更短，引入的误差更小，精度更高，但是开启sof中断后usb的中断会过于频繁，不利于usb的稳定性。作为对比，直接统计usb iso传输中断不会带来额外的中断开销，牺牲的是ppm评估精度。对于我们的公版来讲基本上都是采用±20ppm的晶振，波动在1个ppm以内基本上是可用接受的。</p><h1 id="最终的算法">最终的算法</h1><ol type="1"><li>通过proc文件系统获取sof的timestamp</li><li>计算两个时间戳之间的间隔，期望是1ms</li><li>将该时间戳与1ms做差，进行积分，得到累计误差err_integral</li><li>对累计误差进行中值滤波得到median_filter_err_integral中值滤波后的累计误差</li><li>对中值滤波的结果进行kalman滤波得到kalman_filter_err_integral</li></ol><h1 id="数据验证">数据验证</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/sof15.png"></p><p>我们可用通过示波器或者频谱仪来测量晶振的真实ppm值，但是我们上面算法评估出的不是设备的真实ppm值，而是以pc的时钟为基准，device的时钟相对于pc时钟的ppm值。我们想要验证算法的精度就需要同时测量pc和device各自的ppm，然后再计算得到device相对于pc的相对ppm值。 由于pc的ppm我们不太好获取，因此这里通过测量两台device的ppm值，然后用我们的额算法评估出两个device的相对于pc的ppm值，看两则之间的差值是否相同来验证算法的准确性。这里通过频谱仪测量得到的两台设备的ppm值分别是：</p><p>DeviceA：24.000135Mhz，ppm=（24.000135 - 24）/24 * 1000000 = 5.62ppm DeviceB：23.999953Mhz，ppm = （23.999953 - 24）/24 * 1000000 = -1.9ppm</p><p>两个设备的ppm差值为：5.62+1.9 = 7.52ppm 我们算法评估得到的DeviceA相对于pc的ppm为7.7ppm。DeviceB相对于pc的ppm为1.6ppm，两者之间的差值为6.1ppm。 这里算法得到的ppm相较于频谱仪得到的数据差有1.42ppm。 我们把算法的时间线拉长DeviceA相对于pc的ppm基本在7.4-8.4之间来回震荡，DeviceB相对于pc的ppm在1.2-1.9之间来回震荡，而且ppm值会受温度随着时间的推移也会在一个小范围内来回震荡，因此评估的数据可以认为精度在2ppm以内。</p><h1 id="最后">最后</h1><p>如果Device相对于pc的ppm在10以上是可以采取一定的补偿措施的，如果Device相对于pc的ppm在5以内，补偿的意义就不大了，客户软件可以通过评估ppm大小判断下范围，如果评估出来在10以上可以采取一些措施来补偿ppm，比如调节clk或者调节fifo。 对于A1，由于时钟分频导致的采样率不是整数，这个可以通过async机制来解决，ppm相对于clk的分频不准确性就太小了，没必要进行ppm评估。A4、A5分频得到的ppm是整数，可以用ppm estimate来评估并做一定的补偿。当然直接用async也可以。但是A4、A5用的CRG的usb控制器，端点数量只有3对，uac+FU+Async Feedback就把3对用完了，其他usb功能都得关闭了。需要根据需求来决定采用哪种方案了。</p><h1 id="tips">Tips</h1><p>excel中方差函数：VARPA() excel中标准差函数：STDEVPA()</p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（七）Async Feedback</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACASYNCFeedback/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACASYNCFeedback/</url>
      
        <content type="html"><![CDATA[<h1 id="buffer-统计">buffer 统计</h1><p>采样间隔 1ms、采样 buffer 里的数据长度 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AudioBufferUsage.png"></p><span id="more"></span><p>可以看到整体上 buffer 里的数据是不断增多的，将其放大可以看下细节： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AudioBufferUsageZoomOut.png"></p><p>符合数据变化规律，usb 会每隔 1ms 往 buffer 里放一次数据，audiobridge 会每 period_size 间隔将数据发给 dsp（buffer 里的数据会突然减少，这里是 1024 个 period_size），然后由于 tdmb 的实际采样率要低一些，因此每隔一段时间会出现只有 usb 数据传输过来，而 audiobridge 不会将数据送到 dsp 的情况发生，这样就造成了 buffer 里的数据不断累计。</p><p>这里其实可以通过每次只采样 audiobridge 发送完数据的时刻的 buffer 大小，这样可以大大减少数据采样的次数同时还能采样到局部数据最小值。，如下图这样的： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AudioBufferUsageSMALL.png"></p><p>改用这种方式采样得到的数据曲线如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AudioBufferUsageSMALLZoomout.png"></p><h1 id="async-反馈阈值设定">Async 反馈阈值设定</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AsyncFeedbackWatermark.png"></p><h1 id="async-反馈-srate-给-host-后统计的数据">Async 反馈 srate 给 host 后统计的数据</h1><p>通过设置阈值来调整 uac 的 feedback 速率，得到 buffer 里的数据长度曲线如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AsyncFeedbackresult.png"></p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之基础（二）DMA-API</title>
      <link href="/next/2024/LinuxDriver/LinuxDriverBaseDMA-API/"/>
      <url>/next/2024/LinuxDriver/LinuxDriverBaseDMA-API/</url>
      
        <content type="html"><![CDATA[<h1 id="there-are-two-types-of-dma-mappings">😊 There are two types of DMA mappings</h1><p>Consistent DM（硬件保证 cache 一致性） mappings which are usually mapped at driver initialization, unmapped at the end and for which the hardware should guarantee that the device and the CPU can access the data in parallel and will see updates made by each other without any explicit software flushing.</p><p>Streaming DMA（需要软件来维护 cache 一致性） mappings which are usually mapped for one DMA transfer, unmapped right after it (unless you use dma_sync_* below) and for which hardware can optimize for sequential accesses.</p><span id="more"></span><h1 id="dma-direction">😄 DMA Direction:</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma1.png"></p><p>The interfaces described in subsequent portions of this document take a DMA direction argument, which is an integer and takes on one of the following values:</p><ul><li>DMA_BIDIRECTIONAL</li><li>DMA_TO_DEVICE</li><li>DMA_FROM_DEVICE</li><li>DMA_NONE</li></ul><p>You should provide the exact DMA direction if you know it.</p><p>DMA_TO_DEVICE means "from main memory to the device". DMA_FROM_DEVICE means "from the device to main memory". It is the direction in which the data moves during the DMA transfer.</p><p>You are <em>strongly</em> encouraged to specify this as precisely as you possibly can.</p><p>If you absolutely cannot know the direction of the DMA transfer, specify DMA_BIDIRECTIONAL. It means that the DMA can go in either direction. The platform guarantees that you may legally specify this, and that it will work, but this may be at the cost of performance for example.</p><p>The value DMA_NONE is to be used for debugging(DMA_NONE 用于调试）. One can hold this in a data structure before you come to know the precise direction, and this will help catch cases where your direction tracking logic has failed to set things up properly.</p><p>Another advantage of specifying this value precisely (outside of potential platform-specific optimizations of such) is for debugging. Some platforms actually have a write permission boolean which DMA mappings can be marked with, much like page protections in the user program address space. Such platforms can and do report errors in the kernel logs when the DMA controller hardware detects violation of the permission setting.</p><p>Only streaming mappings specify a direction, consistent mappings implicitly have a direction attribute setting of DMA_BIDIRECTIONAL.</p><p>For Networking drivers, it's a rather simple affair. For transmit packets, map/unmap them with the DMA_TO_DEVICE direction specifier. For receive packets, just the opposite, map/unmap them with the DMA_FROM_DEVICE direction specifier.</p><h1 id="dma_sync_single_for_devicecpu-api">😋 dma_sync_single_for_device/cpu API</h1><p><em>调用栈：</em></p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_single_for_device/cpu</span><br><span class="line">    --&gt;dma_direct_sync_single_for_device/cpu</span><br><span class="line">        --&gt;arch_sync_dma_for_device/cpu</span><br><span class="line">            --&gt;_dma_map_area/__dma_unmap_area --&gt; dcache_clean_poc/dcache_inval_poc</span><br></pre></td></tr></tbody></table></figure><h2 id="stuck_out_tongue_winking_eye-对于-linux-upstream-社区"><span class="github-emoji"><span>😜</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对于 Linux upstream 社区</h2><h3 id="kernel-5.x">kernel 5.x</h3><p>arch_sync_dma_for_device 全部执行 clean cache arch_sync_dma_for_device 如果 direction 是 DMA_TO_DEVICE 则什么也不做否则执行 invalid cache</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma2.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma3.png"></p><h3 id="kernel-6.x">kernel 6.x</h3><p>在 arch_sync_dma_for_device 中 direction 被忽略掉，执行 dcache_clean_poc(clean cache) 在 arch_sync_dma_for_cpu 中 dir 为 DMA_TO_DEVICE 什么也不做直接返回，否则执行 dcache_inval_poc（invalid cache）</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma4.png"></p><h2 id="对于-google-社区">对于 Google 社区</h2><h3 id="kernel-5.x-1">kernel 5.x</h3><p>__dma_map_area(): 如果 direction 是 DMA_FROM_DEVICE 则先执行一个 fluah 操作，然后执行 clean cache，如果 direction 不是 DMA_FROM_DEVICE 则只执行 clean cache __dma_unmap_area(): 如果 direction 等于 DMA_TO_DEVICE 什么也不做否则执行__dma_inv_area(invalid cache) <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma5.png"></p><h3 id="kernel-6.x-1">kernel 6.x</h3><p>for_device 忽略 direction、全部 direction 执行 clean cache for_cpu 忽略 DMA_TO_DEVICE, 其他 direction 执行 invalid cache <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/dma6.png"></p><h2 id="总结">总结</h2><h3 id="linux-upstream">Linux upstream</h3><p><em>kernel 5.x:</em></p><p>dma_sync_single_for_device： 忽略 direction 全部执行 clean cache<br>dma_sync_single_for_cpu： 如果 direction 是 DMA_TO_DEVICE 则什么也不做，否则执行 invalid cache</p><p><em>kernel 6.x:</em></p><p>同 kernel 5.x 逻辑一致，只是改了下 api 名称</p><h3 id="google-社区">Google 社区</h3><p><em>kernel 5.x:</em></p><p>dma_sync_single_for_device： 如果 direction 是 DMA_FROM_DEVICE 则多执行一个 flush cache，全部 direction 都会执行 clean cache<br>dma_sync_single_for_cpu： 如果 direction 是 DMA_TO_DEVICE 则什么也不做，否则执行 invalid cache（同 linux upstream 逻辑一致）</p><p><em>kernel 6.x:</em></p><p>同 linux upstream 逻辑一致</p><p>dma_sync_single_for_device： 忽略 direction 全部执行 clean cache<br>dma_sync_single_for_cpu： 如果 direction 是 DMA_TO_DEVICE 则什么也不做，否则执行 invalid cache</p><h1 id="qa">🍦 QA</h1><p><strong>Q：</strong> 在 cache 和 ddr 中的数据一致后，DMA 将 device 数据搬运到 ddr 后（cache 与 ddr 不一样）如果调用 flush 接口，flush 先做 clean 操作会不会将 cache 中的数据写回 DDR.<br><strong>A：</strong> 不会。clean 操作是检查 dirty 标志位，在硬件改写过程中 dirty 标志位一直是 0（非 dirty），所以此时 flush 操作中的 clean 操作只是检查一遍 dirty bit, 之后做 invalid 操作。</p><h1 id="参考文献">🍭 参考文献</h1><p>《Linux Document》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之基础（一）Device-I/O</title>
      <link href="/next/2024/LinuxDriver/LinuxDriverBaseDeviceIO/"/>
      <url>/next/2024/LinuxDriver/LinuxDriverBaseDeviceIO/</url>
      
        <content type="html"><![CDATA[<h1 id="memory-mapped-io">Memory Mapped IO</h1><h2 id="getting-access-to-the-device">Getting Access to the Device</h2><p>This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap(). An address suitable for accessing the device will be returned to you.</p><p>After you've finished using the device (say, in your module's exit routine), call iounmap() in order to return the address space to the kernel. Most architectures allocate new address space each time you call ioremap(), and they can run out unless you call iounmap().</p><span id="more"></span><h2 id="accessing-the-device">Accessing the device</h2><p>The part of the interface most used by drivers is reading and writing memory-mapped registers on the device. Linux provides interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a historical accident, these are named byte, word, long and quad accesses. Both read and write accesses are supported; there is no prefetch support at this time.</p><p>The functions are named readb(), readw(), readl(), readq(), readb_relaxed(), readw_relaxed(), readl_relaxed(), readq_relaxed(), writeb(), writew(), writel() and writeq().</p><p>Some devices (such as framebuffers) would like to use larger transfers than 8 bytes at a time. For these devices, the memcpy_toio(), memcpy_fromio() and memset_io() functions are provided. Do not use memset or memcpy on IO addresses; they are not guaranteed to copy data in order.</p><p>The read and write functions are defined to be ordered. That is the compiler is not permitted to reorder the I/O sequence. When the ordering can be compiler optimised, you can use __readb() and friends to indicate the relaxed ordering. Use this with care.</p><h1 id="port-space-accesses">Port Space Accesses</h1><h2 id="port-space-explained">Port Space Explained</h2><p>Another form of IO commonly supported is Port Space. This is a range of addresses separate to the normal memory address space. Access to these addresses is generally not as fast as accesses to the memory mapped addresses, and it also has a potentially smaller address space.</p><p>Unlike memory mapped IO, no preparation is required to access port space.</p><h2 id="accessing-port-space">Accessing Port Space</h2><p>Accesses to this space are provided through a set of functions which allow 8-bit, 16-bit and 32-bit accesses; also known as byte, word and long. These functions are inb(), inw(),inl(), outb(), outw() and outl().</p><p>Some variants are provided for these functions. Some devices require that accesses to their ports are slowed down. This functionality is provided by appending a _p to the end of the function. There are also equivalents to memcpy. The ins() and outs() functions copy bytes, words or longs to the given port.</p><h1 id="iomem-pointer-tokens">__iomem pointer tokens</h1><p>The data type for an MMIO address is an __iomem qualified pointer, such as void __iomem *reg. On most architectures it is a regular pointer that points to a virtual memory address and can be offset or dereferenced, but in portable code, it must only be passed from and to functions that explicitly operated on an __iomem token, in particular the ioremap() and readl()/writel() functions. The 'sparse' semantic code checker can be used to verify that this is done correctly.</p><p>While on most architectures, ioremap() creates a page table entry for an uncached virtual address pointing to the physical MMIO address, some architectures require special instructions for MMIO, and the __iomem pointer just encodes the physical address or an offsettable cookie that is interpreted by readl()/writel().</p><h1 id="differences-between-io-access-functions">Differences between I/O access functions</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readq(), readl(), readw(), readb(), writeq(), writel(), writew(), writeb()</span><br></pre></td></tr></tbody></table></figure><p>These are the most generic accessors, providing serialization against other MMIO accesses and DMA accesses as well as fixed endianness for accessing little-endian PCI devices and on-chip peripherals. Portable device drivers should generally use these for any access to __iomem pointers.</p><p>Note that posted writes are not strictly ordered against a spinlock, see Documentation/driver-api/io_ordering.rst.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readq_relaxed(), readl_relaxed(), readw_relaxed(), readb_relaxed(),</span><br><span class="line">writeq_relaxed(), writel_relaxed(), writew_relaxed(), writeb_relaxed()</span><br></pre></td></tr></tbody></table></figure><p>On architectures that require an expensive barrier for serializing against DMA, these "relaxed" versions of the MMIO accessors only serialize against each other, but contain a less expensive barrier operation. A device driver might use these in a particularly performance sensitive fast path, with a comment that explains why the usage in a specific location is safe without the extra barriers.</p><p>See memory-barriers.txt for a more detailed discussion on the precise ordering guarantees of the non-relaxed and relaxed versions.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64(), ioread32(), ioread16(), ioread8(),</span><br><span class="line">iowrite64(), iowrite32(), iowrite16(), iowrite8()</span><br></pre></td></tr></tbody></table></figure><p>These are an alternative to the normal readl()/writel() functions, with almost identical behavior, but they can also operate on __iomem tokens returned for mapping PCI I/O space with pci_iomap() or ioport_map(). On architectures that require special instructions for I/O port access, this adds a small overhead for an indirect function call implemented in lib/iomap.c, while on other architectures, these are simply aliases.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64be(), ioread32be(), ioread16be()</span><br><span class="line">iowrite64be(), iowrite32be(), iowrite16be()</span><br></pre></td></tr></tbody></table></figure><p>These behave in the same way as the ioread32()/iowrite32() family, but with reversed byte order, for accessing devices with big-endian MMIO registers.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi_lo_readq(), lo_hi_readq(), hi_lo_readq_relaxed(), lo_hi_readq_relaxed(),</span><br><span class="line">ioread64_lo_hi(), ioread64_hi_lo(), ioread64be_lo_hi(), ioread64be_hi_lo(),</span><br><span class="line">hi_lo_writeq(), lo_hi_writeq(), hi_lo_writeq_relaxed(), lo_hi_writeq_relaxed(),</span><br><span class="line">iowrite64_lo_hi(), iowrite64_hi_lo(), iowrite64be_lo_hi(), iowrite64be_hi_lo()</span><br></pre></td></tr></tbody></table></figure><p>Some device drivers have 64-bit registers that cannot be accessed atomically on 32-bit architectures but allow two consecutive 32-bit accesses instead. Since it depends on the particular device which of the two halves has to be accessed first, a helper is provided for each combination of 64-bit accessors with either low/high or high/low word ordering. A device driver must include either &lt;linux/io-64-nonatomic-lo-hi.h&gt; or &lt;linux/io-64-nonatomic-hi-lo.h&gt; to get the function definitions along with helpers that redirect the normal readq()/writeq() to them on architectures that do not provide 64-bit access natively.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__raw_readq(), __raw_readl(), __raw_readw(), __raw_readb(),</span><br><span class="line">__raw_writeq(), __raw_writel(), __raw_writew(), __raw_writeb()</span><br></pre></td></tr></tbody></table></figure><p>These are low-level MMIO accessors without barriers or byteorder changes and architecture specific behavior. Accesses are usually atomic in the sense that a four-byte __raw_readl() does not get split into individual byte loads, but multiple consecutive accesses can be combined on the bus. In portable code, it is only safe to use these to access memory behind a device bus but not MMIO registers, as there are no ordering guarantees with regard to other MMIO accesses or even spinlocks. The byte order is generally the same as for normal memory, so unlike the other functions, these can be used to copy data between kernel memory and device memory.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inl(), inw(), inb(), outl(), outw(), outb()</span><br></pre></td></tr></tbody></table></figure><p>PCI I/O port resources traditionally require separate helpers as they are implemented using special instructions on the x86 architecture. On most other architectures, these are mapped to readl()/writel() style accessors internally, usually pointing to a fixed area in virtual memory. Instead of an __iomem pointer, the address is a 32-bit integer token to identify a port number. PCI requires I/O port access to be non-posted, meaning that an outb() must complete before the following code executes, while a normal writeb() may still be in progress. On architectures that correctly implement this, I/O port access is therefore ordered against spinlocks. Many non-x86 PCI host bridge implementations and CPU architectures however fail to implement non-posted I/O space on PCI, so they can end up being posted on such hardware.</p><p>In some architectures, the I/O port number space has a 1:1 mapping to __iomem pointers, but this is not recommended and device drivers should not rely on that for portability. Similarly, an I/O port number as described in a PCI base address register may not correspond to the port number as seen by a device driver. Portable drivers need to read the port number for the resource provided by the kernel.</p><p>There are no direct 64-bit I/O port accessors, but pci_iomap() in combination with ioread64/iowrite64 can be used instead.</p><h1 id="device-memory-mapping-modes">Device memory mapping modes</h1><p>Some architectures support multiple modes for mapping device memory. ioremap_*() variants provide a common abstraction around these architecture-specific modes, with a shared set of semantics.</p><p>ioremap() is the most common mapping type, and is applicable to typical device memory (e.g. I/O registers). Other modes can offer weaker or stronger guarantees, if supported by the architecture. From most to least common, they are as follows:</p><h2 id="ioremap">ioremap()</h2><ul><li><p>Uncached（无缓存）：</p><p>CPU-side caches are bypassed, and all reads and writes are handled directly by the device</p></li><li><p>No speculative operations（无预测执行，可以认为是无乱序执行）：</p><p>the CPU may not issue a read or write to this memory, unless the instruction that does so has been reached in committed program flow.</p></li><li><p>No reordering（无重排序，可以理解为加了强内存屏障指令）：</p><p>The CPU may not reorder accesses to this memory mapping with respect to each other. On some architectures, this relies on barriers in readl_relaxed()/writel_relaxed().</p></li><li><p>No repetition：</p><p>The CPU may not issue multiple reads or writes for a single program instruction.</p></li><li><p>No write-combining（无写合并，cache 的一种策略）：</p><p>Each I/O operation results in one discrete read or write being issued to the device, and multiple writes are not combined into larger writes. This may or may not be enforced when using __raw I/O accessors or pointer dereferences.</p></li><li><p>Non-executable：</p><p>The CPU is not allowed to speculate instruction execution from this memory (it probably goes without saying, but you're also not allowed to jump into device memory).</p></li></ul><h2 id="ioremap_wc">ioremap_wc()</h2><p>Maps I/O memory as normal memory with write combining. Unlike ioremap(),</p><ul><li>The CPU may speculatively issue reads from the device that the program didn't actually execute, and may choose to basically read whatever it wants.<br></li><li>The CPU may reorder operations as long as the result is consistent from the program's point of view.<br></li><li>The CPU may write to the same location multiple times, even when the program issued a single write.<br></li><li>The CPU may combine several writes into a single larger write.</li></ul><p>This mode is typically used for video framebuffers, where it can increase performance of writes. It can also be used for other blocks of memory in devices (e.g. buffers or shared memory), but care must be taken as accesses are not guaranteed to be ordered with respect to normal ioremap() MMIO register accesses without explicit barriers.</p><p>On a PCI bus, it is usually safe to use ioremap_wc() on MMIO areas marked as IORESOURCE_PREFETCH, but it may not be used on those without the flag. For on-chip devices, there is no corresponding flag, but a driver can use ioremap_wc() on a device that is known to be safe.</p><h2 id="ioremap_wt">ioremap_wt()</h2><p>Maps I/O memory as normal memory with write-through caching. Like ioremap_wc(), but also</p><p>The CPU may cache writes issued to and reads from the device, and serve reads from that cache.</p><p>This mode is sometimes used for video framebuffers, where drivers still expect writes to reach the device in a timely manner (and not be stuck in the CPU cache), but reads may be served from the cache for efficiency. However, it is rarely useful these days, as framebuffer drivers usually perform writes only, for which ioremap_wc() is more efficient (as it doesn't needlessly trash the cache). Most drivers should not use this.</p><h2 id="ioremap_np">ioremap_np()</h2><p>就像 ioremap() 一样，但明确请求非发布写语义。ioremap_np() 明确请求非发布语义，这意味着写入指令将不会在设备接收到写入数据之前完成。裸的 ioremap_np() 仅在某些架构上可用；在其他架构上，它始终返回 NULL。驱动程序通常不应使用它。</p><h2 id="ioremap_uc">ioremap_uc()</h2><p>它也将内存标记为非缓存，可移植驱动程序应避免使用 ioremap_uc()。</p><h2 id="ioremap_cache将-io-内存当作普通-ram-使用支持-cache">ioremap_cache()（将 I/O 内存当作普通 RAM 使用，支持 cache）</h2><p>ioremap_cache() effectively maps I/O memory as normal RAM. CPU write-back caches can be used, and the CPU is free to treat the device as if it were a block of RAM.</p><h1 id="architecture-example">Architecture example</h1><p>Here is how the above modes map to memory attribute settings on the ARM64 architecture:</p><table style="width:97%;"><colgroup><col style="width: 34%"><col style="width: 62%"></colgroup><tbody><tr class="odd"><td>API</td><td>Memory region type and cacheability</td></tr><tr class="even"><td>ioremap_np()</td><td>Device-nGnRnE</td></tr><tr class="odd"><td>ioremap()</td><td>Device-nGnRE</td></tr><tr class="even"><td>ioremap_uc()</td><td>(not implemented)</td></tr><tr class="odd"><td>ioremap_wc()</td><td>Normal-Non Cacheable</td></tr><tr class="even"><td>ioremap_wt()</td><td>(not implemented; fallback to ioremap)</td></tr><tr class="odd"><td>ioremap_cache()</td><td>Normal-Write-Back Cacheable</td></tr></tbody></table><p>说明：ARM64 将内存分为两种一种是 Device 类型、一种是 Normal</p><p>对于 Device 内存有：</p><ul><li><p>Gathering 或者 non Gathering (G or nG)：</p><p>这个特性表示对多个 memory 的访问是否可以合并，如果是 nG，表示处理器必须严格按照代码中内存访问来进行，不能把两次访问合并成一次。例如：代码中有 2 次对同样的一个地址的读访问，那么处理器必须严格进行两次 read transaction。</p></li><li><p>Re-ordering (R or nR)：</p><p>这个特性用来表示是否允许处理器对内存访问指令进行重排。nR 表示必须严格执行 program order。</p></li><li><p>Early Write Acknowledgement (E or nE)：</p><p>PE 访问 memory 是有问有答的（更专业的术语叫做 transaction），对于 write 而言，PE 需要 write ack 操作以便确定完成一个 write transaction。为了加快写的速度，系统的中间环节可能会设定一些 write buffer。nE 表示写操作的 ack 必须来自最终的目的地而不是中间的 write buffer。</p></li></ul><h1 id="参考文献">参考文献</h1><p>《Linux Document》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（六）UAC 同步方式</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACASYNC/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACASYNC/</url>
      
        <content type="html"><![CDATA[<h1 id="同步问题原因">同步问题原因</h1><h2 id="usb-isochronous-传输协议无问题">USB Isochronous 传输（协议无问题）</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB_Transfer.png"></p><h2 id="isochronous-transfer-同步问题">Isochronous Transfer 同步问题</h2><p>电脑播放器播放音乐时：是按一个固定的速率，比如 44.1KHZ，电脑内有一个晶振，可分频出一个 44.1KHZ，进行音乐播放，发给 USB 的数据流速率固定。USB 声卡自己得有一个晶振才能工作，它也可分频出一个 44.1KHZ，供给 I2S 信号或 DAC。</p><p>问题来了，晶振是有误差的，这两个 44.1KHZ 不可能完全一模一样，电脑可能是 44.100KHZ，USB 声卡可能是 44.098KHZ，误差约 50ppm，很正常的情况。虽然声卡晶振分频出来是 44.098KHZ，但声卡认为它就是工作在 44.100KHZ 下。好吧，如果二者时钟独立运行，那么 1 个小时会误差 0.2 秒，会出现不同步！ 即电脑播了 1 个小时的数据，USB 声卡实际是无法播完的，要多 0.2 秒才能播完。 如果声卡也要 1 小时播完，那这 1 小时就需要丢掉 0.2 秒的数据。</p><p>所以二者的时钟必须要同步一致才行，这就是 UAC 同步问题的原因，因此 USB 音频规定了一是采用“等时传输模式”，二是设备需要指定为 3 种同步方式之一：同步（synchronous），适应（adaptive），异步（asynchronous）。</p><span id="more"></span><p>以上摘自 <span class="exturl" data-url="aHR0cDovL2Jicy5lcmppLm5ldC9mb3J1bS5waHA/bW9kPXZpZXd0aHJlYWQmdGlkPTIwNzY2NzQmcGFnZT0x">http://bbs.erji.net/forum.php?mod=viewthread&amp;tid=2076674&amp;page=1<i class="fa fa-external-link-alt"></i></span></p><h1 id="usb-音频声卡的时钟同步方式">USB 音频声卡的时钟同步方式</h1><h2 id="usb-的-isochronous-模式">USB 的 isochronous 模式</h2><p>USB 音频声卡采用 isochronous“等时传输模式”，能保证实时传输数据，但错误容忍，出错不重传。它是实时传输，所以 USB 电脑端发出多少速率的数据，USB 接收端（USB 声卡）就得接收多少速率。比如电脑发送 44.1KHZ 的，声卡就接收 44.1KHZ。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/UAC_SyncMethod.png"></p><h3 id="asynchronous">Asynchronous</h3><p>cannot synchronize to SOF or any other clock in the USB domain。</p><p><em>Source：</em> Provides implicit feedforward(data stream)，Free running Fs</p><p><em>Sink：</em> Provides explicit feedback (isochronous pipe)，Free running Fs</p><p>Asynchronous sink endpoints must provide explicit feedback information to an adaptive driver.</p><blockquote><p>Asynchronous：要求 Sink 主动提供 data rate 信息，对信息如何使用没做规范要求，Source 和 Sink 都各自按照自己的速率运行，音频质量是最好的</p></blockquote><h3 id="synchronous">Synchronous</h3><p>Source：Uses implicit feedback(SOF)， Fs locked to SOF</p><p>Sink： Uses implicit feedback(SOF) Fs locked to SOF</p><p><em>Source：</em> its sample clock from SOF and produces a fixed number of audio samples every USB (micro)frame，</p><p><em>Sink：</em> its sample clock from SOF and consumes a fixed number of samples every USB (micro)frame.</p><blockquote><p>Synchronous：Source 和 Sink 都与 SOF 同步，这样导致 Source 和 Sink 的 clk 都不够稳定，音频质量会受到影响，但是 Source 和 Sink 都无需提供 feedback 信息，兼容性最好</p></blockquote><h3 id="adaptive">Adaptive</h3><p>Source：Uses explicit feedback(isochronous pipe) ，Fs locked to sink</p><p><em>Sink：</em> Uses implicitfeedforward (data stream)， Fs locked to data flow</p><p><em>Source：</em> Adaptive source endpoints produce data at a rate that is controlled by the data sink。</p><p>Sink：The sink provides feedback to the source，the data rate information is embedded in the data stream。The average number of samples received during a certain averaging time determines the instantaneous data rate</p><p>condition：Sink Device contains a fully adaptive sample rate converter (SRC)</p><blockquote><p>Adaptive：使用 Sink 提供的 feedback 信息（明确要求 Sink 提供 data rate 信息），调整自己的 clk 对齐 Sink</p></blockquote><h3 id="feedback">Feedback</h3><p><em>ASYNC：</em> An asynchronous sink must provide explicit feedback to the host by indicating accurately what its desired data rate (Ff) is, relative to the USB (micro)frame frequency。This allows the host to continuously adjust the number of samples sent to the sink so that neither underflow or overflow of the data buffer occurs</p><p><em>ADAPTIVE：</em> An adaptive source must receive explicit feedback from the host so that it can accurately generate the number of samples required by the host.</p><p><em>Ff:</em> the desired data rate</p><p><em>Fs:</em> actual sampling rate, 至少需要 1s 的测量时间 Tmeas（单位是帧数）。单位是帧数，对于全速设备 1ms 一帧，那么 1s 就需要 1000 帧（Fs&gt;=1000），而对于高速设备，125us 一帧 (Fs≥8000).</p><p><em>Fm：</em> 通常 Fs 是由 master clock Fm 分频得到：</p><p><span class="math display">\[F_m = F_s * 2^P\]</span></p><p>因此可以利用 Fm 来缩短测量时间 Tmeas:</p><p><span class="math display">\[T_{meas} = \frac{2^K}{2^P} = 2^{K-P}\]</span></p><p>这样测量 Fs 的时间就降低为 <span class="math inline">\(2^(K-P)\)</span> 帧时间了。</p><p>对于全速设备，Fs 需要使用定点数 10.10（K=10）格式，需要 3 字节，调整为 10.14 定点数来表示</p><p>对于高速设备，Fs 需要使用定点数 12.13（K=13）格式，需要 4 字节，调整为 16.16 定点数来表示</p><p>对 P 的要求：</p><ul><li>P must be in the range [0,K]</li><li>P 尽量大一些，这样可以减少 Tmeas 测试时间，也可以减少缓存大小</li><li>P 应该小于 K，保证至少两帧取平均来减少抖动，测量更平滑</li><li>P 不要为 0，保证在 Ff 丢失的情况下可以用更为近的 Fs 来代替，减小误差相邻数据相似性</li></ul><h3 id="implicit-feedback">Implicit Feedback</h3><p>有些时候，可以避免 explicit 实现一个 feedback endpoint，如果设备实现了一组 isochronous data endpoints，且：</p><ul><li>All the endpoints in the group are synchronized (i.e. use sample clocks that are derived from a common master clock)</li><li>The group contains one or more isochronous data endpoints in one direction that normally would need explicit feedback</li><li>The group contains at least one isochronous data endpoint in the opposite direction</li></ul><p>在这些情况下，设备可以不 explicit feedback endpoint.</p><p>有以下可能的情况：</p><ul><li>One or more asynchronous sink endpoints are accompanied by an asynchronous source endpoint. The data rate on the source endpoint can be used as implicit feedback information to adjust the data rate on the sink endpoint(s).</li><li>One or more adaptive source endpoints are accompanied by an adaptive sink endpoint. The source endpoint can adjust its data rate based on the data rate received by the sink endpoint</li></ul><h1 id="解决-5.x-以前的内核在-windows10-系统下无法识别-uac2-的问题">解决 5.x 以前的内核在 Windows10 系统下无法识别 UAC2 的问题</h1><h2 id="uac-端点描述符">UAC 端点描述符</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ENDPOIN_DESCRIPTOR_STRUCT</span> </span></span><br><span class="line"><span class="class">{</span> </span><br><span class="line">    BYTE bLength;           <span class="comment">//设备描述符的字节数大小，为 0x7 </span></span><br><span class="line">    BYTE bDescriptorType;   <span class="comment">//描述符类型编号，为 0x05</span></span><br><span class="line">    BYTE bEndpointAddress;  <span class="comment">//端点地址及输入输出属性 </span></span><br><span class="line">    BYTE bmAttribute;       <span class="comment">//端点的传输类型属性 </span></span><br><span class="line">    WORD wMaxPacketSize;    <span class="comment">//端点收、发的最大包的大小 </span></span><br><span class="line">    BYTE bInterval;         <span class="comment">//主机查询端点的时间间隔 </span></span><br><span class="line">} ENDPOIN_DESCRIPTOR_STRUCT ；</span><br></pre></td></tr></tbody></table></figure><ul><li>bLength : 描述符大小．固定为 0x07．</li><li>bDescriptorType : 端点描述符类型．固定为 0x05．</li><li>bEndpointAddress : USB 设备的端点地址．Bit7，方向，对于控制端点可以忽略，1/0:IN/OUT．Bit6-4，保留．BIt3-0：端点号．</li><li>bmAttributes : 端点属性．Bit7-2，保留（同步有定义）．BIt1-0：00 控制，01 同步，02 批量，03 中断． 当为同步传输时，bEndpointType 的 bit3-2 的值不同代表的含义不同：00：无同步，01：异步，10：适配，11：同步；BIT5:4 含义 00: 表示数据端点，01：表示反馈端点 Feedback endpoint，10：表示隐式反馈数据端点 Implicit feedback Data endpoint，11: 保留</li><li><p>wMaxPacketSize : 本端点接收或发送的最大信息包大小．</p><ul><li><p>USB2.0 时： 对于同步端点，此值用于指示主机在调度中保留的总线时间，这是每（微）帧数据有效负载所需的时间，有效负载时间就是发送一帧数据需要占用的总线时间，在实际数据传输过程中，管道实际使用的带宽可能比保留的带宽少，大家想想，如果实际使用的带宽比保留的还多，那就丢数了；</p><p>对于其类型的端点，bit10~bit0 指定最大数据包大小（以字节为单位）；</p><p>bit12~bit11 对于高速传输的同步和中断端点有效：bit12~bit11 可指定每个微帧的额外通信次数，这里大家一定要知道是在高速传输中，当一个事务超时时，在一个微帧时间内重传的次数，如果设置为 00b（None），则表示在一个微帧内只传输一个事务，不进行额外的超时重传，如果设置为 01b，则表示在一个微帧内可以传输两次事务，有一次额外的重传机会，从下面可以看出，一个微帧最多可以有两次重传事务的机会，如果微帧结束了还是失败，就需要等到下一个微帧继续发送该事务；</p></li><li><p>USB3.0 时： wMaxPacketSize 表示包的大小。对于 bulk 为 1024，而对于同步传输，可以为 0~1024 或 1024。</p></li></ul></li><li>bInterval : 轮询数据传送端点的时间间隔．对于批量传送和控制传送的端点忽略．对于同步传送的端点，必须为１，对于中断传送的端点，范围为 1-255．<ul><li>对于全速/高速同步端点，此值必须在 1 到 16 之间。bInterval 值用作 2 的指数，例如 bInterval 为 4，表示周期为 8 个单位；</li><li>对于全速/低速中断端点，该字段的值可以是 1 到 255，也就是主机多少 ms 给设备发一次数据请求；</li><li>对于高速中断端点，使用 bInterval 值作为 2 的指数，例如 bInterval 为 4 表示周期为 8。这个值必须在 1 到 16 之间；</li><li>对于高速批量/控制输出端点，bInterval 必须指定端点的最大 NAK 速率。值 0 表示端点永不 NAK。其它值表示每个微帧的 bInterval*125us 时间最多 1 个 NAK。这个值的范围必须在 0 到 255 之间；<ul><li>00 = None (1 transaction per microframe)</li><li>01 = 1 additional (2 per microframe)</li><li>10 = 2 additional (3 per microframe)</li><li>11 = Reserved</li><li>其它位默认为 0，</li></ul></li><li>对于全速/低速批量/控制输出端点，此值无意义，可以任意指定。</li></ul></li></ul><p>以 fs_epout_desc 为例描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* STD AS ISO OUT Endpoint */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> <span class="title">fs_epout_desc</span> =</span> {</span><br><span class="line">  .bLength = USB_DT_ENDPOINT_SIZE,    <span class="comment">//#define USB_DT_ENDPOINT_SIZE7</span></span><br><span class="line">  .bDescriptorType = USB_DT_ENDPOINT, <span class="comment">//#define USB_DT_ENDPOINT0x05</span></span><br><span class="line"></span><br><span class="line">  .bEndpointAddress = USB_DIR_OUT,    <span class="comment">// #define USB_DIR_OUT0/* to device */</span></span><br><span class="line">  <span class="comment">// #define USB_ENDPOINT_XFER_ISOC1 /* 同步传输 */</span></span><br><span class="line">    <span class="comment">// #define USB_ENDPOINT_SYNC_ADAPTIVE(2 &lt;&lt; 2) /* 适配 */</span></span><br><span class="line">  .bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE, </span><br><span class="line">  <span class="comment">/* The USB limits the maximum data payload size to 1,023 bytes for each full-speed isochronous endpoint.</span></span><br><span class="line"><span class="comment">High-speed endpoints are allowed up to 1024-byte data payloads. */</span></span><br><span class="line">  .wMaxPacketSize = cpu_to_le16(<span class="number">1023</span>),</span><br><span class="line">  .bInterval = <span class="number">1</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><em>IN 和 OUT 都是相对于 USB Host 设备来讲的：</em></p><p><strong>对于 OUT Endpoint 不支持 ASYNC 做如下说明：</strong></p><ul><li>ASYNC 模式下需要 Sink 设备 Provides explicit feedback，而对于 OUT Endpoint，Sink 设备是我们的主机，这说明我们的设备不支持 feedback</li></ul><p><strong>对于 IN EndPoint，测试发现支持 ASYNC 做如下说明：</strong></p><ul><li>ASYNC 模式下需要 Sink 设备 Provides explicit feedback，而对于 IN Endpoint，Sink 设备是测试的 Windows10 系统，说明 Windows10（基于我的测试版本）是支持 feedback</li></ul><p><em>结论：</em><br>Windows 的 UAC2 是支持 Feedback 的，而我们的系统不支持，那么将 OUT Endpoint 改成 ADAPTIVE 模式符合 USB isochronous 传输规范，但是因为我们设备没有实现 feedback，有没有利用到 Host 提供的 feedback 信息待验证。同理 OUT Endpoint 改成 ADAPTIVE 模式，那么 IN EndPoint 就可以保持为 ASYNC，因为这都要求 Host 端提供 feedback。当然全部改成 SYNC 模式也可以获得很好的兼容性，但是会造成 Source 和 Sink 的 clk 抖动。 还有另外一种做法，我看到 Linux6.x 驱动里已经支持 feedback 了，移植过来 Device 端就支持三种同步方式了。</p><p>fs_epout_desc 端点会由 USB_ENDPOINT_SYNC_ASYNC 改成 USB_ENDPOINT_SYNC_ADAPTIVE，最新的 6.x 内核会根据是否支持 feedback 来决定用哪个同步模式，如果支持 feedback 就用 USB_ENDPOINT_SYNC_ASYNC，如果不支持 feedback 就用 USB_ENDPOINT_SYNC_ADAPTIVE。实际上用 USB_ENDPOINT_SYNC_SYNC 也能够在 windows 上识别。 fs_epin_desc 端点：由 USB_ENDPOINT_SYNC_ASYNC 改成 USB_ENDPOINT_SYNC_SYNC。</p><h1 id="总结">总结</h1><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th></th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>SYNC</td><td>Source 和 Sink 各自运行在自己的 Clock 下，两者之间没有任何反馈，Source 只管发，Sink 只管收</td><td>简单</td><td>运行时间久了由于两则的 clock 不匹配会导致 hw buffer 溢出或者为空导致 xrun 问题</td></tr><tr class="even"><td>ADAPTIVE</td><td>Source 提供自己的 srate 信息给 Sink，Sink 可以自己调节 Clock 或者其他方式匹配 Source 的 Clock</td><td>提供了一种匹配 Clock 的方式，可以解决 xrun 问题了</td><td>由于 Source 端发送频率和大小固定，只能 Device 端靠调节 Clock 来解决 xrun，调节 clock 会影响音质</td></tr><tr class="odd"><td>ASYNC</td><td>Sink 提供自己的 srate 给 Source，Source 通过调节每个 USB 包大小来匹配 Sink 的 Clock</td><td>提供了匹配 clock 的方式，解决了 xrun 问题</td><td></td></tr><tr class="even"><td>Sink 不需要调节 clock，音质不会受到任何影响，完美</td><td>无</td><td></td><td></td></tr></tbody></table><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（五）Feature Unit</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACFU/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACFU/</url>
      
        <content type="html"><![CDATA[<h1 id="音量基本概念">音量基本概念</h1><h3 id="声学中的分贝"><strong>声学中的分贝</strong></h3><p>因为人耳的特性，我们对声音的大小感知呈对数关系。所以我们通常用分贝描述声音大小，分贝（decibel）是量度两个相同单位之数量比例的单位，主要用于度量声音强度，常用 dB 表示。声学中，声音的强度定义为声压。计算分贝值时采用 20 微帕斯卡为参考值（通常被认为是人类的最少听觉响应值，大约是 3 米以外飞行的蚊子声音）。这一参考值是人类对声音能够感知的 <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTklOTglODglRTUlODAlQkMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">阈值<i class="fa fa-external-link-alt"></i></span> 下限。声压是场量，因此使用声压计算分贝时使用下述版本的公式：</p><p><span class="math display">\[L_p = 20log_{10}(\frac{p_{rms}}{p_{ref}})dB\]</span></p><p>其中的 pref 是标准参考声压值 20 微帕。</p><h3 id="分贝声音变化范围"><strong>分贝声音变化范围</strong></h3><p>在编程中，我们可以用以下公式计算两个声音之间的动态范围，单位为分贝：</p><p><span class="math display">\[dB = 20 * log(A1 / A2)\]</span></p><p>其中 A1 和 A2 是两个声音的振幅，在程序中表示每个声音样本的大小。声音采样大小（也就是量化深度）为 1bit 时，动态范围为 0，因为只可能有一个振幅。采样大小为 8bit 也就是一个字节时，最大振幅是最小振幅的 256 倍。因此，动态范围是 48 分贝，计算公式如下：</p><p><span class="math display">\[dB = 20 * log(256)\]</span></p><p>48 分贝的动态范围大约是一个安静房间和一台运行着电动割草机之间的区别。如果将声音采样大小增加一倍到 16bit，产生的动态范围则为 96 分贝，计算公式如下：</p><p><span class="math display">\[dB = 20 * log(65536)\]</span></p><p>这非常接近听力最低阈值和产生痛感之间的区别，这个范围被认为非常适合还原音乐。</p><p><strong>音量滑块与声音增幅大小线性变化</strong></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/fu1.png"></p><span id="more"></span><p>上述左图中，音量滑块位置与声音振幅为线性增长关系，右图是我们人耳感受的音量大小与滑块位置关系。可知，在左侧移动相同距离的滑块，感知到的声音变化范围很大，在右侧接近声音最大值移动相同距离滑块，感知到的声音大小变化就很小了。</p><h2 id="windows-音量滑块与声音-db-转换关系">Windows 音量滑块与声音 DB 转换关系</h2><p>可参考如下链接：</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL3dpbmRvd3MtaGFyZHdhcmUvZHJpdmVycy9hdWRpby9kZWZhdWx0LWF1ZGlvLXZvbHVtZS1zZXR0aW5ncw==">默认的音频音量设置 - Windows drivers<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/fu2.png"></p><p>Linux 中默认的配置是-100db 到 0db，而 windows 中的音量范围对应的是-96db-0db（Device 收到的 volume 将是-96db-0db 而不会收到-100db），而用户可调的滑块是从 0-100 的范围值。实测 UAC 中调节滑块发送给 Device 的音量值如下（单位是分贝）：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/fu3.png"></p><h1 id="feature-功能实现"><strong>Feature 功能实现</strong></h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/fu4.png"></p><p>红色框中就是我们要实现的内容，UAC Spec 里说明了通过描述符来表示一个 Function Tologry 关系，只要利用描述符将这个关系描述清楚，Host 端就知道 Device 支持 Feature Unit，那么 Host 在调节音量的时候就会通过 Request 接口请求获得设备的 volume 和 mute 以及通过 Setup 接口来设置 Volume 和 Mute。这个关系的描述如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AMLOGIC_MODIFY</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_CONFIGFS_UAC_FEATURE_UNIT</span></span><br><span class="line"><span class="keyword">if</span> (FUIN_EN(opts)) {</span><br><span class="line">usb_in_ot_desc.bSourceID = in_feature_unit_desc-&gt;bUnitID;</span><br><span class="line">in_feature_unit_desc-&gt;bSourceID = io_in_it_desc.bTerminalID;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">usb_in_ot_desc.bSourceID = io_in_it_desc.bTerminalID;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">usb_in_ot_desc.bSourceID = io_in_it_desc.bTerminalID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AMLOGIC_MODIFY</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USB_CONFIGFS_UAC_FEATURE_UNIT</span></span><br><span class="line"><span class="keyword">if</span> (FUOUT_EN(opts)) {</span><br><span class="line">io_out_ot_desc.bSourceID = out_feature_unit_desc-&gt;bUnitID;</span><br><span class="line">out_feature_unit_desc-&gt;bSourceID = usb_out_it_desc.bTerminalID;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">io_out_ot_desc.bSourceID = usb_out_it_desc.bTerminalID;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">io_out_ot_desc.bSourceID = usb_out_it_desc.bTerminalID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>简单描述一下就是将 feature unit 描述符插入 Input Terminal（IT）和 Output Terminal（OT）之间，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">as_in_hdr_desc</span><br><span class="line">|</span><br><span class="line">io_in_it_desc -&gt; in_feature_unit_desc -&gt; usb_in_ot_desc</span><br><span class="line">usb_out_it_desc -&gt; out_feature_unit_desc -&gt; io_out_ot_desc</span><br><span class="line">|</span><br><span class="line">as_out_hdr_desc</span><br></pre></td></tr></tbody></table></figure><p>然后只需要在 usb function 里的 setup 回调里识别 bRequestType 和 bRequest 来判断是设置采样率还是设置 mute 或者是设置 volume 来做相应的处理（存储 volume 值和通过 snd_ctl_notify 通知 alsa 的 kcontrol volume 以及发生变化）就可以了。</p><p>同时如果 device 要主动通知 Host 端 Attributes 发生变化，需要实现一个 interrupt endpoint，然后通过这个中断端点通知 Host 变化。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">w_index = unit_id &lt;&lt; <span class="number">8</span> | uac2-&gt;ac_intf;</span><br><span class="line">w_value = cs &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">msg-&gt;bInfo = <span class="number">0</span>; <span class="comment">/* Non-vendor, interface interrupt */</span></span><br><span class="line">msg-&gt;bAttribute = UAC2_CS_CUR;</span><br><span class="line">msg-&gt;wIndex = cpu_to_le16(w_index);</span><br><span class="line">msg-&gt;wValue = cpu_to_le16(w_value);</span><br><span class="line"></span><br><span class="line">req-&gt;length = <span class="keyword">sizeof</span>(*msg);</span><br><span class="line">req-&gt;buf = msg;</span><br><span class="line">req-&gt;context = agdev;</span><br><span class="line">req-&gt;complete = afunc_notify_complete;</span><br><span class="line"></span><br><span class="line">ret = usb_ep_queue(uac2-&gt;int_ep, req, GFP_ATOMIC);</span><br></pre></td></tr></tbody></table></figure><h1 id="feature-unit-vs-hid">Feature Unit VS HID</h1><h3 id="binding-between-physical-buttons-and-audio-controls"><strong>Binding between Physical Buttons and Audio Controls</strong></h3><p>大多数包含音频功能的设备也会有一个或多个 frontpanel buttons，用于控制设备内某些方面的音频功能。最明显的例子是多媒体扬声器前面的音量控制按钮。由于音频功能可能包含许多相同类型的音频控件，因此需要将物理控件（按钮、旋钮、滑块、点动等）绑定到音频功能中的特定音频控件。 本规范提供了两种互斥的方法来提供这种绑定：</p><ul><li>物理按钮实现为 HID 控件</li><li>物理按钮是音频控制的集成部分</li></ul><p>禁止对同一个物理按钮实现这两种方法。但是，允许对某些 frontpanel buttons 使用第一种方法，对其余 frontpanel buttons 使用第二种方法。强烈建议不使用上述两种方法实现前面板按钮，即对主机软件不可见且仅具有局部效果的按钮。</p><h3 id="physical-button-is-a-hid-control"><strong>Physical button is a HID Control</strong></h3><p>HID 是 USB 设备中的一种设备类型，他与 UAC 之间并没有直接的关联性，两者是完全独立的，只是 HID 设备包括鼠标、键盘、遥杆等具有通过 USB 控制 host 的声音的设备，可以通过实现这些设备的描述符实现对 host 的音量控制，这样就可以用来控制 UAC 的音量。</p><p>在这种情况下，物理按键与音频功能完全分离，并在设备的 HID 接口内实现。音频功能甚至不知道按钮的存在。按钮的任何状态变化都通过 HID 报告传送给主机软件。然后由主机软件来解释按钮状态的变化，并从那里获得对音频功能要采取的适当行动。因此，绑定责任完全属于应用程序或操作系统软件。尽管此方法提供了广泛的灵活性但它也给软件带来了提供正确绑定的负担。</p><h3 id="physical-button-is-integral-part-of-the-audio-control"><strong>Physical button is Integral Part of the Audio Control</strong></h3><p>而 Feature Unit 是 UAC 标准里定义的特性单元，功能更强大可以实现对每个逻辑通道提供音频控制，包括但不限于 mute 和 volume。</p><p>在这种情况下，物理按键直接与实际的音频控制交互。按钮状态更改不会报告给主机软件。相反，由按钮操作引起的音频控制的状态变化通过音频控制中断机制报告给主机软件。因此，物理按钮和 Audio 控件之间的绑定非常直接，完全由设备的设计决定。尽管不太灵活，但该方法提供了一种非常清晰和直接的方式来执行绑定。</p><h1 id="测试验证">测试验证</h1><h2 id="host-调节音量">Host 调节音量</h2><p>在 pc 上调节音量，Host 会通过 ep0 端点给 Device 发送音量值，其对应关系如上图所示，Device 端接收到消息后会存储该音量值然后通知用户层 volume change 这个消息，用户就可以知道 Host 修改了 uac 的音量，然后可以通过相关接口获取更改后的音量值。然后具体的行为完全由用户决定。例如这里以设备执行 arecord -Dhw:2,0 -r 48000 -c 2 -f S16_LE | aplay -Dhw:0,1 -c 2 -r 48000 -f S16_LE 为例，arecord 录制 uac 的音频然后通过管道 aplay 到 TDMB 设备。 那么我们就可以通过如下命令获取和设置音量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 uac 声卡的音量</span></span><br><span class="line">amixer -c 2 cget numid=4,iface=MIXER,name=<span class="string">'PCM Capture Volume'</span></span><br><span class="line"><span class="comment"># 设置 tdmb 的音量</span></span><br><span class="line">amixer -c 0 cset numid=13,iface=MIXER,name=<span class="string">'5707_B Master Volume'</span> xxx</span><br></pre></td></tr></tbody></table></figure><p>这种方式非常灵活，且属性的变化以及对变化的操作完全由应用程序控制。</p><h2 id="device-主动调节音量">Device 主动调节音量</h2><p>之前如果是通过按键调节音量那么是通过 HID 驱动程序通知 Host 去调节音量，现在有了 Feature Unit 之后便不再需要 HID 来同步 Device 和 Host 的音量了，可以直接通过设置 uac 声卡的音量然后 Feature Unit 会通过中断端点将 volume 报告给 Host。例如，我们还是通过 amixer 设置 UAC 声卡的音量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amixer -c 2 cset numid=4,iface=MIXER,name=<span class="string">'PCM Capture Volume'</span> 100</span><br></pre></td></tr></tbody></table></figure><p>那么会在 windows 上看到系统的音量条跟着发生变化。</p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（四）HID</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACHID/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACHID/</url>
      
        <content type="html"><![CDATA[<h1 id="hid-相关概念">HID 相关概念</h1><p>报表描述符由描述 HID 设备的数据项目（Item）组成，Item 的第一个字节（项目前缀）由三部分构成，<strong>即项目类型（item type）、项目标签（item tag）和项目长度（item size）。</strong></p><p>HID 的项目有短项目和长项目两种，其中短项目的格式如下图：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid1.png"></p><span id="more"></span><ul><li><em>bSize 定义 short Item 的数据字节数，为 0、1、2、3 时 Data 部分的字节数分别为 0、1、2、4 个字节</em></li><li><em>bType 是 short Item 的类型，为 0、1、2 时分别为 Main、Global 和 Local 类型</em></li><li>bTag 是 Item 标志，有 Input、Output、Collection、Usage Page、Usage 等</li></ul><p>长项目可以携带较多的数据，其格式如下图（用的少）：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid2.png"></p><ul><li><em>item 中的第一个字节为上图中的特定值时表明该项目是一个长项目</em></li><li><em>bDataSize 说明 Data 部分的字节数</em></li><li><em>bLongItemTag 在 HID 规范中没有定义</em></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid3.png"></p><p>下面以 0x05, 0x0c 为例来说明一下：</p><p>0x05（0b00000101）其中 bit2-3 代表 short item 的 type，1 代表的是 global 项目，最后两位代表数据长度是 1Byte，通过查表可以知道这是一个** USAGE_PAGE** item，而后面的 0x0c 也是可以通过查表了解到是 Consumer</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid4.png"></p><p>其他配置依次类推就可以了。</p><h1 id="配置-configfs">配置 configfs</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># HID</span><br><span class="line">echo <span class="string">"hid"</span> &gt; strings/<span class="number">0x409</span>/configuration</span><br><span class="line">mkdir functions/hid<span class="number">.0</span></span><br><span class="line">echo <span class="number">1</span> &gt; functions/hid<span class="number">.0</span>/protocol</span><br><span class="line">echo <span class="number">1</span> &gt; functions/hid<span class="number">.0</span>/subclass</span><br><span class="line">echo <span class="number">8</span> &gt; functions/hid<span class="number">.0</span>/report_length</span><br><span class="line">echo -ne <span class="string">"\x05\x0c\x09\x01\xa1\x01\x09\xe9\x09\xea\x09\xe2\x09\xcd\x15\x00\x25\x01\x95\x04\x75\x01\x81\x02\x75\x04\x95\x01\x81\x03\xc0"</span> &gt; functions/hid<span class="number">.0</span>/report_desc</span><br><span class="line">ln -s functions/hid<span class="number">.0</span> configs/amlogic<span class="number">.1</span>/hid<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><h1 id="报告描述符结构">报告描述符结构</h1><p>关于报告描述符做如下解析：</p><ul><li>0x05, 0x0c // USAGE_PAGE (Consumer Page)</li><li>0x09, 0x01 // USAGE (Consumer Control)</li><li>0xa1, 0x01 //COLLECTION (Application)</li><li>0x09, 0xe9 //USAGE (Volume Increment)</li><li>0x09, 0xea //USAGE (Volume Decrement)</li><li>0x09, 0xe2 //USAGE (Mute)</li><li>0x09, 0xcd //USAGE (Play/Pause)</li><li>0x15, 0x00 //LOGICAL_MINIMUM (0)</li><li>0x25, 0x01 //LOGICAL_MAXIMUM (1)</li><li>0x95, 0x04 //REPORT_COUNT (4)</li><li>0x75, 0x01 //REPORT_SIZE (1)</li><li>0x81, 0x02 //INPUT (Data,Var,Abs)</li><li>0x75, 0x04 //REPORT_SIZE (4)</li><li>0x95, 0x01 //REPORT_COUNT (1)</li><li>0x81, 0x03 //INPUT (Cnst,Var,Abs)</li><li>0xc0 //END_COLLECTION</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid5.png"></p><h3 id="consumer-page-0x0c"><strong>Consumer Page (0x0C)</strong></h3><h3 id="volume-decrementvolume-incrementmuteplay">Volume Decrement、Volume Increment、Mute、Play</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid6.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid7.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid8.png"></p><h1 id="验证">验证</h1><p>在设备端执行 uac_hid command 可以看到 windows 的音量有发生变化就说明 uac hid 功能正常</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/hid9.png"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudXNiemguY29tL2FydGljbGUvZGV0YWlsLTQ4Lmh0bWw=">HID 报表描述符/报告描述符 - USB 中文网<i class="fa fa-external-link-alt"></i></span></p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（三）Spec-Interrupt</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACSpecInterrupt/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACSpecInterrupt/</url>
      
        <content type="html"><![CDATA[<h1 id="interrupts"><strong>Interrupts</strong></h1><p>中断用于通知 host 音频功能的当前状态发生了变化。本规范目前定义了两种不同类型的中断：</p><ul><li>Memory Change: 某些内部实体的内存位置已更新。可以通知主机软件，以便采取适当的行动。</li><li>Control Change: 音频函数内部的某些可寻址控件更改了其一个或多个属性值</li></ul><p>时钟实体、单元或终端内部的音频控件可以是中断的源。同样，AudioControl 接口中的任何可寻址 Control 或任何 AudioStreaming 接口都可以生成中断。最后所有与音频端点相关的可寻址控件都可能是中断的源。</p><p>音频功能的状态变化通常是由发生的特定事件引起的。事件可以是用户发起的，也可以是设备发起的。用户发起的插孔插入或移除是用户发起事件的典型示例。主机可以切换选择器或混音器，以便从刚刚插入的设备 （例如耳机）播放音频，并停止从当前设备（例如扬声器） 播放音频。设备启动事件的示例如下：一个外部设备 （例如 A/V 接收器可以在其光学数字输出上从 PCM 转换为 AC-3 编码数据，这取决于当前正在播放的材料如果此设备连接到具有自动检测功能的音频功能的光学数字输入，则该音频功能上的接口可能需要重新配置（例如，启动 AC-3 解码过程），这可能会导致所有其他接口的格式发生某些变化，甚至变得不可用。设备可以发出中断，让主机知道音频功能需要重新配置。</p><span id="more"></span><h1 id="interrupt-data-message"><strong>Interrupt Data Message</strong></h1><p>实际的中断类型（内存更改或控制更改）及其发起者通过中断端点发送的中断数据消息传递给主机。然后，主机负责通过获取内存请求或第 5.2 节“类特定请求”中定义的获取控制请求之一来查询音频功能，以获得关于中断原因的更详细信息。</p><p>中断被认为是“edge-triggered”类型，这意味着当事件发生时就会生成中断，但是 Host 不需要采取特定的操作来清除中断条件。当 Host 响应中断发出获取请求时，将返回控件属性的最新值。</p><p>中断数据消息的长度始终为 6 个字节。所有中断数据消息都需要第一个 bInfo 字段。它包含 D0 中的信息，表明这是特定于供应商的中断（D0 = 0b1）还是特定于类的中断（D0 = 0b0）。位 D1 表示中断是来自接口（D1 = 0b0）还是来自端点（D1 = 0b1）。bInfo 字段的位 D7..2 被保留为将来的扩展，并且必须设置为零。对于特定于供应商的中断，将不会对中断消息的其余部分的布局进行定义。对于特定于类的中断，其布局定义如下。</p><p>当中断来自接口中的实体（bInfo 字段中的 D1=0b0）时，wIndex 字段指定低字节和实体 ID（时钟实体 ID、单元 ID、终端 ID、编码器 ID 或解码器 ID）中的接口。为了指示接口本身，必须在高字节中指定实体 ID。</p><p>当中断来自一个端点（bInfo 字段中的 D1=0b1）时，wIndex 字段指定要以低字节处理的端点和以高字节处理的零端点。</p><p>wValue 字段的解释由 wIndex 字段中的值限定。wValue 字段的布局根据地址的实体而变化。对于每个支持的 Gat value 控制请求，wValue 字段遵循第 5 节“请求”中概述的完全相同的规则。wValue 字段返回高字节中的控制选择器（CS）和低字节中的通道号（CN）。控制选择器和通道号（CN）一起准确地指示哪个控制产生中断的。如果一个控制是通道独立的，则控制被认为是一个主控制，并返回虚拟信道零以指示它（CN = 0）。</p><p>上面有两个例外。第一个是当混合器单元控制请求返回高字节中的 CS = MU_MIXER_CONTROL 时。然后以低字节返回混合器控制号（MCN）。第二个是内存请求，其中 wValue 字段指定一个基于零的偏移值，该值表示生成中断的实体的内存空间中的位置的地址。如果偏移值为零，则表示多个内存位置可能发生了更改，需要检查整个内存空间</p><p><strong>bAttribute </strong>字段包含一个常量，用来标识被寻址的控件或实体的哪个属性导致了中断。可能的属性包括：</p><ul><li>Current setting attribute (CUR)</li><li>Range attribute (RANGE)</li><li>Memory space attribute (MEM)</li></ul><p>当没有挂起的中断时，中断端点在轮询时必须为 NAK。下表指定了当 D0 = 0b0 时，中断消息的格式：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac15.png"></p><h1 id="interrupt-sources"><strong>Interrupt Sources</strong></h1><p>音频功能的可寻址实体内的任何控制都可以是中断的源。中断消息包含足够的信息来确定究竟是哪个控制导致了中断。然后，主机可以发出正常的控制请求，以进一步确定中断的原因。</p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（二）Spec-Requests</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACSpecRequests/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACSpecRequests/</url>
      
        <content type="html"><![CDATA[<h1 id="standard-requests"><strong>Standard Requests</strong></h1><p>音频设备类支持 USB 规范的第 9 节“USB 设备框架”中描述的标准请求。音频设备类对标准请求的值没有提出特定的要求。</p><h1 id="class-specific-requests"><strong>Class-Specific Requests</strong></h1><p>特定于类的请求用于设置和获取与音频相关的控件。这些控制器主要分为两组：那些操纵音频功能的控制器，如音量，音调，选择器的位置等。以及那些影响等时终点上的数据传输的数据，比如当前的采样频率。</p><ul><li><p><strong>AudioControl Requests</strong></p><p>对音频功能的控制是通过操作嵌入在音频功能的实体中的单个控件的属性来执行的。特定于类的音频控件接口描述符包含一组实体描述符，每个描述符指示实体中存在哪些控件。音频控制请求总是指向音频功能的单个音频控制接口。请求包含足够的信息（实体 ID、控制选择器和通道号），以便音频功能决定必须路由特定请求的位置。同样的请求布局也可用于特定于供应商的对扩展单元的请求。但是，本规范不包括它们</p></li><li><p><strong>AudioStreaming Requests</strong></p><p>对音频流接口的类特定行为的控制是通过操作接口控制或端点控制来执行的。它们可以是特定于类的（如本规范中定义的）或特定于供应商的。对于任何一种情况，都可以使用相同的请求布局。音频流请求被定向到控件所在的收件人。这可以是接口或它关联的等时端点。</p></li></ul><p>音频设备类支持一个附加的特定于类的请求：</p><ul><li><p><strong>Memory Requests</strong></p><p>音频功能中的每个可寻址实体（时钟实体、终端、单元、接口和端点）都可以公开一个内存映射接口，从而提供通用地操作实体的方法。特定于供应商的控制实现可以基于这种类型的请求。</p></li></ul><p>原则上，所有的请求都是可选的。如果音频功能不支持某个请求，则必须通过在向该功能发出请求时停止控制管道来表明这一点。但是，如果支持某个集合请求，则也必须支持关联的 Get 请求。可以支持获取请求，而不支持关联的集合请求。如果支持中断，那么就必须实现所有必要的 Get 请求，这些请求需要从音频功能中检索适当的信息，以响应这些中断</p><span id="more"></span><h2 id="control-attributes"><strong>Control Attributes</strong></h2><p>实体中的每个控件都可以具有一个或多个与其关联的属性。控件当前定义的属性包括：</p><ul><li>Current setting attribute (CUR)</li><li>Range attribute (RANGE)</li></ul><p>CUR 属性用于操作控件的当前实际设置。范围属性提供了关于控制对 CUR 的允许设置所施加的限制的信息属性。范围属性实际上是由一个子属性数组组成的。子属性为最小值（MIN）、最大值（MAX）和分辨率（RES）。它们总是以 [MIN，MAX，RES] 形式的三联体进行操作，不能单独访问或修改。范围属性支持这些三联体的数组，以便能够准确地报告一个控件的不连续的多个子范围。数组中的第一个元素包含控件所支持的子范围的数量。数组中的后续三联体元素对应于每个子范围。子范围必须按升序排列（从较低值到较高值）。单个子范围不能重叠（即前一个子集的最大值不能等于下一个子范围的最小值）。如果一个子集只包含一个值，则对应的三值组必须同时包含其 MIN 和 MAX 子属性的该值，并且 RES 子属性必须设置为零</p><p>例如，考虑一个（假设的）volume 控制，它可以为其 CUR 属性获取以下值：</p><ul><li>-∞ dB</li><li>-70 dB to -40 dB in steps of 3 dB</li><li>-40 dB to -20 dB in steps of 2 dB</li><li>-20 dB to 0 dB in steps of 1 dB</li></ul><p>范围属性的一个可能的布局是：</p><p>RANGE(0) = 3 RANGE(1) = [-70, -40, 3] RANGE(2) = [-38, -20, 2] RANGE(3) = [-19, 0, 1]</p><p>表示相同控件的另一种方法如下：</p><p>RANGE(0) = 3 RANGE(1) = [-70, -43, 3] RANGE(2) = [-40, -22, 2] RANGE(3) = [-20, 0, 1]</p><p>它是由设计者来选择一个合适的表示方式的。虽然可以将一个范围表示为构成该范围的离散值，但非常不鼓励使用这种表示。</p><h2 id="control-request-layout"><strong>Control Request Layout</strong></h2><p>音频设备类定义的请求布局严格遵循 USB 规范中定义的标准请求布局。该请求用于设置或获取音频功能的实体内的控件的属性。下表详细说明了请求的布局：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac6.png"></p><p>Bit D7 of the <strong>bmRequestType</strong> field specifies whether this is a Set request (D7 = 0b0) or a Get request</p><p>(D7 = 0b1). It is a class-specific request (D6..5 = 0b01), directed to either an interface (AudioControl or</p><p>AudioStreaming) of the audio function (D4..0 = 0b00001) or the isochronous endpoint of an</p><p>AudioStreaming interface (D4..0 = 0b00010).</p><p>bReset 字段包含一个常量，标识要操作的控件的哪个属性。控件的可能属性包括：</p><ul><li>Current setting attribute (CUR)</li><li>Range attribute (RANGE)</li></ul><p>如果寻址的控件不支持修改某个属性，则在尝试修改该属性时，控制管道必须指示失速。在大多数情况下，Set 请求只支持 CUR 属性。但是，此规范并不阻止设计者使范围属性可编程。有关请求常量的列表，请参见附录 A.14，“音频类别特定的请求代码”。</p><p>作为一般规则，当设置了一个属性值时，一个控件将自动将传递的值调整到最接近的可用有效值。这个值可以通过后续的获取控制请求来检索。</p><p>上面这个规则的唯一例外是复制保护控制。当复制保护控制不能准确地满足“设置”请求时，控制管道必须指示一个 stall。</p><p>wValue 字段指定高字节中的控制选择器（CS），以及低字节中的通道号（CN）。控制选择器指示此请求正在操作的控制类型。通道号（CN）表示要影响集群的哪个逻辑通道。如果一个控制是通道独立的，则控制被认为是一个主控制，虚拟信道零被用来解决它（CN = 0）。如果请求为该单元指定了未知或不支持的 CS 或 CN，则控制管道必须指示 stall。</p><p>上面也有一个例外。如果混音器单元控制请求想要处理一个混音器控制，它将在高字节中指定 CS = MU_MIXER_CONTROL 为控制选择器，在低字节中指定混音器控制号（MCN）。</p><p>当请求处理接口（bmRequestType=0b00100001 或 10100001）中的实体时，wIndex 字段指定 Interface 由低字节和实体 ID（时钟实体 ID、单元 ID、终端 ID、编码器 ID 或解码器 ID）。要寻址接口本身，必须在高字节中指定一个为零的实体 ID。</p><p>当请求寻端点（bmRequestType=0b00100010 或 10100010）时，wIndex 字段指定 Endpoint 由低字节寻址，高字节为 0。</p><p>wIndex 中的值必须适用于 recipient。只能处理音频功能或音频流媒体接口中的现有实体，并且只能使用适当的接口或端点编号。如果请求指定了未知或非实体 ID 或未知的接口或端点编号，则控制管道必须指示 stall。</p><p>Set 请求的实际参数在控制传输的数据阶段中传递。参数块的长度在请求的 wLength 字段中表示。参数块的布局由 bRequest 和 wIndex 字段限定。有关所有可能的实体的参数块布局的详细描述，请参阅以下部分。</p><p>Get 请求的实际参数将在控制传输的数据阶段中返回。要返回的参数块的长度在请求的 wLength 字段中表示。如果参数块比 wLength 字段中指示的长度更长，则只返回参数块的初始字节。如果参数块小于 wLength 字段中所指示的值，则该设备在请求进一步的数据时，通过发送一个较短的数据包来表示控制传输的结束。参数块的布局由 bRequest 和 wIndex 字段限定。有关所有可能的实体的参数块布局的详细描述，请参阅以下部分。</p><h2 id="control-request-parameter-block-layout"><strong>Control Request Parameter Block Layout</strong></h2><p>除了少数例外情况外，几乎所有的控制请求在集合或获取请求期间都操作单个控制参数。对于这些请求，可能的参数块布局可以分为三类，这取决于控件的 CUR 属性的字节大小。一个 CUR 属性的大小可以是一个 1Byte 一个 word（2 字节）或一个 double word（4 字节）。以下段落指定了这三个类别的 CUR 和范围参数块的布局</p><p>对于那些使用偏差参数块布局的请求，实际布局将在相关部分中明确定义</p><h3 id="layout-1-parameter-block"><strong>Layout 1 Parameter Block</strong></h3><p>控件的 1 字节大小的 CUR 属性的参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac7.png"></p><p>该控件的范围属性的关联参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac8.png"></p><h3 id="layout-2-parameter-block"><strong>Layout 2 Parameter Block</strong></h3><p>控件的 2 字节大小的 CUR 属性的参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac9.png"></p><p>该控件的范围属性的关联参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac10.png"></p><h3 id="layout-3-parameter-block"><strong>Layout 3 Parameter Block</strong></h3><p>控件的 4 字节大小的 CUR 属性的参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac11.png"> 该控件的范围属性的关联参数块如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac12.png"></p><h2 id="common-controls"><strong>Common Controls</strong></h2><p>以下部分描述了一些可以出现在多个实体类型中的控件。这里只对它们进行了描述一次，并且为所有可以包含任何这些控件的实体提供了对这些控件描述的引用</p><h3 id="enable-control"><strong>Enable Control</strong></h3><p>启用控件用于启用实体的功能或完全绕过该实体。在后一种情况下，将假定为默认行为。启用控件必须只有 CUR 属性。“启用控件 CUR”属性的值可以为 TRUE 或 FALSE。“控制选择器”字段必须设置为 XX_ENABLE_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段必须设置为零（主控制）。此控制请求的参数块使用布局 1（参见第 5.2.3.1 节，“布局 1 参数块”）。</p><h3 id="mode-select-control"><strong>Mode Select Control</strong></h3><p>模式选择控件用于更改实体的行为。模式选择控件必须只有 CUR 属性。CUR 属性的有效范围是从 1 到实体支持的模式数（通过实体描述符的 bNrModes 字段报告）。“控制选择器”字段必须设置为 XX_MODE_SELECT_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段必须设置为零（主控制）。此控制请求的参数块使用布局 1（参见第 5.2.3.1 节，“布局 1 参数块”）。</p><h3 id="cluster-control"><strong>Cluster Control</strong></h3><p>集群控制用于从实体中检索当前的逻辑音频通道集群描述符。此控件仅支持 Get 请求（只读）。集群控件必须只有 CUR 属性。CUR 属性返回一个描述符，它按照第 4.1 节“音频通道集群描述符”中定义的格式化。“控制选择器”字段必须设置为 XX_CLUSTER_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段必须设置为零（主控制）。群集控制的 CUR 属性的参数块如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac13.png"></p><h3 id="underflow-control"><strong>Underflow Control</strong></h3><p>Underflow Control 用于指示自上次获取 Underflow 请求以来在实体中出现的计算 Underflow 情况。当试图为一个无符号变量赋值一个负值时，就会出现计算欠流。此控件仅支持 Get 请求（只读）。响应 Get 请求将返回 CUR 属性，然后清除其值。Underflow 控制必须只有 CUR 属性。Underflow 控制 CUR 属性的值必须为 TRUE（发生 Underflow 条件）或 false（正常）。控制选择器字段必须设置为 XX_UNDERFLOW_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段表示所需的通道。此控制请求的参数块使用布局 1（参见第 5.2.3.1 节，“布局 1 参数块”）。</p><h3 id="overflow-control"><strong>Overflow Control</strong></h3><p>溢出控制用于指示自上次获取溢出请求以来在实体内出现的计算溢出情况。当一个值太正或太负，在有符号计算后无法表示，以及当它在无符号计算后表示得太正时，就会发生计算溢出。此控件仅支持 Get 请求（只读）。响应 Get 请求将返回 CUR 属性，然后清除其值。溢出控制必须只有 CUR 属性。溢出控制 CUR 属性的值必须为 TRUE（发生溢出情况）或 false（正常）。</p><h3 id="encoder-error-control"><strong>Encoder Error Control</strong></h3><p>编码器错误控制用于指示自上一次获取编码器错误请求以来，编码器中是否存在一个错误条件。此控件仅支持 Get 请求（只读）。响应 Get 请求将返回 CUR 属性，然后清除其值。编码器错误控制必须只有 CUR 属性。CUR 属性的设置范围可以从-32768（0x8000）到 32767（0x7FFF），步骤为 1（0x0001）。值 0 表示不存在错误的情况。所有其他值都表明存在一个错误条件。</p><p>本规范定义了许多可能出现的错误代码。表 5-9“错误代码”列举了错误代码及其说明。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac14.png"></p><h3 id="decoder-error-control"><strong>Decoder Error Control</strong></h3><p>解码器错误控制用于指示自上一次获取解码器错误请求以来，解码器中存在的错误条件。此控件仅支持 Get 请求（只读）。响应 Get 请求将返回 CUR 属性，然后清除其值。解码器错误控制必须只有 CUR 属性。CUR 属性的设置范围可以从-32768（0x8000）到 32767（0x7FFF），步骤为 1（0x0001）。值 0 表示不存在错误的情况。所有其他值都表明存在一个错误条件。本规范定义了许多可能出现的错误代码。表 5-9“错误代码”列举了错误代码及其说明。控制选择器字段必须设置为 XX_DECODER_ERROR_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段必须设置为零（主控制）。此控制请求的参数块使用布局 2（参见第 5.2.3.2 节，“布局 2 参数块”）。</p><h3 id="latency-control"><strong>Latency Control</strong></h3><p>音频功能必须不支持此控制（特定类音频控制接口描述符的 bm 控制字段中的 D1..0=0b00）或支持音频功能内的每个终端和单元的只读控制（特定类音频控制接口描述符的 bm 控制字段中的 D1..0=0b01）。终端延迟必须包括由 A/D 或 D/A 转换器、编码器、解码器等引起的所有延迟。延迟控制用于准确报告被址实体产生的以纳秒表示的延迟。此控件仅支持 Get 请求（只读）。延迟控件必须只有 CUR 属性。CUR 属性的设置范围可以从 0 ns（0x00000000）到 4,294,967,295ns（0x FFFFFFFF），步骤为 1 ns（0x00000001）。“控制选择器”字段必须设置为 XX_LATENCY_CONTROL（其中 XX 必须由特定实体的适当的双字母缩写替换），并且“通道号”字段必须设置为零（主控制）。此控制请求的参数块使用布局 3（参见第 5.2.3.3 节，“布局 3 参数块”）。</p><h2 id="audiocontrol-requests"><strong>AudioControl Requests</strong></h2><p>以下部分描述了可用于操作音频功能通过其实体公开的音频控制的可能请求。集合和 Get 请求都使用相同的参数块布局。</p><h3 id="clock-source-control-request"><strong>Clock Source Control Request</strong></h3><p>此请求用于操作音频功能的时钟源实体内的控件。请求的确切布局在第 5.2.2 节“控制请求布局”中定义。以下各段详细描述了时钟源实体可以合并的所有可能的控制项。对于每个控件，都指定受支持的属性及其值范围。此外，还列出了适当的控制选择器值和参数块的布局类型。控制选择器代码在附录 A.17.1，“时钟源控制选择器”中定义。</p><h3 id="sampling-frequency-control"><strong>Sampling Frequency Control</strong></h3><p>采样频率控制用于操纵由时钟源实体产生的时钟信号的实际采样频率。采样频率控制必须支持 CUR 和范围（MIN、MAX、RES）属性。CUR、MIN、MAX 和 RES 属性的设置范围可以从 0Hz（0x000000000）到 4,294,967,295Hz（0x FFFFFFFF），步骤为 1 Hz（0x00000001）。注：可以使用 5.2.1 节“控制属性”中解释的方法的离散列表来表示。在许多情况下，时钟源实体表示一个基于单一固定频率的晶体振荡器的发生器。在这种情况下，不支持设置请求。控制选择器字段必须设置为 CS_SAM_FREQ_CONTROL，通道号字段必须设置为零（主控制）。此控制请求的参数块使用布局 3（参见第 5.2.3.3.3 节“布局 3 参数块”）</p><h3 id="clock-validity-control"><strong>Clock Validity Control</strong></h3><p>时钟有效性控制用于指示由时钟源实体产生的时钟信号是否有效（稳定和可靠）。此控件只支持 Get 请求。时钟有效性控制必须只有 CUR 属性。时钟有效性控制 CUR 属性的值必须为 TRUE（时钟有效）或 false（时钟无效）。控制选择器字段必须设置为 CS_CLOCK_VALID_CONTROL，通道号字段必须设置为零（主控制）。此控制请求的参数块使用布局 1（参见第 5.2.3.1 节，“布局 1 参数块”）。</p><h3 id="clock-selector-control-request"><strong>Clock Selector Control Request</strong></h3><p>此请求用于操作音频功能的时钟选择器实体内的控制。请求的确切布局在第 5.2.2 节“控制请求布局”中定义。以下段落详细描述了时钟选择器实体可以合并的所有可能的控制项。对于每个控件，都指定了受支持的属性及其值范围。此外，还列出了适当的控制选择器值和参数块的布局类型。控制选择器代码在附录 A.17.2，“时钟选择器控制选择器”中都有定义。</p><ul><li><strong>Clock Selector Control</strong></li><li><strong>Clock Multiplier Control Request</strong><ul><li><strong>Numerator Control</strong></li><li><strong>Denominator Control</strong></li></ul></li></ul><h3 id="terminal-control-request"><strong>Terminal Control Request</strong></h3><p>此请求用于操作音频功能的终端内的控件。请求的确切布局在第 5.2.2 节“控制请求布局”中定义。以下各段详细描述了终端可以包含的所有可能的控制件。对于每个控件，都指定了受支持的属性及其值范围。此外，还列出了适当的控制选择器值和参数块的布局类型。控制选择器代码的定义见附录 A.17.4，“终端控制选择器”</p><p>…</p><h2 id="feature-unit-control-request"><strong>Feature Unit Control Request</strong></h2><p>此请求用于操作音频功能的特征单元内的控制。请求的确切布局在第 5.2.2 节“控制请求布局”中定义。以下各段详细描述了特性单元可以合并的所有可能的控制件。对于每个控件，都指定了受支持的属性及其值范围。此外，还列出了适当的控制选择器值和参数块的布局类型。控制选择器代码的定义见附录 A.17.7，“特征单元控制选择器。</p><h3 id="mute-control"><strong>Mute Control</strong></h3><p>静音控件是功能单元的构建模块之一。静音控件必须只有 CUR 属性。“静音控件 CUR”属性的值必须为 TRUE（静音）或 false（非静音）。通过设置/获取特征单元内的特定静音控制请求的单元 ID 和通道号字段进行处理。通道号字段的有效范围是从零（“主”通道）到音频通道集群中的逻辑通道数目。控制选择器字段必须设置为 FU_MUTE_CONTROL，并且通道号字段指示所需的通道。此控制请求的参数块使用布局 1（参见第 5.2.3.1 节，“布局 1 参数块”）。</p><h3 id="volume-control"><strong>Volume Control</strong></h3><p>音量控制是功能单元的构建模块之一。volume 控制必须支持 CUR 和范围（MIN、MAX、RES）属性。CUR、MIN 和 MAX 属性的设置范围可以从+127.9961 dB（0x7FFF）到-127.9961 dB（0x8001），步骤为 1/256 dB 或 0.00390625 dB（0x0001）。RES 属性的设置只能为正值，且范围从 1/256 dB（0x0001）到+127.9961 dB（0x7FFF）。此外，必须始终实现表示沉默（即-∞dB）的代码 0x8000。但是，永远不能将其报告为 MIN 属性值。</p><p>通过设置/获取特征单元控制请求中的单元 ID 和通道号字段来处理特征单元内的特定卷控制。通道号字段的有效范围是从零（“主”通道）到音频通道集群中的逻辑通道数目。控制选择器字段必须设置为 FU_VOLUME_CONTROL，“通道号”字段指示所需的通道。此控制请求的参数块使用布局 2（参见第 5.2.3.2 节，“布局 2 参数块”）。</p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（一）Spec-Functional Characteristics</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACSpecFunctionalCharacteristics/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACSpecFunctionalCharacteristics/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>在许多情况下，音频功能不作为独立设备存在。它是一种能力，与其他功能一起构成了一个“复合”设备。一个很好的例子 DVD-ROM 播放器就是音频、数据存储和传输控制功能的集合。音频功能因此位于设备类层次结构中的接口级别。它由多个接口组成，共同实现音频功能的接口。</p><p>音频功能被认为是一个“closed box”，具有非常独特的和定义良好的接口到 outside world。音频功能通过它们的音频接口进行寻址。每个音频功能都必须有一个 AudioControl 接口可以有 0 个或多个 AudioStreaming 和 0 个或多个 MIDI Streaming 接口。AudioControl（AC）接口用于访问 function 的音频控件，而 AudioStreaming (AS) 接口用于将音频流传入和传出 function。 MIDI streaming (MS) 接口可用于将 midi 数据流传输到和输出音频功能。单个 AudioControl 接口以及属于同一音频功能的 AudioStreaming 和 MIDI Streaming 接口的集合称为 Audio Interface Collection（AIC）。一个设备可以同时激活多个音频接口集合（AIC）。这些集合用于控制位于同一 composite device 中的多个独立音频功能。通过标准 USB 接口关联机制来描述音频接口集合，通过接口关联描述符 (IAD) 来表示接口绑定。</p><p>注：所有与 MIDI 相关的信息被分组在一个单独的文档中，MIDI 设备的通用串行总线设备类定义被认为是本规范的一部分。因此，本文档的其余部分将不再提及 MIDI Streaming 接口及其细节。 下图说明了这个概念：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac1.png"></p><span id="more"></span><p>所有与直接影响音频感知（如音量） 的控制参数相关的功能都位于中央矩形内，并仅通过 AudioControl 接口进行控制。通过单独的 AudioStreaming 接口处理与音频功能之间的流媒体通信。AudioStreaming 接口主要用于在 Audio function 和 outside world 之间传输音频数据。但是，所有与流行为具体相关的控制数据也通过 AudioStreaming 接口进行传输。特别是，所有用于影响解码器或编码器过程的控制数据，可能驻留在实际流端点和音频功能之间（例如，从 AC-3 编码流到 5.1 物理音频通道的转换） 通过 AudioStreaming 接口传送。</p><p>请注意，在某些情况下，Audiostreaming 接口仅用于执行 controlling functions，而不会通过该接口传输实际数据。与 S/PDIF 连接就是一个典型的例子。虽然实际的音频数据是从外部输入的 （不是通过 USB)，但可能需要控制 S/PDIF 连接的 aspects。在这种情况下，S/PDIF 连接由 AudioStreaming 接口表示，这样它就可以通过 USB 寻址。</p><p>还要注意的是，AudioStreaming 接口和音频功能之间的连接不是“solid”。这样做的原因是当从 audio function 内部看时，每个进入或离开音频函数的音频流都由一个称为 Terminal 的特殊对象表示（见下文）。Terminal 概念抽象了音频功能内部的实际 Audio Streaming 接口，并提供了连接的逻辑视图，而不是物理视图。这种抽象允许音频函数中的音频通道被视为不再具有与之相关的物理特性的逻辑“音频通道”。 （模拟量与数字、格式、采样率、位分辨率等）。</p><h1 id="audio-interface-collection">Audio Interface Collection</h1><p>在 USB 上，音频功能完全由其接口定义。一个音频函数有一个 AudioControl 接口和零个或多个 AudioStreaming 接口，它们组成一个音频接口集合。标准的 USB 接口关联机制用于描述音频接口集合，即将这些接口绑定在一起。接口关联通过标准 USB 接口关联描述符 (IAD) 表示。每个接口关联描述符都有一个 FunctionClass、FunctionSubClass 和 FunctionProtocol 字段，它们共同标识由关联表示的函数。以下段落定义音频设备类的这些字段。</p><h2 id="audio-function-class">Audio Function Class</h2><p>接口关联被分配了一个 Function Class code。该规范要求函数类代码与音频接口类代码相同。音频函数类代码由本规范指定。有关详细信息，请参见附录 A.1“音频函数类代码</p><h2 id="audio-function-subclass">Audio Function Subclass</h2><p>音频函数类分为函数子类。此时，Function SubClass 代码未被使用，必须设置为 FUNCTIONSUBCLASSUNDEFINED 分配的代码可以在本规范的 A.2“音频功能子类代码”中找到。</p><h2 id="audio-function-protocol">Audio Function Protocol</h2><p>音频函数类和子类可以由函数协议代码进一步限定。函数协议代码用于反映本规范的当前版本，以便枚举软件可以决定需要实例化哪些驱动程序版本 指定的协议代码可以在本规范的附录 A.3“音频功能协议代码”中找到。</p><h1 id="audio-interface-class">Audio Interface Class</h1><p>音频接口类将所有可以与 USB 兼容的音频数据流交互的功能分组。在模拟和数字音频域之间转换的所有函数都可以是此类的一部分。此外，那些将符合 USB 的音频数据流转换成其他符合 USB 的音频数据流的函数也属于此类。即使是通过 USB 控制的模拟音频功能也属于此类。</p><p>事实上，要使音频函数成为此类的一部分，唯一的要求是它公开一个 AudioControl 接口。虽然音频接口类中的大多数函数将支持一个或多个可选的 AudioStreaming 接口，用于消费或产生一个或多个等时音频数据流，但与该函数的进一步交互是强制性的。</p><p>音频接口类代码由 USB 分配。有关详细信息，请参见附录 A.4“音频接口类代码”</p><h1 id="audio-interface-subclass">Audio Interface Subclass</h1><p>音频接口类分为子类。所有音频功能都是某个接口子类的一部分。本规范中目前定义了以下三个接口子类：</p><ul><li>AudioControl Interface Subclass</li><li>AudioStreaming Interface Subclass</li><li>MIDIStreaming Interface Subclass</li></ul><p>指定的代码可以在本规范的附录 A.5“音频接口子类代码”中找到。</p><h1 id="audio-interface-protocol">Audio Interface Protocol</h1><p>音频接口类和子类可以由接口协议代码进一步限定。接口协议代码用于反映本规范的当前版本。指定代码可以在附录 A.6“音频接口协议代码”中找到。</p><h1 id="audio-function-category">Audio Function Category</h1><p>音频功能类别指示音频功能的主要预期用途。本规范中目前定义了以下功能类别：</p><ul><li>Desktop Speaker: 在小型环境中设置的一个或多个扬声器，主要供一个人使用的音频。</li><li>Home Theater: 在中等大小的环境中设置多个扬声器，以提供比桌面扬声器设置更大的音频电平，并旨在让多人清楚地听到。</li><li>Microphone: 一种装置，设置成从可听的来源录制音频。</li><li>Headset: 具有至少一个扬声器和至少一个麦克风的设备，以提供个人音频播放和语音输入功能。</li><li>Telephone: 也连接到电话系统（例如 POT、PBX、VolP) 的耳机或手持设备，能够拨打和接听电话</li><li>Converter: 允许音频从一种电或光格式转换为另一种电或光格式，或将音频数据从一种编码格式转换为另一种编码格式 （例如 AC-3 转换为 PCM 等）的设备。</li><li>Voice/Sound recorder: 至少有一个麦克风和至少一个扬声器的设备，其设计目的是至少在某些时候独立于主机来记录和存储声音源并播放其记录的内容。</li><li>I/O Box: 设计用于提供一个或多个可能不同的电气和光学输入和输出以连接到其他设备的设备</li><li>Musical Instrument: 如钢琴、吉他、合成器、鼓机等。</li><li>Pro-Audio: 音频消费者通常不使用的设备，例如编辑设备、多轨录音设备等</li><li>Audio/Video: 来自同时提供视频的设备的音频，期望音频与视频紧密耦合，例如便携式摄像机、DVD 播放器电视机等。</li><li>Control Panel: 用于控制通过音频设备系统的音频流的设备，如混音器面板。</li><li>Other: 任何器械，其主要用途与上述描述有足够的不同，以至于被认为是一种完全不同形式的器械</li></ul><p>指定的代码可在本规范附录 A.7“音频功能类别代码”中找到。</p><h1 id="clock-domains">Clock Domains</h1><p>时钟域被定义为一个区域，在该区域内所有采样时钟都来自同一个主时钟。因此，在同一时钟域内，所有采样时钟是同步的，它们的时序关系是恒定的。然而，采样时钟可以在不同的采样频率。主时钟可以通过许多不同的方式产生。内部晶体可以是主时钟，可以使用 USB 帧起始 (SOF) ，或者甚至可以使用外部提供的时钟作为主时钟。一般来说，同一音频功能中可以存在多个不同的时钟域。</p><h1 id="audio-synchronization-types">Audio Synchronization Types</h1><p>AudioStreaming 接口中使用的每个同步音频端点都属于 USB 规范第 5 节中定义的同步类型。以下各节简要介绍可能的同步类型。</p><h1 id="inter-channel-synchronization">Inter Channel Synchronization</h1><p>处理音频（尤其是 3-D 音频） 时的一个重要问题是不同物理音频通道之间的相位关系。</p><p>为了向主机提供一个可管理的相位模型，需要一个音频功能来报告每个 Audiostreaming 接口的内部延迟。这种延迟以（微）帧数表示，这是由于音频功能必须缓冲至少一个（微）帧的采样值，以有效地消除（微）帧内的数据包抖动。此外，一些音频函数将引入额外的延迟，因为它们需要时间来正确地解释和处理音频数据流（例如，压缩和解压缩）。</p><h1 id="audio-function-topology">Audio Function Topology</h1><p>为了能够操作音频功能的物理属性，它的功能必须被划分为可寻址的实体。两种类型的这种通用实体被识别，并被称为 Unit 和 Terminals。此外，还定义了一种特殊类型的实体这些实体被称为 Clock Entities，它们用于描述和操作音频函数内部的时钟信号。</p><p>Unit 提供了基本的 building blocks 来充分描述大多数音频功能。音频功能是通过连接这些 Unit 中的几个来构建的。一个 Unit 有一个或多个输入 Pins 和一个输出 Pin，其中每个 Pins 代表音频功能内的逻辑音频通道簇（请参见第 3.13.1 节"音频通道簇”》。根据所需的拓扑结构，Unit 通过连接其 I/0 Pins 连接在一起。请注意，将一个实体的输出 Pins 连接到位于不同其他实体上的多个输入 Pins 是完全合法的，有效地创建了一个一对多连接。</p><p>此外，还引入了 Terminals 的概念。有两种类型的 Terminals。Input Terminals (IT) 是表示音频功能内部音频通道的起点的实体。Output Terminals (OT) 表示音频通道的结束点。从音频功能的角度来看 USB 端点是输入或输出端子的典型示例。它或者向音频功能 (IT) 提供数据流，或者消耗来自音频功能 (OT) 的数据流。</p><p>一个 Unit 的输入 Pins 编号从 1 开始到 Unit 上的输入 Pins 总数。输出 Pins 号始终为 1。Input Terminals 只有一个输出 Pins，其数量总是一个。Output Terminals 只有一个输入 Pins 永远都是 1。</p><p>音频功能中的每个 Unit 都由其关联的单元描述符 (UD) 完整描述。单元描述符包含识别和描述 Unit 所需的所有字段。同样，音频函数中的每个 Terminals 都有一个 Terminals 描述符 (TD)。此外，这些描述符还提供了有关音频功能的拓扑结构的所有必要信息。它们充分描述了 Terminals 和 Unit 是如何相互连接的。</p><p>本规范描述了以下八种不同类型的标准 Unit 和 Terminals，被认为足以代表当今和不久的将来可用的大多数音频功能：</p><ul><li>Input Terminal (IT)</li><li>Output Terminal (OT)</li><li>Mixer Unit (MU)</li><li>Selector Unit (SU)</li><li>Feature Unit (FU)</li><li>Sampling Rate Converter Unit</li><li>Effect Unit (EU)</li><li>Processing Unit (PU)</li><li>Extension Unit (XU)</li></ul><p>除了 Unit 和 Terminals 之外，还引入了时钟实体的概念。本规范定义了三种类型的时钟实体：</p><ul><li>Clock Source (CS)</li><li>Clock Selector (CX)</li><li>Clock Multiplier (CM)</li></ul><p>时钟源为音频功能的全部或部分提供一定的采样时钟频率。时钟源可以代表一个内部采样频率发生器，但也可以代表一个外部采样时钟信号输入到音频功能。 时钟源有一个时钟输出 Pins，该 Pins 携带由时钟源表示的采样时钟信号。时钟输出 Pins 数始终为 1。时钟选择器用于在音频功能内部可能提供的多个采样时钟信号之间进行选择。它有多个时钟输入 Pins 和一个时钟输出 Pins。时钟输入 Pins 的编号从 1 到时钟选择器上时钟输入 Pins 的总数。</p><p>时钟 Multiplier 用于在其单个时钟输入引脚处获得与时钟信号频率不同的新时钟信号。它通过将时钟信号频率乘以分子 P，再除以分母 Q. 对于给定的时钟 Multiplier，P 和 Q 值是固定的。保证新的时钟信号与输入时钟信号同步。时钟 Multiplier 有一个输入 Pins 和一个输出 Pins，它们的数字总是一个。</p><p>通过使用时钟源、时钟选择器和时钟 Multiplier 实体的组合，可以将最复杂的时钟系统表示出来，并将其暴露在主机软件中。</p><p>时钟输入和输出 Pins 与为单元和端子定义的输入和输出 Pins 有本质的区别。时钟 Pins 只携带时钟信号，因此不能连接到 unit 或 Terminals 输入和输出 Pins。它们仅用于表示时钟电路拓扑。 每个输入和输出 Terminals 具有连接到时钟实体的时钟输出 Pins 和单个时钟输入 Pins。时钟输出 Pins 所携带的时钟信号决定了 Terminals 所代表的硬件工作的采样频率。 每个采样速率转换器单元有两个时钟输入 Pins，通常连接到两个不同时钟实体的时钟输出 Pins。这些时钟输出 Pins 携带的时钟信号决定采样率转换单元转换的采样频率。</p><p>每个时钟实体由时钟实体描述符 (CED) 描述。时钟实体描述符包含识别和描述时钟实体的所有必要字段。 描述符将在本文档第 4 节“描述符”中进一步详细介绍。单元描述符、终端描述符和时钟实体描述符的集合为主机提供了音频功能的完整描述。此信息通常在枚举时从设备中检索。通过解析描述符，通用音频驱动程序应该能够完全控制音频功能（扩展单元表示的功能除外）。</p><p>完整的音频功能描述符集仅提供音频功能的静态初始描述。在操作过程中，可能会发生许多事件，迫使音频功能改变其状态。必须将这些更改通知主机软件，以便始终与音频功能保持”同步”一个广泛的中断机制已经到位，以报告任何和所有的状态变化的主机软件。</p><p>如图 3-2 所示，“音频内部功能”说明了上面定义的概念。使用进一步定义的图标符号，它描述了一个假想的包含 16 个实体的音频功能：3 个输入端子、5 个单元、3 个输出端子、2 个时钟源、1 个时钟选择器和 2 个时钟 Multiplier。每个实体都有其唯一的 ID（从 1 到 16) 和描述符，该描述符充分描述了实体的功能以及该特定实体如何连接到音频功能的整体拓扑中。</p><p>输入端子 1(IT1) 可以表示用于将音频从主机流式传输到音频设备的 USBOUT 端点；IT2 可以是一个模拟的表示音频设备上的 Line-IN 连接器；IT3 可以是音频设备上的模拟麦克风输入连接器。选择器单元 4(SU4) 在来自主机的音频和 Line in 连接器上的音频之间进行选择。特征单元 5(FU 5) 被用来控制音频 （音量，低音，高音··.)，然后将其提供给输出端子 9(OT9)。 OT9 可以是音频设备上的耳机输出插孔的表示。</p><p>(USB OUT、Line In 和 MicIn) 连接到混音器单元 6 (MU 6)。然后，混音器的输出被送入处理单元 7 (PU 7)，它可以对混音执行一些音频处理算法。结果又被发送到 FU8，在那里对音频 （音量。..) 进行一些最后的调整。FU 8 与 OT10 和 OT11 相连。OT10 可以表示集成到音频设备中的扬声器，OT11 可以表示用于将处理后的音频发送到主机以进行录制的 USBIN 端点。</p><p>时钟源 12(CS12) 可以表示内部采样频率发生器，例如以 96 kHz 运行。时钟源 15(CS15) 可以是外部主采样时钟输入的表示，其可以用于将设备同步到外部源。时钟选择器 13(CS13) 可在两个可用时钟源之间进行选择。CS13 的输出为 IT1 IT2 IT3、OT10 和 OT11 提供 96kHz 的采样频率。时钟 Multiplier CM14 进一步将该时钟信号乘以 0.5，为 OT9 提供 48kHz 的采样频率以驱动耳机。由于音频功能中使用的所有采样频率始终来自单个主时钟（内部或外部），因此音频功能中的所有音频流都是同步的。</p><p>有关描述符内容的进一步详细信息，请参阅本文档的第 4 节“描述符”</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac2.png"></p><p>在实体内部，通过音频控件进一步描述功能。控件通常提供对特定音频或时钟属性的访问。每个 Control 都有一组属性，这些属性可以被操作，或者提供有关控件行为的附加信息。控件可以具有以下属性：</p><ul><li>Current setting attribute</li><li>Range attribute triplet consisting of: • Minimum setting attribute • Maximum setting attribute • Resolution attribute</li></ul><p>例如，考虑要对单元内的音量控制。通过发出适当的 Get 请求，主机软件可以获得音量控制的属性值，例如，使用它们在屏慕上正确显示控制。设置音量控制的当前属性允许主机软件更改音量控制的音量设置。 此外，音频函数中的每个实体都可以具有内存空间属性。该属性可选地提供对 Entity 的内部内存空间的通用访问。这可以用于通过一般提供的访问来实现特定于供应商的实体控制。</p><h2 id="audio-channel-cluster">Audio Channel Cluster</h2><p>音频通道簇是一组承载紧密相关的同步音频信息的音频通道。在音频功能内部，完全抽象了通过终端和单元之间的连接传输的音频数据的实际物理表示形式，集群中的每个音频通道被认为是一个逻辑通道以及该通道的所有物理属性（位宽、位分辨率等）。</p><p>集群中的通道编号从通道 1 开始，一直到集群中的通道数。虚拟通道零是用来解决一个单位（如果存在）的主控制，有效地影响所有的渠道。注意主控制 （如果存在的话）必须与每通道控制分开来实现。更改主控件的设置不会影响任何单个通道控件的设置。音频通道群集中独立通道的最大数量限制为 255（通道零用于引用主通道）。 在许多情况下，音频集群中的每个通道都与侦听空间中的某个位置相关联。这方面的一个简单示例是包含左右音频通道的群集。为了能够以可管理的方式描述更复杂的情况，本规范对音频通道簇中通道的顺序施加了一些限制和约束。 为了支持在连接上流动的信息不能被解释为逻辑音频通道的集群的情况下，本规范定义了一个额外的虚拟空间位置，称为原始数据。此空间位置与本规范中定义的所有其他空间位置相互排斥。它不能与其他空间位置共存于同一集群中，其使用受到很大的限制。它只能用于不操作音频内容的实体之间的连接。这些实体只能是输入端子和输出端子。禁止对原始数据虚拟空间位置的所有其他使用。 有 28 个预定义的空间位置 (27+1 个虚拟）:</p><ul><li>Front Left - FL</li><li>Front Right - FR</li><li>Front Center - FC</li><li>Low Frequency Effects - LFE</li><li>Back Left - BL</li><li>Back Right - BR</li><li>Front Left of Center - FLC</li><li>Front Right of Center - FRC</li><li>Back Center - BC</li><li>Side Left - SL</li><li>Side Right - SR</li><li>Top Center - TC</li><li>Top Front Left - TFL</li><li>Top Front Center - TFC</li><li>Top Front Right - TFR</li><li>Top Back Left - TBL</li><li>Top Back Center - TBC</li><li>Top Back Right – TBR</li><li>Top Front Left of Center – TFLC</li><li>Top Front Right of C</li><li>Left Low Freque</li><li>Right Low Frequen</li><li>Top Side Left – TSL</li><li>Top Side Right – TSR</li><li>Bottom Center – BC</li><li>Back Left of Center – BLC</li><li>Back Right of Center – BRC</li><li>Raw Data – RD</li></ul><p>如果音频通道簇中存在与某些先前定义的空间位置相对应的通道，则它们必须按照上述列表中指定的顺序出现。例如，如果一个群集包含前左、前右和 LFE 通道，则通道 1 是前左，通道 2 是前右，通道 3 是 LFE。</p><p>音频通道群集仅具有两个属性</p><ul><li>群集中的音频通道数</li><li>群集中每个音频通道的空间位置，可以是预定义的 （前左、前右、后左、LFE 等），也可以是自定义的。 注：自定义也可用于指定与任何空间位置不直接相关的通道分配。一个简单的通道枚举模式（通道 1、通道 2 等） 就是一个典型的例子。</li></ul><p>每个音频通道群集都有一个群集描述符 (CD)，它完全描述了群集。 本规范中使用了两种类型的音频通道集群：</p><ul><li>逻辑音频通道簇描述音频功能 （封闭框）内的音频数据，其中音频通道被视为逻辑概念。</li><li>物理音频通道簇描述 AudioStreaming 接口中的音频数据，该接口处理音频流中的实际物理音频通道（离散或编码）。</li></ul><h2 id="mapping-between-physical-and-logical-audio-channel-clusters">Mapping between Physical and Logical Audio Channel Clusters</h2><p>AudioStreaming 界面可以有多个备用设置，每个设置代表界面的不同“操作模式”。例如，表示外部 S/PDIF 连接的 AudioStreaming 接口可以有一个备用设置，用于 S/PDIF 连接携带 Stereo PCM 数据时 （两个通道）和另一个备用设置，当 AC-3 编码的信息通过 S/PDIF 连接 (6 个通道）传送时使用。因此，从一个备用设置切换到另一个可以有效地更改接口中实际音频通道的数量，还可能更改这些通道的空间位置。 AudioStreaming 接口与音频函数中相应的 Terminal 之间存在一对一关系。但是，AudioStreaming 界面可以有多个备用设置，每个备用设置具有不同的物理音频通道群集必须能够将每个物理音频通道簇映射到通过相应终端显示的单个逻辑音频通道簇上。因此，逻辑音频通道群集本质上是动态的，并且在为 AudioStreaming 接口选择不同的备用设置时可能会发生更改。当前的逻辑音频通道集群可以通过终端上的获取集群控制请求（如果实现的话）来检索。或者，主机软件可以跟踪当前处于活动状态的备用设置，并从该备用设置中检索物理音频通道簇描述，并将其用作逻辑通道簇定义。</p><h2 id="input-terminal">Input Terminal</h2><p>输入端子 (IT) 用于音频功能的“outside world”和音频功能中的其他单元之间的接口。它作为音频信息流入音频功能的容器。</p><p>输入端子可以代表除 USB OUT 端点之外的音频功能的输入，音频设备上的 Line in 连接器就是此类非 USB 输入的示例。但是，如果音频流通过 USB OUT 端点进入音频功能，则包含该端点的 AudioStreaming 接口与其关联的输入端子之间存在一对一的关系。特定于类的接口描述符包含一个字段，该字段保存对此输入终端的直接引用。主机需要同时使用音频流接口和端点描述符以及输入终端描述符，以充分了解输入终端的特性和功能。与流相关的参数存储在 AudioStreaming 描述符中。控制相关参数存储在 Terminal Deserintor 中。</p><p>从传入的（可能是编码的）音频流到逻辑音频通道的转换过程总是涉及到某种解码引擎。本规范定义了几种类型的解码（参见第 3.14 节“编码器和解码器”)。这些解码类型的范围从相当琐碎的解码方案，如将交错的立体声 16 位 PCM 数据转换为左和右逻辑通道，到非常复杂的方案，如将 MPEG-27.1 编码的音频流转换为左前，前左中心，前中心，前右中心前右，后左，后右和低频效果逻辑通道。 解码引擎被认为是实体的一部分，它实际上接收编码的音频数据流（类似于 USBAudiostreaming 接口）。因此，解码类型隐含在 bmFormats 值中，该值位于特定于类的 AudioStreaming 接口描述符中。特定于解码引擎的请求必须指向 Audiostreaming 接口。相关联的输入端在逻辑信道被解码后处理它们。</p><p>输入端子具有单个时钟输入 Pins。该 Pins 上的时钟信号用作由该输入端子表示的所有底层硬件的采样时钟。在输入端子描述符中有一个字段唯一标识输入端子所连接的时钟实体。输入端子的符号如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac3.png"></p><h2 id="output-terminal">Output Terminal</h2><p>输出终端 (OT) 用于音频功能内部的单元与“outside world”之间的接口。它作为音频信息的出口，流出音频功能。它的功能是在输出音频数据从原始独立的逻辑通道正确打包到输出音频流（编码过程） 之前，表示输出音频数据的接收器。音频通道群集通过单个输入 Pins 进入输出端子。</p><p>输出端子可以表示除 USB IN 端点之外的音频 Function 的输出。内置于音频设备或 Line Out 连接器中的扬声器就是这种非 USB 输出的示例。但是，如果音频流通过 USB IN 端点离开音频 Function，则包含此端点的 Audiostreaming 接口与其关联的输出端子之间存在一对一关系。特定于类的接口描述符包含一个字段，该字段保存对此输出终端的直接引用。主机需要同时使用 AudioStreaming 接口和端点描述符以及输出终端描述符，以充分了解输出终端的特性和功能。与流相关的参数存储在 Audiostreaming 描述符中控件相关的参数存储在 Terminal 描述符中。</p><p>从传入的逻辑音频通道到可能编码的音频流的转换过程总是涉及到某种编码引擎。本规范定义了几种类型的编码 （见第 3.14 节“编码器和解码器”)，范围从简单的到非常复杂的方案。编码引擎被认为是实体的一部分，它实际上传输编码的音频数据流（类似于 USBAudiostreaming 接口）。因此，编码类型隐含在 bmFormats 值中，该值位于特定于类的 AudioStreaming 接口描述符中。特定于编码引擎的请求必须是指向 AudioStreaming 接口。相关联的输出终端在编码之前处理逻辑通道</p><p>输出端子具有单个时钟输入引脚。该引脚上的时钟信号用作由该输出端子表示的所有底层硬件的采样时钟。在输出终端描述符中有一个字段，它唯一地标识输出终端连接到的时钟实体输出端子的符号如下图所示</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac4.png"></p><h2 id="feature-unit">Feature Unit</h2><p>特征单元 (FU) 本质上是一个多通道处理单元，它提供对传入逻辑通道上的多个单参数音频控件的基本操作。对于每个逻辑通道，功能单元可选地为以下功能提供音频控制：</p><ul><li>Mute</li><li>Volume</li><li>Tone Control(Bass, Mid, Treble)（音调控制）</li><li>Graphic Equalizer（图像均衡器）</li><li>Automatic Gain Control（自动增益控制）</li><li>Delay</li><li>Bass Boost（低音增强）</li><li>Loudness（响度）</li><li>Input Gain</li><li>Input Gain Pad</li><li>Phase Inverter（反相器）</li></ul><p>此外，功能单元可选择提供上述音频控制，但现在可同时影响集群的所有通道。通过这种方式可以实现“主”控件。主控制在各个通道控制之后级联。此设置在多通道系统中特别有用，其中单个通道控件可用于通道平衡，主控件可用于整体设置。集群中的逻辑信道的编号从 1 到集群中信道的总数。主通道的通道号为零，实际上总是存在的。</p><p>特征单元描述符报告了特征单元中每个通道和主通道的控制。所有单元中的逻辑通道都完全独立，特征单元内的通道之间不存在交叉耦合。逻辑输出通道和输入通道一样多。这些被组合成一个音频通道簇，通过一个输入引脚进入功能单元，并通过一个输出引脚离开单元。特征单元的符号如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/uac5.png"></p><h2 id="feature-unit-与-hid-对比">Feature Unit 与 HID 对比</h2><h3 id="binding-between-physical-buttons-and-audio-controls"><strong>Binding between Physical Buttons and Audio Controls</strong></h3><p>大多数包含音频功能的设备也会有一个或多个 frontpanel buttons，用于控制设备内音频功能的某些方面。最明显的例子是多媒体扬声器前面的音量控制按钮。由于音频功能可能包含许多相同类型的音频控件，因此需要将物理控件（按钮、旋钮、滑块、点动等）绑定到音频功能中的特定音频控件。 本规范提供了两种互斥的方法来提供这种绑定：</p><ul><li>物理按钮实现为 HID 控件</li><li>物理按钮是音频控制的集成部分</li></ul><p>禁止对同一个物理按钮实现这两种方法。但是，允许对某些 frontpanel buttons 使用第一种方法，对其余 frontpanel buttons 使用第二种方法。强烈建议不使用上述两种方法实现前面板按钮，即对主机软件不可见且仅具有局部效果的按钮。</p><h3 id="physical-button-is-a-hid-control"><strong>Physical button is a HID Control</strong></h3><p>HID 是 USB 设备中的一种设备类型，他与 UAC 之间并没有直接的关联性，两者是完全独立的，只是 HID 设备包括鼠标、键盘、遥杆等具有通过 USB 控制 host 的声音的设备，可以通过实现这些设备的描述符实现对 host 的音量控制，这样就可以用来控制 UAC 的音量。</p><p>在这种情况下，物理按键与音频功能完全分离，并在设备的 HID 接口内实现。音频功能甚至不知道按钮的存在。按钮的任何状态变化都通过 HID 报告传送给主机软件。然后由主机软件来解释按钮状态的变化，并从那里获得对音频功能要采取的适当行动。因此，绑定责任完全属于应用程序或操作系统软件。尽管此方法提供了广泛的灵活性但它也给软件带来了提供正确绑定的负担。</p><h3 id="physical-button-is-integral-part-of-the-audio-control"><strong>Physical button is Integral Part of the Audio Control</strong></h3><p>而 Feature Unit 是 UAC 标准里定义的特性单元，功能更强大可以实现对每个逻辑通道提供音频控制，包括但不限于 mute 和 volume。</p><p>在这种情况下，物理按键直接与实际的音频控制交互。按钮状态更改不会报告给主机软件。相反，由按钮操作引起的音频控制的状态变化通过音频控制中断机制报告给主机软件。因此，物理按钮和 Audio 控件之间的绑定非常直接，完全由设备的设计决定。尽管不太灵活，但该方法提供了一种非常清晰和直接的方式来执行绑定。</p><h1 id="encoders-and-decoders"><strong>Encoders and Decoders</strong></h1><p>每当音频数据流进入或离开音频 Function 时，都涉及到某种解码或编码过程。这个过程可以是相当琐碎的（交织或解交织样本），但也可以是相当复杂的。</p><p>在某些情况下，主机软件和编码或解码过程之间的交互是必要的。此时定义了五个这种类型的编码器和解码器进程：</p><ul><li>MPEG Encoder and Decoder</li><li>AC-3 Encoder and Decoder</li><li>Windows Media Audio (WMA) Encoder and Decoder</li><li>DTS Encoder and Decoder</li><li>OTHER Encoder and Decoder</li></ul><p>这些进程各自定义了特定的控件，允许操纵或监视编码器或解码器进程的内部状态。这些控件是通过编码器或解码器所属的 AudioStreaming 接口寻址的。</p><h1 id="copy-protection"><strong>Copy Protection</strong></h1><p>由于音频设备类主要处理数字音频流，因此不能忽视保护这些通常受版权保护的流的问题。因此，本规范提供了保存任何可用的版权信息的方法。然而，管理整个音频功能的复制保护信息流是主机软件的责任。 每当数字音频流进入或离开音频功能时，复制保护问题就会出现。因此，复制保护机制是在音频功能的终端级实现的。进入音频功能的流可以伴随着特定的信息，描述该音频流的复制保护级别。同样，如果硬件允许的话，离开音频功能的流应该伴随着适当的复制保护信息。该规范提供了两个专用请求，可用于管理复制保护机制。 GetCopy Protect 请求可用于从输入端检索复制保护信息，而 Set Copy Protect 请求可用于预设输出端的复制保护级别。 本规范提供了三个级别的拷贝许可，类似于 CGMS（拷贝生成管理系统）和 SCMS （串行拷贝管理系统）。</p><ul><li>Level 0: 不受限制地允许复制。该材料要么没有版权，要么没有主张版权。</li><li>Level 1: 可以制作一个副本。材料受版权保护，为原创。</li><li>Level 2: 材料受版权保护，不允许数字拷贝</li></ul><h1 id="operational-model"><strong>Operational Model</strong></h1><p>一个设备可以支持多种配置。在每个配置中可以有多个接口，每个接口都可能有备用设置这些接口可以属于同一个复合设备中共存的不同功能。甚至几个独立的音频功能可以存在于同一个设备中。属于同一音频功能的接口被分组到音频接口集合中。如果设备包含多个独立的音频功能，则必须有多个音频接口集合，每个接口集合都提供对其相关音频功能的完全访问权限。</p><p>以复合设备为例，考虑配备内置立体声扬声器系统的 PC 监视器。这样的设备可以配置为具有一个处理配置和控制设备的监视器部分的接口 (HID 类），而其他两个接口的集合处理其音频方面其中之一，AudioControl 接口，是用来控制内部工作的 Function （音量控制等）。而另一个 AudioStreaming 接口，处理数据流量，发送到监视器的音频子系统。</p><p>AudioStreaming 接口可以配置为在单声道模式下工作（可选设置 x) 其中只有一个单声道数据流被发送到音频功能。接收输入终端可以将音频流复制到两个逻辑通道中，然后在两个扬声器上再现。从接口的角度来看，这样的设置除了 AudioControl 接口中的强制控制端点和可选中断端点之外，还需要音频流接口中的一个等时端点来接收单音频数据流。</p><p>同样的系统可以用来播放立体声音频。在这种情况下，必须选择立体声音频流接口（备用设置 y)。该接口还包含一个同步端点，该端点现在接收交错前左和前右通道采样的数据流。接收输入 Terminal 现在将流拆分为前左和前右逻辑通道。AudioControl 接口备用设置保持不变。 如果上面的 AudioStreaming 接口是一个异步接收器，那么还需要一个额外的等时反馈端点。 如前所述，音频功能位于设备类层次结构中的接口级别。以下各节描述了音频接口集合，其中包含单个 AudioControl 接口和可选 AudioStreaming 接口，以及用于音频功能控制和音频数据流传输的相关端点。</p><h2 id="audiocontrol-interface"><strong>AudioControl Interface</strong></h2><p>为了控制特定音频函数的功能行为，主机可以操纵音频函数中的时钟实体、单位和终端。要使这些对象可访问，音频函数必须公开一个 AudioControl 接口。此接口可以包含以下端点</p><ul><li>用于操纵时钟实体、单元和终端设置以及检索音频功能状态的控制端点。此端点是强制性的，默认端点 0 用于此目的</li><li>中断端点。此端点是可选的，但非常有用，应在除最简单的音频设备外的所有设备上实现，以便在音频功能的行为发生任何变化时，主机软件可以随时收到通知</li></ul><p>AudioControl 接口是访问音频 Function 内部构件的单一入口点。所有与音频功能的时钟实体、单元或终端内的某些音频控件的操作有关的请求都必须指向音频功能的音频控件接口。同样，所有与音频函数内部相关的描述符都是特定于类的 AudioControl 接口描述符的一部分。音频功能的 AudioControl 接口只能支持单个备用设置 。</p><h2 id="control-endpoint"><strong>Control Endpoint</strong></h2><p>音频接口类使用端点 0（默认管道）作为使用特定于类的请求控制音频功能的标准方式。这些请求总是指向组成音频 Function 的单元或终端之一。这些请求的格式和内容将在本文件中进一步详述。</p><h2 id="interrupt-endpoint"><strong>Interrupt Endpoint</strong></h2><p>USB AudioControl 接口可支持可选中断端点，以通知主机音频功能内不同可寻址实体（时钟实体、端子、单元、接口和端点） 上发生的动态变化。中断端点被整个音频接口集合用来向主机传递更改信息。它被认为是 AudioControl 接口的一部分，因为它是 Collection 的锚点接口。</p><h2 id="audiostreaming-interface"><strong>AudioStreaming Interface</strong></h2><p>AudioStreaming 接口用于在主机和音频 Function 之间交换数字音频数据流。它们是可选的，一个音频 Function 可以有零个或多个与之关联的 AudioStreaming 接口，每个接口都可能携带不同性质和格式的数据。每个 AudioStreaming 接口最多只能有一个同步数据端点。这种构造保证了 Audiostreaming 接口和与端点相关的单个音频数据流之间的一对一关系。在某些情况下，同步数据端点伴随着一个相关的同步显式反馈端点，以实现同步。等时数据端点及其关联的反馈端点必须遵循 USB 规范第 9.6.6 节端点"中规定的端点编号方案。</p><p>AudioStreaming Interface 可以具有备用设置，可用于更改 Interface 和基础端点的某些特性。“ Alternate Settings”的典型用途是提供一种在 active Audiostreaming interface 上更改子帧大小/或通道数的方法。每当 Audiostreaming 接口需要同步数据端点时，它必须至少提供 0 带宽要求（未定义同步数据端点）的默认备用设置 （备用设置 0) 和包含实际同步数据端点的附加备用设置。</p><p>音频流接口本质上是用来为主机软件（驱动程序）提供一个接入点来操作它所代表的物理接口的行为。因此，甚至外部连接到音频功能 (S/PDIF 接口， analog input 等）可以用音频流接口来表示，这样主机软件就可以控制这些连接的某些方面。这种类型的音频流接口没有关联的 USB 端点。相关的音频数据流不使用 USB 作为传输介质。</p><p>对于在任何 AudioStreaming 接口中定义的每个同步 OUT 或 IN 端点，必须在 audio 函 Function 中定义相应的输入或输出端子。为了让主机完全理解连接的性质和行为，它必须考虑与接口和端点相关的描述符以及与终端相关的描述符。</p><h2 id="isochronous-audio-data-stream-endpoint"><strong>Isochronous Audio Data Stream Endpoint</strong></h2><p>通常，由等时音频数据端点处理的数据流不一定直接映射到音频功能中存在的逻辑通道。作为示例，考虑多个逻辑音频通道被压缩成单个数据流 (AC-3、WMA...) 的情况。这种数据流的格式可以完全不同于逻辑通道的原始格式（例如，640 Kbits/s AC-35.1 音频，而不是 6 通道 16 位 44.1 kHz 音频）。因此，为了正确地描述端点级的数据传输，逻辑信道的概念被音频数据流的概念所取代。 包含 OUT 端点的 AudioStreaming 接口负责在音频数据流和嵌入式逻辑通道之间进行转换，然后将数据移交给输入终端。在许多情况下，这种转换过程涉及到某种形式的解码。同样，包含 IN 端点的 AudioStreaming 接口必须将输出终端的逻辑通道转换为音频数据流，通常使用某种形式的编码。如果解码或编码过程公开影响编码或解码的控件，则可以通过 AudioStreaming 接口访问这些控件。</p><p>无法将控制音频功能中存在的属性（如音量或静音）的请求发送到 Audiostreaming 接口中的端点。AudioStreaming 接口对音频数据流进行操作，并且不知道它最终服务的逻辑通道数。相反，这些请求必须通过 AudioControl 接口指向正确的音频功能单元或终端。 如已经提到的，AudioStreaming 接口可以具有零个或一个等时音频数据端点。如果必须在主机和音频功能之间通信多个同步音频通道，则必须通过交织各个音频数据将它们聚集到一个物理音频通道簇中，然后将结果定向到单个端点。 如果一个音频功能需要多个集群才能运行，则每个集群会定向到一个单独的 AudioStreaming 接口的端点，该接口属于同一个 Audiolnterface Collection （所有集群都服务于同一个音频功能）。</p><h2 id="isochronous-feedback-endpoint"><strong>Isochronous Feedback Endpoint</strong></h2><p>对于自适应音频源端点和异步音频接收端点，需要显式同步机制来保持传输过程中的同步。有关同步的详细信息，请参见 USB 规范中的第 5 节”USB 数据流模型”。格式的具体信息，请参阅关于经过反馈管道的数据，请参见 USB 规范中的第 5.12.4.2 节”反馈"和第 9.6.6 节"端点”</p><h2 id="audio-data-format"><strong>Audio Data Format</strong></h2><p>用于通过 USB 传输音频数据的格式完全由特定于类的接口描述符的 bFormatType 和 bmFormats 字段中的代码决定。对于每个定义的格式类型，需要一个格式类型描述符来完整描述格式。有关已定义的格式类型以及相关数据格式和描述符的详细信息，请参见单独的文档 USB 音频数据格式该文档被认为是本规范的一部分。制造商必须充分记录特定于供应商的协议。</p><h1 id="clock-model"><strong>Clock Model</strong></h1><p>时钟实体提供了一种方法来准确地描述整个音频功能中采样时钟信号的使用和分布音频功能内部的采样频率只能通过与时钟源实体内部的采样频率控制直接交互来影响。采样频率控制范围属性为主机软件提供了必要的信息，以确定什么样的采样频率控制（以及因此相关联的时钟域） 支持。 改变采样频率的副作用可能是某些音频流接口可能需要切换到不同的备用设置，以支持新采样频率所需的带宽。此规范不允许 AudioStreaming 接口自行从一个备用设置切换到另一个备用设置，除非更改为备用设置零，这是空闲设置。相反，当音频功能检测到它不再支持 AudioStreaming 接口上的某个备用设置时，它必须在该接口上切换到备用设置零，并通过活动备用设置控制中断向主机软件报告更改。 然后，主机可以通过 GET 有效的备用设置控制请求来查询接口的新的有效的备用设置，并进行适当的选择。 注：若要将 AudioStreaming 接口中的备用设置数量保持在最低水平，建议不要为每个支持的采样频率提供单独的备用设置。相反，如果主机软件能够回收带宽即使是同步传输），提供一个活动备用设置可能就足够了。或者，只需几个活动备用设置（中等带宽，高带宽） 就足以提供合理的带宽控制。 音频流可以通过使用采样率转换器从一个时钟域桥接到另一个时钟域。</p><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB OTG</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBOTG/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBOTG/</url>
      
        <content type="html"><![CDATA[<h1 id="otg接口与转换器">OTG接口与转换器</h1><p>OTG是"On The Go"的英文缩写，字面上可以理解为“安上即可用”。USB传输是主从结构，一切USB传输都有Host发起。比如在开发板上可以插入U盘，这时开发板作为USB Host。但是开发板要跟PC通信，开发板就要作为USB Device。开发板要作为USB Host、USB Device两种角色，可以使用OTG插口：它可以根据硬件电路自动识别自己的角色，切换为USB Host或USB Deivce。</p><p>OTG插口有多种形态，常用的有Micro USB、Type C，如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG1.png"></p><span id="more"></span><h2 id="micro-usb">Micro USB</h2><p>对于Micro USB插座，它有5条引脚： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG2.png"></p><p>引脚作用如下表所示：</p><table><thead><tr class="header"><th>引脚名</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>VBUS</td><td>作为Host时，对外供电作为Device时，接收外部输入的电源</td></tr><tr class="even"><td>DM</td><td>数据信号</td></tr><tr class="odd"><td>DP</td><td>数据信号</td></tr><tr class="even"><td>ID</td><td>分辨自己角色的引脚：1：作为Device0：作为Host</td></tr><tr class="odd"><td>GND</td><td>地线</td></tr></tbody></table><p>开发板作为USB Device时跟PC上的USB相连，PC的USB接口只有VBUS、DM、DP、GND，所以开发板的ID引脚跟PC的USB口并无连接，它被板子上的上拉电阻拉高。</p><p>开发板作为USB Host时，需要接入一个"OTG转换器"，如下图黑色的转换器： [OTG3.png](<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG3.png"></p><p>OTG转换器的内部电路很简单(参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVsaWFuLmNuL25ld3Mvb3RnX2dvbmduZW5nX2ppZXhpLWNuLmh0bWw=">https://www.lulian.cn/news/otg_gongneng_jiexi-cn.html<i class="fa fa-external-link-alt"></i></span>)：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG4.png"></p><p>这个转换器插入开发板的OTG口之后，OTG口上的ID引脚就被拉低，软件转换为USB Host。</p><h2 id="type-c">Type C</h2><p>Type C插座里面有两组完全一样的信号，Type C数据线无论正插、反插，都可以使用： [OTG5.png](<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG5.png"></p><p>Type C插座有如下信号(参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjU5MDE0L2FydGljbGUvZGV0YWlscy8xMjQ0NzkxMjU=">https://blog.csdn.net/qq_37659014/article/details/124479125<i class="fa fa-external-link-alt"></i></span>)，在USB2.0协议里我们只关心红框里的信号：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG6.png"></p><p>开发板作为USB Device时跟PC上的USB相连，PC的USB接口只有VBUS、DM、DP、GND，所以开发板的CC1、CC2引脚跟PC的USB口并无连接，它被板子上的上拉电阻拉高。</p><p>开发板作为USB Host时，需要接入一个"OTG转换器"，如下图黑色的转换器： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG7.png"></p><p>如果不考虑兼容USB 3.0协议，上述转换器的电路图很简单，把Type C插头里面的CC引脚连接5.1K欧姆电阻到GND即可。</p><h1 id="otg接口电路">OTG接口电路</h1><p>开发板上的OTG接口需要实现两个功能：</p><ul><li>检测ID引脚(使用Type C接口的话是CC1、CC2引脚)，引入主控芯片：软件根据它设置USB控制器的角色(Host或Device)</li><li>根据ID引脚(或者CC1、CC2)决定VBUS是否输出电源：硬件电路自动实现</li></ul><h2 id="micro-usb-1">Micro USB</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG9.png"></p><h2 id="type-c-1">Type C</h2><p>如果不考虑兼容USB 3.0协议，可以使用如下精简电路：CC1、CC2作为ID引脚。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG10.png"></p><p>如果要兼容USB 3.0协议，则需要加入专用的芯片：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/OTG11.png"></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAC（零）UAC Topology</title>
      <link href="/next/2024/LinuxDriver/LinuxUSBUACTopology/"/>
      <url>/next/2024/LinuxDriver/LinuxUSBUACTopology/</url>
      
        <content type="html"><![CDATA[<h1 id="uac-拓扑结构">UAC 拓扑结构</h1><p>UAC 规范描述了以下类型的标准单元和终端，这些单元和终端被认为足以代表当前和近期可用的大多数视频功能：</p><ul><li>输入终端 - Input Terminal (IT)</li><li>输出终端 - Output Terminal (OT)</li><li>混音器单元 - Mixer Unit (MU)</li><li>选择器单元 - Selector Unit (SU)</li><li>特性单元 - Feature Unit (FU)</li><li>采样速率转换单元 - Sampling Rate Converter Unit (RU)</li><li>特效单元 - Effect Unit (EU)</li><li>处理单元 (PU) - Processing Unit (PU)</li><li>扩展单元 (XU) - Extension Unit (XU)</li></ul><p>除了单元和终端外，还引入了时钟实体的概念。定义了三种类型的时钟实体</p><ul><li>时钟源 - Clock Source (CS)</li><li>时钟选择器 - Clock Selector (CX)</li><li>时钟倍频器 - Clock Multiplier (CM)</li></ul><span id="more"></span><h1 id="uac-设备拓扑结构">UAC 设备拓扑结构</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uac5.png"></p><p>控件通常提供对特定的音频或时钟属性。每个控件都有一组可以操作或显示的属性。</p><p>有关控件行为的其他信息。控件可以具有以下属性：</p><ul><li>电流设置属性</li><li>范围属性三元组包括：<ul><li>最小设置属性</li><li>最大设置属性</li><li>分辨率属性</li></ul></li><li>中断启用属性</li></ul><p>例如，考虑要素单元内的音量控制。通过发出适当的 Get 请求，主机软件可以获取音量控制的属性值，例如，使用它们来正确显示控制。设置音量控制的当前属性允许主机软件更改音量音量设置控制。</p><p>另外，音频功能中的每个实体都可以有一个内存空间属性。此属性提供对实体内部内存空间的通用访问。</p><h1 id="uac-音频控制">UAC 音频控制</h1><p>一个 USB 设备可能包含多个配置。像手机一样，当手机通过 USB 线缆接入 PC 机后，会弹出一个选择对话框： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uac6.png"></p><p>让用户选择。当然一个 USB 设备只能工作在一种配置描述符下。</p><p>对于每一个 USB 配置描述符，可能含有多个 USB 接口描述描述符，同时这些接口描述符可能每个接口描述符又包含多个转换接口描述符。</p><p>这些接口描述符可能每一个接口描述符实现的是不同的独立的功能或者多个接口描述符组合实现一些设备功能。 在实际的设备工作中，可能又因为工作状态的不同，这些接口描述符进行转换接口的切换。</p><h1 id="uac-音频设备的接口的分类">UAC 音频设备的接口的分类</h1><p>这些接口配合实现的 UAC 设备接口，分为两种，分别叫做 UAC 音频控制接口和 UAC 音频流接口。</p><ul><li>UAC 音频控制接口：用于实现 UAC 音频控制接口及拓扑结构的枚举</li><li>UAC 音频流接口：用于音频数据流的传输</li></ul><h2 id="uac-音频控制接口">UAC 音频控制接口</h2><p>为了控制特定音频功能的功能行为，主机可以操纵时钟实体、单元以及音频功能内部的终端。为了使这些对象可访问，音频功能应提供单音频控制接口。此接口可以包含以下端点：</p><ul><li>控制端点，用于操作时钟实体、单元和终端设置以及检索系统状态音频功能。此端点是必需的，默认端点 0 用于此目的。</li><li>中断端点。中断端点是可选的，如果设备需要通知主机音频功能行为变化。</li></ul><p>音频控制接口是访问音频功能内部的惟一入口。所有要求与音频功能的时钟实体、单元或内部音频控件的操作有关终端应指向音频功能的音频控制接口。所有与音频功能的描述符都是音频控制接口描述符的一部分。音频控制接口的转换接口 AlternateSetting 只能为 0。</p><h3 id="uac-音频控制接口中的音频控制端点">UAC 音频控制接口中的音频控制端点</h3><p>音频控制端点使用默认的 USB 端点 0 来进行 UAV 音频的功能控制。实现方式是 UAC 通过端点 0 发送 USB 特定类请求。</p><h3 id="uac-音频控制接口中的音频中断端点">UAC 音频控制接口中的音频中断端点</h3><p>UAC 音频中断端点是可选的。通过此中断端点可以向主机上报动态中断的信息，这些信息可来源于可寻址实体（时钟实体、终端、单元、接口和端点）。</p><p>中断控制端点返回的数据长度为 2 字节，分别为 bStatusType 和 bOriginator。</p><ul><li>bStatusType 的 D7 位标识中断是否挂起，D6 用于标识是否是固件内存变化中断（通过 Get Memory 特定类请示清除），D4,D5 保留为 0，D0-D3 为 0 表示是中断来源于音频控制接口，为 1 表示中断来源于音频流接口，为 2 表示中断来源于音频流接口端点，值 3-15 保留。</li><li>bOriginator：根据中断的来原于用标识中断源的 ID 或端点地址。</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uac7.png"></p><h2 id="uac-音频流接口">UAC 音频流接口</h2><p>UAC 音频流接口用于传输音频流数据。一个 UAC 音频设备可以有多个音频流接口，每个音频流接口可以传输不同的音频数据格式。每一个音频流接口只能有一个等时传输端点，这样保证的是数据的传输与端点相关。</p><p>音频流接口包含转换接口进行音频流的切换。但至少包含一个转换接口为 0 的零带宽即不传输音频流接口和一个包含实际传输数据的转换接口 1。</p><h2 id="uac-音频其它控制">UAC 音频其它控制</h2><ul><li>时钟控制</li><li>电源域控制</li><li>按钮控制：分为通过 HID 接口实现和音响控制的一个组成部分</li></ul><h1 id="参考文献">参考文献</h1><p>《USB2.0 协议规范》<br>《UAC2 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（九）虚拟声卡 Latency</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAVCardLatency/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAVCardLatency/</url>
      
        <content type="html"><![CDATA[<h1 id="测试方法">测试方法</h1><ul><li>两块板子之间通过 I2S 通信，其中一块板子配置为 Slave 另一块板子为 Master</li><li><p>Master 板端执行 arecord | aplay 或者 gstream 命令 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arecord -Dhw:2,0 -r 44100 -c 8 -f S32_LE | aplay -Dhw:2,0 -c 8 -r 44100 -f S32_LE</span><br><span class="line">gst-launch-1.0 alsasrc device=device_input_split ! alsasink device=device_output <span class="built_in">sync</span>=<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p></p></li><li>Slave 通过 aplay 播放一段 wav 文件</li><li><p>通过示波器抓取 Master 板的 I2S 输入和输出端的波形间隔来测量虚拟声卡的 Latency</p></li></ul><span id="more"></span><h1 id="datastream">DataStream</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/alsa_latency.png"></p><p>上图就是 arecord | aplay（没有使用插件） 整个虚拟声卡的数据流，其中延迟最大的部分就是红色框中的缓存。</p><p>走 USB 通路的 latency： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/vsoundCardUSBLatency.png"></p><h1 id="增大-buffer-size-为什么会增大-latency">增大 Buffer Size 为什么会增大 latency？</h1><p>aplay 通过调用 snd_pcm_write 写数据给驱动，alsa lib 中 snd_pcm_write 有如下调用栈：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_snd_pcm_writei(pcm, buffer, size)</span><br><span class="line">--&gt;pcm-&gt;fast_ops-&gt;writei(pcm-&gt;fast_op_arg, buffer, size)</span><br><span class="line">--&gt;snd_pcm_hw_writei</span><br><span class="line">--&gt;ioctl(fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &amp;xferi)</span><br></pre></td></tr></tbody></table></figure><p>alsa lib 通过 ioctl 系统调用到内核，打印 snd_pcm_write 内核调用栈：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   14.513126@2]  Call trace:</span><br><span class="line">[   14.513472@2]  [ffffffc0201cbb20+  96][&lt;ffffffe610095490&gt;] dump_backtrace+0x0/0x188</span><br><span class="line">[   14.514417@2]  [ffffffc0201cbb80+  32][&lt;ffffffe61009563c&gt;] show_stack+0x24/0x30</span><br><span class="line">[   14.515329@2]  [ffffffc0201cbba0+  64][&lt;ffffffe611010068&gt;] dump_stack+0xc8/0xf0</span><br><span class="line">[   14.516240@2]  [ffffffc0201cbbe0+ 208][&lt;ffffffe610cc4d14&gt;] __snd_pcm_lib_xfer+0x834/0x850</span><br><span class="line">[   14.517257@2]  [ffffffc0201cbcb0+  80][&lt;ffffffe610cb9a34&gt;] snd_pcm_ioctl_xferi_compat+0x14c/0x260</span><br><span class="line">[   14.518360@2]  [ffffffc0201cbd00+ 208][&lt;ffffffe610cbd66c&gt;] snd_pcm_ioctl_compat+0x10c/0xdb8</span><br><span class="line">[   14.519405@2]  [ffffffc0201cbdd0+ 144][&lt;ffffffe610323754&gt;] __arm64_compat_sys_ioctl+0x16c/0x1220</span><br><span class="line">[   14.520496@2]  [ffffffc0201cbe60+  64][&lt;ffffffe61009ee28&gt;] el0_svc_common.constprop.3+0x90/0x1b0</span><br><span class="line">[   14.521589@2]  [ffffffc0201cbea0+ 336][&lt;ffffffe61009f014&gt;] el0_svc_compat_handler+0x2c/0x38</span><br><span class="line">[   14.522630@2]  [ffffffc0201cbff0+   0][&lt;ffffffe610083d5c&gt;] el0_svc_compat+0x8/0x2c</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>整理一下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/alsa_latency1.png"></p><p>内核中通过 Ioctl 系统调用最终调用到__snd_pcm_lib_xfer 函数，然后发现该数有如下逻辑：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/alsa_latency2.png"></p><p>如果是 playback 流，且状态为 parpare，当 runtime→dma_area 里的数据大于等于 runtime→start_threshold，状态才会切换到 running。通过打印 log 发现：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[   14.571395@0]  playback : buffer_size : 2048 dma size : 65536 start_threshold : 2048 stop_threshold : 2048</span><br><span class="line">[   14.572960@2]  capture : buffer_size : 2048 dma size : 65536 start_threshold : 1 stop_threshold : 2048</span><br></pre></td></tr></tbody></table></figure><p>playback 的 runtime→start_threshold 跟 buffer_size 一样大，也就是 playback 会先缓存 buffer_size 个 frame 的数据然后再开始播放，这样会导致 latency 随着 buffer_size 的变大而变大了。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxzYS1wcm9qZWN0Lm9yZy9hbHNhLWRvYy9hbHNhLWxpYi9wY21fcGx1Z2lucy5odG1s">https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbHNhLm9wZW5zcmMub3JnL0FMU0FfcGx1Z2lucw==">https://alsa.opensrc.org/ALSA_plugins<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核调试（三）VM 参数调试</title>
      <link href="/next/2024/LinuxKernel/LinuxKernelDebugVM/"/>
      <url>/next/2024/LinuxKernel/LinuxKernelDebugVM/</url>
      
        <content type="html"><![CDATA[<h1 id="vm-参数说明">vm 参数说明</h1><p>Currently, these files are in /proc/sys/vm: <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vm.png"></p><span id="more"></span><ul><li><p>admin_reserve_kbytes：<strong>系统中应为用户保留的可用内存量</strong>。</p><p>默认 (3% of free pages, 8MB)。这应该足以让 admin 登录并终止进程。这个值的设置，最好保证系统足够运行 sshd or login + bash (or some other shell) + top (or ps, kill, etc.)</p></li><li>block_dump：<strong>当设置为非零值时，block_dump 启用块 I/O 调试</strong>。</li><li><p>compact_memory：压缩内存。</p><p>仅当设置 CONFIG_COMPACTION 时可用。 当写入 1 时，所有区域都会被压缩，以便可以更好的提供连续内存。 这在分配大页面时可能很重要，尽管进程也会根据需要直接压缩内存。</p></li><li>compact_unevictable_allowed：压缩时检查 lru。</li><li>dirty_background_bytes：如果 dirty 页大于这个值，内核后台线程开始工作，将 dirty 内存写回到 flash。</li><li>dirty_background_ratio：dirty_background_bytes 是 dirty_background_ratio 的对应项， 一次只能指定其中之一。dirty_background_ratio 是按照总可用内存的百分比（空闲页和可回收页的总可用内存的百分比）来设置的，总可用内存不等于总系统内存。</li><li>dirty_bytes：系统 dirty 内存超过该值时，写文件的 process 会开始回写 dirty 内存到 flash。dirty_bytes 允许的最小值是两页（以字节为单位）； 任何低于此限制的值都将被忽略，旧的配置将被保留。</li><li>dirty_ratio：dirty_bytes 是 dirty_ratio 的对应项，一次只能指定其中之一。按照空闲页和可回收页的总可用内存的百分比来设置。</li><li><p>dirty_expire_centisecs：此参数定义 dirty page 多久必须刷入 flash，他以百分之一秒来表示，如下所示表示 30s，如果 dirty page 超过 30s 没有被写入 flash，那么下次 flusher thread 被调度的时候该页将回写到 flash。</p></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm <span class="comment"># cat dirty_expire_centisecs</span></span><br><span class="line">3000</span><br></pre></td></tr></tbody></table></figure><ul><li>dirtytime_expire_seconds：此可调参数用于定义 dirty inode 何时足够 dirty，超过这个值内核 flusher thread 进行写回。</li><li>dirty_writeback_centisecs：是用来表示内核检查 dirty page 的运行间隔，单位是秒的百分之一，与&nbsp;<code>dirty_expire_centisecs</code>&nbsp;配合起来使用。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm <span class="comment"># cat dirty_writeback_centisecs</span></span><br><span class="line">500</span><br></pre></td></tr></tbody></table></figure><ul><li><p>drop_caches:</p><p>Writing to this will cause the kernel to drop clean caches, as well as reclaimable slab objects like dentries and inodes. Once dropped, their memory becomes free</p><ul><li>To free pagecache::</li></ul><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></tbody></table></figure><p></p><p>pagecache 是已经和外部磁盘同步过的部分，既然已经同步过了，直接丢弃即可，下次要用再从磁盘上拷贝回来就可以了，如果要 clean 更多需要先执行 sync</p><ul><li>To free reclaimable slab objects (includes dentries and inodes)::</li></ul><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></tbody></table></figure><p></p><p>slab objects 包括 includes dentries and inodes。对于磁盘文件系统，内存 inode 存在 flash 中，因此同 page cache 一样，较易在内存中重建，释放的代价较低。dentry 虽然在磁盘上没有直接对应的结构，但也可根据文件系统中目录 inode 的信息进行重建</p><ul><li>To free slab objects and pagecache::</li></ul><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></tbody></table></figure><p></p><p>这是一个非破坏性操作，不会释放任何 dirty objects。 要增加此操作释放的对象数量，用户可以在写入 /proc/sys/vm/drop_caches 之前运行“sync”。 这将最大限度地减少系统上脏对象的数量，并创建更多要删除的候选对象。</p><p>该文件不是控制各种内核缓存（索引节点、目录项、页面缓存等）增长的手段。当系统上的其他地方需要内存时，这些对象会由内核自动回收。</p><p>使用此文件可能会导致性能问题。 由于它会丢弃缓存的对象，因此可能会花费大量 I/O 和 CPU 来重新创建删除的对象，尤其是在大量使用它们的情况下。 因此，不建议在测试或调试环境之外使用。</p><p>To disable them, echo 4 (bit 2) into drop_caches.</p></li><li>extfrag_threshold：该参数影响内核是否压缩内存或直接回收以满足高阶分配，该值设置得越小，越倾向于进行内存整理，默认值 500</li><li>highmem_is_dirtyable：该参数控制是否考虑对高端内存进行 dirty 写入限制。默认为 0，即在计算 dirty_ratio 和 dirty_background_ratio 的时候只考虑 low mem。当打开之后才会将 highmem 也计算在内</li><li>hugetlb_shm_group：包含允许使用 hugetlb 页表创建 SysV 共享内存段的组 ID</li><li>laptop_mode：笔记本电脑模式</li><li>legacy_va_layout：</li><li><p>lowmem_reserve_ratio：lowmem_reserve_ratio 是防止 highmem 内存在不充裕情况下，过度借用低端内存。lowmem_reserve_ratio 决定了每个 zone 保留多少数目的页面。lowmem_reserve_ratio 中定义了不同 zone 的预留比例，值越大保留比例越小。如，DMA 为 1/256，NORMAL 为 1/32。</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm <span class="comment"># cat /proc/sys/vm/lowmem_reserve_ratio</span></span><br><span class="line">256     32      0</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>第一个是 normal zone 的保护率，会保护该 zone 的 1/256 的内存</li><li>第二个是 dma zone 或 dma32 zone 的保护率， 1/32</li><li>第三个是其他 0</li></ul></li><li>max_map_count: 包含限制一个进程可以拥有的 VMA 的数量，默认 65530</li><li>memory_failure_early_kill: 控制当发生内核无法处理的内存错误时，该如何终止进程<ul><li>1：一旦检测到损坏，杀死所有损坏的进程和不可重新加载页面的所属进程。请注意，某些类型的页面不支持此功能，例如内核内部分配的数据或交换缓存，但适用于大多数用户页面</li><li>0：从所有进程中取消损坏页的映射，只杀死一个试图访问它的进程</li></ul></li><li>memory_failure_recovery：启用内存故障恢复<ul><li>1: Attempt recovery</li><li>0: Always panic on a memory failure</li></ul></li><li><p>min_free_kbytes：最少保留的字节数，用于计算 zone 的低水位值</p><p>这用于强制 Linux VM 保持最少的可用字节数。 VM 使用此数字来计算系统中每个 lowmem 区域的 watermark [WMARK_MIN] 值。每个 lowmem 区域根据其大小按比例获取一些保留的空闲页面</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/vm <span class="comment"># cat min_free_kbytes</span></span><br><span class="line">3987</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果您将其设置为低于 1024KB，在高负载下容易出现死锁。设置得太高会导致机器容易 OOM。</p></li><li><p>min_slab_ratio：This is available only on NUMA kernels.</p><p>每个区域中总页数的百分比，如果超过该百分比的 page 都是可回收的，则回收该 zone，默认值 5</p></li><li><p>min_unmapped_ratio：This is available only on NUMA kernels.</p><p>仅当超过此百分比的页面处于 zone_reclaim_mode 允许回收的状态时，才会发生区域回收。默认值 1</p></li><li>mmap_min_addr：控制着用户进程 mmap 能够映射的最低内存地址</li><li><p>mmap_rnd_bits：</p><p>该值可用于选择用于确定 vma 区域基地址的随机偏移量的位数，这些偏移量是由支持调整地址空间随机化的架构上的 mmap 分配产生的。 该值将受到架构支持的最小和最大值的限制。</p></li><li><p>mmap_rnd_compat_bits<strong>：</strong></p><p>该值可用于选择位数，用于确定 vma 区域基地址的随机偏移量，这些偏移量是在支持调整地址空间随机化的体系结构上以兼容模式运行的应用程序的 mmap 分配产生的。该值将受到架构支持的最小和最大值的限制</p></li><li>nr_hugepages<strong>：</strong>Change the minimum size of the hugepage pool.</li><li>nr_overcommit_hugepages&nbsp;<strong>：</strong>可以过量使用的大页，最大值=nr_hugepages + nr_overcommit_hugepages</li><li>nr_trim_pages：仅适用于 NOMMU 内核</li><li>numa_zonelist_order：已废弃</li><li>oom_dump_tasks：允许在内核执行 OOM 终止时生成系统范围的 Task 转储（不包括内核线程），并包括 pid、uid、tgid、vm 大小、rss、pgtables_bytes、swapents、oom_score_adj 分数和名称等信息</li><li>oom_kill_allocating_task：<ul><li>非 0：&nbsp;OOM 只会终止触发内存不足的任务。这避免了昂贵的任务列表扫描</li><li>0：OOM 将扫描整个任务列表并根据 heuristics kill task。这通常会选择一个流氓内存占用任务，该任务在被杀死时会释放大量内存</li></ul></li><li><p>overcommit_kbytes：overcommit_kbytes 是 overcommit_ratio 的对应项，一次只能指定其中之一，这里是配置允许申请多少 K 超出的内存</p><p>当 overcommit_memory 设置为 2 时，提交的地址空间不允许超过 swap 加上此物理 RAM 量</p></li><li>overcommit_memory：是否允许申请过度可用内存的内存<ul><li>当此标志为 0 时，内核会将用户空间内存请求大小与总内存加上交换分区大小进行比较，并拒绝明显的过度使用</li><li>当此标志为 1 时，内核假装始终有足够的内存，直到实际耗尽为止</li><li>当此标志为 2 时，内核使用“never overcommit”策略来尝试防止任何内存过度使用，请注意，user_reserve_kbytes 会影响此策略。</li></ul></li><li>overcommit_ratio：当 overcommit_memory 设置为 2 时，提交的地址空间不允许超过 swap 加上物理 RAM 的此百分比</li><li>page-cluster：从 swap 单次读入的连续页（与 page cache readahead 互斥）</li><li>panic_on_oom：用或禁用内存不足功能的 panic<ul><li>0，内核将杀死一些恶意进程，称为 oom_killer。通常，oom_killer 可以杀死恶意进程，系统将继续存在</li><li>1，则当发生内存不足时内核会发生 Panic。然而，如果某个进程通过 mempolicy/cpusets 限制使用节点，并且这些节点变成内存耗尽状态，则该进程可能会被 oom-killer 杀死。在这种情况下不会发生恐慌。因为其他节点的内存可能是空闲的。这意味着系统总体状态可能还不是致命的</li><li>2，即使出现上述情况，内核也会强制发生 Panic</li></ul></li><li>percpu_pagelist_fraction：这是每个区域中可以存储到每个 cpu 页面列表中的页面比例。它是根据在线 CPU 数量划分的上限。最小值为 8，这意味着我们不允许每个区域中超过 1/8 的页面存储在每个 cpu 页面列表中</li><li>stat_interval：多少 s 更新一次 vm 信息，默认是 1</li><li>stat_refresh：任何读写该文件，都会导致 vm 信息立刻更新</li><li>numa_stat：允许运行时配置 numa 统计信息</li><li>swappiness：io 和文件 cache 的权重，范围在 0-200，当=100 时表示等额，值越小表示 IO 代价越昂贵，内核更倾向于文件 cache，默认值 60</li><li>unprivileged_userfaultfd&nbsp;：控制用户是否可以使用 userfaultfd 系统调用。将其设置为 1 以允许非特权用户不受任何限制地使用 userfaultfd 系统调用。将其设置为 0 以限制非特权用户仅在用户模式下处理页面错误</li><li>user_reserve_kbytes：overcommit_memory = 2 的时，用户进程预留多少空闲内存。默认 3%。如果将其减少到零，则用户将被允许使用单个进程分配所有可用内存，减去 admin_reserve_kbytes。任何后续尝试执行命令都将导致“fork: Cannot allocate memory”</li><li>vfs_cache_pressure：控制内核回收 cache 和 inode 的趋势，默认是 100，内核以公平的速率回收 cache 和 inode；=0，即内核从不回收 cache 和 inode；&gt;100，内核更倾向回收 cache 和 inode</li><li>watermark_boost_factor：控制内存碎片时的回收级别，分母是 10000，默认值是 15000，即回收 150%的高水位线的页</li><li>watermark_scale_factor：swap 线程被唤醒后要释放多少内存，分母是 10000，最小值是 10，最大值是 3000。即每次被唤醒都会释放系统可用内存的 0.1%-30%</li><li>zone_reclaim_mode：zone 的会回收模式，默认关闭<ul><li>0：不在 zone 回收，从其他 zone 回收内存</li><li>1：打开 zone 回收</li><li>2：将脏页换出</li><li>4：回收交换页</li></ul></li></ul><h1 id="用户进程因为回写数据导致运行卡顿">用户进程因为回写数据导致运行卡顿</h1><p>我们知道刷 dirty 数据有两种方式，一种是 linux 内核线程异步刷 dirty 数据，另一种是由写数据的线程自己刷（用户线程自己刷 dirty 数据的时候就干不了其他事情导致线程卡顿）。对于 video 或者 audio 应用都会比较常遇到这个问题，这里简单起见，以一个 audio 例子来说明：</p><p>对于 48k、8channel、32bit 的采样参数来说明，则每秒采样的数据量为 48000<em>8</em>4=1536000/1024/1024=1.46M</p><p>由于数据量是可以精确计算的，这里主要调节 dirty_background_bytes、dirty_bytes 和 dirty_expire_centisecs 这三个参数。</p><p>调参数原则如下：</p><ul><li>尽可能的触发 dirty_background_bytes 阈值而不触发 dirty_bytes</li><li>尽可能的利用空闲内存做缓存，避免频繁刷 dirty 数据</li></ul><p>在以上两个原则下我们可以做如下调整：</p><p>查看当前 dirty 相关参数</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># sysctl -a | grep "dirty"</span></span><br><span class="line">kernel.osrelease = 5.4.242-09263-g35630c03e7d6-dirty</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br><span class="line">vm.dirtytime_expire_seconds = 43200</span><br></pre></td></tr></tbody></table></figure><ul><li>dirty_expire_centisecs 默认值为 3000，是按照百分之一秒来表示的，也就是 30s，代表 30s 会检查一次看 dirty 数据是否超过相关阈值，如果超过则执行刷 dirty 数据操作，这个值不要设置太小，可以先保持不变</li><li>dirty_background_bytes：代表 dirty 数据超过这个值就会唤醒内核线程回写 dirty page，30s 内会生成 1536000*30=46080000 字节数据，那么保险起见 dirty_background_bytes 可以小于 46080000 1-2M</li><li>dirty_bytes：代表 dirty 数据超过这个值，用户线程将停下正在干的事情去回写 dirty page，这样就导致用户线程卡顿，那么解决办法就是不要让用户线程主动回写 dirty 数据，该值应该设置为大于 46080000，这样永远先触发内核线程刷 dirty 数据，用户线程就不需要主动回写 dirty 数据了</li><li>当然如果内存紧张，这个时候要考虑降低 dirty_expire_centisecs 了，提高内核回写线程运行频率</li></ul><h1 id="为什么-drop_caches-后-cache-值并未减少">为什么 drop_caches 后 cache 值并未减少</h1><p>因为这种方式只能清空 page cache 中"clean"的部分，也就是已经和外部磁盘同步过的部分。而针对匿名页，内存没有与之对应的文件，如果想要回收这部分内存就需要添加 swap 分区，如果系统中有大量的使用匿名页的情况想要回收更多的内存应该添加 swap 分区。</p><h1 id="参考文献">参考文献</h1><p>《Linux Document》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（八）Alsa Plugin</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAPlugin/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAPlugin/</url>
      
        <content type="html"><![CDATA[<h1 id="pcm-digital-audio-plugins">PCM (digital audio) plugins</h1><p>PCM plugins extends functionality and features of PCM devices. The plugins take care about various sample conversions, sample copying among channels and so on.</p><span id="more"></span><h1 id="plugin-hw">Plugin: hw</h1><p>This plugin communicates directly with the ALSA kernel driver. It is a raw communication without any conversions. The emulation of mmap access can be optionally enabled, but expect worse latency in the case.</p><p>The nonblock option specifies whether the device is opened in a non-blocking manner. Note that the blocking behavior for read/write access won't be changed by this option. This influences only on the blocking behavior at opening the device. If you would like to keep the compatibility with the older ALSA stuff, turn this option off.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">    <span class="built_in">type</span> hw         <span class="comment"># Kernel PCM</span></span><br><span class="line">    card INT/STR        <span class="comment"># Card name (string) or number (integer)</span></span><br><span class="line">    [device INT]        <span class="comment"># Device number (default 0)</span></span><br><span class="line">    [subdevice INT]     <span class="comment"># Subdevice number (default -1: first available)</span></span><br><span class="line">    [sync_ptr_ioctl BOOL]   <span class="comment"># Use SYNC_PTR ioctl rather than the direct mmap access for control structures</span></span><br><span class="line">    [nonblock BOOL]     <span class="comment"># Force non-blocking open mode</span></span><br><span class="line">    [format STR]        <span class="comment"># Restrict only to the given format</span></span><br><span class="line">    [channels INT]      <span class="comment"># Restrict only to the given channels</span></span><br><span class="line">    [rate INT]      <span class="comment"># Restrict only to the given rate</span></span><br><span class="line">    [chmap MAP]     <span class="comment"># Override channel maps; MAP is a string array</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Example:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pcm.!default{</span><br><span class="line">    <span class="built_in">type</span> hw</span><br><span class="line">    card 0</span><br><span class="line">    device 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ctl.!default{</span><br><span class="line">    <span class="built_in">type</span> hw</span><br><span class="line">    card 0</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pcm.microphone {</span><br><span class="line">    <span class="built_in">type</span> hw</span><br><span class="line">    card 0</span><br><span class="line">    device 2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pcm.avs_input {</span><br><span class="line">    <span class="built_in">type</span> hw</span><br><span class="line">    card 0</span><br><span class="line">    device 4</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>给 hw:0,1 设备重命名为 default</p><p>Test：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay -D default test.wav</span><br></pre></td></tr></tbody></table></figure><h1 id="slave-definition">Slave definition</h1><p>The slave plugin can be specified directly with a string or the definition can be entered inside a compound configuration node. Some restrictions can be also specified (like static rate or count of channels).</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcm_slave.NAME {</span><br><span class="line">    pcm STR     <span class="comment"># PCM name</span></span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    pcm { }     <span class="comment"># PCM definition</span></span><br><span class="line">    format STR  <span class="comment"># Format or "unchanged"</span></span><br><span class="line">    channels INT    <span class="comment"># Count of channels or "unchanged" string</span></span><br><span class="line">    rate INT    <span class="comment"># Rate in Hz or "unchanged" string</span></span><br><span class="line">    period_time INT <span class="comment"># Period time in us or "unchanged" string</span></span><br><span class="line">    buffer_time INT <span class="comment"># Buffer time in us or "unchanged" string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Example:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcm_slave.slave_rate44100Hz {</span><br><span class="line">    pcm <span class="string">"hw:0,0"</span></span><br><span class="line">    rate 44100</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">pcm.rate44100Hz {</span><br><span class="line">    <span class="built_in">type</span> plug</span><br><span class="line">    slave slave_rate44100Hz</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>The equivalent configuration (in one compound):</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcm.rate44100Hz {</span><br><span class="line">    <span class="built_in">type</span> plug</span><br><span class="line">    slave {</span><br><span class="line">        pcm <span class="string">"hw:0,0"</span></span><br><span class="line">        rate 44100</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>将 hw:0,0 声卡的采样频率转换为 44100hz。</strong></p><p>Test：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay -D rate44100Hz test.wav</span><br></pre></td></tr></tbody></table></figure><h1 id="plugin-rate">Plugin: Rate</h1><p>This plugin converts a stream rate. The input and output formats must be linear.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">    <span class="built_in">type</span> rate               <span class="comment"># Rate PCM</span></span><br><span class="line">        slave STR               <span class="comment"># Slave name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        slave {                 <span class="comment"># Slave definition</span></span><br><span class="line">                pcm STR         <span class="comment"># Slave PCM name</span></span><br><span class="line">                <span class="comment"># or</span></span><br><span class="line">                pcm { }         <span class="comment"># Slave PCM definition</span></span><br><span class="line">                rate INT        <span class="comment"># Slave rate</span></span><br><span class="line">                [format STR]    <span class="comment"># Slave format</span></span><br><span class="line">        }</span><br><span class="line">    converter STR           <span class="comment"># optional</span></span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    converter [ STR1 STR2 ... ] <span class="comment"># optional</span></span><br><span class="line">                <span class="comment"># Converter type, default is taken from</span></span><br><span class="line">                <span class="comment"># defaults.pcm.rate_converter</span></span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    converter {     <span class="comment"># optional</span></span><br><span class="line">        name STR    <span class="comment"># Convertor type</span></span><br><span class="line">        xxx yyy     <span class="comment"># optional convertor-specific configuration</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="plugin-route-volume">Plugin: Route &amp; Volume</h1><p>This plugin converts channels and applies volume during the conversion. The format and rate must match for both of them.</p><p>SCHANNEL can be a channel name instead of a number (e g FL, LFE). If so, a matching channel map will be selected for the slave.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">        <span class="built_in">type</span> route              <span class="comment"># Route &amp; Volume conversion PCM</span></span><br><span class="line">        slave STR               <span class="comment"># Slave name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        slave {                 <span class="comment"># Slave definition</span></span><br><span class="line">                pcm STR         <span class="comment"># Slave PCM name</span></span><br><span class="line">                <span class="comment"># or</span></span><br><span class="line">                pcm { }         <span class="comment"># Slave PCM definition</span></span><br><span class="line">                [format STR]    <span class="comment"># Slave format</span></span><br><span class="line">                [channels INT]  <span class="comment"># Slave channels</span></span><br><span class="line">        }</span><br><span class="line">        ttable {                <span class="comment"># Transfer table (bi-dimensional compound of cchannels * schannels numbers)</span></span><br><span class="line">                CCHANNEL {</span><br><span class="line">                        SCHANNEL REAL   <span class="comment"># route value (0.0 - 1.0)</span></span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="automatic-conversion-plugin">Automatic conversion plugin</h1><p>This plugin converts channels, rate and format on request.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">        <span class="built_in">type</span> plug               <span class="comment"># Automatic conversion PCM</span></span><br><span class="line">        slave STR               <span class="comment"># Slave name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        slave {                 <span class="comment"># Slave definition</span></span><br><span class="line">                pcm STR         <span class="comment"># Slave PCM name</span></span><br><span class="line">                <span class="comment"># or</span></span><br><span class="line">                pcm { }         <span class="comment"># Slave PCM definition</span></span><br><span class="line">        [format STR]    <span class="comment"># Slave format (default nearest) or "unchanged"</span></span><br><span class="line">        [channels INT]  <span class="comment"># Slave channels (default nearest) or "unchanged"</span></span><br><span class="line">        [rate INT]  <span class="comment"># Slave rate (default nearest) or "unchanged"</span></span><br><span class="line">        }</span><br><span class="line">    route_policy STR    <span class="comment"># route policy for automatic ttable generation</span></span><br><span class="line">                <span class="comment"># STR can be 'default', 'average', 'copy', 'duplicate'</span></span><br><span class="line">                <span class="comment"># average: result is average of input channels</span></span><br><span class="line">                <span class="comment"># copy: only first channels are copied to destination</span></span><br><span class="line">                <span class="comment"># duplicate: duplicate first set of channels</span></span><br><span class="line">                <span class="comment"># default: copy policy, except for mono capture - sum</span></span><br><span class="line">    ttable {        <span class="comment"># Transfer table (bi-dimensional compound of cchannels * schannels numbers)</span></span><br><span class="line">        CCHANNEL {</span><br><span class="line">            SCHANNEL REAL   <span class="comment"># route value (0.0 - 1.0)</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    rate_converter STR  <span class="comment"># type of rate converter</span></span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    rate_converter [ STR1 STR2 ... ]</span><br><span class="line">                <span class="comment"># type of rate converter</span></span><br><span class="line">                <span class="comment"># default value is taken from defaults.pcm.rate_converter</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Example：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcm.nfbtout {</span><br><span class="line">        <span class="built_in">type</span> plug</span><br><span class="line">        slave {</span><br><span class="line">                pcm <span class="string">"hw:1,0"</span></span><br><span class="line">                rate 8000</span><br><span class="line">                channels 2</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="plugin-multiple-streams-to-one">Plugin: Multiple streams to One</h1><p>This plugin converts multiple streams to one.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">        <span class="built_in">type</span> multi              <span class="comment"># Multiple streams conversion PCM</span></span><br><span class="line">        slaves {        <span class="comment"># Slaves definition</span></span><br><span class="line">        ID STR      <span class="comment"># Slave PCM name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        ID {</span><br><span class="line">            pcm STR     <span class="comment"># Slave PCM name</span></span><br><span class="line">            <span class="comment"># or</span></span><br><span class="line">            pcm { }     <span class="comment"># Slave PCM definition</span></span><br><span class="line">            channels INT    <span class="comment"># Slave channels</span></span><br><span class="line">        }</span><br><span class="line">    bindings {      <span class="comment"># Bindings table</span></span><br><span class="line">        N {</span><br><span class="line">            slave STR   <span class="comment"># Slave key</span></span><br><span class="line">            channel INT <span class="comment"># Slave channel</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    [master INT]        <span class="comment"># Define the master slave</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>For example, to bind two PCM streams with two-channel stereo (hw:0,0 and hw:0,1) as one 4-channel stereo PCM stream, define like this:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pcm.quad {</span><br><span class="line">    <span class="built_in">type</span> multi</span><br><span class="line"> </span><br><span class="line">    slaves.a.pcm <span class="string">"hw:0,0"</span></span><br><span class="line">    slaves.a.channels 2</span><br><span class="line">    slaves.b.pcm <span class="string">"hw:0,1"</span></span><br><span class="line">    slaves.b.channels 2</span><br><span class="line"> </span><br><span class="line">    bindings.0.slave a</span><br><span class="line">    bindings.0.channel 0</span><br><span class="line">    bindings.1.slave a</span><br><span class="line">    bindings.1.channel 1</span><br><span class="line">    bindings.2.slave b</span><br><span class="line">    bindings.2.channel 0</span><br><span class="line">    bindings.3.slave b</span><br><span class="line">    bindings.3.channel 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Note that the resultant pcm "quad" is not in the interleaved format but in the "complex" format. Hence, it's not accessible by applications which can handle only the interleaved (or the non-interleaved) format. In such a case, wrap this PCM with&nbsp;route&nbsp;or&nbsp;plug&nbsp;plugin.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcm.quad2 {</span><br><span class="line">    <span class="built_in">type</span> route</span><br><span class="line">    slave.pcm <span class="string">"quad"</span></span><br><span class="line">    ttable.0.0 1</span><br><span class="line">    ttable.1.1 1</span><br><span class="line">    ttable.2.2 1</span><br><span class="line">    ttable.3.3 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="plugin-dmix">Plugin: dmix</h1><p>This plugin provides direct mixing of multiple streams. The resolution for 32-bit mixing is only 24-bit. The low significant byte is filled with zeros. The extra 8 bits are used for the saturation.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">    <span class="built_in">type</span> dmix       <span class="comment"># Direct mix</span></span><br><span class="line">    ipc_key INT     <span class="comment"># unique IPC key</span></span><br><span class="line">    ipc_key_add_uid BOOL    <span class="comment"># add current uid to unique IPC key</span></span><br><span class="line">    ipc_perm INT        <span class="comment"># IPC permissions (octal, default 0600)</span></span><br><span class="line">    hw_ptr_alignment STR    <span class="comment"># Slave application and hw pointer alignment type</span></span><br><span class="line">                <span class="comment"># STR can be one of the below strings :</span></span><br><span class="line">                <span class="comment"># no</span></span><br><span class="line">                <span class="comment"># roundup</span></span><br><span class="line">                <span class="comment"># rounddown</span></span><br><span class="line">                <span class="comment"># auto (default)</span></span><br><span class="line">    slave STR</span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    slave {         <span class="comment"># Slave definition</span></span><br><span class="line">        pcm STR     <span class="comment"># slave PCM name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        pcm { }     <span class="comment"># slave PCM definition</span></span><br><span class="line">        format STR  <span class="comment"># format definition</span></span><br><span class="line">        rate INT    <span class="comment"># rate definition</span></span><br><span class="line">        channels INT</span><br><span class="line">        period_time INT <span class="comment"># in usec</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        period_size INT <span class="comment"># in bytes</span></span><br><span class="line">        buffer_time INT <span class="comment"># in usec</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        buffer_size INT <span class="comment"># in bytes</span></span><br><span class="line">        periods INT <span class="comment"># when buffer_size or buffer_time is not specified</span></span><br><span class="line">    }</span><br><span class="line">    bindings {      <span class="comment"># note: this is client independent!!!</span></span><br><span class="line">        N INT       <span class="comment"># maps slave channel to client channel N</span></span><br><span class="line">    }</span><br><span class="line">    slowptr BOOL        <span class="comment"># slow but more precise pointer updates</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ipc_key 必须是整数形式的唯一 ipc key。对于每个不同的 dmix 定义，这个数字必须是唯一的，因为共享内存是用这个 key 创建的。当 ipc_key_add_uid 设置为 true 时，uid 值将添加到 ipc_key 设置中。这样可以避免同一个 IPC 密钥与不同用户同时发生冲突。</p><p>hw_ptr_alignment 这个配置默认是 auto</p><p>An example configuration for setting 44100 Hz,&nbsp;<code>S32_LE</code>&nbsp;format as the slave PCM of "hw:0" is like below:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcm.dmix_44 {</span><br><span class="line">    <span class="built_in">type</span> dmix</span><br><span class="line">    ipc_key 321456  <span class="comment"># any unique value</span></span><br><span class="line">    ipc_key_add_uid <span class="literal">true</span></span><br><span class="line">    slave {</span><br><span class="line">        pcm <span class="string">"hw:0"</span></span><br><span class="line">        format S32_LE</span><br><span class="line">        rate 44100</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Test：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay -Dplug:dmix_44 foo_48k.wav</span><br></pre></td></tr></tbody></table></figure><h1 id="plugin-dsnoop">Plugin: dsnoop</h1><p>此插件将一个 capture 流拆分为多个。它的工作方式与 dmix 插件相反，从多个客户端同时读取共享捕获缓冲区。以下参数的含义与 dmix 插件几乎相同。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pcm.name {</span><br><span class="line">    <span class="built_in">type</span> dsnoop     <span class="comment"># Direct snoop</span></span><br><span class="line">    ipc_key INT     <span class="comment"># unique IPC key</span></span><br><span class="line">    ipc_key_add_uid BOOL    <span class="comment"># add current uid to unique IPC key</span></span><br><span class="line">    ipc_perm INT        <span class="comment"># IPC permissions (octal, default 0600)</span></span><br><span class="line">    slave STR</span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    slave {         <span class="comment"># Slave definition</span></span><br><span class="line">        pcm STR     <span class="comment"># slave PCM name</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        pcm { }     <span class="comment"># slave PCM definition</span></span><br><span class="line">        format STR  <span class="comment"># format definition</span></span><br><span class="line">        rate INT    <span class="comment"># rate definition</span></span><br><span class="line">        channels INT</span><br><span class="line">        period_time INT <span class="comment"># in usec</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        period_size INT <span class="comment"># in bytes</span></span><br><span class="line">        buffer_time INT <span class="comment"># in usec</span></span><br><span class="line">        <span class="comment"># or</span></span><br><span class="line">        buffer_size INT <span class="comment"># in bytes</span></span><br><span class="line">        periods INT <span class="comment"># when buffer_size or buffer_time is not specified</span></span><br><span class="line">    }</span><br><span class="line">    bindings {      <span class="comment"># note: this is client independent!!!</span></span><br><span class="line">        N INT       <span class="comment"># maps slave channel to client channel N</span></span><br><span class="line">    }</span><br><span class="line">    slowptr BOOL        <span class="comment"># slow but more precise pointer updates</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="open-流程">Open 流程</h1><p>下面以 dsnoop 插件为例梳理下 alsa-lib 使用插件的流程，详细如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkYjA5N2E1YTQ4YmMwMjc2ODg4MzNk">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/snd_pcm_dsnoop_open.png"></p><ul><li>解析配置文件并生成配置树</li><li>打开实际设备，通过 mmap 映射驱动中的控制信息和 buffer</li></ul><h1 id="read-流程">Read 流程</h1><p>以下是 read 流程，write 流程不再列出来了。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkYjA5YWM5YTM0M2QzZTg5OWQ5MTgy">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/snd_pcm_readi.png"></p><ul><li>memcopy 驱动 DMA buffer 中的数据</li><li>hw_ptr 数据指针的 sync</li></ul><p>可以看到 alsa plug 支持多进程，可以多个进程打开同一个 slave 声卡，多进程间通过信号量同步。 如果要自己创建一个声卡，同时让创建的声卡支持 plugin，那么最好不要使用 appl_ptr 和依赖 appl_ptr 的 api。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxzYS1wcm9qZWN0Lm9yZy9hbHNhLWRvYy9hbHNhLWxpYi9wY21fcGx1Z2lucy5odG1s">https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbHNhLm9wZW5zcmMub3JnL0FMU0FfcGx1Z2lucw==">https://alsa.opensrc.org/ALSA_plugins<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（六）声卡创建流程</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSACreateSoundCard/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSACreateSoundCard/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YzA2ZjYwZTNlNzQwNmUyMDNmMzkz">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/ALSA_Struct1.png"></p><span id="more"></span><ul><li>snd_card: 是最顶层数据结构，通过链表挂载该 sound card 的所有设备 snd_device。</li><li>snd_pcm: 挂在 snd_card 下面的一个 snd_device。</li><li>snd_pcm_str: 代表 playback stream 和 capture stream。</li><li>snd_pcm_substream: 是 pcm 中间层的核心，绝大部分任务都是在 substream 中处理，尤其是他的 ops（snd_pcm_ops）字段，许多 user 空间的应用程序通过 alsa-lib 对驱动程序的请求都是由该结构中的函数处理。它的 runtime 字段则指向 snd_pcm_runtime 结构，snd_pcm_runtime 记录这 substream 的一些重要的软件和硬件运行环境和参数。</li><li>snd_pcm_ops: 创建声卡需要提供的回调。</li><li>snd_pcm_runtime: 运行时参数，包括 sample rate、channel、format 等参数，以及 buffer 相关信息。</li><li>snd_pcm_harward: 硬件相关参数，创建声卡需要提供相关参数。</li></ul><h1 id="hw-buffer">HW Buffer</h1><p>当 app 在调用 snd_pcm_writei 时，alsa core 将 app 传来的数据搬到 HW buffer（即 DMA buffer）中，alsa driver 从 HW buffer 中读取数据传输到硬件播放。</p><p>ALSA buffer 是采用 ring buffer 来实现的。ring buffer 有多个 HW buffer 组成。HW buffer 一般是在 alsa driver 的 hw_params 函数中分配的一块大小为 buffer size 的 DMA buffer. 之所以采用多个 HW buffer 来组成 ring buffer, 是防止读写指针的前后位置频繁的互换（即写指针到达 HW buffer 边界时，就要回到 HW buffer 起始点）。</p><p>ring buffer = n * HW buffer. 通常这个 n 比较大，在数据读写的过程中，很少会出现读写指针互换的情况。下图是 ALSA buffer 的实现以及读写指针更新的方法：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/hw_buffer.png"></p><ul><li>hw_ptr_base: 是当前 HW buffer 在 Ring buffer 中的起始位置。当读指针到达 HW buffer 尾部时，hw_ptr_base 按 buffer size 移动。</li><li>hw_ptr: 即 HW buffer 的读指针。alsa driver 将数据从 HW buffer 中读走并送到声卡硬件时，hw_ptr 就会移动到新位置。</li><li>appl_ptr: 即 HW buffer 的写指针。app 在调用 snd_pcm_write 写数据，alsa core 将数据 copy 到 HW buffer 后，appl_ptr 就更新。</li><li>boundary: 即 Ring buffer 边界。</li><li>hw_ofs: 是读指针在当前 HW buffer 中的位置。由 alsa driver 的 pointer() 返回。</li><li>appl_ofs: 是写指针在当前 HW buffer 中的位置。</li></ul><p>hw_ptr 的更新是通过调用 snd_pcm_update_hw_ptr() 完成。此函数在 app 写数据时会调用，也会在硬件中断时通过 snd_pcm_peroid_elapsed 调用</p><h1 id="流程">流程</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YmMwYzUxZTA4NTMwNmQ3NDJlYzkz">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/snd_card_register1.png"></p><ul><li>分配并设置 snd_card 数据结构</li><li>创建 snd_pcm instance</li><li>设置 snd_pcm_ops 结构体成员</li><li>分配 DMA 内存</li><li>注册声卡</li></ul><h1 id="参考文献">参考文献</h1><p>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（七）XRUN</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAXRUN/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAXRUN/</url>
      
        <content type="html"><![CDATA[<p>XRUN 是缓冲区不足或溢出，X 代表不足或溢出。在这两种情况下，都表明系统速度不够快，未能及时处理来自 ALSA 音频缓冲区的数据，因此丢失了一些数据。当我们以非常小的缓冲区大小运行时，声卡应该非常快地处理传入缓冲区的数据，否则就溢出 overrun 了。有些芯片无法适应较小的缓冲区大小，因此我们必须增加缓冲区长度以减轻声音芯片的工作量。通常，xruns 可以听到爆裂声或爆裂声。</p><span id="more"></span><blockquote><p>在录音例子中，如果应用程序读取数据不够快，循环缓存区将会被新的数据覆盖。这种数据的丢失被称为"over run" 在回放例子中，如果应用程序写入数据到缓存区中的速度不够快，缓存区将会"饿死"。这样的错误被称为"under run"</p></blockquote><h1 id="proc">/Proc</h1><p>ALSA 提供了一种通过 proc 记录和调试 xrun 的方法：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers  ---&gt;  &lt;*&gt; Sound card support  ---&gt;  &lt;*&gt;   Advanced Linux Sound Architecture  ---&gt; [*]   Sound Proc FS Support</span><br><span class="line"></span><br><span class="line">Device Drivers  ---&gt;  &lt;*&gt; Sound card support  ---&gt;  &lt;*&gt;   Advanced Linux Sound Architecture  ---&gt; [*]   Debug  ---&gt;  [*]     Enable PCM ring buffer overrun/underrun debugging</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/alsa_debug_config.png"></p><h1 id="procasoundcardpcm0pxrun_debug">/proc/asound/card#/pcm0p/xrun_debug</h1><p>将“#”替换为 card number。该 proc 文件可以启用各种调试工具。必须在内核中启用 CONFIG_SND_PCM_XRUN_DEBUG、CONFIG_SND_VERBOSE_PROCFS、CONFIG_SND_DEBUG 选项（如果 xrun_debug proc 文件存在 - 该功能已启用）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1   Basic debugging - show xruns <span class="keyword">in</span> ksyslog interface</span><br><span class="line">2   Dump stack - dump stack <span class="keyword">for</span> basic debugging</span><br><span class="line">4   Jiffies check - compare the position with kernel jiffies (a <span class="built_in">sort</span> of in-kernel monotonic clock),</span><br><span class="line">    show what<span class="string">'s changed when basic debugging is enabled</span></span><br><span class="line"><span class="string">8   Dump positions on each period update call</span></span><br><span class="line"><span class="string">16  Dump positions on each hardware pointer update call</span></span><br><span class="line"><span class="string">32  Enable logging of last 10 ring buffer positions</span></span><br><span class="line"><span class="string">64  Show the last 10 ring buffer position only once (when first error situation occured)</span></span><br></pre></td></tr></tbody></table></figure><p>To enable more features just do sum values of above (for example 1+2=3).</p><p>Some good value combinations:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable basic debugging and dump stack</span></span><br><span class="line"><span class="comment"># Usefull to just see, if PCM stream is stopped for a reason (usually wrong audio process timing from scheduler)</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable basic debugging and dump stack, check hardware pointer on the period update</span></span><br><span class="line"><span class="comment"># Usefull to just see, if PCM stream is stopped for a reason (usually wrong audio process timing from scheduler)</span></span><br><span class="line"><span class="comment"># And to check the values from driver</span></span><br><span class="line"><span class="built_in">echo</span> 11 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable basic debugging and dump stack, check hardware pointer on all updates</span></span><br><span class="line"><span class="comment"># Usefull to just see, if PCM stream is stopped for a reason (usually wrong audio process timing from scheduler)</span></span><br><span class="line"><span class="comment"># And to do the exact check the values from driver</span></span><br><span class="line"><span class="built_in">echo</span> 27 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable basic debugging, do jiffies check and enable one shot dump of last 10 ring buffer positions</span></span><br><span class="line"><span class="comment"># Usefull, when the position is broken only after some of time (to reduce ksyslog messages)</span></span><br><span class="line"><span class="built_in">echo</span> 101 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable basic debugging, do jiffies check and dump position on each period and hardware pointer update calls</span></span><br><span class="line"><span class="comment"># Usefull when the lowlevel (specific) hardware driver is somehow broken</span></span><br><span class="line"><span class="built_in">echo</span> 29 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，在进入 XRUN 状态时会停止 DMA 传输，直到有 available 空间可写入（overrun 时），或者直到有数据写入（underrun 时）。 但是用户空间可以通过配置 silence_threshold 来继续播放缓冲区的重复的音频数据或静音数据（silence_size 为填充的大小），当空余空间超过 silence threshold 时，就 hardware buffer 写入 silence。</p><h1 id="trace">Trace</h1><ol type="1"><li><p>在 menuconfig 中开启以下选项 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers  </span><br><span class="line">---&gt;  &lt;*&gt; Sound card support  </span><br><span class="line">---&gt;  &lt;*&gt;   Advanced Linux Sound Architecture  </span><br><span class="line">---&gt; [*]   Sound Proc FS Support</span><br><span class="line"></span><br><span class="line">Device Drivers  </span><br><span class="line">---&gt;  &lt;*&gt; Sound card support  </span><br><span class="line">---&gt;  &lt;*&gt;   Advanced Linux Sound Architecture  </span><br><span class="line">---&gt; [*]   Debug  </span><br><span class="line">---&gt;  [*]     Enable PCM ring buffer overrun/underrun debugging</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>在设备中挂在 debugfs 和使能 audio 相关 trace</p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /sys/kernel/debug/</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/kernel/debug/tracing/events/snd_pcm/hwptr/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  /sys/kernel/debug/tracing/events/snd_pcm/applptr/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/snd_pcm/xrun/enable</span><br></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>执行 arecord，出现 xrun 后：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>以下是执行</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -Dhw:2,0 -r 44100 -c 8 -f S32_LE  /data/record.wav</span><br></pre></td></tr></tbody></table></figure><p>复现到的一次 xrun 问题：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/xrun_trace.png"></p><p>这里 hwptr 的 old 就是 hwptr 指针，applptr 的 current 就是 applptr 指针位置，可以看到发生 xrun 前面 hwptr=2781184，applyptr=2779136。系统中 buffer_size = 2048（frames）, 而这里 hwptr 指针领先 applptr 指针 2048 个 frame，说明 runtime 里的 dma buffer 已经满了（overrun），应用没有及时取走数据。下一步就可以分析应用为什么没有及时取走数据了。</p><h1 id="关于-hw-buffer">关于 HW Buffer</h1><p>当 app 在调用 snd_pcm_writei 时，alsa core 将 app 传来的数据搬到 HW buffer（即 DMA buffer）中，alsa driver 从 HW buffer 中读取数据传输到硬件播放。</p><p>ALSA buffer 是采用 ring buffer 来实现的。ring buffer 有多个 HW buffer 组成。</p><p>HW buffer 一般是在 alsa driver 的 hw_params 函数中分配的一块大小为 buffer size 个 frames 的 DMA buffer.</p><p>之所以采用多个 HW buffer 来组成 ring buffer, 是防止读写指针的前后位置频繁的互换（即写指针到达 HW buffer 边界时，就要回到 HW buffer 起始点）。</p><p>ring buffer = n * HW buffer. 通常这个 n 比较大，在数据读写的过程中，很少会出现读写指针互换的情况。</p><p>下图是 ALSA buffer 的实现以及读写指针更新的方法：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/hw_buffer.png"></p><ul><li>hw_ptr_base 是当前 HW buffer 在 Ring buffer 中的起始位置。当读指针到达 HW buffer 尾部时，hw_ptr_base 按 buffer size 移动</li><li>hw_ptr 即 HW buffer 的 driver 操作指针</li><li>appl_ptr 即 HW buffer 的应用操作指针</li><li>boundary 即 Ring buffer 边界。</li><li>hw_ofs 是 driver 指针在当前 HW buffer 中的位置。由 alsa driver 的 pointer() 返回</li><li>appl_ofs 是应用操作指针在当前 HW buffer 中的位置</li><li>hw_ptr 的更新是通过调用 snd_pcm_update_hw_ptr0 完成。此函数在 app 写数据时会调用，也会在硬件中断时通过 snd_pcm_peroid_elapsed 调用</li></ul><h1 id="实验">实验</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arecord -Dhw:2,0 -c 8 -r 44100 -f S32_LE /dev/null</span><br><span class="line">arecord -Dhw:2,0 -r 44100 -c 8 -f S32_LE | aplay -Dhw:2,0 -c 8 -r 44100 -f S32_LE</span><br></pre></td></tr></tbody></table></figure><p>以上两种方式都不会出现 overrun，这种一般都是 IO 性能问题。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/vm.png"></p><p>cat meminfo 节点，发现系统会在缓存 41M 左右的时候进行刷 dirty page。</p><p>对于 44100 采样率、8channel、32bit 位深，每秒钟产生的数据量为 44100<em>8</em>4Byte = 1411200Byte = 1.345MByte</p><p>可以通过修改刷 dirty page 的频率来降低出现 overrun 的概率：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 7056000 &gt; /proc/sys/vm/dirty_background_bytes</span><br><span class="line"><span class="built_in">echo</span> 70560000 &gt; /proc/sys/vm/dirty_bytes</span><br><span class="line"><span class="built_in">echo</span> 2000 &gt; /proc/sys/vm/dirty_expire_centisecs</span><br><span class="line"><span class="built_in">echo</span> 500 &gt; /proc/sys/vm/dirty_writeback_centisecs</span><br></pre></td></tr></tbody></table></figure><p>修改成这样大概 5s 左右刷一次数据，这样 overrun 概率大大降低。</p><h1 id="常见原因">常见原因</h1><ul><li>Linux CFS（完全公平的调度程序）</li><li>具有 SCHED_FIFO 调度的高优先级线程</li><li>优先级倒置</li><li>长时间调度延迟</li><li>长时间运行的中断处理程序</li><li>长时间中断禁用</li><li>电源管理</li><li>安全内核</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZG9jcy9jb3JlL2F1ZGlvL2xhdGVuY3kvY29udHJpYj9obD16aC1jbg==">https://source.android.com/docs/core/audio/latency/contrib?hl=zh-cn<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxzYS1wcm9qZWN0Lm9yZy93aWtpL1hSVU5fRGVidWc=">https://www.alsa-project.org/wiki/XRUN_Debug<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（五）Machine 驱动</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAMachineDriver/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAMachineDriver/</url>
      
        <content type="html"><![CDATA[<p>ASoC 架构的设计方式是平台和编解码器类驱动程序必须绑定在一起才能构建音频设备。这种绑定可以在所谓的机器驱动程序或设备树中完成，每一个机器驱动程序和设备树都是与特定机器相关的。也就是说，机器驱动程序针对特定系统，并且不同的板卡需要不同的机器驱动程序。</p><span id="more"></span><h1 id="machine-驱动程序开发流程">Machine 驱动程序开发流程</h1><p>一般来说，机器驱动程序的职责包括以下内容</p><ul><li>使用适当的 CPU 和编解码器 DAI 填充 struct snd_soc_dai_link 结构体</li><li>物理编解码器时钟设置（如果有的话）和编解码器初始化主/从配置（如果有的话）</li><li>定义 DAPM widget 以路由物理编解码器内部并根据需要完成 DAPM 路径</li><li>根据需要将运行时采样频率传播到各个编解码器驱动程序</li></ul><p>鉴于此，机器类驱动程序的开发可执行以下流程。</p><ul><li>编解码器驱动程序注册组件驱动程序、DAI 驱动程序以及它们的操作函数</li><li>平台驱动程序注册组件驱动程序、PCM 驱动程序、CPU DAI 驱动程序和它们的操作函数，并根据需要设置回放和采集操作</li><li>机器层在编解码器和 CPU 之间创建 DAI 链接并注册声卡和 PCM 设备</li></ul><p>现在我们已经了解了机器类驱动程序的开发流程，接下来从步骤 (1) 开始展开叙述，这包括填充 DAI 链接。</p><h2 id="dai-链接">DAI 链接</h2><p>DAI 链接是 CPU 和编解码器 DAI 之间链接的逻辑表示。它在 Kemmel 中使用 struct snd_soc_dai_link 表示，其定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> {</span></span><br><span class="line"><span class="comment">/* config - must be set by machine driver */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* Codec name */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *stream_name;<span class="comment">/* Stream name */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * You MAY specify the link's CPU-side device, either by device name,</span></span><br><span class="line"><span class="comment"> * or by DT/OF node, but not both. If this information is omitted,</span></span><br><span class="line"><span class="comment"> * the CPU-side DAI is matched using .cpu_dai_name only, which hence</span></span><br><span class="line"><span class="comment"> * must be globally unique. These fields are currently typically used</span></span><br><span class="line"><span class="comment"> * only for codec to codec links, or systems using device tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * You MAY specify the DAI name of the CPU DAI. If this information is</span></span><br><span class="line"><span class="comment"> * omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node</span></span><br><span class="line"><span class="comment"> * only, which only works well when that device exposes a single DAI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">cpus</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_cpus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * You MUST specify the link's codec, either by device name, or by</span></span><br><span class="line"><span class="comment"> * DT/OF node, but not both.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* You MUST specify the DAI name within the codec */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_codecs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * You MAY specify the link's platform/PCM/DMA driver, either by</span></span><br><span class="line"><span class="comment"> * device name, or by DT/OF node, but not both. Some forms of link</span></span><br><span class="line"><span class="comment"> * do not need a platform. In such case, platforms are not mandatory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">platforms</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_platforms;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;<span class="comment">/* optional ID for machine driver link identification */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_params;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dpcm_trigger</span> <span class="title">trigger</span>[2];</span> <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* codec/machine specific init - e.g. add machine controls */</span></span><br><span class="line"><span class="type">int</span> (*init)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* optional hw_params re-writing for BE and FE sync */</span></span><br><span class="line"><span class="type">int</span> (*be_hw_params_fixup)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd,</span><br><span class="line"><span class="keyword">struct</span> snd_pcm_hw_params *params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* machine stream operations */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark this pcm with non atomic ops */</span></span><br><span class="line"><span class="type">bool</span> nonatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For unidirectional dai links */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> playback_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> capture_only:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep DAI active over suspend */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Symmetry requirements */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not create a PCM for this DAI link (Backend link) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This DAI link can route to other DAI links at runtime (Frontend)*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DPCM capture and Playback support */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DPCM used FE &amp; BE merged format */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dpcm_merged_format:<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* DPCM used FE &amp; BE merged channel */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dpcm_merged_chan:<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* DPCM used FE &amp; BE merged rate */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dpcm_merged_rate:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pmdown_time is ignored at stop */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not create a PCM for this DAI link (Backend link) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ignore:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* DAI link list of the soc card */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span> <span class="comment">/* For topology */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>此链接是在机器驱动程序中设置的。它应该指定 cpu dai、codec dai 和使用的平台。在设置完成之后，DAI 链接将被输送到表示声卡的 struct snd_soc_card。struct snd_soc_dai_link 结构体中的元素解释如下：</p><ul><li>name: 这是任意选择的。它可以是任何内</li><li>codec_dai_name: 这必须与编解码器芯片驱动程序中的 snd_soc_dai_driver.name 字段相匹配。编解码器可能有一个或多个 DAI。开发人员可参考编解码器驱动程序来识别 DAI 名称</li><li>cpu_dai_name: 该名称必须与 CPU DAI 驱动程序中的 snd_soc_dai_driver.name 字段相匹配</li><li>stream_name: 这是该链接的流名称</li><li>init: 这是 DAI 链接初始化回调函数。它通常用于添加与 DAI 链接相关的 widget 或其他类型的一次性设置</li><li>dai_fmt: 这应该使用支持的格式和时钟配置进行设置，同时对于 CPU 和 CODEC DAI 驱动程序来说应该是一致的。稍后将介绍该字段的可能位标志</li><li>ops: 该字段属于 struct snd_soc_ops 类型。它应该与 DAI 链接的机器级 PCM 操作一起设置，包括 startup、hw_params、prepare、trigger、hw_free、shutdown 等。稍后将详细介绍该字段</li><li>codec_name: 如果已经设置，则这应该是编解码器驱动程序的名称，如 platform_driver.driver.name 或 i2c_driver.driver.name</li><li>codec_of_node: 这是与编解码器关联的设备树节点</li><li>cpu_name: 如果已经设置，则这应该是 CPU DAI 驱动程序 CPU 的名称</li><li>cpu_of_node: 这是与 CPU DAI 关联的设备树节</li><li>platform_namme 或 platform_of_node: 这是对提供 DMA 功能的平台节点的名称或 DT 节点引用</li><li>playback_only 和 capture_only: 仅在单向链接的情况下使用，如 SPDIF。如果这是一个仅输出链接（仅回放），则 playback_only 和 capture_only 必须分别设置为 true 和 false。而对于仅输入链接，则应使用相反的值。</li></ul><p>在大多数情况下。cpu_of_node 和。platform_of_node 是相同的，因为 CPU DAI 驱动程序和 DMA PCM 驱动程序是由同一设备实现的。也就是说，你必须通过名称或 of_node 指定链接的编解码器，但不能同时使用两者。你必须对 CPU 和平台执行相同操作。但是，必须至少指定 CPU DAI 名称或 CPU 设备名称/节点之一。</p><h2 id="获取-cpu-和编解码器节点">获取 CPU 和编解码器节点</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sound {</span><br><span class="line">        compatible = <span class="string">"fsl,imx6ul-evk-wm8960"</span>,</span><br><span class="line">                 <span class="string">"fsl,imx-audio-wm8960"</span>;</span><br><span class="line">        model = <span class="string">"wm8960-audio"</span>;</span><br><span class="line">        cpu-dai = &lt;&amp;sai2&gt;;</span><br><span class="line">        audio-codec = &lt;&amp;codec&gt;;</span><br><span class="line">        asrc-controller = &lt;&amp;asrc&gt;;</span><br><span class="line">        codec-master;</span><br><span class="line">        gpr = &lt;&amp;gpr <span class="number">4</span> <span class="number">0x100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        hp-det = &lt;<span class="number">3</span> <span class="number">0</span>&gt;;</span><br><span class="line">        <span class="comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span></span><br><span class="line"><span class="comment">        mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span></span><br><span class="line">        audio-routing =</span><br><span class="line">            <span class="string">"Headphone Jack"</span>, <span class="string">"HP_L"</span>,</span><br><span class="line">            <span class="string">"Headphone Jack"</span>, <span class="string">"HP_R"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_LP"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_LN"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_RP"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_RN"</span>,</span><br><span class="line">            <span class="string">"LINPUT2"</span>, <span class="string">"Mic Jack"</span>,</span><br><span class="line">            <span class="string">"LINPUT3"</span>, <span class="string">"Mic Jack"</span>,</span><br><span class="line">            <span class="string">"RINPUT1"</span>, <span class="string">"Main MIC"</span>,</span><br><span class="line">            <span class="string">"RINPUT2"</span>, <span class="string">"Main MIC"</span>,  </span><br><span class="line">            <span class="string">"Mic Jack"</span>, <span class="string">"MICB"</span>,</span><br><span class="line">            <span class="string">"Main MIC"</span>, <span class="string">"MICB"</span>,</span><br><span class="line">            <span class="string">"CPU-Playback"</span>, <span class="string">"ASRC-Playback"</span>,</span><br><span class="line">            <span class="string">"Playback"</span>, <span class="string">"CPU-Playback"</span>,</span><br><span class="line">            <span class="string">"ASRC-Capture"</span>, <span class="string">"CPU-Capture"</span>,</span><br><span class="line">            <span class="string">"CPU-Capture"</span>, <span class="string">"Capture"</span>;</span><br><span class="line">            status = <span class="string">"okay"</span>;</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure><p>在上述机器节点中可以看到，编解码器和 CPU 分别通过 audio-codec 和 cpu-dai 属性传递，传递的方法是引用它们的 phandle。 只要机器驱动程序是由开发人员自己编写的，那么这些属性名称就不会是标准化的（当然，如果你使用的是 simple-card 机器驱动程序，则又另当别论，因为它需要一些预定义的名称）。在机器驱动程序中，你将看到以下类似内容：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_wm8960_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu_np</span>, *<span class="title">codec_np</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">cpu_pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_priv</span> *<span class="title">priv</span> =</span> &amp;card_priv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">codec_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_wm8960_data</span> *<span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">asrc_pdev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">asrc_np</span>;</span></span><br><span class="line">u32 width;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">priv-&gt;pdev = pdev;</span><br><span class="line"></span><br><span class="line">cpu_np = of_parse_phandle(pdev-&gt;dev.of_node, <span class="string">"cpu-dai"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!cpu_np) {</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">"cpu dai phandle missing or invalid\n"</span>);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">codec_np = of_parse_phandle(pdev-&gt;dev.of_node, <span class="string">"audio-codec"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!codec_np) {</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">"phandle missing or invalid\n"</span>);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">}</span><br><span class="line">    [...]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，上述代码片段使用了 of_parse_phandle() 来获取节点引用。</p><h1 id="machine-路由">Machine 路由</h1><h2 id="编解码器引脚">编解码器引脚</h2><p>编解码器引脚 (codec pin) 可以连接到板卡接口 (board connector)。可用的编解码器引脚在编解码器驱动程序中使用 SND_SOC_DAPM_INPUT 和 SND_SOC_DAPM_OUTPUT 宏定义。可以在编解码器驱动程序中使用 grep 命令搜索这些宏，以找到可用的引脚。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> <span class="title">wm8960_dapm_widgets</span>[] =</span> {</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT1"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT1"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT2"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT2"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT3"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT3"</span>),</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_LP"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_LN"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"HP_L"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"HP_R"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_RP"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_RN"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"OUT3"</span>),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们来看看这些引脚如何连接到板卡。</p><h2 id="板卡接口">板卡接口</h2><p>板卡接口 (board connector) 在机器驱动程序中定义，其位于 struct snd_soc_card 的 struct snd_soc_dapm_widget 部分中。 大多数时候，这些板卡接口是虚拟的。它们只是与编解码器引脚（这是真实的）连接的逻辑表示。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> <span class="title">imx_wm8960_dapm_widgets</span>[] =</span> {</span><br><span class="line">SND_SOC_DAPM_HP(<span class="string">"Headphone Jack"</span>, <span class="literal">NULL</span>),</span><br><span class="line">SND_SOC_DAPM_SPK(<span class="string">"Ext Spk"</span>, <span class="literal">NULL</span>),</span><br><span class="line">SND_SOC_DAPM_MIC(<span class="string">"Mic Jack"</span>, <span class="literal">NULL</span>),</span><br><span class="line">SND_SOC_DAPM_MIC(<span class="string">"Main MIC"</span>, <span class="literal">NULL</span>),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接下来，让我们看看如何将这个接口连接到编解码器引脚。</p><h2 id="机器路由">机器路由</h2><h3 id="设备树路由">设备树路由</h3><p>即前面列出的，这里再列以下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sound {</span><br><span class="line">        compatible = <span class="string">"fsl,imx6ul-evk-wm8960"</span>,</span><br><span class="line">                 <span class="string">"fsl,imx-audio-wm8960"</span>;</span><br><span class="line">        model = <span class="string">"wm8960-audio"</span>;</span><br><span class="line">        cpu-dai = &lt;&amp;sai2&gt;;</span><br><span class="line">        audio-codec = &lt;&amp;codec&gt;;</span><br><span class="line">        asrc-controller = &lt;&amp;asrc&gt;;</span><br><span class="line">        codec-master;</span><br><span class="line">        gpr = &lt;&amp;gpr <span class="number">4</span> <span class="number">0x100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        hp-det = &lt;<span class="number">3</span> <span class="number">0</span>&gt;;</span><br><span class="line">        <span class="comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span></span><br><span class="line"><span class="comment">        mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span></span><br><span class="line">        audio-routing =</span><br><span class="line">            <span class="string">"Headphone Jack"</span>, <span class="string">"HP_L"</span>,</span><br><span class="line">            <span class="string">"Headphone Jack"</span>, <span class="string">"HP_R"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_LP"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_LN"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_RP"</span>,</span><br><span class="line">            <span class="string">"Ext Spk"</span>, <span class="string">"SPK_RN"</span>,</span><br><span class="line">            <span class="string">"LINPUT2"</span>, <span class="string">"Mic Jack"</span>,</span><br><span class="line">            <span class="string">"LINPUT3"</span>, <span class="string">"Mic Jack"</span>,</span><br><span class="line">            <span class="string">"RINPUT1"</span>, <span class="string">"Main MIC"</span>,</span><br><span class="line">            <span class="string">"RINPUT2"</span>, <span class="string">"Main MIC"</span>,  </span><br><span class="line">            <span class="string">"Mic Jack"</span>, <span class="string">"MICB"</span>,</span><br><span class="line">            <span class="string">"Main MIC"</span>, <span class="string">"MICB"</span>,</span><br><span class="line">            <span class="string">"CPU-Playback"</span>, <span class="string">"ASRC-Playback"</span>,</span><br><span class="line">            <span class="string">"Playback"</span>, <span class="string">"CPU-Playback"</span>,</span><br><span class="line">            <span class="string">"ASRC-Capture"</span>, <span class="string">"CPU-Capture"</span>,</span><br><span class="line">            <span class="string">"CPU-Capture"</span>, <span class="string">"Capture"</span>;</span><br><span class="line">            status = <span class="string">"okay"</span>;</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure><p>来自设备树的路由期望以某种格式给出音频映射。也就是说，条目被解析为字符串对，第一个是连接的接收方，第二个是连接的源。大多数情况下，这些连接被具体化为编解码器引脚和板卡接口的映射。源和接收方的有效名称取决于硬件绑定，如下所示。</p><ul><li>编解码器：使用名称定义引脚</li><li>机器：使用名称定义接口或插孔 (jack)</li></ul><h3 id="静态路由">静态路由</h3><p>静态路由包括从机器驱动程序定义一个 DAPM 路由映射并将其直接分配给声卡，当然，使用这种方法也有一个缺点，那就是如果不重新编译内核，就无法更改路由。这里不再做过多说明了。</p><h1 id="时钟与格式注意事项">时钟与格式注意事项</h1><h2 id="时钟和格式设置辅助函数">时钟和格式设置辅助函数</h2><p>ASoC 核心提供了辅助函数来更改这些配置。具体如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_dai_set_fmt</span><span class="params">(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">unsigned</span> <span class="type">int</span> fmt)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_dai_set_pll</span><span class="params">(<span class="keyword">struct</span> snd_soc_dai *dai,</span></span><br><span class="line"><span class="params"><span class="type">int</span> pll_id, <span class="type">int</span> source, <span class="type">unsigned</span> <span class="type">int</span> freq_in, <span class="type">unsigned</span> <span class="type">int</span> freq_out)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_dai_set_sysclk</span><span class="params">(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> clk_id,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> freq, <span class="type">int</span> dir)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_dai_set_clkdiv</span><span class="params">(<span class="keyword">struct</span> snd_soc_dai *dai,</span></span><br><span class="line"><span class="params"><span class="type">int</span> div_id, <span class="type">int</span> div)</span>;</span><br></pre></td></tr></tbody></table></figure><p>在上面的辅助函数列表中，各字段解释如下：</p><ul><li>snd_soc_dai_set_fmt 可为时钟主从关系、音频格式和信号反转等设置 DAI 格式</li><li>snd_soc_dai_set_pll 可配置时钟 PIL</li><li>snd_soc_dai_set_sysckk 可配置时钟源</li><li>snd_soc_dai_set_clkdiv 可配置时钟分频器</li></ul><p>这些辅助函数中的每一个都将在底层 DAI 的驱动程序操作中调用适当的回调函数。例如，使用 CPU DAI 调用 snd_soc_dai_set_fmt() 辅助函数时，将会调用此 CPU DAI 的 dai-&gt;driver-&gt;ops-&gt;set_fmt 回调函数。 接下来，我们将分别介绍可以分配给 DAI 或 dai_link.fommat 字段的格式/标志的实际列表。它可以分为格式、时钟源和时钟分频器 3 类。</p><h3 id="格式">格式</h3><h4 id="时钟主从关系">时钟主从关系</h4><p>与时钟主从关系相关的标志包括以下 3 部分：</p><ul><li>SND_SOC_DAIFMT_CBM_CFM:CPU 是位时钟 (bit clock) 和帧同步 (firamesync) 的从属 (slave)。这也意味着编解码器是两者的主控 (master)</li><li>SND_SOC_DAIFMT_CBS_CFS:CPU 是位时钟和帧同步的主控。这也意味着编解码器是两者的从属</li><li>SND_SOC_DAIFMT_CBM_CFS:CPU 是位时钟的从属和帧同步的主控。这也意味着编解码器是前者的主控和后者的从属</li></ul><h4 id="音频格式">音频格式</h4><p>与音频格式相关的标志包括以下 9 部分</p><ul><li>SND_SOC_DAIFMT_DSP_A: 帧同步为 1 位时钟宽度，1 位延迟</li><li>SND_SOC_DAIFMT_DSP_B: 帧同步为 1 位时钟宽度，0 位延迟。此格式可用于 TDM 协议</li><li>SND_SOC_DAIFMT_I2S: 帧同步为 1 个音频字宽，1 位延迟，I2S 模式</li><li>SND_SOC_DAIEMT_RIGHT_J: 右对齐模式</li><li>SND_SOC_DAIFMT_LEFT_J: 左对齐模式</li><li>SND_SOC_DATFMT_DSP_A: 帧同步为 1 位时钟宽度，1 位延迟</li><li>SND_SOC_DAIFMT_AC97: AC97 模式</li><li>SND_SOC_DAIFMT_PDM: 脉冲密度调制 (pulse density modulation，PDM)</li><li>SND_SOC_DAIFMT_DSP_B: 帧同步为 1 位时钟宽度，1 位延迟</li></ul><h4 id="信号反转">信号反转</h4><p>与信号反转 (signal inversion) 相关的标志包括以下 4 部分：</p><ul><li>SND_SOC_DAIEMT_NB_NF: 正常位时钟 (normal bit clock)，正常帧同步 (nonmal fame sync)。CPU 发送器在位时钟的下降沿移出数据，接收方在上升沿采样数据。CPU 帧同步发生器在帧同步的上升沿启动帧。CPU 侧的 I2S 推荐使用该参数</li><li>SND_SOC_DAIFMT_NB_FF: 正常位时钟，反转帧同步。CPU 发送器在位时钟的下降沿移出数据，接收方在上升沿采样数据。CPU 帧同步发生器在帧同步的下降沿启动帧</li><li>SND_SOC_DAIFMT_IB_NF: 反转位时钟，正常帧同步。CPU 发送器在位时钟的上升沿移出数据，接收方在下降沿采样数据。CPU 帧同步发生器在帧同步的上升沿启动帧</li><li>SND_SOC_DAIEMT_IB_F: 反转位时钟，反转帧同步。CPU 发送器在位时钟的上升沿移出数据，接收方在下降沿采样数据。CPU 帧同步发生器在帧同步的下降沿启动帧。此配置可用于 PCM 模式（如蓝牙或基于调制解调器的音频芯片）</li></ul><h3 id="时钟源">时钟源</h3><p>时钟源可通过 snd_soc_dai_set_sysclk() 辅助函数配置。以下是让 ALSA 知道使用哪个时钟的方向参数。</p><ul><li>SND_SOC_CLOCK_IN: 这意味着将内部时钟用于系统时钟</li><li>SND_SOC_CLOCK_OUT: 这意味着将外部时钟用于系统时钟</li></ul><h3 id="时钟分频器">时钟分频器</h3><p>时钟分频器：(clock divider) 可以通过 snd_soc_dai_set_clkdiv() 辅助函数配置</p><h1 id="machine-初始化流程">Machine 初始化流程</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkMzQyMjYwMTM0NTQ0MmQ3OTI3Mzg0">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/Machine_Init.png"></p><h1 id="参考文献">参考文献</h1><p>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（四）Platform 驱动</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAPlatformDriver/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAPlatformDriver/</url>
      
        <content type="html"><![CDATA[<p>平台驱动程序可以注册 PCM 驱动程序、CPU DAI 驱动程序及其操作函数，为 PCM 组件预分配缓冲区，并根据需要设置回放和采集操作。换言之，平台驱动程序包含该平台的音频引擎和音频接口驱动程序（如 I2S、AC97 和 PCM）。</p><p>平台驱动程序以构成平台的 SoC 为目标。它涉及平台的 DMA（即音频数据在 SoC 中的每个块之间如何传输）和 CPU DAI（即 CPU 向编解码器发送音频数据的路径或 CPU 从编解码器获得音频数据的路径）。</p><p>平台驱动程序有两个重要的数据结构体：structsnd_soc_component_driver 和 structsnd_soc_dai_driver。前者负责 DMA 数据管理，后者负责 DAI 的参数配置。当然，前文在讨论编解码器类驱动程序时已经描述过这两种数据结构体，因此，本节将仅介绍与平台代码相关的附加概念。</p><span id="more"></span><h1 id="cpu-dai-驱动程序">CPU DAI 驱动程序</h1><p>在平台侧，大部分工作都可以由 core 完成，尤其是与 DMA 相关的工作。因此，CPU DAI 驱动程序通常只提供组件驱动程序结构中的接口名称，而让 core 完成其余的工作。以下是 STM SPDIF 驱动程序的示例，它在<code>sound/soc/stm/stm32_spdif.c</code>中实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">stm32_spdifrx_pcm_dai_ops</span> =</span> {</span><br><span class="line">.startup= stm32_spdifrx_startup,</span><br><span class="line">.hw_params= stm32_spdifrx_hw_params,</span><br><span class="line">.trigger= stm32_spdifrx_trigger,</span><br><span class="line">.shutdown= stm32_spdifrx_shutdown,</span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">stm32_spdifrx_dai</span>[] =</span> {</span><br><span class="line">{</span><br><span class="line">.probe = stm32_spdifrx_dai_probe,</span><br><span class="line">.capture = {</span><br><span class="line">.stream_name = <span class="string">"CPU-Capture"</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">2</span>,</span><br><span class="line">.rates = SNDRV_PCM_RATE_8000_192000,</span><br><span class="line">.formats = SNDRV_PCM_FMTBIT_S32_LE |</span><br><span class="line">   SNDRV_PCM_FMTBIT_S16_LE,</span><br><span class="line">},</span><br><span class="line">.ops = &amp;stm32_spdifrx_pcm_dai_ops,</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> <span class="title">stm32_spdifrx_component</span> =</span> {</span><br><span class="line">.name = <span class="string">"stm32-spdifrx"</span>,</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stm32_spdifrx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    ret = snd_dmaengine_pcm_register(&amp;pdev-&gt;dev, pcm_config, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) {</span><br><span class="line"><span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">"PCM DMA register error %d\n"</span>, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line">ret = snd_soc_register_component(&amp;pdev-&gt;dev,</span><br><span class="line"> &amp;stm32_spdifrx_component,</span><br><span class="line"> stm32_spdifrx_dai,</span><br><span class="line"> ARRAY_SIZE(stm32_spdifrx_dai));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中 snd_soc_component_driver 只提供了 name 信息，件驱动程序和 DAI 驱动程序都和往常一样通过 snd_soc_register_component() 注册。 struct snd_soc_dai_driver 必须根据实际的 DAI 属性设置，如果需要，应该设置 dai_ops。当然，该设置的很大一部分是由 snd_dmaengine_pcm_register() 完成的，它将根据提供的设置组件驱动程序的 PCM 操作。</p><h1 id="platform-dma-驱动程序">Platform DMA 驱动程序</h1><p>在声音生态系统中，我们有多种类型的设备：PCM、MIDI、混音器、音序器、计时器等。这里的 PCM 指的是脉冲编码调制（pulse code modulation），即对连续变化的模拟信号进行采样、量化和编码以产生数字信号。但要注意，这里它是指处理基于采样的数字音频的设备，而不是 MIDI 等。PCM 层（ALSA 核心的一部分）负责完成所有数字音频工作，例如，准备板卡以进行采集或回放、启动与设备之间的传输等。简而言之，如果你想回放或采集声音，那么你就需要一个 PCM 设备。</p><p>PCM 驱动程序通过覆盖由 struct snd_pcm_ops 结构体公开的函数指针来帮助执行 DMA 操作。它与平台无关，仅与 SOC DMA 引擎上游 API 交互。然后，DMA 引擎与特定于平台的 DMA 驱动程序交互以获得正确的 DMA 设置。struct snd_pcm_ops 是一个包含一组回调函数的结构体，这些回调函数与有关 PCM 接口的不同事件相关。在处理 ASoC（不是纯粹的 ALSA）时，只要你使用通用 PCM DMA 引擎框架，就永远不需要按原样实例化此结构体。核心会为你完成这项工作。</p><h1 id="音频-dma-接口">音频 DMA 接口</h1><p>音频 DMA 驱动程序通过 snd_dmaengine_pcm_register() 注册。此函数可以为设备注册一个 struct snd_dmaengine_pcm_config。下面是它的原型：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_dmaengine_pcm_register - Register a dmaengine based PCM device</span></span><br><span class="line"><span class="comment"> * @dev: The parent device for the PCM device</span></span><br><span class="line"><span class="comment"> * @config: Platform specific PCM configuration</span></span><br><span class="line"><span class="comment"> * @flags: Platform specific quirks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snd_dmaengine_pcm_register</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> snd_dmaengine_pcm_config *config, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>dev 是 PCM 设备的父设备，通常是&amp;pdev-&gt;dev<br></li><li>config 是特定于平台的 PCM 配置，其类型为 struct snd_dmaengine_pcm_config。下文将详细介绍这个结构体<br></li><li><p>flags 表示描述如何处理 DMA 通道的附加标志。大多数情况下，它取值为 0。但是，其可能的值已在 include/sound/dmaengine_pcm.h 中定义并且均以 SND_DMAENGINE_为前缀。经常使用的标志包括以下 3 个</p><ul><li>SND_DMAENGINE_PCM_FLAG_COMPAT /* 表示将使用自定义回调函数来请求通道 */</li><li>SND_DMAENGINE_PCM_FLAG_NO_DT /* 要求核心不要尝试通过设备树（DT）请求 DMA 通道 */</li><li>SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX /* 示 PCM 是半双工（half-duplex）的，DMA 通道在采集和回放之间共享 */</li></ul></li></ul><p>在注册之后，通用 PCM DMA 引擎框架将构建合适的 snd_pcm_ops 并设置组件驱动程序的。ops 字段。</p><p>Linux 中经典的 DMA 操作流程如下：</p><ul><li>dma_request_channel: 用于分配 slave 通道（slave channel）</li><li>dmaengine_slave_config: 设置与 slave 通道和控制器相关参数</li><li>dma_prep_xxx: 获取事务的描述符</li><li>dma_cookie = dmaengine_submit(tx): 提交事务并抓取 DMA cookie</li><li>dma_async_issue_pending(chan): 开始传输并等待回调函数通知</li></ul><p>在 ASOC 中，设备树用于将 DMA 通道映射到 PCM 设备。 snd_dmaengine_pcm_register（）可以通过 dmaengine_pcm_request_chan_of（）请求 DMA 通道，为了执行上述前 3 个步骤，需要为 PCM DMA 引擎核心提供附加信息，可以通过填充 struct snd_dmaengine_pcm_config 来完成。后两步由 PCM DMA 引擎核心透明处理。</p><p>struct snd_dmaengine_pcm_config 结构体如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_dmaengine_pcm_config</span> {</span></span><br><span class="line"><span class="type">int</span> (*prepare_slave_config)(<span class="keyword">struct</span> snd_pcm_substream *substream,</span><br><span class="line"><span class="keyword">struct</span> snd_pcm_hw_params *params,</span><br><span class="line"><span class="keyword">struct</span> dma_slave_config *slave_config);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> *(*<span class="title">compat_request_channel</span>)(</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_runtime</span> *<span class="title">rtd</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>);</span></span><br><span class="line"><span class="type">int</span> (*process)(<span class="keyword">struct</span> snd_pcm_substream *substream,</span><br><span class="line">       <span class="type">int</span> channel, <span class="type">unsigned</span> <span class="type">long</span> hwoff,</span><br><span class="line">       <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> bytes);</span><br><span class="line">dma_filter_fn compat_filter_fn;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dma_dev</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *chan_names[SNDRV_PCM_STREAM_LAST + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hardware</span> *<span class="title">pcm_hardware</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> prealloc_buffer_size;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>该结构体主要处理 DMA 通道管理、缓冲区管理和通道配置，具体参数如下：</p><ul><li>prepare_slave_config: 用于为 PCM 子流填充 DMA slave_config。它将从 PCM 驱动程序的 hwparams 回调函数中调用。</li><li>compat_request_channel：用于为不使用设备树的 platform 请求 DMA channel。如果设置了它，则。compat_filter_fn 将被忽略</li><li>compat_filter_fn：当为不使用设备树的 platform 请求 DMA 通道时，它发挥过滤功能，过滤的参数将是 DAI 的 DMA 数据</li><li>dma_dev：允许为注册 PCM 驱动程序的设备以外的设备请求 DMA 通道，如果设置了它，则将在此设备而不是 DAI 设备上请求 DMA 通道</li><li>chan_names：这是请求采集/回放 DMA 通道时使用的名称数组，如果设备有多个通道，则每个通道具有不同的 DMA 通道名称</li><li>pcm_hardware：描述了 PCM 硬件功能</li><li>prealloc_buffer_size：表示预分配音频缓冲区的大小</li></ul><p>PCM DMA 配置可能不会提供注册 API（可能是 NULL），在这种情况下你应该通过 snd_soc_dai_init_dma_data（）提供采集和回放 DAI DMA 通道配置。通过这种方法，其他元素将从系统核心派生。</p><h1 id="流程梳理">流程梳理</h1><p>数据流程框图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/ASOC_Playback_Stream.png"></p><p>可以看到，音频数据从用户复制到 DMA 缓冲区，然后，DMA 事务将数据移动到平台音频 TxFIF, 由于它与编解码器的链接（通过它们各自的 DAI), 这些数据将被发送到编解码器，以通过扬声器回放音频。采集操作流则相反，只是扬声器被麦克风取代。</p><p>相关函数流程如下： <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkMmViMDIyOGJmMWQwMGQwOGM3NzVm">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/stm32_i2s_probe.png"></p><h1 id="参考文献">参考文献</h1><p>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（三）编解码器类驱动实例</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAEncClassInstance/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAEncClassInstance/</url>
      
        <content type="html"><![CDATA[<p>这里以 Wolfson 公司的编解码芯片 WM8960 为例来说明上篇介绍的相关内容。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/wm8960_framework.png"></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/wm8960_mixer_list.png"></p><span id="more"></span><h1 id="定义-widget-所需的-dapm-kcontrol">定义 widget 所需的 DAPM Kcontrol</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">wm8960_loutput_mixer</span>[] =</span> {</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"PCM Playback Switch"</span>, WM8960_LOUTMIX, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"LINPUT3 Switch"</span>, WM8960_LOUTMIX, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"Boost Bypass Switch"</span>, WM8960_BYPASS1, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">wm8960_routput_mixer</span>[] =</span> {</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"PCM Playback Switch"</span>, WM8960_ROUTMIX, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"RINPUT3 Switch"</span>, WM8960_ROUTMIX, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"Boost Bypass Switch"</span>, WM8960_BYPASS2, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">wm8960_mono_out</span>[] =</span> {</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"Left Switch"</span>, WM8960_MONOMIX1, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    SOC_DAPM_SINGLE(<span class="string">"Right Switch"</span>, WM8960_MONOMIX2, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在上述代码中定义了左右输出通道的混音器控件，以及单声道输出混音器：wm8960_loutput_mixer、wm8960_routput_mixer、wm8960_mono_out。</p><h1 id="定义真实的-widget包括-damp-控件">定义真实的 widget，包括 DAMP 控件</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> <span class="title">wm8960_dapm_widgets</span>[] =</span> {</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT1"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT1"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT2"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT2"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"LINPUT3"</span>),</span><br><span class="line">    SND_SOC_DAPM_INPUT(<span class="string">"RINPUT3"</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_SUPPLY(<span class="string">"MICB"</span>, WM8960_POWER1, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Left Boost Mixer"</span>, WM8960_POWER1, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line">       wm8960_lin_boost, ARRAY_SIZE(wm8960_lin_boost)),</span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Right Boost Mixer"</span>, WM8960_POWER1, <span class="number">4</span>, <span class="number">0</span>,</span><br><span class="line">       wm8960_rin_boost, ARRAY_SIZE(wm8960_rin_boost)),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Left Input Mixer"</span>, WM8960_POWER3, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line">       wm8960_lin, ARRAY_SIZE(wm8960_lin)),</span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Right Input Mixer"</span>, WM8960_POWER3, <span class="number">4</span>, <span class="number">0</span>,</span><br><span class="line">       wm8960_rin, ARRAY_SIZE(wm8960_rin)),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_ADC(<span class="string">"Left ADC"</span>, <span class="string">"Capture"</span>, WM8960_POWER1, <span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">    SND_SOC_DAPM_ADC(<span class="string">"Right ADC"</span>, <span class="string">"Capture"</span>, WM8960_POWER1, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_DAC(<span class="string">"Left DAC"</span>, <span class="string">"Playback"</span>, WM8960_POWER2, <span class="number">8</span>, <span class="number">0</span>),</span><br><span class="line">    SND_SOC_DAPM_DAC(<span class="string">"Right DAC"</span>, <span class="string">"Playback"</span>, WM8960_POWER2, <span class="number">7</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Left Output Mixer"</span>, WM8960_POWER3, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">    &amp;wm8960_loutput_mixer[<span class="number">0</span>],</span><br><span class="line">    ARRAY_SIZE(wm8960_loutput_mixer)),</span><br><span class="line">    SND_SOC_DAPM_MIXER(<span class="string">"Right Output Mixer"</span>, WM8960_POWER3, <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">    &amp;wm8960_routput_mixer[<span class="number">0</span>],</span><br><span class="line">    ARRAY_SIZE(wm8960_routput_mixer)),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"LOUT1 PGA"</span>, WM8960_POWER2, <span class="number">6</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"ROUT1 PGA"</span>, WM8960_POWER2, <span class="number">5</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"Left Speaker PGA"</span>, WM8960_POWER2, <span class="number">4</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"Right Speaker PGA"</span>, WM8960_POWER2, <span class="number">3</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"Right Speaker Output"</span>, WM8960_CLASSD1, <span class="number">7</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line">    SND_SOC_DAPM_PGA(<span class="string">"Left Speaker Output"</span>, WM8960_CLASSD1, <span class="number">6</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_LP"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_LN"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"HP_L"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"HP_R"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_RP"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"SPK_RN"</span>),</span><br><span class="line">    SND_SOC_DAPM_OUTPUT(<span class="string">"OUT3"</span>),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在这一步中为左右声道选择器定义了一个 MUX widget，他们是 Left Output Mixer、Right Output Mixer 和 Mono Output Mixer。 我们还为每个扬声器定义了一个混音器 widget：SPK_LP、SPK_LN、HP_L、HP_R、SPK_RP、SPK_RN、OUT3。具体的混音器控制由 wm8960_loutput_mixer、wm8960_routput_mixer、wm8960_mono_out 来完成，这三个 widget 都具有 power 属性，因此，当这些 widget 中的一个或多个位于一个有效的音频路径时，DAPM 框架可以通过其各自的寄存器的第 7 和第 8 位来控制电源状态。</p><h1 id="定义-widget-的连接路径">定义 widget 的连接路径</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> <span class="title">audio_paths</span>[] =</span> {</span><br><span class="line">{ <span class="string">"Left Boost Mixer"</span>, <span class="string">"LINPUT1 Switch"</span>, <span class="string">"LINPUT1"</span> },</span><br><span class="line">{ <span class="string">"Left Boost Mixer"</span>, <span class="string">"LINPUT2 Switch"</span>, <span class="string">"LINPUT2"</span> },</span><br><span class="line">{ <span class="string">"Left Boost Mixer"</span>, <span class="string">"LINPUT3 Switch"</span>, <span class="string">"LINPUT3"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Left Input Mixer"</span>, <span class="string">"Boost Switch"</span>, <span class="string">"Left Boost Mixer"</span> },</span><br><span class="line">{ <span class="string">"Left Input Mixer"</span>, <span class="string">"Boost Switch"</span>, <span class="string">"LINPUT1"</span> },  <span class="comment">/* Really Boost Switch */</span></span><br><span class="line">{ <span class="string">"Left Input Mixer"</span>, <span class="literal">NULL</span>, <span class="string">"LINPUT2"</span> },</span><br><span class="line">{ <span class="string">"Left Input Mixer"</span>, <span class="literal">NULL</span>, <span class="string">"LINPUT3"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Right Boost Mixer"</span>, <span class="string">"RINPUT1 Switch"</span>, <span class="string">"RINPUT1"</span> },</span><br><span class="line">{ <span class="string">"Right Boost Mixer"</span>, <span class="string">"RINPUT2 Switch"</span>, <span class="string">"RINPUT2"</span> },</span><br><span class="line">{ <span class="string">"Right Boost Mixer"</span>, <span class="string">"RINPUT3 Switch"</span>, <span class="string">"RINPUT3"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Right Input Mixer"</span>, <span class="string">"Boost Switch"</span>, <span class="string">"Right Boost Mixer"</span> },</span><br><span class="line">{ <span class="string">"Right Input Mixer"</span>, <span class="string">"Boost Switch"</span>, <span class="string">"RINPUT1"</span> },  <span class="comment">/* Really Boost Switch */</span></span><br><span class="line">{ <span class="string">"Right Input Mixer"</span>, <span class="literal">NULL</span>, <span class="string">"RINPUT2"</span> },</span><br><span class="line">{ <span class="string">"Right Input Mixer"</span>, <span class="literal">NULL</span>, <span class="string">"RINPUT3"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Left ADC"</span>, <span class="literal">NULL</span>, <span class="string">"Left Input Mixer"</span> },</span><br><span class="line">{ <span class="string">"Right ADC"</span>, <span class="literal">NULL</span>, <span class="string">"Right Input Mixer"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Left Output Mixer"</span>, <span class="string">"LINPUT3 Switch"</span>, <span class="string">"LINPUT3"</span> },</span><br><span class="line">{ <span class="string">"Left Output Mixer"</span>, <span class="string">"Boost Bypass Switch"</span>, <span class="string">"Left Boost Mixer"</span> },</span><br><span class="line">{ <span class="string">"Left Output Mixer"</span>, <span class="string">"PCM Playback Switch"</span>, <span class="string">"Left DAC"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Right Output Mixer"</span>, <span class="string">"RINPUT3 Switch"</span>, <span class="string">"RINPUT3"</span> },</span><br><span class="line">{ <span class="string">"Right Output Mixer"</span>, <span class="string">"Boost Bypass Switch"</span>, <span class="string">"Right Boost Mixer"</span> },</span><br><span class="line">{ <span class="string">"Right Output Mixer"</span>, <span class="string">"PCM Playback Switch"</span>, <span class="string">"Right DAC"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"LOUT1 PGA"</span>, <span class="literal">NULL</span>, <span class="string">"Left Output Mixer"</span> },</span><br><span class="line">{ <span class="string">"ROUT1 PGA"</span>, <span class="literal">NULL</span>, <span class="string">"Right Output Mixer"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"HP_L"</span>, <span class="literal">NULL</span>, <span class="string">"LOUT1 PGA"</span> },</span><br><span class="line">{ <span class="string">"HP_R"</span>, <span class="literal">NULL</span>, <span class="string">"ROUT1 PGA"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Left Speaker PGA"</span>, <span class="literal">NULL</span>, <span class="string">"Left Output Mixer"</span> },</span><br><span class="line">{ <span class="string">"Right Speaker PGA"</span>, <span class="literal">NULL</span>, <span class="string">"Right Output Mixer"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"Left Speaker Output"</span>, <span class="literal">NULL</span>, <span class="string">"Left Speaker PGA"</span> },</span><br><span class="line">{ <span class="string">"Right Speaker Output"</span>, <span class="literal">NULL</span>, <span class="string">"Right Speaker PGA"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"SPK_LN"</span>, <span class="literal">NULL</span>, <span class="string">"Left Speaker Output"</span> },</span><br><span class="line">{ <span class="string">"SPK_LP"</span>, <span class="literal">NULL</span>, <span class="string">"Left Speaker Output"</span> },</span><br><span class="line">{ <span class="string">"SPK_RN"</span>, <span class="literal">NULL</span>, <span class="string">"Right Speaker Output"</span> },</span><br><span class="line">{ <span class="string">"SPK_RP"</span>, <span class="literal">NULL</span>, <span class="string">"Right Speaker Output"</span> },</span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> <span class="title">audio_paths_out3</span>[] =</span> {</span><br><span class="line">{ <span class="string">"Mono Output Mixer"</span>, <span class="string">"Left Switch"</span>, <span class="string">"Left Output Mixer"</span> },</span><br><span class="line">{ <span class="string">"Mono Output Mixer"</span>, <span class="string">"Right Switch"</span>, <span class="string">"Right Output Mixer"</span> },</span><br><span class="line"></span><br><span class="line">{ <span class="string">"OUT3"</span>, <span class="literal">NULL</span>, <span class="string">"Mono Output Mixer"</span>, }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>通过这一步的定义我们知道 Left output Mux 和 Right output Mux 有三个输入引脚，分别是 Boost Bypass Switch、LINPUT3 Switch、PCM Playback Switch。Mono Output Mixer 只有两个输入引脚，Left Switch、Right Switch，所以，上述定义的含义如下：</p><ul><li>Left Boost Mixer 通过 Boost Bypass Switch 连接到 Left Output Mixer</li><li>Left DAC 通过 PCM Playback Switch 连接到 Left Output Mixer</li><li>LINPUT3 通过 LINPUT3 Switch 连接到 Left Output Mixer</li><li>Left Output Mixer 连接到 LOUT1 PGA，但是此链接没有开关控制</li><li>Right xxx 同理这里不一一列举出来了</li></ul><h1 id="在编解码器驱动程序的-probe-回调函数中注册-widget-和路径">在编解码器驱动程序的 probe 回调函数中注册 widget 和路径</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">wm8960_add_widgets</span><span class="params">(<span class="keyword">struct</span> snd_soc_component *component)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wm8960_priv</span> *<span class="title">wm8960</span> =</span> snd_soc_component_get_drvdata(component);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wm8960_data</span> *<span class="title">pdata</span> =</span> &amp;wm8960-&gt;pdata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span> =</span> snd_soc_component_get_dapm(component);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"></span><br><span class="line">snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets,</span><br><span class="line">  ARRAY_SIZE(wm8960_dapm_widgets));</span><br><span class="line"></span><br><span class="line">snd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In capless mode OUT3 is used to provide VMID for the</span></span><br><span class="line"><span class="comment"> * headphone outputs, otherwise it is used as a mono mixer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pdata &amp;&amp; pdata-&gt;capless) {</span><br><span class="line">snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_capless,</span><br><span class="line">  ARRAY_SIZE(wm8960_dapm_widgets_capless));</span><br><span class="line"></span><br><span class="line">snd_soc_dapm_add_routes(dapm, audio_paths_capless,</span><br><span class="line">ARRAY_SIZE(audio_paths_capless));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">snd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_out3,</span><br><span class="line">  ARRAY_SIZE(wm8960_dapm_widgets_out3));</span><br><span class="line"></span><br><span class="line">snd_soc_dapm_add_routes(dapm, audio_paths_out3,</span><br><span class="line">ARRAY_SIZE(audio_paths_out3));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to power up the headphone output stage out of</span></span><br><span class="line"><span class="comment"> * sequence for capless mode.  To save scanning the widget</span></span><br><span class="line"><span class="comment"> * list each time to find the desired power state do so now</span></span><br><span class="line"><span class="comment"> * and save the result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_for_each_entry(w, &amp;component-&gt;card-&gt;widgets, <span class="built_in">list</span>) {</span><br><span class="line"><span class="keyword">if</span> (w-&gt;dapm != dapm)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(w-&gt;name, <span class="string">"LOUT1 PGA"</span>) == <span class="number">0</span>)</span><br><span class="line">wm8960-&gt;lout1 = w;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(w-&gt;name, <span class="string">"ROUT1 PGA"</span>) == <span class="number">0</span>)</span><br><span class="line">wm8960-&gt;rout1 = w;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(w-&gt;name, <span class="string">"OUT3 VMID"</span>) == <span class="number">0</span>)</span><br><span class="line">wm8960-&gt;out3 = w;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">wm8960_probe</span><span class="params">(<span class="keyword">struct</span> snd_soc_component *component)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">wm8960_add_widgets(component);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 machine 驱动程序 probe 到这个编解码时，就会调用编解码器组件的 probe 回调函数 wm8960_probe，以完成编解码器驱动程序的初始化。编解码器需要绑定到 platform 驱动程序才能发挥作用，这是后面要介绍的内容。</p><h1 id="流程">流程</h1><p>由于函数调用栈很深，没有办法一一列出，这里通过一个思维导图来将各函数调用关系列出来，感兴趣的读者可以自行阅读源码。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkMmI2MjQ5MmU0OWMzYWI1OWFlYjcx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/wm8960_i2c_probe.png"></p><h1 id="参考文献">参考文献</h1><p>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（二）编解码器类驱动相关概念</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSAEncClass/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSAEncClass/</url>
      
        <content type="html"><![CDATA[<p>编解码器类驱动程序是最基本的，他实现的代码应该利用编解码器设备并公开其硬件属性，以便 amixer 等用户空间工具可以使用它。</p><p>由于驱动程序针对特定的编解码器，因此它应该包含音频控制、音频接口功能、编解码器 DAPM 定义和 I/O 功能，每个编解码器必须满足：</p><ul><li>通过定义 DAI 和 PCM 配置来提供与其他模块的接口</li><li>提供编解码器控制 I/O hook（使用 I2C、SPI 的 API）</li><li>根据用户空间的需要，公开其他内核控件（Kernel control，Kcontrol）以动态控制模块行为</li><li>定义 DAPM widget，为动态电源切换建立 DAPM 路由，并提供 DAC 数字静音控制（option）</li></ul><span id="more"></span><h1 id="component">Component</h1><p>包含编解码器的路由、widget、控件金额一组编解码器相关函数回调指针，以及一个或多个 dai 驱动。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* component interface */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_component_driver</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Default control and setup, added after probe() is run */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">controls</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_controls;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">dapm_widgets</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_dapm_widgets;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> *<span class="title">dapm_routes</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_dapm_routes;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*probe)(<span class="keyword">struct</span> snd_soc_component *component);</span><br><span class="line"><span class="type">void</span> (*remove)(<span class="keyword">struct</span> snd_soc_component *component);</span><br><span class="line"><span class="type">int</span> (*suspend)(<span class="keyword">struct</span> snd_soc_component *component);</span><br><span class="line"><span class="type">int</span> (*resume)(<span class="keyword">struct</span> snd_soc_component *component);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*read)</span><span class="params">(<span class="keyword">struct</span> snd_soc_component *component,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">int</span> reg)</span>;</span><br><span class="line"><span class="type">int</span> (*write)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pcm creation and destruction */</span></span><br><span class="line"><span class="type">int</span> (*pcm_new)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd);</span><br><span class="line"><span class="type">void</span> (*pcm_free)(<span class="keyword">struct</span> snd_pcm *pcm);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* component wide operations */</span></span><br><span class="line"><span class="type">int</span> (*set_sysclk)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line">  <span class="type">int</span> clk_id, <span class="type">int</span> source, <span class="type">unsigned</span> <span class="type">int</span> freq, <span class="type">int</span> dir);</span><br><span class="line"><span class="type">int</span> (*set_pll)(<span class="keyword">struct</span> snd_soc_component *component, <span class="type">int</span> pll_id,</span><br><span class="line">       <span class="type">int</span> source, <span class="type">unsigned</span> <span class="type">int</span> freq_in, <span class="type">unsigned</span> <span class="type">int</span> freq_out);</span><br><span class="line"><span class="type">int</span> (*set_jack)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_jack *jack,  <span class="type">void</span> *data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DT */</span></span><br><span class="line"><span class="type">int</span> (*of_xlate_dai_name)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line"> <span class="keyword">struct</span> of_phandle_args *args,</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> **dai_name);</span><br><span class="line"><span class="type">int</span> (*of_xlate_dai_id)(<span class="keyword">struct</span> snd_soc_component *comment,</span><br><span class="line">       <span class="keyword">struct</span> device_node *endpoint);</span><br><span class="line"><span class="type">void</span> (*seq_notifier)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line">     <span class="keyword">enum</span> snd_soc_dapm_type type, <span class="type">int</span> subseq);</span><br><span class="line"><span class="type">int</span> (*stream_event)(<span class="keyword">struct</span> snd_soc_component *component, <span class="type">int</span> event);</span><br><span class="line"><span class="type">int</span> (*set_bias_level)(<span class="keyword">struct</span> snd_soc_component *component,</span><br><span class="line">      <span class="keyword">enum</span> snd_soc_bias_level level);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line"><span class="type">int</span> probe_order;</span><br><span class="line"><span class="type">int</span> remove_order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * signal if the module handling the component should not be removed</span></span><br><span class="line"><span class="comment"> * if a pcm is open. Setting this would prevent the module</span></span><br><span class="line"><span class="comment"> * refcount being incremented in probe() but allow it be incremented</span></span><br><span class="line"><span class="comment"> * when a pcm is opened and decremented when it is closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> module_get_upon_open:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bits */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idle_bias_on:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> suspend_bias_off:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> use_pmdown_time:<span class="number">1</span>; <span class="comment">/* care pmdown_time at stop */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> endianness:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> non_legacy_dai_naming:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this component uses topology and ignore machine driver FEs */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ignore_machine;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *topology_name_prefix;</span><br><span class="line"><span class="type">int</span> (*be_hw_params_fixup)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd,</span><br><span class="line">  <span class="keyword">struct</span> snd_pcm_hw_params *params);</span><br><span class="line"><span class="type">bool</span> use_dai_pcm_id;<span class="comment">/* use DAI link PCM ID as PCM device number */</span></span><br><span class="line"><span class="type">int</span> be_pcm_base;<span class="comment">/* base device ID for all BE PCMs */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>name: 此组件的名称对于编解码器和 platform 来说都是必须的，platform 可能不需要其他字段</li><li>probe：组件驱动 probe 函数，组件 probe 函数，当组件驱动被 mechine 驱动 probe 到时（实际上是当 machine 驱动向 ASOC core 注册一个由该组件组成的 card 时）执行，必要时完成组件初始化</li><li>control：控制接口指针，如控制音量，通道选择等，主要用于编解码器</li><li>set_pll: 设置锁相环的函数指针</li><li>read：读取编解码器寄存器的函数</li><li>write：写入编解码器寄存器的函数</li><li>dapm_widget: dapm 的 widget 指针</li><li>dapm_routes: dapm 路由指针</li><li>ops： platform DMA 相关回调</li></ul><p>此结构体同时抽象编解码器和 Platform 机器 DAI 驱动程序</p><h1 id="dai">DAI</h1><p>编解码驱动程序包括编解码设备本身和 DAI 组件，他们在与 platform 绑定时使用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> {</span></span><br><span class="line"><span class="comment">/* DAI description */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> base;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DAI driver callbacks */</span></span><br><span class="line"><span class="type">int</span> (*probe)(<span class="keyword">struct</span> snd_soc_dai *dai);</span><br><span class="line"><span class="type">int</span> (*remove)(<span class="keyword">struct</span> snd_soc_dai *dai);</span><br><span class="line"><span class="type">int</span> (*suspend)(<span class="keyword">struct</span> snd_soc_dai *dai);</span><br><span class="line"><span class="type">int</span> (*resume)(<span class="keyword">struct</span> snd_soc_dai *dai);</span><br><span class="line"><span class="comment">/* compress dai */</span></span><br><span class="line"><span class="type">int</span> (*compress_new)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd, <span class="type">int</span> num);</span><br><span class="line"><span class="comment">/* Optional Callback used at pcm creation*/</span></span><br><span class="line"><span class="type">int</span> (*pcm_new)(<span class="keyword">struct</span> snd_soc_pcm_runtime *rtd,</span><br><span class="line">       <span class="keyword">struct</span> snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ops */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_cdai_ops</span> *<span class="title">cops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DAI capabilities */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bus_control:<span class="number">1</span>; <span class="comment">/* DAI is also used for the control bus */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line"><span class="type">int</span> probe_order;</span><br><span class="line"><span class="type">int</span> remove_order;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>name: DAI 接口名称</li><li>probe：dai probe 函数，当 machine 驱动程序 probe 到该 dai 驱动程序所属的组件驱动程序时（实际是 machine 驱动程序向 ASOC core 注册 card 时）执行</li><li>ops：提供用于配置和控制 DAI 的回调函数</li><li>capture：它表示音频采集的硬件参数，包括通道数、rate、format 等</li><li>playback：它表示音频回放的硬件参数，包括通道数、rate、format 等</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> {</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*set_sysclk)(<span class="keyword">struct</span> snd_soc_dai *dai,</span><br><span class="line"><span class="type">int</span> clk_id, <span class="type">unsigned</span> <span class="type">int</span> freq, <span class="type">int</span> dir);</span><br><span class="line"><span class="type">int</span> (*set_pll)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> pll_id, <span class="type">int</span> source,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> freq_in, <span class="type">unsigned</span> <span class="type">int</span> freq_out);</span><br><span class="line"><span class="type">int</span> (*set_clkdiv)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> div_id, <span class="type">int</span> div);</span><br><span class="line"><span class="type">int</span> (*set_bclk_ratio)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">unsigned</span> <span class="type">int</span> ratio);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI format configuration</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*set_fmt)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">unsigned</span> <span class="type">int</span> fmt);</span><br><span class="line"><span class="type">int</span> (*xlate_tdm_slot_mask)(<span class="type">unsigned</span> <span class="type">int</span> slots,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *tx_mask, <span class="type">unsigned</span> <span class="type">int</span> *rx_mask);</span><br><span class="line"><span class="type">int</span> (*set_tdm_slot)(<span class="keyword">struct</span> snd_soc_dai *dai,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tx_mask, <span class="type">unsigned</span> <span class="type">int</span> rx_mask,</span><br><span class="line"><span class="type">int</span> slots, <span class="type">int</span> slot_width);</span><br><span class="line"><span class="type">int</span> (*set_channel_map)(<span class="keyword">struct</span> snd_soc_dai *dai,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tx_num, <span class="type">unsigned</span> <span class="type">int</span> *tx_slot,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rx_num, <span class="type">unsigned</span> <span class="type">int</span> *rx_slot);</span><br><span class="line"><span class="type">int</span> (*get_channel_map)(<span class="keyword">struct</span> snd_soc_dai *dai,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *tx_num, <span class="type">unsigned</span> <span class="type">int</span> *tx_slot,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *rx_num, <span class="type">unsigned</span> <span class="type">int</span> *rx_slot);</span><br><span class="line"><span class="type">int</span> (*set_tristate)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> tristate);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*set_sdw_stream)(<span class="keyword">struct</span> snd_soc_dai *dai,</span><br><span class="line"><span class="type">void</span> *stream, <span class="type">int</span> direction);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI digital mute - optional.</span></span><br><span class="line"><span class="comment"> * Called by soc-core to minimise any pops.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*digital_mute)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> mute);</span><br><span class="line"><span class="type">int</span> (*mute_stream)(<span class="keyword">struct</span> snd_soc_dai *dai, <span class="type">int</span> mute, <span class="type">int</span> stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ALSA PCM audio operations - all optional.</span></span><br><span class="line"><span class="comment"> * Called by soc-core during audio PCM operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*startup)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="type">int</span> (*hw_params)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_pcm_hw_params *, <span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="type">int</span> (*hw_free)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="type">int</span> (*prepare)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Commands passed to the trigger function are not necessarily</span></span><br><span class="line"><span class="comment"> * compatible with the current state of the dai. For example this</span></span><br><span class="line"><span class="comment"> * sequence of commands is possible: START STOP STOP.</span></span><br><span class="line"><span class="comment"> * So do not unconditionally use refcounting functions in the trigger</span></span><br><span class="line"><span class="comment"> * function, e.g. clk_enable/disable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*trigger)(<span class="keyword">struct</span> snd_pcm_substream *, <span class="type">int</span>,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="type">int</span> (*bespoke_trigger)(<span class="keyword">struct</span> snd_pcm_substream *, <span class="type">int</span>,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For hardware based FIFO caused delay reporting.</span></span><br><span class="line"><span class="comment"> * Optional.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">snd_pcm_sframes_t</span> (*delay)(<span class="keyword">struct</span> snd_pcm_substream *,</span><br><span class="line"><span class="keyword">struct</span> snd_soc_dai *);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>第一类：时钟配置回调函数</strong></p><ul><li>set_sysclk: 设置 DAI 的主时钟</li><li>set_pll: 设置 PLL 函数</li><li>set_clkdiv: 设置时钟分频值</li></ul><p><strong>第二类：DAI 的格式配置函数</strong></p><ul><li>set_fmt: 设置 DAI 的格式</li><li>set_tdm_slot: 设置 TDM 的时隙</li><li>set_channel_map: 通道 TDM 的映射设置 machine 驱动通过 snd_soc_dai_set_channel_map 调用</li><li>set_tristate: 设置 DAI 引脚的状态，在于其他 DAI 并行使用同一引脚时需要使用该状态</li></ul><p><strong>第三类：普通的标准前端</strong></p><ul><li>startup：打开采集/回放设备时，在打开 PCM 子流时由 ALSA 调用</li><li>hw_params：设置音频流时调用</li><li>prepare：当 PCM 准备好时调用</li><li>trigger： PCM 启动、停止、暂停时调用</li></ul><h1 id="control">Control</h1><p>编解码器驱动程序通常需要公开一些可以从用户空间更改的编解码器属性，这些就是编解码器控件（control）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> {</span></span><br><span class="line"><span class="type">snd_ctl_elem_iface_t</span> iface;<span class="comment">/* interface identifier */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> device;<span class="comment">/* device/client number */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> subdevice;<span class="comment">/* subdevice (substream) number */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *name;<span class="comment">/* ASCII name of item */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> index;<span class="comment">/* index of item */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> access;<span class="comment">/* access rights */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;<span class="comment">/* count of same elements */</span></span><br><span class="line"><span class="type">snd_kcontrol_info_t</span> *info;</span><br><span class="line"><span class="type">snd_kcontrol_get_t</span> *get;</span><br><span class="line"><span class="type">snd_kcontrol_put_t</span> *put;</span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">} tlv;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private_value;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>iface : 控件类型 可能是简单开关控件、立体声控件（Stereo）、混音器（MIXER）、MUX 控件等</li><li>name： 控件名称，命名包含源（Master、PCM、CD、Line）、方向（playback、capture、Bypass）以及功能（switch、volume、route 等）</li><li>access : 控件访问权限，READ、WRITE、VOLATILE 等</li><li>get : 读取控件的当前值并返回给用户空间</li><li>put : 按照应用程序要求设置控件值</li><li>tlv : 为控件提供元数据，有些混音器控件需要以分贝（db）为单位提供信息，可以使用 DECLARE_TLV_xxx 宏定义一些包含这些信息的变量，然后将控制 tlv.p 字段指向的变量，tlv 是类型-长度-值（type-length-value）是一种编码方案。</li></ul><h2 id="设置开关控件">设置开关控件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOC_SINGLE(xname, reg,shift.max,invert)</span><br></pre></td></tr></tbody></table></figure><p>这种类型的控件只有一个设置，一般用于组件开关</p><h2 id="设置带有音量级别的开关">设置带有音量级别的开关</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOC_SINGLE_TLV(name, reg,shift.max,invert,tlv_array)</span><br></pre></td></tr></tbody></table></figure><p>用于定义具有增益的控件，如音量控件、EQ 均衡器等</p><h2 id="立体声控件">立体声控件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOC_DOUBLE_R(xname, reg_left,reg_right,xshift,xmax,xinvert)</span><br></pre></td></tr></tbody></table></figure><p>在一个寄存器中控制两个相似的变量，因此可以同时控制左右声道</p><h2 id="带音量级别的立体声控件">带音量级别的立体声控件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOC_DOUBLE_R_TLV(xname, reg_left,reg_right,xshift,xmax,xinvert,tlv_array)</span><br></pre></td></tr></tbody></table></figure><h2 id="混音器控件">混音器控件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOC_SINGLE(<span class="string">"Input Switch"</span>, WM8960_SPEAKER_MIXER,<span class="number">7</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">SOC_SINGLE(<span class="string">"Output Switch"</span>, WM8960_SPEAKER_MIXER,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">SOC_SINGLE(<span class="string">"DAC Switch"</span>, WM8960_SPEAKER_MIXER,<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="dapmdynamic-audio-power-management">DAPM(dynamic audio power management)</h1><h2 id="widget">widget</h2><p>普通 kcontrol 具有以下特点：</p><ul><li>自我描述，无法描述每个 kcontrol 之间的关系</li><li>缺乏电源管理机制</li><li>缺乏响应回放、停止、开机、关机等音频事件的时间处理机制</li><li>缺少爆音防止机制</li><li>无法自动关闭音频路径中涉及的所有控件</li></ul><p>为解决以上问题，DAPM 引入 widget，widget 是 kcontrol 的进一步升级和封装。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">snd_soc_dapm_type</span> <span class="title">id</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* widget name */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *sname;<span class="comment">/* stream name */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *priv;<span class="comment">/* widget specific data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span><span class="comment">/* attached regulator */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span><span class="comment">/* attached pinctrl */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dapm control */</span></span><br><span class="line"><span class="type">int</span> reg;<span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shift;<span class="comment">/* bits to shift */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask;<span class="comment">/* non-shifted mask */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> on_val;<span class="comment">/* on state value */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> off_val;<span class="comment">/* off state value */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> power:<span class="number">1</span>;<span class="comment">/* block power status */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> active:<span class="number">1</span>;<span class="comment">/* active stream on DAC, ADC's */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> connected:<span class="number">1</span>;<span class="comment">/* connected codec pin */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> new:<span class="number">1</span>;<span class="comment">/* cnew complete */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> force:<span class="number">1</span>;<span class="comment">/* force state */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> new_power:<span class="number">1</span>;<span class="comment">/* power from this run */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> power_checked:<span class="number">1</span>;<span class="comment">/* power checked this run */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> is_supply:<span class="number">1</span>;<span class="comment">/* Widget is a supply type widget */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> is_ep:<span class="number">2</span>;<span class="comment">/* Widget is a endpoint type widget */</span></span><br><span class="line"><span class="type">int</span> subseq;<span class="comment">/* sort within widget type */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*power_check)(<span class="keyword">struct</span> snd_soc_dapm_widget *w);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* external events */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> event_flags;<span class="comment">/* flags to specify event types */</span></span><br><span class="line"><span class="type">int</span> (*event)(<span class="keyword">struct</span> snd_soc_dapm_widget*, <span class="keyword">struct</span> snd_kcontrol *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kcontrols that relate to this widget */</span></span><br><span class="line"><span class="type">int</span> num_kcontrols;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> *<span class="title">kcontrol_news</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol</span> **<span class="title">kcontrols</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget input and output edges */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">edges</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used during DAPM updates */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">work_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">power_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dirty</span>;</span></span><br><span class="line"><span class="type">int</span> endpoints[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> channel;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>id: widget 类型，如 snd_soc_dapm_output、snd_soc_dapm_mixer 等</li><li>name:widget 名称</li><li>shift 和 mask：用于控制 widget 的电源状态，对应寄存器地址 reg</li><li>on_val 和 off_val：表示更改 widget 当前电源状态的值</li><li>event：表示 DAPM 事件处理回调函数指针</li><li>kcontrol_news：组成该 kcontrol 的控件数组</li><li>dirty：当 widget 状态改变时，dirty 用于将这个 widget 插入到 dirty 列表中，然后扫描整个列表执行整个路径的更新</li></ul><h2 id="定义-widget">定义 widget</h2><p>有很多宏定义来定义 widget 控件，包括：</p><ul><li>编解码域：如 VREF 和 VMID，可以提供参考电压 widget</li><li>platform/machine domain：需要物理连接的 platfoem 或板卡的输入输出接口，如耳机、扬声器、麦克风等</li><li>音频路径域：指在编解码器中控制音频路径的 MUX、Mixer 和其他 widget</li><li>音频流域：处理音频流数据，如 ADC、DAC 等</li></ul><h2 id="路径的概念--widget-之间的连接器">路径的概念--widget 之间的连接器</h2><p>由 struct snd_soc_dapm_path 结构体表示，该结构体表示两个 widget 之间的连接，他的 source 字段指向连接的开始 widget，而 sink 字段则指向连接到达的 widget。所有输入端点的 snd_soc_dapm_path 连接到 list_node[SND_SOC_DAPM_DIR_IN] 列表中，所有输出端点的 snd_soc_dapm_path 连接到 list_node[SND_SOC_DAPM_DIR_OUT] 列表中。</p><h2 id="路由的概念--widget-互联">路由的概念--widget 互联</h2><p>为了不想处理 path，引入 route 概念，路由至少包括，起始 widget，跳线路径 jumper path 和接收方 widger 组成，使用 struct snd_soc_dapm_route 表示。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *sink;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *control;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line"><span class="type">int</span> (*connected)(<span class="keyword">struct</span> snd_soc_dapm_widget *source,</span><br><span class="line"> <span class="keyword">struct</span> snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dobj</span> <span class="title">dobj</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>sink: 指向到达 widget 的名称串</li><li>source：指向起始 widget 的名称串</li><li>control：指向负责控制连接的 kcontrol 名称串</li><li>connected：定义了自定义连接检查的回调函数</li></ul><p>source 通过 kcontrol 连接到 sink，可以调用 connected 检查连接状态</p><h1 id="数据结构">数据结构</h1><p>前面列出了一些关键数据结构，除此之外还有很多其他关键数据结构，以及各数据结构之间的关系没有一一列出来，下面只通过一副图片来将相关数据结构以及他们之间的关系列出来。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjVkMmI0ZjdlYTRjMTcwMjJmYzY0YzQx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/asoc_codec.png"></p><h1 id="参考文献">参考文献</h1><p>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 ALSA（一）概述</title>
      <link href="/next/2024/LinuxDriver/LinuxAudioALSASummer/"/>
      <url>/next/2024/LinuxDriver/LinuxAudioALSASummer/</url>
      
        <content type="html"><![CDATA[<h1 id="asoc">ASOC</h1><p>ALSA 是为桌面计算机而设计的，没有考虑嵌入式设备的限制，在处理嵌入式设备时会产生很多问题，包括但不限于如下：</p><ul><li>编解码器和 CPU 之间的耦合太强，导致代码移植困难。</li><li>没有处理用户音频相关行为通知的标准方法，在移动场景中，用户的相关音频操作很频繁。</li><li>在最初的 ALSA 设置中没有考虑 PM 机制。</li></ul><p>ASOC 就是为了解决以上问题而产生的。ALSA（ALSA system on chip， ASOC）层的目的是为嵌入式处理器和各种编解码器提供更好的 ALSA 支持。ASOC 具有以下优势：</p><ul><li>独立的编解码器驱动程序。</li><li>更方便的配置 CPU 和编解码器动态音频电源管理（dynamic audio power management， DAPM）之间的音频数据接口。</li><li>减少弹出和点击操作，并增加与平台相关的控件。</li></ul><span id="more"></span><p>为了实现上述功能，ASoC 将嵌入式音频系统划分为 3 个可重用的组件驱动程序，即机器类（machine class）、平台类（platform class）和编解码器类（codec）。其中，平台类和编解码器类是跨平台（cross-platform）的，而机器类是板级的（board-specific）。</p><h1 id="asoc-数字音频接口">ASoC 数字音频接口</h1><p>数字音频接口（digital audio interface，DAI）是一种总线控制器，它可以将音频数据从一端（如 SoC）传送到另一端（编解码器）。ASoC 当前支持 SoC 控制器和便携式音频编解码器上的大多数 DAI，如 AC97、I2S、PCM、S/PDIF 和 TDM。</p><h2 id="i2s">I2S</h2><p>I2S 全称 Inter-IC Sond Bus，是飞利浦在 1986 年定义 (1996 年修订）的数字音频传输标准，用于数字音频数据在系统内部器件之间传输，例如编解码器 Codec、DSP、数字输入/输出接口、ADC、DAC 和数字滤波器等。 对于 I2S 的数字接口定义也比较简单，没有从地址或者从设备的概念，在 I2S 总线上，只能同时存在一个主设备和发送设备。在 I2S 系统中，提供时钟（SCK）的设备为主设备，其常见的系统框图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/iis.png"></p><p>在 I2S 传输协议中，数据信号、时钟信号以及控制信号是分开传输的。I2S 协议只定义三根信号线：时钟信号 SCK、数据信号 SD 和左右声道选择信号 WS。</p><ul><li><p>SCLK：<br>时钟信号：模块内的同步信号，主模式时由模块内部自己产生，从模式由外部提供</p></li><li><p>SD：<br>数据信号：在 WS 变化后的第一个 SCK 脉冲，先传输最高位（MSB, Most Significant Bit）。先传送 MSB 是因为发送设备和接收设备的字长可能不同</p></li><li><p>WS：<br>左右声道选择信号 Word Select:WS＝0，表示选择左声道；WS＝1，表示选择右声道。WS 也称帧时钟，即 LRCLK/Left Right Clock。WS 频率等于声音的采样率</p></li></ul><!--more--><p>其数据传输的方式如下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/iis_format.png"></p><h2 id="pcmtdm">PCM/TDM</h2><p>PCM = Pulse Code Modulation 是通过等时间隔（即采样率时钟周期）采样将模拟信号数字化的方法。下图是 4bit 采样速率的 PCM 数据量化示意图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/pcm.png"></p><p>PCM 接口常用于板级音频数字信号的传输，与 I2S 类似，其实 I2S 也是 PCM 的一种特例接口，只不过，I2S 的速率会更高，比较适用于传音乐。而 PCM 通常用于 AP 处理器与通信 MODEM 之间的语言数据传输（就是双向打电话数据），对于 I2S 只能传 2 个声道的数据，而 PCM 可以传多达 16 路数据，采用时分复用的方式，也就是 TDM。其接口与 I2S 类似，电路信号为：</p><ul><li>PCM_CLK 数据时钟信号</li><li>PCM_SYNC 帧同步时钟信号</li><li>PCM_IN 接收数据信号</li><li>PCM_OUT 发送数据信号</li></ul><h2 id="pdm">PDM</h2><p>PDM(Pulse Density Modulation) 是一种数字信号表示模拟信号的调制方法，声音通过传感器获得模拟信号，经过 AD，得到音频数字信号，然后经过 PDM 脉冲转换成数字信号。PDM 使用远高于 PCM 采样率的时钟采用调制模拟分量，只有 1 位输出，要么是 0，要么是 1。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/pdm.png"></p><p>PDM 方式的逻辑相对复杂，但只需要两根线，时钟和数据。对于下图，主设备为两个从设备提供时钟，分别在时钟的上升沿和下降沿触发选择 Source 1/2 作为数据输入。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/pdm_source.png"></p><p>PDM 在诸如手机和平板等对于空间限制严格的场合有着广泛的应用前景。在数字麦克风领域，应用最广的就是 PDM 接口，其次为 I2S 接口。</p><h2 id="spdif">S/PDIF</h2><p>S/PDIF 的全称是 Sony/Philips Digital Interface Format，由于被广泛采用，它成为事实上的民用数字音频格式标准，大量的消费类音频数字产品如民用 CD 机、DAT、MD 机、计算机声卡数字口等都支持 S/PDIF，在不少专业设备上也有该标准的接口。就传输方式而言，SPDIF 分为输出（SPDIF OUT）和输入（SPDIF IN）两种。</p><h1 id="asoc-子元素">ASOC 子元素</h1><ul><li>平台（platform）：这是指 SoC 的音频 DMA 引擎，如 i.MX、Rockchip 和 STM32。平台类驱动程序可以细分为两部分，如下所述：<ul><li>CPU DAI 驱动程序：在嵌入式系统中，它通常是指 CPU 的音频总线控制器，如、I2S、S/PDIF、AC97 和 PCM 总线控制器，有时可能会集成到一个更大的模块中，即串行音频接口（serialaudiointerface，SA）</li><li>PCM DMA 驱动程序：PCM 驱动程序与平台无关，仅与 SOCDMA 引擎上游 API 交互</li></ul></li><li><p>编解码器（codec）：除了编解码功能外还包括 AIF、DAC、ADC、Mixer、PGA、Lin-in、Lin-out。一些高端芯片还具有回声消除、噪声抑制和其他组件。</p></li><li><p>机器（machine）：系统级表示，链接两个音频接口（cpu_dai 和 codec dai），该链接在内核通过 struct snd_soc_dai_link 实例抽象出来。</p></li></ul><h1 id="框架">框架</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Audio/ALSA_Framework1.png"></p><ul><li><p>alsa-utils（用户空间） ALSA 实用程序包由 Linux 社区提供，包含 ALSA 项目的命令行实用程序（aplay、arecord、amixer、alsamixer ...）。</p></li><li><p>alsa-lib（用户空间） ALSA 库包含需要访问 ALSA 声音接口的程序（例如 alsa-utils 程序）使用的 ALSA 库。ALSA 库在内核模块提供的音频设备上提供了一定程度的抽象，例如 PCM 和控制抽象 。</p></li><li><p>ALSA Framework（内核空间） ALSA 核心提供了一个 API 来实现音频驱动程序和 PCM/控制接口，以在用户空间上公开音频设备。PCM 接口处理数据流和控制。该界面管理 ALSA 驱动程序导出的控件（音频路径、音量。..）。</p></li><li><p>ASoC Framework（内核空间） ALSA 片上系统 ( ASoC ) 层的目标是改进 ALSA 对嵌入式片上系统处理器和音频编解码器的支持。ASoC 框架提供了一个 DMA 引擎，它与 DMA 框架连接以处理音频样本的传输。ASoC 还通过 DAPM 驱动程序支持音频路径的动态电源管理。ASoC 充当 ALSA 驱动程序，它将嵌入式音频系统分为三种类型的独立于平台的驱动程序：CPU DAI、编解码器和机器驱动程序。</p></li><li>ASoC driver（内核空间） ASoC 驱动程序允许为 ASoC 驱动程序类实现硬件相关代码 ：<ul><li>编解码器驱动程序</li><li>CPU DAI 驱动程序</li><li>机器驱动程序</li></ul></li></ul><h1 id="debug">Debug</h1><h2 id="procfs-filesystem">Procfs filesystem</h2><ul><li>List PCM audio devices:</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/asound/pcm</span><br></pre></td></tr></tbody></table></figure><ul><li>Get hardware parameters of a PCM audio device (device "0" of card "0" here):</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/asound/card0/pcm0p/sub0/hw_params</span><br></pre></td></tr></tbody></table></figure><h2 id="debugfs-filesystem">Debugfs filesystem</h2><ul><li>List DAIs</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/asoc/dais</span><br></pre></td></tr></tbody></table></figure><ul><li>List DAPMs of "xxx.audio-controller" CPU DAI of "STM32MP1-EV" soundcard</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /sys/kernel/debug/asoc/STM32MP1-EV/xxx.audio-controller/dapm</span><br></pre></td></tr></tbody></table></figure><h2 id="how-to-trace">How to trace</h2><h3 id="dynamic-traces">Dynamic traces</h3><p>ALSA framework and driver debug traces can be added to the kernel logs by using the dynamic debug mechanism.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">'file stm32_sai.c +p; file stm32_sai_sub.c +p'</span> &gt; /sys/kernel/debug/dynamic_debug/control; </span><br><span class="line">$ dmesg -n8;</span><br></pre></td></tr></tbody></table></figure><h3 id="tracing-filesystem">Tracing filesystem</h3><h4 id="activate-dapm-traces">Activate DAPM traces</h4><ul><li>Enable trace</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/kernel/debug/tracing/events/asoc/enable</span><br></pre></td></tr></tbody></table></figure><ul><li>Check log</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></tbody></table></figure><h4 id="activate-pcm-hardware-parameter-traces">Activate PCM hardware parameter traces</h4><ul><li>Enable trace</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/kernel/debug/tracing/events/snd_pcm/enable</span><br></pre></td></tr></tbody></table></figure><ul><li>Check log</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></tbody></table></figure><h4 id="activate-pcm-buffer-state-traces">Activate PCM buffer state traces</h4><p>Prerequisite: the CONFIG_FUNCTION_TRACER, CONFIG_SND_DEBUG, CONFIG_SND_DEBUG_VERBOSE and SND_PCM_XRUN_DEBUG configurations must first be enabled in the Linux kernel configuration</p><ul><li>Set XRUN trace verbosity</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 3 &gt; /proc/asound/card0/pcm0p/xrun_debug</span><br></pre></td></tr></tbody></table></figure><ul><li>Enable trace</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/kernel/debug/tracing/events/snd_pcm/enable</span><br></pre></td></tr></tbody></table></figure><ul><li>Check log</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0ODkyMzYvYXJ0aWNsZS9kZXRhaWxzLzk4MDQwOTg1P3NwbT0xMDAxLjIwMTQuMzAwMS41NTAx">https://blog.csdn.net/u012489236/article/details/98040985?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0ODkyMzYvYXJ0aWNsZS9kZXRhaWxzLzk4MDY4MTIyP3NwbT0xMDAxLjIwMTQuMzAwMS41NTAx">https://blog.csdn.net/u012489236/article/details/98068122?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0ODkyMzYvYXJ0aWNsZS9kZXRhaWxzLzk4MDc5MTc2P3NwbT0xMDAxLjIwMTQuMzAwMS41NTAx">https://blog.csdn.net/u012489236/article/details/98079176?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发-约翰-马德奥》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Audio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio </tag>
            
            <tag> ALSA </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB 子系统（四）USB Gadget 驱动</title>
      <link href="/next/2023/LinuxDriver/LinuxUSBGadgetDriver/"/>
      <url>/next/2023/LinuxDriver/LinuxUSBGadgetDriver/</url>
      
        <content type="html"><![CDATA[<p>USB 控制器可以呈现出两种不同的状态。USB 控制器作为 Host 时，称为 USB 主机控制器，使用 USB 主机控制器驱动。USB 控制器作为 Device 时，称为 USB 设备控制器，使用 UDC（usb device controller）驱动。</p><p>USB 控制器作为 Device 时，最上层的是 Gadget Function 驱动，代表了具体设备的驱动，如 U 盘、USB 串口、USB 虚拟网卡、UAC 驱动。Composite 层是一个可选的中间层，可通过一种配置或多种配置高效的支持多种功能的设备，简化了 USB 复合设备驱动的开发。目前最流行的是使用基于 Composite 和 configfs 实现的 USB gadget configfs，可在用户空间灵活的配置 USB 设备。UDC 驱动直接访问硬件，控制 USB 设备与 USB 主机之间的通信。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Framework.png"></p><span id="more"></span><h1 id="busdevicedriver模型">Bus/Device/Driver模型</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/usbDriver.png"></p><ul><li>"USB接口"是逻辑上的USB设备，我们编写的usb_driver驱动程序，支持的是"USB接口"： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/usbDriver1.png"></li><li>USB控制器或Hub识别出USB设备后，会创建、注册usb_deive</li><li>usb_device被"drivers.c"驱动认领后，会选择、设置某个配置</li><li>这个配置下面的接口，都会分配、设置、注册一个usb_interface</li><li>左边的usb_driver和右边的usb_interface如果匹配，则调用usb_driver.probe</li></ul><h1 id="数据结构">数据结构</h1><p>以 UAC 为例来说明： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/UAC-Struct.png"></p><ul><li><p>usb_configuration： 代表一个 gadget 配置</p></li><li><p>usb_composite_dev： 它里面汇集有各类描述符，内嵌 gadget 对象，以及 usb 设备的一些配置和请求，有一个 usb_funciton 链表（实现数据传输），主要用于初始化。</p></li><li><p>usb_composite_driver： 设备驱动的入口，用来管理设备配置信息，保存设备描述符。</p></li><li><p>usb_gadget_driver： 提供一个通用的 usb gadget driver 模板，向下注册到 udc, 向上给 functions driver 提供 bind 回调等。</p></li></ul><h1 id="代码逻辑">代码逻辑</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/UAC-Driver.png"></p><p>UAC 驱动框架如上图所示，主要各入口函数以及各层相关函数流程都列出来了，感兴趣的可以自己追踪代码查看。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWV0LWNoaW5hLmNvbS9tcC9hNTUzMTAuaHRtbA==">https://www.eet-china.com/mp/a55310.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwMzc1OTMvYXJ0aWNsZS9kZXRhaWxzLzEyMDMzODk2OT9zcG09MTAwMS4yMDE0LjMwMDEuNTUwMg==">https://blog.csdn.net/u011037593/article/details/120338969?spm=1001.2014.3001.5502<i class="fa fa-external-link-alt"></i></span><br>《韦东山老师相关课程》<br>《圈圈教你玩 USB》<br>《USB2.0 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB 子系统（三）USB 设备描述符</title>
      <link href="/next/2023/LinuxDriver/LinuxUSBDeviceDescriptor/"/>
      <url>/next/2023/LinuxDriver/LinuxUSBDeviceDescriptor/</url>
      
        <content type="html"><![CDATA[<h1 id="标准设备请求">标准设备请求</h1><h2 id="setup-事务的数据格式">SETUP 事务的数据格式</h2><p>Host 使用控制传输来识别设备、设置设备地址、启动设备的某些特性，对于控制传输，它首先发出"setup 事务"，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description3.png"></p><span id="more"></span><p>在"setup 事务"中，</p><ul><li>SETUP 令牌包：用来通知设备，"要开始传输了"。</li><li>DATA0 数据包：它含有固定的格式，用来告诉设备"是读还是写"、"读什么"、"写什么"。</li></ul><p>Hos 通过 DATA0 数据包发送 8 字节数据给设备，它的格式如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description4.png"></p><h2 id="标准设备请求-1">标准设备请求</h2><p>控制传输的建立事务中，可以使用下列格式的数据： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description5.png"></p><p>上表中各个"宏"取值如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description6.png"></p><h2 id="设备配置接口端点">设备/配置/接口/端点</h2><p>在 SETUP 事务的数据里，表示了要访问的是什么：Device？Interface？Endpoint？</p><p>对于一个 USB 设备，它可以多种配置 (Configuration)。比如 4G 上网卡就有 2 种配置：U 盘、上网卡。第 1 次把 4G 上网卡插入电脑时，它是一个 U 盘，可以安装里面的程序。装好程序后，把它再次插入电脑，它就是一个上网卡。驱动程序可以选择让它工作于哪种配置，同一时间只能有一种配置。大多数的 USB 设备只有一种配置。</p><p>一个配置下，可以有多个接口 (Interface)，接口等同于功能 (Function)。比如 USB 耳机有两个接口（功能）：声音收发、按键控制。</p><p>一个接口，可能有多个设置 (Setting)，比如默认设置下它使用较低的带宽，可以选择其他设置以使用更高带宽。</p><p>一个接口，由一个或多个端点 (Endpoint) 组成。端点 0 属于整个设备的，端点 0 是双向的。接口还可以有其他端点，这些端点是单向的，要么是批量 (Bulk) 端点、要么是中断 (Interrupt) 端点、要么是同步 (Isochronous) 端点。</p><h1 id="描述符">描述符</h1><p>使用描述符 (Descriptors) 描述设备、配置、接口和端点，有设备描述符、配置描述符、接口描述符、端点描述符。所谓描述符，就是一些格式化的数据，用来描述信息。</p><p>一个 USB 设备，</p><ul><li>只有一个设备描述符：用来表示设备的 ID、它有多少个配置、它的端点 0 一次最大能传输多少字节数据。</li><li>可能有多个配置描述符：用来表示它有多少个接口、供电方式、最大电流。</li><li>一个配置描述符下面，可能有多个接口描述符：用来表示它是哪类接口、有几个设置 (Setting)、有几个端点。</li><li>一个接口描述符符下面，可能有多个端点描述符：用来表示端点号、方向 (IN/OUT)、类型（批量/中断/同步）。</li></ul><p>还有一些字符串描述符 (String descriptors)，它用可读的文字来描述设备，是可选的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description7.png"></p><h2 id="设备描述符">设备描述符</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description8.png"></p><h2 id="配置描述符">配置描述符</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description9.png"></p><h2 id="接口描述符">接口描述符</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description10.png"></p><h2 id="端点描述符">端点描述符</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description11.png"></p><h1 id="设备枚举过程示例">设备枚举过程示例</h1><p>使用"usbprotocolsuite"打开，可以看到设备的枚举过程：</p><ul><li><p>使用控制传输，读取设备信息（设备描述符）：第一次读取时，它只需要得到 8 字节数据，因为第 8 个数据表示端点 0 能传输的最大数据长度。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description12.png"></p></li><li><p>Host 分配地址给设备，然后把新地址发给设备： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description13.png"></p></li><li><p>使用新地址，重新读取设备描述符，设备描述符长度是 18： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description14.png"></p></li><li><p>读取配置描述符：它传入的长度是 255，想一次性把当前配置描述符、它下面的接口描述符、端点描述符全部读出来 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description15.png"></p></li><li><p>读取字符描述符 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description16.png"></p></li></ul><h1 id="参考文献">参考文献</h1><p>《韦东山老师相关课程》<br>《圈圈教你玩 USB》<br>《USB2.0 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB 子系统（二）USB 协议层数据格式</title>
      <link href="/next/2023/LinuxDriver/LinuxUSBProtoFormat/"/>
      <url>/next/2023/LinuxDriver/LinuxUSBProtoFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件拓扑结构">硬件拓扑结构</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol1.png"></p><ul><li>compound device ：多个设备组合起来，通过 HUB 跟 Host 相连</li><li>composite device ：一个物理设备有多个逻辑设备 (multiple interfaces)</li></ul><span id="more"></span><p>在软件开发过程中，我们可以忽略 Hub 的存在，硬件拓扑图简化如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol2.png"></p><p>一个物理设备里面可能有多个逻辑设备，Hos 可以外接多个逻辑设备，硬件拓扑图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol3.png"></p><h1 id="协议层">协议层</h1><ul><li>寻址设备阶段：USB 系统是一个 Host 对应多个设备，要传输数据首先要通知设备<ul><li>发出 IN 令牌包：表示想读数据，里面含有设备地址</li><li>发出 OUT 令牌包：表示想写数据，里面含有设备地址</li></ul></li><li>数据传输阶段<ul><li>Host 想读数据：发出 IN 令牌包后读取数据包</li><li>Host 想发出数据：发出 OUT 令牌包后发出数据包</li></ul></li><li>数据确认阶段<ul><li>Host 读数据，设备可能未就绪，就会回应 NAK 包</li><li>Host 写数据，它发出数据后，设备正确接收了，就回复 ACK 包</li></ul></li></ul><h2 id="sync-域">SYNC 域</h2><p>Host 发出 SOP 信号后，就会发出 SYNC 信号（前一节的那个 K-J-K-J-K-J-K 信号）：它是一系列的、最大传输频率的脉冲，接收方使用它来同步数据。对于低速/全速设备，SYNC 信号是 8 位数据（从左到右是 00000001)；对于高速设备，SYNC 信号是 32 位数据（从左到右是 00000000000000000000000000000001)。使用 NRZI 编码时，前面每个"0"都对应一个跳变。</p><p>在很多文档里，把 SOP 和 SYNC 统一称为"SYNC"。</p><h2 id="包格式">包格式</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol4.png"></p><p>USB 总线上传输的数据以包为单位。USB 包里含有哪些内容 ("域")？</p><ul><li>SOP：用来表示包的起始</li><li>SYNC：用来同步时钟</li><li>PID：表示包的类型</li><li>地址：在 USB 硬件体系中，一个 Host 对应多个 Logical Device，那么 Host 发出的包，如何确定发给谁？<ul><li>发给所有设备：包里不含有设备地址</li><li>发给某个设备：包里含有设备地址、端点号</li></ul></li><li>帧号、数据等跟 PID 相关的内容</li><li>CRC 校验码</li></ul><p>发起一次完整的传输，可能涉及多个包。那么，第 1 个包里含有设备地址、端点号，后续的包就没必要包含设备地址、端点号。</p><h2 id="pid-域">PID 域</h2><p>注意：所有的 USB 文档提到的"输入"、"输出"，都是基于 Host 的角度，"输出"表示从 Host 输出到设备，"输入"表示 Host 从设备得到数据。</p><p>有哪些 USB 包？根据包数据里的 PID 的 bit1, bit0 可以分为 4 类：</p><ul><li>令牌包 (Token)：01B</li><li>数据包 (Data)：11B</li><li>握手包 (Handshake)：10B</li><li>特殊包 (Special)：00B</li></ul><p>PID 有 4 位，使用 bit1,bit0 确定分类，使用 bit3,bit2 进一步细分。如下表（来自《圈圈教你玩 USB》) 所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol5.png"></p><p>在 USB 包中，PID 域使用 8 位来表示，格式如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol6.png"></p><p>前 4 位表示 PID，后 4 位是对应位的取反。接收方发现后 4 位不是前 4 位的取反的话，就认为发生了错误。</p><h2 id="令牌包-token">令牌包 (Token)</h2><p>令牌类的 PID，起"通知作用"，SOF 令牌包被用来通知所有设备，OUT/IN/SETUP 令牌包被用来通知某个设备。</p><p>对于 OUT、IN、SETUP 令牌包，它们都是要通知到具体的设备，格式如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol7.png"></p><p>USB 设备的地址有 7 位，格式如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol8.png"></p><p>对于 SOF 包，英文名为"Start-of-Frame marker and frame number"。对于 USB 全速设备，Host 每 1ms 产生一个帧；对于高速设备，每 125us 产生一个微帧，1 帧里有 8 个微帧。Host 会对当前帧号进行累加计数，在每帧或每微帧开始时，通过 SOF 令牌包发送帧号。对于高速设备，每 1 毫秒里有 8 个微帧，这 8 个微帧的帧号是一样的，每 125us 发送一个 SOF 令牌包。</p><p>SOF 令牌包格式如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol9.png"></p><h2 id="数据包">数据包</h2><p>Host 使用 OUT、IN、SETUP 来通知设备要传输数据了，数据通过"数据包"进行传输。</p><p>数据包也有 4 种类型：DATA0、DATA1、DATA2、MDATA。其中 DATA2、MDATA 在高速设备中使用。</p><p>Host 和设备都会维护自己的数据包切换机制，当数据包成功发送或者接收时，数据包类型切换。当检测到对方使用的数据包类型不对时，USB 系统认为发生了错误。</p><ul><li>Host 发送 DATA0 给设备，设备返回 ACK 表示成功接收，设备期待下一个数据是 DATA1</li><li>但是 Host 没有接收到 ACK，Host 认为数据没有发送成功，Host 继续使用 DATA0 发送上一次的数据</li><li>设备再次接收到 DATA0 数据包，它就知道：这是重传的数据包</li></ul><p>数据包格式如下：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol10.png"></p><p>对于全速设备，数据包中的数据做大是 1023 字节；对于高速设备，数据包中的数据做大是 1024 字节。</p><h2 id="握手包">握手包</h2><p>握手包有 4 类：ACK、NAK、STALL、NYET</p><ul><li>ACK：数据接收方用来回复发送方，表示正确接收到了数据并且有足够的空间保存数据</li><li>NAK：Host 发送数据给设备时，设备可以回应 NAK 表示"我还没准备好，没办法接收数据"；Host 想读取设备的数据时，设备可以回复 NAK 表示"我没有数据给你"</li><li>STALL：表示发生了错误，比如设备无法执行这个请求（不支持该端点等）、端点已经挂起。设备返回 STALL 后，需要主机进行干预才能接触 STALL 状态</li><li>NYET：仅适用于高速设备。Host 可以发出 PING 包用来确认设备有数据，设备可以回应 NYET 表示"还没呢"。Hub 也可以回应 NYET 表示低速/全速传输还没完结</li></ul><h1 id="传输细节">传输细节</h1><h2 id="事务-transaction-和传输-transfer">事务 (Transaction) 和传输 (Transfer)</h2><p>USB 传输的基本单位是包 (Packet)，包的类型由 PID 表示。一个单纯的包，是无法传输完整的数据的。完整的数据传输，需要涉及多个包：令牌包、数据包、握手包。这个完整的数据传输过程，被称为事务 (Transaction)。有些事务需要握手包，有些事务不需要握手包。</p><p>有四类** Transaction**：<br>- 批量事务：用来传输大量的数据，数据的正确性有保证，时效没有保证 - 中断事务：用来传输周期性的、小量的数据，数据的正确性和时效都有保证 - 实时事务：用来传输实时数据，数据的正确性没有保证，时效有保证 - 建立事务：跟批量事务类似，只不过令牌包是 SETUP 令牌包</p><p>有四类传输 (Transfer)：<br>- 批量传输：就是使用批量事务实现数据传输，比如 U 盘 - 中断传输：就是使用中断事务实现数据传输，比如鼠标 - 实时传输：就是使用实时事务实现数据传输，比如摄像头 - 控制传输：由建立事务、批量事务组成，所有的 USB 设备都必须支持控制传输，用于"识别/枚举"</p><p>Filed、Packer、Transaction、Transfer 之间的关系：<br>- BIT 组成域 (Field) - 域组成包 (Packet) - 包组成事务 (Transaction) - 事务组成传输 (Transfer)</p><p>以 Isochronous TransFer 为例，如下图所示，表示了他们之间的关系： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB_Transfer.png"></p><h2 id="过程-stage-和阶段-phase">过程 (stage) 和阶段 (phase)</h2><p>事务（<strong>Transaction</strong>）由多个包组成，比如 Host 要发送数据给设备，这就会涉及很多个包：</p><ul><li>Host 发出 OUT 令牌包，表示要发数据给哪个设备</li><li>Host 发出 DATA 数据包</li><li>设备收到数据后，回应 ACK 包</li></ul><p>这个完整的事务涉及 3 个包 (Packet)，分为 3 个阶段 (Phase)：</p><ul><li>令牌阶段 (Token phase)：由令牌包实现</li><li>数据阶段 (Data phase)：由数据包实现</li><li>握手阶段 (Handshake phase)：由握手包实现</li></ul><p>事务由包组成，这些包分别处于 3 个阶段 (phase)：令牌阶段，数据阶段，握手阶段。</p><p>对于批量传输、中断传输、实时传输，它们分别由一个事务组成，不再细分为若干个过程。</p><p>但是控制传输由多个事务组成，这些事务分别处于 3 个过程：建立过程 (stage)、数据过程 (stage)、状态过程 (stage)。</p><p>总结起来就是：</p><ul><li>控制传输由多个过程 (stage) 组成，每个过程由一个事务来实现</li><li>每个事务由多个阶段 (phase) 组成，每个阶段有一个包来实现</li></ul><h2 id="批量传输">批量传输</h2><p>批量传输用批量事务来实现，用于传输大量的数据，数据的正确性有保证，时效没有保证。</p><p>批量事务由 3 个阶段 (phase) 组成：令牌阶段、数据阶段、握手阶段。每个阶段都是一个完整的包，含有 SOP、SYNC、PID、EOP。</p><p>下图中各个矩形框就对应一个完整的包。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol11.png"></p><p>《圈圈教你玩 USB》中有详细的示例： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol12.png"></p><h2 id="中断传输">中断传输</h2><p>中断传输用中断事务来实现，用于传输小量的、周期性的数据，数据的正确性和时效都有保证。</p><p>中断事务由 3 个阶段 (phase) 组成：令牌阶段、数据阶段、握手阶段。每个阶段都是一个完整的包，含有 SOP、SYNC、PID、EOP。</p><p>下图中各个矩形框就对应一个完整的包。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol13.png"></p><p>中断事务跟批量事务非常类似，Host 使用它来周期性地读数据、写数据。</p><p>以鼠标为例，我们需要及时获得鼠标的数据，不及时的话你会感觉鼠标很迟钝。但是 USB 协议中并没有中断功能，它使用"周期性的读、写"来实现及时性。具体过程如下：</p><ul><li>Host 每隔 n 毫秒发出一个 IN 令牌包</li><li>鼠标有数据的话，发出 DATA0 或 DATA1 数据包给 Host；鼠标没有数据的话，发出 NAK 给 Host</li></ul><p>中断事务的优先级比批量事务更高，它要求实时性，而批量事务不要求实时性。</p><h2 id="实时传输">实时传输</h2><p>实时传输用实时事务来实现，用于传输实时数据，对数据的正确性没有要求。</p><p>实时事务由 2 个阶段 (phase) 组成：令牌阶段、数据阶段。每个阶段都是一个完整的包，含有 SOP、SYNC、PID、EOP。</p><p>下图中各个矩形框就对应一个完整的包。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol14.png"></p><p>实时事务跟中断事务非常类似，Host 也会周期性的发起实时事务，主要区别在于：</p><ul><li>实时事务不要求准确性，没有握手阶段</li><li>实时事务传输的数据量比较大，中断事务传输的数据量比较小</li></ul><h2 id="控制传输">控制传输</h2><p>在使用批量传输时，使用 IN 令牌包或 OUT 令牌包表示数据传输方向。</p><p>控制传输的令牌包永远是 SETUP，怎么分辨是读数据，还是写数据？发出 SETUP 令牌包后，还要发出 DATA0 数据包，根据数据的内容来确定后续是读数据，还是写数据。这个过程称为"建立事务"(SETUP Transaction)。</p><p>但是控制传输由多个事务组成，这些事务分别处于 3 个过程：建立过程 (stage)、数据过程 (stage)、状态过程 (stage)。</p><ul><li>建立过程 (stage)，使用 SETUP 事务：Host 发出 SETUP 令牌包、DATA0 数据包、得到 ACK 握手包</li><li>数据过程 (stage)，使用批量事务：<ul><li>对于输出：Host 发出 OUT 令牌包，发出 DATA0、DATA1 数据包、得到 ACK 握手包</li><li>对于输入：Host 发出 IN 令牌包，读到 DATA0、DATA1 数据包、发出 ACK 握手包</li></ul></li><li>状态过程 (stage)，使用批量事务：<ul><li>对于输出：Host 发出 IN 令牌包，读到 DATA1 数据包，发出 ACK 握手包</li><li>对于输入：Host 发出 OUT 令牌包，发出 DATA1 数据包，等待 ACK 握手包</li></ul></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol15.png"></p><p>上图中的每一个方框，都是一个完整的事务，含有：Token Packet、Data Packet、Handshake Packet。</p><h1 id="抓包">抓包</h1><p>安装"usbprotocolsuite"后，可以在文档目录里找打很多示程序（后缀名为 usb)： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol16.png"></p><p>使用"usbprotocolsuite"打开这些文件，即可体验 USB 数据传输： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Protol17.png"></p><h1 id="参考文献">参考文献</h1><p>《韦东山老师相关课程》<br>《圈圈教你玩 USB》 《USB2.0 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB 子系统（一）USB 电器特性</title>
      <link href="/next/2023/LinuxDriver/LinuxUSBEletrictFeature/"/>
      <url>/next/2023/LinuxDriver/LinuxUSBEletrictFeature/</url>
      
        <content type="html"><![CDATA[<p>USB 2.0 协议支持 3 种速率：低速 (Low Speed，1.5Mbps)、全速 (Full Speed, 12Mbps)、高速 (High Speed, 480Mbps)。</p><p>USB Hub、USB 设备，也分为低速、全速、高速三种类型。一个 USB 设备，可能兼容低速、全速，可能兼容全速、高速，但是不会同时兼容低速、高速。</p><span id="more"></span><h1 id="usb-设备状态切换图">USB 设备状态切换图</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-eletrict-feature.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-description2.png"></p><ul><li>连接 (Attached)：USB 设备在已连接到 USB，但还没有上电的时候处于连接状态。</li><li>上电 (Powered)：USB 设备在已连接到 USB，并且已经上电，但还没有被复位的时候，处于上电状态。 USB 设备的电源获取分为两种，一种是通过外部电源进行获取，另一种是通过设备所连接的集线器 (hub) 处获得电源。通过外部供电的 USB 设备被称为自供电 (self-powered) 设备。尽管自供电设备在连接到 USB 之前可能已经有了电源，但在连接到 USB 并且 VBUS 被应用到设备之前，它们不被认为是处于上电状态。USB 设备可以同时支持自供电和总线供电 (bus-powered) 的配置。某些设备配置支持任一电源，其他设备配置可能只有在设备是自供电的情况下才可用。设备通过配置描述符 (configuration descriptor) 报告其电源能力 (power source capability)。当前电源作为设备状态的一部分进行报告。</li><li>默认 (Default)：USB 设备在已连接到 USB，且已经上电，并已经复位，但还没有分配唯一的地址时，处于默认状态，设备响应默认地址。 当复位过程完成后，USB 设备以正确的速度运行（即低速 low-speed/全速 full-speed/高速 high-speed）。低速和全速的速度选择由设备端终端电阻决定。作为复位过程的一部分，能够高速运行的设备决定是否以高速运行。</li><li>地址 (Address)：USB 设备在已连接到 USB，且已经上电和复位，并已分配了一个唯一的设备地址，但还没有被配置时，处于地址状态。 在完成 Set Address 请求后，如果指定的地址是个非零地址，则设备进入地址状态；否则，设备将保持处于默认状态。</li><li>配置 (Configured)：USB 设备已连接到 USB，已上电和复位，已分配了一个唯一的设备地址，并且已配置，且未挂起，处于配置状态。 配置设备或改变备用设置，会导致与受影响接口中的端点相关的所有状态和配置值被设置为其默认值。这包括任何使用数据切换 (data toggle) 的端点将其数据切换 (data toggle) 重置成值 DATA0。</li><li>挂起 (Suspended)：USB 设备在已连接到 USB，且已上电，并且 3ms 内未看到总线活动时，USB 设备会进入挂起状态。</li></ul><h1 id="硬件线路">硬件线路</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-interface.png"></p><p>USB 连接涉及 Hub Port 和 USB 设备，硬件连接如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Hub-Device.png"></p><h1 id="usb-总线信号">USB 总线信号</h1><p>USB 连接线有 4 条：5V、D+、D-、GND。数据线 D+、D-，只能表示 4 种状态。USB 协议中，很巧妙地使用这两条线路实现了信号 1、信号 0、SE0 状态、SE1 状态、J 状态、K 状态、空闲 IDLE、开始 SOP、结束 EOP、复位 Reset、Suspend 信号、Resume 信号、SYNC 信号、Connect 信号、Disconnect 信号等。</p><p><strong>低速/全速信号电平</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Low-Full-speed-signal.png"></p><p><strong>高速信号电平</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-High-speed-signal.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-High-speed-signal1.png"></p><p><strong>数据信号</strong><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-data-signal-packer.png"></p><ul><li>Reset 信号：<ul><li>主机拉低两根信号线（SE0 状态）并保持 10ms</li><li>USB 设备看到 Reset 信号后，需要准备接收"SetAddress()"请求；如果它不能回应这个请求，就是"不能识别的设备"</li></ul></li><li>Suspend 信号：<ul><li>总线 3ms 以上的 IDLE 状态，则设备会认为主机发起了一次挂起操作</li></ul></li><li>Resume 信号：<ul><li>Resume 信号可以由 USB 主机发起，也可以由 USB 设备本身触发，但是只有 USB 主机可以结束 Resume 信号</li><li>主机在挂起设备后可通过翻转数据线上的极性并保持 20ms 来唤醒设备，并以低速 EOP 信号结尾</li><li>如果设备支持远程唤醒，设备可向主机发起远程唤醒请求，前提是设备已进入 idle 状态至少 5ms，设备会驱动总线进入 K 状态，如下图，K 状态必须维持 1ms-15ms 之内，此信号会在 1ms 内被主机接管，主机会继续驱动唤醒信号直到 20ms，并以低速 EOP 信号结尾</li></ul></li><li>SYNC 信号：<ul><li>低速设备的 SYNC 信号，3 个 KJ 状态的切换，后跟随 2 位时间的 K 状态，完成一次同步信号的发送 Idle-K-J-K-J-K-J-K-K</li><li>高速模式中的 SYNC 格式为：KJKJKJKJ KJKJKJKJ KJKJKJKJ KJKJKJKK，即 15 对 KJ，外加 2 个 K</li></ul></li><li><p>Connect 信号：<br>Hub 端口的 D+、D-都有 15K 的下拉电阻，平时为低电平。全速设备内部的 D+有 1.5K 的上拉电阻，低速设备内部的 D-有 1.5K 的上拉电阻，连接到 Hub 后会导致 Hub 的 D+或 D-电平变化，Hub 根据变化的引脚分辨接进来的是全速设备还是低速设备。</p><p>高速设备一开始也是作为全速设备被识别的。</p><p>全速设备、高速设备连接时，D+引脚的电平由低变高： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-High-speed-connected.png"></p><p>低速设备连接时，D-引脚的电平由低变高： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Low-speed-connected.png"></p></li><li><p>Disconnect 信号：<br>对于低速、全速设备，接到 Hub 时导致 D-或 D+引脚变为高电平，断开设备后，D-或 D+引脚变为低电平： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-disconnected-low-speed.png"></p><p>对于高速设备，它先作为全速设备被识别出来，然后再被识别为高速设备。工作于高速模式时，D+的上拉电阻是断开的，所以对于工作于高速模式的 USB 设备，无法通过 D+的引脚电平变化监测到它已经断开。</p><p>工作于高速模式的设备，D+、D-两边有 45 欧姆的下拉电阻，用来消除反射信号： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Disconnected-full-speed.png"></p><p>当断开高速设备后，Hub 发出信号，得到的反射信号无法衰减，Hub 监测到这些信号后就知道高速设备已经断开，内部电路图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Disconnected-full-speed1.png"></p></li><li>SOP 信号 (Start Of Packet)：<ul><li>低速设备 SOP 信号：总线从 IDLE 状态（J 状态：差分 0）切到 K 状态（差分 1），即可完成低速 SOP 信号的发送</li><li>全速设备 SOP 信号：总线从 IDLE 状态（J 状态：差分 1）切到 K 状态（差分 0），即可完成全速 SOP 信号的发送 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-sop-signal.png"></li></ul></li><li>EOP 结束包（End of Packet）：<ul><li>全速或低速设备的结束包：SE0 状态用于发信号通知分组结束（EOP）。 通过将 D +和 D-驱动到 SE0 状态两位时间，然后将线路驱动到 J 状态一位时间来发信号通知 EOP。 从 SE0 到 J 状态的转换定义了接收器处的分组的结束。 J 状态被置位一个位时间，然后 D +和 D-输出驱动器都处于高阻态。 总线终端电阻将总线保持在空闲状态<br></li><li>高速设备的 EOP: 在高速信号中，以从 EOP 之前的最后一个符号到相反符号的转换开始。这个相反的符号是 EOP 模式中的第一个符号对于 SOF 以外的高速数据包。故意生成位填充错误以指示 EOP。需要接收器将任何位错误解释为 EOP。发送的 EOP 定界符必须是没有位填充的 NRZ 字节 01111111。例如，如果 EOP 字段之前的最后一个符号是 J，则这将导致 EOP 为 KKKKKKKK。对于高速 SOF，传输的 EOP 分隔符需要 5 个 NRZ 字节而不需要填充比特，由 01111111 11111111 11111111 11111111 11111111 组成。因此，如果 EOP 字段之前的最后一位是 J，这将导致线路上有 40 个 K 状态，线路必须返回到高速空闲状态。额外的 EOP 长度对接收器没有意义，它用于断开检测<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-eop-signal.png"></li></ul></li></ul><h1 id="nrzi-与位填充">NRZI 与位填充</h1><p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjAwMTg5OTM=">USB 的 NRZI 信号格式<i class="fa fa-external-link-alt"></i></span><br>NRZI：Non Return Zero Inverted Code，反向不归零编码。NRZI 的编码方位为：对于数据 0，波形翻转；对于数据 1，波形不变。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-NRZI1.png"></p><p>使用 NRZI，发送端可以很巧妙地把"时钟频率"告诉接收端：只要传输连续的数据 0 即可。在下图中，低速/全速协议中"Sync Pattern"的原始数据是"00000001"，接收端从前面的 7 个 0 波形就可以算出"时钟频率"。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-NRZI2.png"></p><p>NRZI 数据格式如上图所示。</p><p>使用 NRZI 时，如果传输的数据总是"1"，会导致波形维持不变。如果电平长时间维持不变，比如传输 100 位 1 时，如果接收方稍有偏差，就可能认为接收到了 99 位 1、101 位 1。而 USB 中采用了 Bit-Stuffing 位填充处理，即在连续发送 6 个 1 后面会插入 1 个 0，强制翻转发送信号，从而让接收方调整频率，同步接收。而接收方在接收时只要接收到连续的 6 个 1 后，直接将后面的 0 删除即可恢复数据的原貌。</p><h1 id="设备速率识别">设备速率识别</h1><h2 id="低速全速">低速/全速</h2><p>Hub 端口的 D+、D-都有 15K 的下拉电阻，平时为低电平。全速设备内部的 D+有 1.5K 的上拉电阻，低速设备内部的 D-有 1.5K 的上拉电阻，连接到 Hub 后会导致 Hub 的 D+或 D-电平变化，Hub 根据变化的引脚分辨接进来的是全速设备还是低速设备。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-Low-speed-cable-and-resistor-connections.png"></p><h2 id="高速">高速</h2><p>高速设备必定兼容全速模式，所以高速设备内部 D+也有 1.5K 的上拉电阻，只不过这个电阻是可以断开的：工作于高速模式时要断开它。</p><p>高速设备首先作为全速设备被识别出来，然后 Hub 如何确定它是否支持高速模式？</p><p>Hub 端口如何监测一个新插入的 USB 设备能否工作于高速模式？流程如下：</p><ul><li>对于低速设备，Hub 端口不会监测它能否工作于高速模式。低速设备不能兼容高速模式。</li><li>Hub 端口发出 SE0 信号（10ms），这就是复位信号。</li><li>USB 设备监测到 SE0 信号后，会发出"a high-speed detection handshake"信号表示自己能支持高速模式，这可以细分为一下 3 种情景。<ul><li>如果 USB 设备原来处于"suspend"状态，它检测到 SE0 信号后，就发出"a high-speed detection handshake"信号</li><li>如果 USB 设备原来处于"non-suspend"状态，并且处于全速模式，它检测到 SE0 信号后，就发出"a high-speed detection handshake"信号。这个情景，就是一个设备刚插到 Hub 端口时的情况，它一开始工作于全速模式</li><li>如果 USB 设备原来处于"non-suspend"状态，并且处于高速模式，它会切换回到全速模式（重新连接 D+的上拉电阻），然后发出"a high-speed detection handshake"信号</li></ul></li></ul><p>"a high-speed detection handshake"信号，就是"高速设备监测握手信号"，既然是握手信号，自然是有来有回：</p><ul><li>USB 设备维持 D+的上拉电阻，发出"Chirp K "信号，表示自己能支持高速模式。</li><li>如果 Hub 没监测到"Chirp K "信号，它就知道这个设备不支持高速模式。</li><li>如果 Hub 监测到"Chirp K "信号后，如果 Hub 能支持高速模式，就发出一系列的"Chirp K"、"Chirp J"信号，这是用来通知 USB 设备：Hub 也能支持高速模式。发出一系列的"Chirp K"、"Chirp J"信号后，Hub 继续维持 SE0 信号直到 10ms。</li><li>USB 设备发出"Chirp K "信号后，就等待 Hub 回应一系列的"Chirp K"、"Chirp J"信号。<ul><li>收到一系列的"Chirp K"、"Chirp J"信号：USB 设备端口 D+的上拉电阻，使能高速模式</li><li>没有收到一系列的"Chirp K"、"Chirp J"信号：USB 设备转入全速模式</li></ul></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/USB/USB-High-speed-cable-and-resistor-connections.png"></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWFpcGFuMTMxNC9hcnRpY2xlL2RldGFpbHMvMTEzNjM5OTEx">https://blog.csdn.net/weiaipan1314/article/details/113639911<i class="fa fa-external-link-alt"></i></span><br>《韦东山老师相关课程》<br>《USB2.0 协议规范》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP YUV 域之 CE（Contrast Enhancement）</title>
      <link href="/next/2023/Camera/CameraISPYUVCE/"/>
      <url>/next/2023/Camera/CameraISPYUVCE/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念">相关概念</h1><h2 id="直方图-histogram">直方图 Histogram</h2><p>在分析图像数据的统计特性时，有时可以抛弃图像的色度分量，只考察图像的亮度分量，此时可以引入图像的亮度直方图（Luminance Histogram），以常用的 8 位精度图像为例，直方图的 X 轴为 0~255，共 256 个桶，每个桶刚好覆盖 1 个像素值，直方图的 Y 轴表示每个桶盛纳了多少个像素。所有桶中盛纳的像素数加到一起应等于图像的总像素数。</p><span id="more"></span><p>在分析画面的亮暗特征，人们经常把亮度区间定性地划分成暗调、阴影、中调、亮调、高光等几个区域，各区域的边界则可以根据应用特点灵活掌握。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce1.png"></p><p>当需要分析图像的颜色特性时，可以引入通道直方图（Channel Histogram），分别对 R/G/B 三个颜色通道进行直方图统计。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce2.png"></p><h2 id="对比度-contrast">对比度 Contrast</h2><p>图像对比度指的是一幅图像中最亮的白和最暗的黑之间灰度反差的大小。差异越大代表对比越大，否则对比越小。一种常用的定量度量方法是 Michelson 对比度，定义为</p><p><span class="math display">\[C_M = \frac{I_{Max} - I_{Min}}{I_{Max} + I_{Min}}\]</span></p><p>当一幅图像最白和最黑像素灰度都是 128 时，图像对比度最低，C=0。 当一幅图像最白像素灰度=255，最黑像素灰度=0 时，图像对比度最高，C=1.0。</p><h2 id="对比度拉伸-contrast-stretching">对比度拉伸 Contrast Stretching</h2><p>既然搞清楚了图像不通透的原因，就很容通过数学的方法将一个低对比度图像处理得更通透一些。一类简单有效的处理方法叫做对比度拉伸（Contrast Stretching），基本思想是用一个下图所示分段线性函数（Piece-Wise Linear, PWL Function）对像素亮度进行映射。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce3.png"></p><p>这种方法虽然简单，但是对很多低对比度图像能够收到相当好的效果。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce4.png"></p><p>对比度拉伸的局限：对比度拉伸适合处理低动态（LDR）图像，这类图像的特点是对比度低，直方图的跨度较小，存在向两极拉伸的空间。对于高动态（HDR）图像，直方图跨度已经很大，对比度拉伸没有操作的空间。</p><h1 id="直方图均衡化-histogram-equalization">直方图均衡化 Histogram Equalization</h1><p>直方图均衡化被认为是提升图像对比度最为有效的方法，它的基本思想是用数学方法重新调整像素的亮度分布，使调整后的直方图具有最大的动态范围，每个桶（bin/bucket）盛纳的像素数量几乎相等。</p><p>用数学语言描述，假设均衡前直方图的像素密度函数为 p(x)，每个桶的宽度为 dx，则每个桶的像素数量为 p(x)dx。假设均衡后像素密度函数为 p(y)，且 p(y) 为常数，不妨取 1。</p><p>直方图均衡的方法是 dy=p(x)dx，意义是将源直方图 dx 宽度所盛纳的 p(x)dx 个像素映射到目标直方图的 dy 宽度中，映射前后像素数量不变，密度发生变化，意义如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce5.png"></p><p>显然直方图均衡前后图像的总像素数量应保持不变，所以有约束方程</p><p><span class="math display">\[\int_{0}^{1}  p(x)dx = \int_{0}^{1} dy = 1\]</span></p><p>我们的最终目标是求解 x 与 y 的映射函数 y=f(x)，这个的问题并不困难，</p><p><span class="math display">\[y = f(x) = \int_{0}^{x}p(u)du = P(x) - P(0) = P(x) \]</span></p><p>这个公式可以理解为，x 对应的 y 值是原图上 0~x 这些像素的概率之和。原图中最大的 x 对应 y=1。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce6.png"></p><p>下面一组图显示了直方图均衡改善图像对比度的效果。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce7.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce8.png"></p><p>下图是对直方图拉伸和均衡两种方法的效果做比较。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce9.png"></p><h1 id="直方图均衡的局限">直方图均衡的局限</h1><p>朴素的直方图均衡算法对整幅图像的像素使用相同的变换公式，当图像像素值分布比较均衡时效果较好。如果图像的颜色比较集中，比如存在明显的暗区或亮区，则这些区域的处理效果会不太理想。</p><h2 id="分色问题">分色问题</h2><p>当原图的直方图比较集中时，这意味着原图实际上只出现了少数几个颜色值，如果对原图进行拉伸操作，则这些颜色之间的距离就会变大，直方图上留下了更多概率为 0 的空洞，这样，原本比较接近的颜色在拉伸后的图上会出现显著的差异，图像出现颜色分层现象（banding），或者叫分色现象。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce10.png"></p><h2 id="对齐问题">对齐问题</h2><p>直方图均衡的一个重要特征是把原图中最亮的像素对齐到预设的最大值（比如 8bit 图是 255）。当原图中颜色比较丰富时，这个操作一般问题不大。但是也会有有一些比较极端的情况，比如原图中所有像素都是一个值（例如 8，这对应一幅纯黑的图像，多半是拍摄于夜间），则均衡之后所有像素都被映射到 255，图像变成了纯白的。于是，直方图均衡相当于无脑改变了原图的色调，而不管这种改变是否合理。</p><h2 id="噪声问题">噪声问题</h2><p>直方图均衡算法一种常见的问题是放大暗区的噪声，其根源也是对齐问题。如果一个区域的像素分布大体是均匀的，但是图像中带有一些噪声，则 HE 变换函数会把原图中很窄的 x 值分布映射到整个 y 值空间，这同时也就放大了原图中的噪声。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce11.png"></p><h1 id="自适应直方图均衡-adaptive-histogram-equalizationahe">自适应直方图均衡 Adaptive Histogram Equalization（AHE)</h1><p>参考人类视觉的局部性原理，人们提出了自适应直方图均衡算法（AHE），基本思想是将图像分成若干个区域（tile），比如 8x8=64 个 tile，直方图均衡的基本单位不再是整个图像，而是对每个小区域做直方图均衡。AHE 更适合于用来改善图像的局部对比度，以及增强图像边缘信息，但是并没有解决直方图均衡会放大图像噪声的问题。</p><h2 id="限制对比度自适应直方图均衡-clahe">限制对比度自适应直方图均衡 CLAHE</h2><p>我们已经知道，如果原图中某些颜色的频率太高，挤占了其它颜色的机会，均衡后的图像就会出现颜色分层、色调异常、噪声过大等比较棘手的问题。</p><p>为了解决这些问题，一个显然的思路就是损有余而补不足，或者叫削峰填谷，把我们认为多余的概率平均分摊给其它像素，使亮度增益相对均匀地散布到所有像素上，而不是让某一个颜色突然地对齐到最大亮度。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce12.png"></p><p>按照这个思路设计的算法就是 Contrast Limited Adaptive Histogram Equalization。</p><p>回头再来分析那个黑图像被对齐到全白的例子。如果用 CLAHE 来处理这个黑图，我们可以拍脑袋规定直方图每个 bin 的频数不能超过总像素数的 50%，超过的部分要被均摊到各个 bin 中。根据这个规定，像素 x=8 被映射成</p><p>y=P(8)=0.5*255=128.</p><p>CLAHE 把 x=8 的频数强制分给了其它 X 值，但是由于原图中并不存在所谓的其它 X 值，所以这部分频数实际上就浪费了，目标图中除了 128 之外，根本不会出现别的像素值。</p><p>以下图为例，由于 CLAHE 人为削减了最亮像素的频数，所以 CLAHE 图的亮区得到了抑制，而暗区的亮度得到了明显的提升。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce13.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ce14.png"></p><p>如果仔细分析图像质量的话，这个图的绿植效果其实并不好，绿得很不自然，可能还不如原图的效果。其实原图的主要问题是亮部对比度不足，需要拉伸，而暗部的直方图分布是没有太大问题的，不调整也可以。</p><p>从这个例子我们发现，被强制裁掉的频数该如何分配仍然是一个可以讨论的话题。有的时候可能直接丢弃了会比较好，如果舍不得丢，也可以考虑优先分配给离本主比较近的像素。</p><p>当然，单纯地限制像素频数无助于解决颜色数量不够导致的分色问题。如果需要改善分色问题，则还要引入抖色（dither）之类的机制，让原本一个颜色随机地抖动变成一些相近的颜色，以填补直方图中的空洞。从视觉效果上看，抖色相对于在图像中主动添加噪声，而噪声会模糊两层颜色之间的边界，起到平滑过渡的作用。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNTAzODE5Mzc=">https://zhuanlan.zhihu.com/p/150381937<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP YUV 域之 HueAndSaturation</title>
      <link href="/next/2023/Camera/CameraISPYUVHueAndSaturation/"/>
      <url>/next/2023/Camera/CameraISPYUVHueAndSaturation/</url>
      
        <content type="html"><![CDATA[<h1 id="色调-hue">色调 Hue</h1><h2 id="hue-的定义">hue 的定义</h2><p>hue 可以理解为占主导地位的纯色颜色，或两种纯色颜色的组合。简单来说，hue 就是颜色的“名字”，人们最常用黄色、橙色等概念来描述一个颜色。 Hue is the color portion of the model, expressed as a number from 0 to 360 degrees. <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/hue1.png"></p><span id="more"></span><ul><li>Red: 0 and 60 degrees。</li><li>Yellow: 61 and 120 degrees。</li><li>Green: 121 and 180 degrees。</li><li>Cyan: 181 and 240 degrees。</li><li>Blue: 241 and 300 degrees。</li><li>Magenta: 301 and 360 degrees。</li></ul><h2 id="色调恒常-hue-constancy">色调恒常 Hue constancy</h2><p>描述一个颜色的三个参数是 hue, lightness, chroma (saturation)。</p><p>色调恒常是指，当颜色的 lightness/saturation 改变时，色调的感知（sensation）保持不变。否则就是发生了色调漂移（hue shift）。</p><p>Tint = 在白色（或高亮白光）中加入纯色。</p><p>Tone = 在灰色（或中等白光）中加入纯色。</p><p>Shade = 在黑色（或无光）中加入纯色。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/hue3.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/hue4.png"></p><h2 id="hsv-空间">HSV 空间</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/hsv1.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/hsv2.png"></p><h1 id="saturation">Saturation</h1><p>色饱和度是指彩色的纯度，即颜色掺入白光的程度，或指颜色的深浅程度。某彩色掺入的白光越多，其色饱和度就越低；掺入的白光越少，其色饱和度就越高。不掺入白光，即白光为零，则其色饱和度为 100 % ; 全为白光，则其色饱和度为零。</p><p>YCbCr 不是一种绝对色彩空间，是 YUV 压缩和偏移的版本。YCbCr 的 Y 与 YUV 中的 Y 含义一致，Cb 和 Cr 与 UV 同样都指色彩，Cb 指蓝色色度，Cr 指红色色度。在应用上很广泛，JPEG、MPEG、DVD、摄影机、数位电视等皆采此一格式。因此一般俗称的 YUV 大多是指 YCbCr。</p><p>在 YCbCr 空间来看，Cb 和 Cr 等于 128 时饱和度为 0，图像等效于灰度图。|Cr-128|和|Cr-128|越大则饱和度也越大，计算公式如下，</p><p><span class="math display">\[f(cb, s) = (cb - 128) * s + 128\]</span></p><p><span class="math display">\[f(cr, s) = (cr - 128) * s + 128\]</span></p><p>其中 s 即为饱和度系数，一般可以取 0~2，即允许一定程度的过饱和以增加颜色的鲜艳度。</p><p>论上饱和度调整也可以合并在 CCM 或 CSC 矩阵中，即饱和度调整与颜色校正 (CC) 和色彩空间变换 (CSC) 同步完成，所以在一些 ISP 设计中并不单独提供调整饱和度的步骤，这样做的好处是能够节省一个处理步骤，减少一个噪声来源。</p><p>合并 CCM、CSC 和饱和度的最终变换矩阵的过程如下，</p><p><span class="math display">\[\begin{pmatrix}Y \\Cb' \\Cr'\end{pmatrix} = \begin{pmatrix}1  &amp; 0 &amp; 0 \\0  &amp; s &amp; 0\\0  &amp; 0 &amp; s\end{pmatrix}\begin{pmatrix}Y \\Cb \\Cr\end{pmatrix} \]</span></p><p><span class="math display">\[\begin{pmatrix}Y \\Cb' \\Cr'\end{pmatrix} = \begin{pmatrix}1  &amp; 0 &amp; 0 \\0  &amp; s &amp; 0\\0  &amp; 0 &amp; s\end{pmatrix} \cdotC \cdot M \cdot \begin{pmatrix}R \\G \\B\end{pmatrix} \]</span></p><p><span class="math display">\[\begin{pmatrix}Y \\Cb' \\Cr'\end{pmatrix} = D \cdot \begin{pmatrix}R \\G \\B\end{pmatrix} \]</span></p><p>其中 Cb,Cr 均已调整为中心值位于 0，C 是从 RGB 空间变换到 YCbCr 空间的变换矩阵，M 为 CCM 矩阵，而 D 就是合并了饱和度和 CCM 的色彩还原矩阵。当系统需要调整饱和度或 CCM 时，控制软件会根据当前的饱和度和 CCM 参数重新计算色彩还原矩阵。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgzMjM2Ng==">https://zhuanlan.zhihu.com/p/98832366<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgzMzAzOA==">https://zhuanlan.zhihu.com/p/98833038<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDUxNzg1MTQ=">https://zhuanlan.zhihu.com/p/145178514<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP YUV 域之 EdgeEnhancement</title>
      <link href="/next/2023/Camera/CameraISPYUVEdgeEnhancement/"/>
      <url>/next/2023/Camera/CameraISPYUVEdgeEnhancement/</url>
      
        <content type="html"><![CDATA[<h1 id="retinex-理论">Retinex 理论</h1><p>Retinex 这个词由 Retina 和 Cortex 两个单词组成。在 Retinex 理论中，物体的颜色是由物体对长波、中波和短波光线的反射能力决定的，而不是由反射光强度的绝对值决定的，并且物体的色彩不受光照非均性的影响，具有一致性。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ee1.png"></p><span id="more"></span><p>在 Retinex 理论中，人眼得到的图像数据取决于入射光和物体表面对入射光的反射。如上图所示，I(x,y) 是我们最终得到的图像数据，先是由入射光照射，然后经由物体反射进入成像系统，最终形成我们所看到的图像。该过程可以用公式表示：</p><p><span class="math display">\[I(x,y) = R(x,y) \cdot  L(x,y)\]</span></p><p>其中，I(x,y) 代表被观察或照相机接收到的图像信号；L(x,y) 代表环境光的照射分量 ；R(x,y) 表示携带图像细节信息的目标物体的反射分量。将该式子两边取对数，可以得到物体原本的信息：</p><p><span class="math display">\[log[I(x,y)] = log[R(x,y)] - log[L(x,y)]\]</span></p><p>在图像处理领域，常将该理论用于图像增强，为了得到成像更好的图片。这时，R(x,y) 表示为图像增强得到后的图像，I(x,y) 为原始的图像。在处理过程中 L(x,y) 常为 I(x,y) 高通滤波之后的结果，也可以用其他滤波的方法，比如中值滤波，均值滤波等等。</p><h1 id="ssr-算法">SSR 算法</h1><p>SSR (Singal Scale Retinex)，即单尺度视网膜算法是 Retinex 算法中最基础的一个算法。运用的就是上面的方法，具体步骤如下：</p><ul><li>输入原始图像 I(x,y) 和滤波的半径范围 sigma。</li><li>计算原始图像 I(x,y) 高斯滤波后的结果，得到 L(x,y)。</li><li>按照公式计算，得到 Log[R(x,y)]。</li><li>将得到的结果量化为 [0, 255] 范围的像素值，然后输出结果图像。</li></ul><p>需要注意的是，最后一步量化的过程中，并不是将 Log[R(x,y)] 进行 Exp 化得到 R(x,y) 的结果，而是直接将 Log[R(x,y)] 的结果直接用如下公式进行量化：</p><p><span class="math display">\[R(x,y) = \frac{Value - Min}{Max - Min} * 255\]</span></p><p>将过程整合在一起就是如下过程：</p><p><span class="math display">\[R_{SSR_i}(x,y,\delta) = log(I_i(x,y)) - log(I_i(x,y) * G(x,y, \delta))\]</span></p><p>G(x,y) 代表高斯核，Retinex 算法是去掉光照的影响，还原图像的本来面目。</p><h1 id="msr-算法">MSR 算法</h1><p>MSR 是在 SSR 基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR 也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于 X 光图像增强。</p><p>为了得到更好的效果，人们又开发出所谓的多尺度视网膜增强算法（MSR， Multi-Scale Retinex），最为经典的就是 3 尺度的，大、中、小，既能实现图像动态范围的压缩，又能保持色感的一致性较好。同单尺度相比，该算法有在计算 Log[R(x,y)] 的值时步骤有所不同：</p><ul><li>需要对原始图像进行每个尺度的高斯模糊，得到模糊后的图像 Li(x,y), 其中小标 i 表示尺度数。</li><li>对每个尺度下进行累加计算。</li></ul><p>公式如下所示：</p><p><span class="math display">\[R_{MSR}(x,y,\delta) = \sum_{k=1}^{n}w_kR_{SSR_k}(x,y,\delta_k)   \]</span></p><p>其中 n 是尺度的数量，<span class="math inline">\(\delta = {\delta 1,\delta 2,...\delta n}\)</span> 是高斯模糊系数的向量，<span class="math inline">\(w_k\)</span> 是与第 k 个尺度相关的权重，其中 <span class="math inline">\(w_1 + w_2 + ... w_n = 1\)</span></p><h1 id="msrcr-算法">MSRCR 算法</h1><p>由于 R 是对数域的输出，要转换为数字图像，必须将他们量化为 [0,255] 的数字图像范畴，关于这个量化的算法，有这极为重要的意义，他的好坏直接决定了最终输出的图像的品质。目前，结合上述文章中提出的一些过程，有 4 种方式进行处理：</p><ul><li><p>直接线性量化，即采用下式进行处理。 <span class="math display">\[  R_{MSRCR_i}(x,y) = \frac{R_{MSRCR_i}(x,y) - Min(R_{MSRCR_i}(x,y))}{Max(R_{MSRCR_i}(x,y)) -  Min(R_{MSRCR_i}(x,y))} * 255  \]</span></p></li><li><p>在经典的 MSRCR 文章《A Multiscale Retinex for Bridging the Gap Between Color Images and the Human Observation of Scenes》中提出的 Canonical Gain/set 算法。 <span class="math display">\[ R_{MSRCR_i}(x,y) = G[R_{MSRCR_i}(x,y) - b] \]</span> 其中 G 和 b 为经验参数。</p></li><li><p>种方式的处理类似于 Photoshop 中的自动色阶，他把数据按照一定的百分比去除最小和最大的部分，然后中间的部分重新线性量化到 0 和 255 之间。</p></li></ul><p>在用第二种或第三种方式处理时，最好还需要有个 Color Restoration 的过程，因为如果直接对 MSR 处理的结果进行量化，得到的图像往往整体偏灰度，这是由于原始的彩色值经过 log 处理后的数据范围就比较小了，这样各通道之间的差异也很小，而之后的线性量化比 log 曲线要平滑很多，因此整体就丧失了彩色。论文中提出了修正方式如下：</p><p><span class="math display">\[I_{i}^{'}(x,y) = \frac{I_{i}(x,y)}{ {\textstyle \sum_{j=1}^{S}} I_{j}(x,y)} \]</span></p><p><span class="math display">\[C_i(x,y) = \beta log[\alpha I_{i}^{'}(x,y)]\]</span></p><p><span class="math display">\[R_{MSRCR_i}(x,y) = C_i(x,y)R_{MSR_i}(x,y)\]</span></p><p>对于一些原始图像 HUE 较为合理的图，如果用经典的 MSRCR 算法，会导致处理后的图容易偏色，上述论文提出了对图像的 Intensity 数据进行 Retinex 处理，然后再把数据根据原始的 RGB 的比例映射到每个通道，这样就能在保留原始颜色分布的基础上增强图像，文章中称其为 MSRCP。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6MDQ5OS9hcnRpY2xlL2RldGFpbHMvODExNTQ5Mzc=">https://blog.csdn.net/lz0499/article/details/81154937<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDIyMzY0">https://cloud.tencent.com/developer/article/1422364<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSW1hZ2VzaG9wL2FyY2hpdmUvMjAxMy8wNC8xNy8zMDI2ODgxLmh0bWw=">https://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP Raw 域之 BayerDemosaic</title>
      <link href="/next/2023/Camera/CameraISPRawBayerDemosaic/"/>
      <url>/next/2023/Camera/CameraISPRawBayerDemosaic/</url>
      
        <content type="html"><![CDATA[<h1 id="bayer-demosaic-概述">Bayer Demosaic 概述</h1><p>RAW 域的最后一步处理是 Demosaic，将像素从 RAW 域变换到 RGB 域进行下一阶段的处理。Demosaic 算法的主要难点在于，RAW 域的任何一个像点（photosite）只包含一个真实的采样值，而构成像素（R,G,B）的其它两个值需要从周围像点中预测得到。既然是预测，就一定会发生预测不准的情况，这是不可避免的，而预测不准会带来多种负面影响，包括拉链效应（zipper artifacts），边缘模糊，颜色误差等。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline18.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline19.png"></p><span id="more"></span><p>所以 Demosaic 算法的主要挑战就是尽量提高算法的准确性，减少图像边缘损失和颜色误差。</p><p>Bayer 格式图像色彩恢复时有两种思路：</p><ul><li>无方向性插值：不加边缘方向判断（思路：临近像素的均值），直接利用周围像素信息恢复。</li><li>有方向性插值：先判断边缘方向，再利用周围像素信息恢复。</li></ul><p>Bayer 格式图像的绿色成分占比例较多，信息较丰富，色彩恢复时步骤通常是：a、先恢复 G 通道；b、再利用 G 通道信息恢复 R、B 通道。</p><h1 id="cfa-双线性插值">CFA 双线性插值</h1><h2 id="无边缘检测">无边缘检测</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/dm1.png"></p><ul><li><p>绿色像素上的 R，B 值分别由相邻的 2 个 R，B 像素的灰度求平均值得到。 以象素点 (2，3) 为例，即已知 G23 该点的 R，B 值计算公式如下： <span class="math display">\[  R_{23} = \frac{R_{13} + R_{33}}{2}  \]</span> B_{23} =  $$</p></li><li><p>红、蓝像素上的 G 值由相邻的 4 个绿色像素求平均值得到。 如图中象素点 (3，3) 和 (4，4)，即已知 R33 和 B44 这两点的绿色分量值表示为 <span class="math display">\[  G_{33} = \frac{G_{23} + G_{43} + G_{32} + G_{34}}{4}  \]</span></p><p><span class="math display">\[  G_{44} = \frac{G_{34} + G_{54} + G_{43} + G_{45}}{4}  \]</span></p></li><li><p>红色像素上的 B 值由对角线上相邻的 4 个 B 像素平均得到。象素点 (3，3) ，R33 的 B 值表示为。 <span class="math display">\[  B_{33} = \frac{B_{22} + B_{24} + B_{42} + B{44}}{4}  \]</span> 蓝色像素上的 R 值由对角线上相邻的 4 个 R 像素平均得到。象素点 (4，4)，B44 的 R 值表示为 <span class="math display">\[  R_{44} = \frac{R_{33} + R_{35} + R_{53} + R_{55}}{4}  \]</span></p></li></ul><p>边缘检测，直接采用最近临同色像素的均值求解，图像边缘不够清晰，算法简单。</p><h2 id="基于边缘检测和色差的-cfa-插值hibbard-原理">基于边缘检测和色差的 CFA 插值：Hibbard 原理</h2><p>G 分量的恢复加入了相邻 G 通道的一阶微分方向判断因子。使用周围 G 通道值信息。</p><ul><li><p>恢复采样点 R 和 B 点的绿色分量：例 B44。 梯度因子：水平方向 H <span class="math display">\[  \alpha = \left | G_{43} - G_{45} \right |   \]</span> 竖直方向 W： <span class="math display">\[  \beta = \left | G_{34} - G_{54} \right |   \]</span> 变化小的方向可能是边缘，所以 G44 表示如下： <span class="math display">\[  G_{44} = \frac{G_{43} + G_{45}}{2} (\alpha &lt; \beta)  \]</span> G_{44} =  (&gt; ) <span class="math display">\[  G_{44} = \frac{G_{34} + G_{54} + G_{43} + G_{45}}{4} (\alpha = \beta)  \]</span></p></li><li><p>对 R、B 分量插值。基本思想是在图片的小平滑区域内，色差恒定的。假设像素点 P(i，j) 邻近的一个像素点是 P(m，n) 则有： <span class="math display">\[  R_{ij} - G_{ij} = R_{mn} - G_{mn} \\  B_{ij} - G_{ij} = B_{mn} - G_{mn}  \]</span> 例求 R 分量： 如已知 G43，红色分量表达式： <span class="math display">\[  R_{43} = \frac{R_{33} + R_{35}}{2} - \frac{G_{33} + G_{35}}{2} + G_{43}  \]</span> 如已知 G34，红色分量表达式： <span class="math display">\[  R_{34} = \frac{R_{33} + R_{35}}{2} - \frac{G_{33} + G_{35}}{2} + G_{34}  \]</span> 如已知 B44，红色分量表达式： <span class="math display">\[  R_{44} = \frac{R_{33} + R_{35} + R_{53} + R_{55}}{4} - \frac{G_{33} + G_{35} + G_{53} + G_{55}}{4} + G_{44}  \]</span> 例求 B 分量：如已知 G43，蓝色分量表达式： <span class="math display">\[  B_{43} = \frac{B_{24} + B_{44}}{2} - \frac{G_{24} + G_{44}}{2} + G_{34}  \]</span> 如已知 R33，蓝色分量表达式： <span class="math display">\[  B_{33} = \frac{B_{22} + B_{24} + B_{42} + B_{44}}{4} - \frac{G_{22} + G_{24} + G_{42} + G_{44}}{4} + G_{33}  \]</span></p></li></ul><p>G 通道有边缘检测采用相邻 G，恢复无色差、色度信息，R、B 通道无边缘检测，恢复采用色差信息。效果接近原始图，算法难度适中。</p><h2 id="基于边缘检测和色差的-cfa-插值laroche-原理">基于边缘检测和色差的 CFA 插值：laroche 原理</h2><p>G 分量的恢复改用相邻 R 或 B 通道的二阶微分方向判断因子；恢复时使用相邻 G 通道信息。 R、B 分量的恢复同 Hibbard 使用色差原理。</p><ul><li><p>恢复采样点 R 和 B 点的绿色分量：例 B44。 梯度因子：水平方向 H： <span class="math display">\[  \alpha = \left | 2 * B_{44} - B_{42} - B_{46} \right |   \]</span> 竖直方向 W: <span class="math display">\[  \beta = \left | 2 * B_{44} - B_{24} - B_{64} \right |   \]</span> 变化小的方向可能是边缘，所以 G44 表示如下： <span class="math display">\[  G_{44} = \frac{G_{43} + G_{45}}{2} (\alpha &lt; \beta)  \]</span></p><p><span class="math display">\[  G_{44} = \frac{G_{34} + G_{54}}{2}  (\alpha &gt; \beta)  \]</span></p><p><span class="math display">\[  G_{44} = \frac{G_{34} + G_{54} + G{43} + G_{45}}{4} (\alpha = \beta)  \]</span> 其他像素插值方法同 Hibbard。</p></li></ul><p>G 通道有边缘检测采用相邻 B 色度信息，恢复用均值无色差信息、色度信息，R、B 通道无边缘检测，恢复采用色差信息。效果接近原始图，算法难度适中。</p><h2 id="基于边缘色度和色差自适应插值">基于边缘、色度和色差自适应插值</h2><p>G 分量的恢复改用相邻 R 或 B 的二阶微分加 G 通道的一阶微分方向判断因子；R、B 分量的恢复使用了色差原理。</p><ul><li><p>恢复绿色分量 G。 已知 B44, 水平方向梯度和色度算子： <span class="math display">\[  \alpha = \left | 2 * B_{44} - B_{42} - B_{46} \right |  + \left | G_{43} - G_{45} \right |   \]</span> 已知 B44, 竖直方向梯度和色度算子： <span class="math display">\[  \beta = \left | 2 * B_{44} - B_{24} - B_{64} \right |  + \left | G_{34} - G_{54} \right |   \]</span> G 值公式： <span class="math display">\[  \begin{equation}  G_{44}= \begin{cases}\frac{G_{43}+G_{45}}{2}+\frac{2 * B_{44}-B_{42}-B_{46}}{4} &amp;   \alpha&lt;\beta \\ \frac{G_{34}+G_{54}}{2}+\frac{2 * B_{44}-B_{24}-B_{64}}{4} &amp; \alpha&gt;\beta     \\ \frac{G_{34}+G_{43}+G_{45}+G_{54}}{4}+\frac{4 * B_{44}-B_{24}-B_{42}-B_{46}-B_{64}}  {8} &amp; \alpha=\beta\end{cases}  \end{equation}  \]</span> 已知 R33, 水平方向梯度和色度算子： <span class="math display">\[  \alpha = \left |  2* R_{33} - R_{31} - R_{35}   \right | +  \left |   G_{32} - G_{34}   \right |   \]</span> 已知 R33, 竖直方向梯度和色度算子： <span class="math display">\[  \beta = \left | 2 * R_{33} - R_{13} - R_{53}  \right |  + \left |   G_{23} - G_{43}   \right |   \]</span> G 值公式： <span class="math display">\[  \begin{equation}  G_{33}= \begin{cases}\frac{G_{32}+G_{34}}{2}+\frac{ 2*R_{33} - R_{31} - R_{35}}{4} &amp;   \alpha&lt;\beta \\ \frac{G_{23}+G_{43}}{2}+\frac{2 * R_{33}-R_{13}-R_{53}}{4} &amp; \alpha&gt;\beta     \\ \frac{G_{32}+G_{34}+G_{23}+G_{43}}{4}+\frac{4 * R_{33}-R_{31}-R_{35}-R_{13}-R_{53}}  {8} &amp; \alpha=\beta\end{cases}  \end{equation}  \]</span></p></li><li><p>若已知 R33，求 B33。 B 分量的恢复采用相邻 G 的二阶微分加 B 通道的一阶微分方向判断因子；B 分量的恢复使用了色差原理 先求对角线方向的梯度和色度算子 <span class="math display">\[  \alpha = \left |  2 * G_{33} - G_{24} - G{42}  \right |  + \left | B_{24 - B_{42}} \right |   \]</span> = | 2 * G_{33} - G_{22} - G_{44} | + | B_{22} - B_{44} | <span class="math display">\[  B 分量表达式：  \]</span> <span class="math display">\[\begin{equation}  B_{33}= \begin{cases}\frac{B_{24}+B_{42}}{2} - \frac{G_{24}+G_{42}}{2} + G_{33} &amp;   \alpha&lt;\beta \\ \frac{B_{22}+B_{44}}{2} - \frac{G_{22} + G_{44}}{2} + G_{33} &amp;  \alpha&gt;\beta     \\ \frac{B_{22}+B_{24}+B_{42}+B_{44}}{4} - \frac{ G_{22}+G_{24}+G_{42}+G_{44}}  {4} + G_{33} &amp; \alpha=\beta\end{cases}  \end{equation}\]</span> $$</p></li><li><p>已知 B44，求 R44。 先求对角线方向的梯度和色度算子 R 分量的恢复采用相邻 G 的二阶微分加 R 通道的一阶微分方向判断因子；R 分量的恢复使用了色差原理。 <span class="math display">\[  \alpha = \left |  2 * G_{44} - G_{35} - G{53}  \right |  + \left | R_{35} - R_{53} \right |   \]</span> = | 2 * G_{44} - G_{33} - G_{55} | + | B_{33} - B_{55} | <span class="math display">\[  R 分量表达式：  \]</span> <span class="math display">\[\begin{equation}  B_{44}= \begin{cases}\frac{R_{35}+R_{53}}{2} - \frac{G_{35}+G_{53}}{2} + G_{44} &amp;   \alpha&lt;\beta \\ \frac{R_{33}+R_{55}}{2} - \frac{G_{35} + G_{55}}{2} + G_{44} &amp;  \alpha&gt;\beta     \\ \frac{R_{35}+R_{53}+R_{33}+R_{55}}{4} - \frac{ G_{35}+G_{53}+G_{33}+G_{55}}  {4} + G_{44} &amp; \alpha=\beta\end{cases}  \end{equation}\]</span> $$</p></li><li><p>如已知 G43。 红色分量表达式： <span class="math display">\[  R_{43} = \frac{R_{33} + R_{53}}{2} - \frac{G_{33} + G_{53}}{2} + G_{43}  \]</span> 蓝色分量表达式： <span class="math display">\[  B_{43} = \frac{B_{42} + B_{44}}{2} - \frac{G_{42} + G_{44}}{2} + G_{43}  \]</span></p></li><li><p>如已知 G34。 红色分量表达式： <span class="math display">\[  R_{34} = \frac{R_{33} + R{35}}{2} -  \frac{G_{33} + G_{35}}{2} + G_{34}  \]</span> 蓝色分量表达式： <span class="math display">\[  B_{34} = \frac{B_{24} + B_{44}}{2} - \frac{G_{24} + G_{44}}{2} + G_{34}  \]</span></p></li></ul><p>R、G、B 通道分别进行了边缘检测，颜色恢复时采用了色差信息及其他通道的信息。效果接近原始图，算法难度较大。</p><h2 id="基于边缘色度和色差自适应插值之标志位减少-false-color">基于边缘、色度和色差自适应插值之标志位：减少 False color</h2><p>G 分量的恢复改用相邻 R 或 B 的二阶微分加 G 通道的一阶微分方向判断因子；并采用标志因子的统计，R、B 分量的恢复使用了色差原理。</p><ul><li>对每个像素计算水平和垂直方向梯度和色度算子。</li><li>比较两个方向的算子大小，用 0 或 1 标记。</li><li>统计局部区域内如 3x3 窗口统计邻域九个位置的 flag 之和即 total_flag。</li><li>设置阈值，判断该像素在局部区域内最可能的方向。</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/dm2.png"></p><p>对于图 (a): 已知 B5 水平方向方向算子：</p><p><span class="math display">\[G_{h} = \left |   G_4 - G_6  \right |  + \left |  2 * B_5 - B_3 - B_7  \right | \]</span></p><p>竖直方向方向算子： <span class="math display">\[G_{v} = \left |   G_2 - G_8  \right |  + \left |  2 * B_5 - B_1 - B_9  \right | \]</span> 方向梯度算子非固定 标志位： flag=1，<span class="math inline">\(G_h&lt;G_v\)</span> ; flag=0，else <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/dm3.png"></p><p>对于图 (b): 已知 G5（G43） 水平方向方向算子：</p><p><span class="math display">\[G_h = \left | 2*G_5 - G_{12} - G_{13} \right |   + \left | G_1 - G_3   \right | + \left | G_7 - G_9   \right |\]</span></p><p>竖直方向方向算子： <span class="math display">\[G_v = \left | 2*G_5 - G_{10} - G_{11} \right |   + \left | G_1 - G_7   \right | + \left | G_3 - G_9   \right |\]</span></p><p>标志位： flag=1，Gh&lt;Gv; flag=0，else 已知 G34 和 R33，flag 计算方法同理。</p><p><strong>根据阈值判断方向的方法：</strong></p><p>对于 B 和 R 位置，取 3x3 窗口，统计邻域九个位置的 flag 之和即 total_flag，在 [0.9] 之间，越大水平方向边界可能性越大，越小竖直方向为边界可能性越大。</p><p>取 high_thresh 和 low_thresh，判断边界方向。</p><p>total_flag &gt; = high_thresh，水平方向存在边界，插值沿水平方向进行；</p><p>total_flag =&lt; low_thresh，竖直方向存在边界，插值沿竖直方向进行；</p><p>low_thresh &lt; total_flag &lt; high_thresh，为平滑区域，插值在整个区域进行；</p><p>经验值， high_thresh 和 low_thresh 取 7 和 3.</p><p>插值方法同上。</p><blockquote><p>有局部区域内边缘方向的整体判断，使得边缘方向判断更加准确。</p></blockquote><p>CFA 插值，还有其他一些比较经典的算法：基于色比的算法；2003 年提出的 Lu 算法；基于权重的 CFA 插值算法；去 False color 的改进算法；其他一些在此基础上改进的算法等等</p><p><strong>插值评价方法：</strong> 取一张 RGB 三色图像，按照 Bayer 格式取出对应的像素，构成 Bayer 格式图，然后经过 CFA 插值算法插值形成插值后图像。</p><p>评价参数：</p><ul><li>颜色均方误差（CMSE）：插值前与插值后图像的对应像素间的差值（绝对值，方差值）之和的平均值。越小越重建接近原图，重建质量越高。</li></ul><p><span class="math display">\[\begin{equation}C M S E=\frac{1}{3 H W} \sum_{k=R, G, B} \sum_{i=1}^H \sum_{j=1}^W\left(I_o(i, j) k-I_d(i, j) k\right)^2\end{equation}\]</span></p><ul><li>例颜色峰值信噪比（Color Peak Signal to Noise Ratio ,CPSNR）：越大越重建接近原图，重建质量越高。</li></ul><p><span class="math display">\[CPSNR = 10 log_{10}(\frac{255^2}{CMSE})\]</span></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgyMDkyNw==">https://zhuanlan.zhihu.com/p/98820927<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDYyNjYyMA==">https://zhuanlan.zhihu.com/p/40626620<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISPRaw 域之 LSC</title>
      <link href="/next/2023/Camera/CameraISPRawLSC/"/>
      <url>/next/2023/Camera/CameraISPRawLSC/</url>
      
        <content type="html"><![CDATA[<h1 id="镜头阴影校正-lsc">镜头阴影校正 LSC</h1><p>镜头阴影有两种表现形式，分别是</p><ul><li>Luma shading，又称 vignetting，指由于镜头通光量从中心向边缘逐渐衰减导致画面边缘亮度变暗的现象。</li><li>Chroma shading，指由于镜头对不同波长的光线折射率不同引起焦平面位置分离导致图像出现伪彩的现象。</li></ul><span id="more"></span><h2 id="vignetting-原理">Vignetting 原理</h2><p>画面边缘镜头能量衰减： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline9.png"></p><p>如上图所示，由于镜头中都会存在多处光阑，当入射光线偏离光轴角度较大时，部分光线就会被光阑遮挡而不能参与成像，因此越靠近 sensor 边缘的像素接收到的曝光量就越低。</p><p>边缘像素微透镜和感光面的错位： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline10.png"></p><p>这个问题在手机 sensor 上通常会更严重一些，因此设计手机 sensor 的厂家会采取一些特定的方法去缓解这个问题。一种常用的方法是在微透镜上做文章，即从中心像素开始，微透镜的尺寸略小于感光面的面积一点点，这样越往边缘微透镜与感光面之间的错位就越大，刚好可以补偿入射光线角度增大导致的焦点偏移，使光线可以更好地聚焦到感光面上，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline11.png"></p><p>不过深入研究会发现，这个补偿办法其实也是有局限的，如果 sensor 采用的是下图左所示的 FSI 工艺（前照式），从像素微观结构来看，当入射光线角度比较大时，会有较多光线与像素中的金属布线层发生吸收、散射从而产生损失，单纯移动微透镜的位置并不能有效解决这个问题。但是，如果像素采用的是右图所示的 BSI 工艺（背照式），因为布线层在硅片的另外一侧，所以光线损失会少，补偿效果更加有效。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline12.png"></p><p>Vigetting 是由镜头引起的现象，所以 LSC 校正也是针对特定镜头的。若果产品的适配镜头发生变化，原则上需要重新进行 LSC 校正。</p><p>另外，Vigetting 现象在 sensor 靶面较大、镜头焦距较短时表现更加明显。采用非球面镜头通常可以改善 vignetting。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline13.png"></p><h2 id="chroma-shading-原理">Chroma shading 原理</h2><p>镜头对不同波长的光线折射率不同会导致色差问题，即不同波长的焦点在空间上不重合，导致焦平面分裂为三个不完全重合的曲面，这会破坏图像的白平衡，使图像出现伪彩，如下图所示。根据 sensor 所处的前后位置不同，伪彩可能偏红也可能偏蓝。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline14.png"></p><p>Chroma shading 一般主要通过镜头选型来控制其影响。如果 ISP 支持 chroma shading 校正，则可以通过标定三个颜色平面的增益来修正。为了控制标定表格的存储空间，通常只标定 MxN 个关键点，任意位置处的像素增益可以使用相邻四个标定关键点通过双线性插值的方法动态计算得到。在一个典型的 ISP 实现中，可以取 M=N=17 即可得到令人满意的效果。</p><h1 id="矫正方法">矫正方法</h1><p>LSC 的本值就是能量有衰减，反过来为了矫正就用该点的像素值乘以一个 gain 值，让其恢复到衰减前的状态，所以矫正的本质就是找到这个 gain 值。</p><p>从目前的矫正方法来看个人觉得可以分成三大类：</p><ul><li>储存增益法。</li><li>多项式拟合法。</li><li>自动矫正法。</li></ul><p>目前方法 1 和方法 2 是使用最多的。</p><h2 id="储存增益法">储存增益法</h2><h3 id="radial-shading-correct">radial shading correct</h3><p>上面有提到衰减符合 cos(θ) 的四次方规律，而θ在三维空间对各个方向是一致的，所以各个方向的衰减如下图 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lsc1.png"></p><p>图中相同颜色可以理解成亮度是一样的，也就是图中红色一圈圈的像素需要的增益是一样的，所以就可以用半径为变量来求出不同半径像素需要的增益。然后把半径对应的增益值储存在内存中，到了要用的时候再拿出来用，从而完成矫正。但是不可能把所有像素的半径都存储起来，所以就通过采样的方式提取特征半径的增益存储到内存，然后其他半径对应的增益在矫正的时候通过插值算法求出来。这种方式对内存的硬件要求就低了。这就是 radial shading correct。</p><h3 id="mesh-shading-correct">mesh shading correct</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lsc2.png"></p><p>和半径不同，这种方式是把整幅图像分成 n*n 个网格，然后针对网格顶点求出矫正的增益，然后把这些顶点的增益储存到内存中，同理其他的点的增益也是通过插值的方式求出。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lsc3.png"></p><p>如图是上图分成网格后，每个网格亮度的分布，可以看出和 cos(θ) 的四次方很接近，然后针对这样的网格亮度求出增益如下图，刚好和亮度分布相反 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lsc4.png"></p><h2 id="多项式拟合">多项式拟合</h2><p>多项式拟合的方式就是用半径为采样点，然后把这些采样点通过高次拟合的方式拟合成一个高次曲线，然后把高次曲线的参数储存起来，用的时候把半径带入公式就能求出对应的 gain 值用于矫正。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgyMDkyNw==">https://zhuanlan.zhihu.com/p/98820927<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODkzMzQyNjk=">https://zhuanlan.zhihu.com/p/389334269<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP Raw 域之降噪</title>
      <link href="/next/2023/Camera/CameraISPRawNoiseReduction/"/>
      <url>/next/2023/Camera/CameraISPRawNoiseReduction/</url>
      
        <content type="html"><![CDATA[<h1 id="raw-域降噪的原因">Raw 域降噪的原因</h1><h2 id="sensor-本身的噪声">Sensor 本身的噪声</h2><p>Sensor 输出的 RAW 图像本身是携带了噪声的，前面提到过 sensor 噪声的种类主要包括热噪声、光散粒噪声、读出噪声、固定模式噪声等。当 sensor 温度较高、增益较大、环境较暗的情况下各种噪声会变得更加明显，成为影响图像质量的主要因素。</p><span id="more"></span><h2 id="lsclens-shading-correction-对噪声的影响">LSC（Lens shading correction） 对噪声的影响</h2><p>除了 Sensor 图像本身携带的噪声之外，图像每次会经过 ISP 模块的处理之后都会引入一些新的噪声，或者对原有噪声进行了放大。以 LSC 模块为例，LSC 校正的实质是在输入图像上乘以一个与像素位置有关的增益系数以补偿光信号的衰减，而补偿的规律是越远离图像中心的地方增益越大。由于 ISP 所用乘法器的精度是有限的，每做一次乘法就会重新引入一次截断误差，这是新增的噪声来源，所以经 LSC 处理后图像的整体噪声水平会有所增加，而且在图像的边缘处表现会更加明显，典型的效果如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline16.png"></p><p>Shading 固然是不好的，需要校正，但是为了校正 shading 而给图像引入噪声同样也不好的，所以人们需要权衡在多大程度上校正 shading 能够收到满意的效果。这是在主观图像质量调试阶段需要考虑的问题之一。</p><h2 id="最后">最后</h2><p>噪声在 ISP 流水线各模块中会不断产生、传播、放大、改变统计特性，对图像质量的影响会越来越大，而且越来越不容易控制。因此处理噪声的基本原则是越早越好，随时产生随时处理，尽可能将问题消灭在萌芽状态。目前主流的 ISP 产品中一般会选择在 RAW 域、RGB 域、YUV 域等多个环节设置降噪模块以控制不同类型和特性的噪声。在 YUV 域降噪的方法已经得到了广泛的研究并且出现了很多非常有效的算法，但是在 RAW 域进行降噪则因为 RAW 数据本身的一些特点而受到不少限制。主要的限制是 RAW 图像中相邻的像素点分别隶属于不同的颜色通道，所以相邻像素之间的相关性较弱，不具备传统意义上的像素平滑性，所以很多基于灰度图像的降噪算法都不能直接使用。又因为 RAW 数据每个像素点只含有一个颜色通道的信息，所以很多针对彩色图像的降噪算法也不适用。</p><h1 id="频域滤波器">频域滤波器</h1><p>意法半导体的算法专家们提出了一种基于频域变换的方法，基本思想是将使用 8x8 大小的 DCT 变换将小块图像变换到频域，然后对频率分量进行分析：</p><ul><li>如果 DCT 变换后非零系数很少，且能量集中在低频，说明是平坦区域，应加强降噪力度。</li><li>如果两个相邻的 DCT 单元具备相同或相近的直流分量，则说明是平坦区域，应加强降噪力度。</li><li>如果某个方向（水平、垂直、对角）上存在明显占优的系数，则说明存在强边缘，应避免降噪。</li><li>如果某两个方向上存在占优的系数，则说明存在弱边缘，应进行中等强度的降噪。</li><li>如果很多方向上都有非零的系数，但又没有明显的优势系数，此时可能是纹理与噪声并存的情况，需要一定强度的滤波，削弱高频成分。</li></ul><p>详细可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzZWFyY2hnYXRlLm5ldC9wdWJsaWNhdGlvbi8yMjA1MzkxMzdfQ2hyb21hX05vaXNlX1JlZHVjdGlvbl9pbl9EQ1RfRG9tYWluX1VzaW5nX1NvZnQtVGhyZXNob2xkaW5n">https://www.researchgate.net/publication/220539137_Chroma_Noise_Reduction_in_DCT_Domain_Using_Soft-Thresholding<i class="fa fa-external-link-alt"></i></span></p><h1 id="空域滤波器spatial-filter">空域滤波器（Spatial Filter）</h1><p>空域降噪是一种 2D 降噪方法，它只处理一帧图像内部的噪声，主要方法是使用空域滤波器对图像进行滤波。滤波操作通常是针对以某个像素为中心的滤波窗口上进行的，滤波窗口的大小与具体的算法有关，常用的大小有 3x3、5x5、7x7 等尺寸。滤波操作在数学上称为卷积，需要使用一个与滤波窗口大小一致的卷积核，卷积核的每个元素代表一个权重，与对应位置的图像像素值相乘，然后所有乘积累加到一起就是滤波后的结果。</p><p>卷积滤波用公式表示是，</p><p><span class="math display">\[g(x,y) = \sum_{s=-a}^{a}\sum_{t=-b}^{b}w(s,t)f(x+s,y+t)  \]</span></p><p>下面是卷积滤波操作的示意图。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline15.png"></p><ul><li>经典低通滤波器，如均值滤波、中值滤波、高斯滤波、维纳滤波等。这类方法的优点是比较简单，占用资源少，速度快，缺点是滤波器是各向同性的，容易破坏图像中的边缘。另外由于没有考虑颜色通道之间的相关性所以也容易引入伪彩等噪声，而人眼对这种颜色噪声是比较敏感的。</li><li>改进的经典滤波器，如 Eplison 滤波、双边滤波 (bilateral filter)，在经典滤波器的基础上增加了阈值检测用于区分同类像素和异类像素，同类像素分配较大的滤波权重，异类像素则权重很小因而基本不参与滤波。这类方法的优点是可以有效地保护图像边缘，复杂度增加也不大，其它特点与经典滤波器基本相同。</li></ul><h1 id="时域降噪temporal">时域降噪（Temporal）</h1><p>时域降噪是一种 3D 降噪方法，它的主要思想是利用多帧图像在时间上的相关性实现降噪。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr30.png"></p><p>一种最简单的实现方法是时域均值滤波，即将相邻几帧图像做加权平均。由于累加后噪声的增长速度（根号关系）小于信号的增长速度（线性关系），所以图像的信噪比会提高。这种方法的主要问题在于只适合处理静态图像，如果画面中存在运动的物体则会出现伪影（ghost effect）。</p><h2 id="运动适应降噪-motion-adaptive-noise-filter">运动适应降噪 Motion Adaptive Noise Filter</h2><p>对基本的时域降噪进行一些改造就可以得到一种自适应降噪算法。假设图像中坐标 (x,y) 处的像素值为 P(x,y)， 新一帧中同位置像素值为 P'(x,y)，如果两个像素值的差异小于某阈值，即|P'-P|&lt;threshold， 则可以用 P 代替 P'。这种方法对静止的图像效果非常明显。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr31.png"></p><p>假设 <span class="math inline">\(\hat{g}(i,j,k)\)</span> 代表有噪声的视频信号序列，其中 (i,j) 代表像素坐标，k 代表时间序列，则 <span class="math inline">\(\hat{g}(i,j,k)\)</span> 可以表示为真实信号 <span class="math inline">\(\hat{f} (i,j,k)\)</span> 和噪声信号 <span class="math inline">\(\hat{n} (i,j,k)\)</span> 的叠加形式：</p><p><span class="math display">\[\hat{g}(i,j,k) = \hat{f}(i,j,k) + \hat{n}(i,j,k)\]</span></p><p>真实信号 f (i,j,k) 当然是不可能知道的，只能用某种方法对其进行估计。一种经典的估计方法是采用以下非线性滤波器：</p><p><span class="math display">\[\hat{f} (k) = \hat{f}(k-1) + \alpha [\hat{g}(k) - \hat{f}(k-1)]\]</span></p><p>其中 <span class="math inline">\(\hat{f}(k)\)</span> 代表第 k 帧图像，它的来源是在第 k-1 帧图像的基础上叠加了 g(k) 与 <span class="math inline">\(\hat{f}(k-1)\)</span> 的差值成分，即 <span class="math inline">\(∆= α(k)|\hat{g}(k)-\hat{f}(k-1)|\)</span> ，其中α(k) 是与∆相关联的阻尼系数。</p><ul><li>当∆ &lt; thres0 时判断为噪声，采用α(k)=0。</li><li>当∆ &gt; thres1 时判断为真实信号，采用取α(k)=1。</li><li>当 thres0 &lt; ∆ &lt; thres1 时α(k) 介于 0 和 1 之间。</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr32.png"></p><p>当然，这种方法的局限也是很明显的，一方面阈值的选取需要能够有效地区分噪声与画面变化，这本身不是一件很容易的事情；另一方面当像素变化超过阈值后此方法就失效了，因此画面前景部分的噪声处于逍遥法外的状态，这也是一个问题。</p><p>因此，一个理想的滤波器应该同时满足几个特征，即</p><ul><li>能够有效地区分画面的前景（运动目标）和背景（不动目标）。</li><li>对画面中的前景像素进行空域降噪。</li><li>对画面中的背景像素进行时域降噪。</li></ul><h1 id="空域时域降噪stnr">空域时域降噪（STNR）</h1><p>STNR 是一种 2D+3D 降噪方法，它通过一套算法判别一个像素是属于前景还是背景，被判决为背景的像素将会参与时域平滑，被判决为前景的像素将会参与空域平滑，而判决条件则每一帧都在动态更新，以尽可能保证判决准确性。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr33.png"></p><h2 id="光流法-optical-flow">光流法 Optical Flow</h2><p>假设前一帧时间为 t， 后一帧时间为 t+δt。在理想情况下（δt 很小，在δt 时间内图像亮度保持稳定，物体运动速度不大，并且不会突然消失或被遮挡），则前一帧 I 的像素点 I(x, y, z, t) 在后一帧中的位置为 I(x+δx, y+δy, z+δz, t+δt )。</p><p>如果假定图像亮度恒定，即可得到光流法的约束方程（constraint equation）</p><p><span class="math display">\[I(x,y,z,t) = I(x+δx, y+δy, z+δz, t+δt )\]</span></p><p>进一步假定图像中的物体运动速度不大，则后一帧图像可以用前一帧图像的泰勒展开形式表示（只保留一阶近似）</p><p><span class="math display">\[I(x+δx, y+δy, z+δz, t+δt ) = I(x,y,z,t) + \frac{\mathrm{d} I}{\mathrm{d} x} δx + \frac{\mathrm{d} I}{\mathrm{d} y} δy + \frac{\mathrm{d} I}{\mathrm{d} z} δz + \frac{\mathrm{d} I}{\mathrm{d} t} δt\]</span></p><p>根据约束方程，上式中偏导数之和应为 0，即</p><p><span class="math display">\[\frac{\mathrm{d} I}{\mathrm{d} x} V_x + \frac{\mathrm{d} I}{\mathrm{d} y} V_y + \frac{\mathrm{d} I}{\mathrm{d} z} V_z + \frac{\mathrm{d} I}{\mathrm{d} t} V_t = 0\]</span></p><p>对于二维图像可忽略 z 分量，约束方程的最终形式为：</p><p><span class="math display">\[I_x V_x + I_y V_y = - I_t\]</span></p><p>通常在一个小窗口内进行光流计算，采用最小二乘法求得该窗口内的平均运动向量。理想情况下，小窗口内的像素应具有一致的运动向量，因此求得的平均向量就代表着物体真实的运动方向。</p><h2 id="块匹配法-block-matching">块匹配法 Block Matching</h2><p>块匹配的思想是在参考帧（通常是上一帧）中的一个小范围内搜索与当前块 (block) 最匹配的块，如果确实能够找到则计算出运动向量 v。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr34.png"></p><p>所谓“最匹配”的块其实可以有很多种不同的评判标准。常用的标准有 Mean Squared Error (MSE) 以及 Mean Absolute Error (MAE) 等算法。</p><p>搜索区域一般是根据产品的需求和设计约束而定，常用的有 13x13，17x17 像素等。搜索区域越大能够检测的运动速度越大，但是所需的算力成本也会呈平方增长。</p><p>当图像种存在重复的纹理模式时，光流法和块匹配法都容易失效。在下图的例子中，绿框所示的块状纹理和黄框所示的边缘纹理都容易引起算法失效。而蓝框所示的含直角的块则较容易被算法正确识别。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/nr35.png"></p><h1 id="bm3d-算法">BM3D 算法</h1><h2 id="基础估计">基础估计</h2><ul><li>对于每个目标图块，在附近寻找最多 MAXN1（超参数）个相似的图块，为了避免噪点的影响，将图块经过 2D 变换（代码中使用 DCT 变换）后再用欧氏距离衡量相似程度。按距离从小到大排序后取最多前 MAXN1 个。叠成一个三维数组。</li></ul><p><span class="math display">\[\begin{equation}d\left(Z_{x_R}, Z_x\right)=\frac{\left\|\Upsilon^{\prime}\left(\mathcal{T}_{2 \mathrm{D}}^{\mathrm{ht}}\left(Z_{x_R}\right)\right)-\Upsilon^{\prime}\left(\mathcal{T}_{2 \mathrm{D}}^{\mathrm{ht}}\left(Z_x\right)\right)\right\|_2^2}{\left(N_1^{\mathrm{ht}}\right)^2}\end{equation}\]</span></p><ul><li>对 3D 数组的第三维，即图块叠起来后，每个图块同一个位置的像素点构成的数组，进行 DCT 变换后，采用硬阈值的方式将小于超参数 <span class="math inline">\(\lambda_{3D}\)</span> 的成分置为 0。同时统计非零成分的数量作为后续权重的参考。后将第三维进行逆变换。</li></ul><p><span class="math display">\[\begin{equation}\widehat{\mathbf{Y}}_{S_{x_R}^{\mathrm{ht}}}^{\mathrm{ht}}=\mathcal{T}_{3 \mathrm{D}}^{\mathrm{ht}^{-1}}\left(\Upsilon\left(\mathcal{T}_{3 \mathrm{D}}^{\mathrm{ht}}\left(\mathbf{Z}_{S_{x_R}^{\mathrm{ht}}}\right)\right)\right),\end{equation}\]</span></p><ul><li>将这些图块逆变换后放回原位，利用非零成分数量统计叠加权重，最后将叠放后的图除以每个点的权重就得到基础估计的图像，此时图像的噪点得到了较大的去除。</li></ul><p><span class="math display">\[\begin{equation}\hat{y}^{\text {basic }}(x)=\frac{\sum_{x_R \in X} \sum_{x_m \in S_{x_R}^{\mathrm{ht}}} w_{x_R}^{\mathrm{ht}} \widehat{Y}_{x_m}^{\mathrm{ht}, x_R}(x)}{\sum_{x_R \in X} \sum_{x_m \in S_{x_R}^{\mathrm{ht}}} w_{x_R}^{\mathrm{ht}} \chi_{x_m}(x)}, \forall x \in X,\end{equation}\]</span></p><h2 id="最终估计">最终估计</h2><ul><li>由于基础估计极大地消除了噪点，对于含噪原图的每个目标图块，可以直接用对应基础估计图块的欧氏距离衡量相似程度。按距离从小到大排序后取最多前 MAXN1 个。将基础估计图块、含噪原图图块分别叠成两个三维数组。</li></ul><p><span class="math display">\[\begin{equation}S_{x_R}^{\text {wie }}=\left\{x \in X: \frac{\left\|\widehat{Y}_{x_R}^{\text {basic }}-\widehat{Y}_x^{\text {basic }}\right\|_2^2}{\left(N_1^{\text {wie }}\right)^2}&lt;\tau_{\text {match }}^{\text {wie }}\right\} .\end{equation}\]</span></p><ul><li>对含基础估计 3D 数组的第三维，即图块叠起来后，每个图块同一个位置的像素点构成的数组，进行 DCT 变换，利用如下公式得到系数。</li></ul><p><span class="math display">\[\begin{equation}\mathbf{W}_{S_{x_R}^{\text {wie }}}=\frac{\left|\mathcal{T}_{3 \mathrm{D}}^{\text {wie }}\left(\widehat{\mathbf{Y}}_{S_{x_R}^{\text {waic }}}^{\text {wasic }}\right)\right|^2}{\left|\mathcal{T}_{3 \mathrm{D}}^{\text {wie }}\left(\widehat{\mathbf{Y}}_{S_{x_R}^{\text {basic }}}^{\text {baic }}\right)\right|^2+\sigma^2}\end{equation}\]</span></p><ul><li>将系数与含噪 3D 图块相乘放回原处，最后做加权平均调整即可得到最终估计图。相对于基础估计图，还原了更多原图的细节。</li></ul><p><span class="math display">\[\begin{equation}\widehat{\mathbf{Y}}_{S_{x_R}^{\text {wie }}}^{\text {wie }}=\mathcal{T}_{3 \mathrm{D}}^{\text {wie }^{-1}}\left(\mathbf{W}_{S_{x_R}^{\text {wie }}} \mathcal{T}_{3 \mathrm{D}}^{\text {wie }}\left(\mathbf{Z}_{S_{x_R}^{\text {wie }}}\right)\right)\end{equation}\]</span></p><h2 id="bm3d-代码实现">BM3D 代码实现</h2><ul><li>BM3D 官网，Matlab 实现 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWdlcy50dW5pLmZpL2ZvaS9HQ0YtQk0zRC8=">https://webpages.tuni.fi/foi/GCF-BM3D/<i class="fa fa-external-link-alt"></i></span>。</li><li>一篇 BM3D 的快速实现，提供了源码 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaXBvbC5pbS9wdWIvYXJ0LzIwMTIvbC1ibTNkLw==">https://www.ipol.im/pub/art/2012/l-bm3d/<i class="fa fa-external-link-alt"></i></span>。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgyMDkyNw==">https://zhuanlan.zhihu.com/p/98820927<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY1NDQyMTU=">https://zhuanlan.zhihu.com/p/536544215<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjM5OTc4NA==">https://zhuanlan.zhihu.com/p/46399784<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXBvbC5pbS9wdWIvYXJ0LzIwMTIvbC1ibTNkLw==">https://www.ipol.im/pub/art/2012/l-bm3d/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWdlcy50dW5pLmZpL2ZvaS9HQ0YtQk0zRC8=">https://webpages.tuni.fi/foi/GCF-BM3D/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDI0MjM2MTU=">https://zhuanlan.zhihu.com/p/102423615<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP RGB 域之 CCM</title>
      <link href="/next/2023/Camera/CameraISPRGBCCM/"/>
      <url>/next/2023/Camera/CameraISPRGBCCM/</url>
      
        <content type="html"><![CDATA[<h1 id="why">Why？</h1><p>我们肉眼的对光谱的 RGB 响应曲线和 sensor 的响应曲线是不同的； <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ccm1.png"></p><p>CCM 一般是 3x3 矩阵形式，也有 3x4 形式的，3x4 形式主要是给 rgb 各自加一个 offset</p><p><span class="math display">\[\begin{bmatrix}R_{out} \\G_{out} \\B_{out} \end{bmatrix} = \begin{bmatrix}CC_{00}  &amp; CC_{01} &amp; CC_{02}\\CC_{10}  &amp; CC_{11} &amp; CC_{12}\\CC_{20}  &amp; CC_{21} &amp; CC_{22}\end{bmatrix} \ast  \begin{bmatrix}R_{in} \\G_{in} \\B_{in} \end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}R_{out} \\G_{out} \\B_{out} \end{bmatrix} = \begin{bmatrix}CC_{00}  &amp; CC_{01} &amp; CC_{02} &amp; OFFSET_r\\CC_{10}  &amp; CC_{11} &amp; CC_{12} &amp; OFFSET_g\\CC_{20}  &amp; CC_{21} &amp; CC_{22} &amp; OFFSET_b\end{bmatrix} \ast  \begin{bmatrix}R_{in} \\G_{in} \\B_{in} \end{bmatrix}\]</span></p><span id="more"></span><p>上面的人眼 rgb 响应和 sensor rgb 响应曲线都是非线性的，所以指望通过一个 CCM 矩阵就得到匹配度很好的映射关系是不现实的。现实中，往往会标定很多个 CCM，ISP 在运行的时候根据照度，光源等等因素，选择两个最近的 CCM 插值得到最终的 CCM；</p><p>CCM 模块在 apply awb gain 后面，因此 3x3 个值存在约束条件：</p><p><span class="math display">\[CC_{00} + CC_{01} + CC_{02} = 1CC_{10} + CC_{11} + CC_{12} = 1CC_{20} + CC_{21} + CC_{22} = 1\]</span></p><p>保证灰点也就是 r=g=b 的点，经过 CCM 以后仍然 r=g=b；</p><h1 id="标定-ccm-方法">标定 CCM 方法</h1><ul><li><p>用 camera 拍一张某个色温下的 24 色卡 raw 文件：注意 shading 影响，拍这个色卡占整个 sensor 中间一小部分就可以。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ccm2.png"></p></li><li>raw 文件预处理。主要包括减 blc，根据第 4 行的 patch，获取 awb gain 值，乘上去；这样就拿到了这个色温下 24 个 patch 的 rgb 值。</li><li><p>理想 rgb 值。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ccm3.png"></p></li></ul><p>这是色卡厂家提供的 24 个 patch 的标准 rgb 空间下的理论值；拿到这个值以后，需要进行反 gamma 处理，因为厂家提供的是 srgb 的值，是带了 2.2gamma 的，ISP 的 CCM 模块一般是在 gamma 前面，因此要对理论值进行反 gamma 处理；</p><h1 id="标定算法">标定算法</h1><p>已知 100 个 raw rgb 值，已知对应的理论 rgb 值；求一个 3x3 线性变换矩阵；这个矩阵要使得映射后的 rgb 值尽可能的接近理论值；</p><p>借鉴深度学习的梯度下降方法，可以快速得到 CCM；并且可以自定义 100 个 patch 的重要程度，使得某些 patch 的误差非常小。</p><p>定义损失和梯度函数，测量 rgb 值得差异，采用 L2 距离；</p><p><span class="math display">\[L_i =  {\textstyle \sum_{n=1}^{18}} (CCM \ast RGB_{origin} - RGB_{standard})^2\]</span></p><p>完整代码如下：</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">ccm = torch.tensor([[<span class="number">1655</span>, <span class="number">-442</span>, <span class="number">-189</span>], [<span class="number">-248</span>, <span class="number">1466</span>, <span class="number">-194</span>], [<span class="number">-48</span>, <span class="number">-770</span>, <span class="number">1842</span>]], dtype=torch.float32)</span><br><span class="line">rgb_data = torch.randint(<span class="number">0</span>, <span class="number">255</span>, (<span class="number">3</span>, <span class="number">100</span>))</span><br><span class="line">rgb_data = rgb_data.float()</span><br><span class="line"></span><br><span class="line">error_manual = torch.<span class="built_in">randn</span>((<span class="number">3</span>, <span class="number">100</span>)) * <span class="number">16</span></span><br><span class="line">rgb_target = ccm.mm(rgb_data)/<span class="number">1024.0</span></span><br><span class="line">rgb_target_error = rgb_target + error_manual</span><br><span class="line">ccm_calc1 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line">ccm_calc2 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line">ccm_calc3 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line">ccm_calc5 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line">ccm_calc6 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line">ccm_calc7 = torch.tensor([<span class="number">0.0</span>], dtype=torch.float32, requires_grad=True)</span><br><span class="line"></span><br><span class="line">def squared_loss(rgb_tmp, rgb_ideal):</span><br><span class="line">    <span class="keyword">return</span> torch.sum((rgb_tmp-rgb_ideal)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">def sgd(params, lr, batch_size):</span><br><span class="line">    <span class="keyword">for</span> param in params:</span><br><span class="line">        param.data -= lr * param.grad/batch_size;</span><br><span class="line"></span><br><span class="line">def net(ccm_calc1, ccm_calc2, ccm_calc3, ccm_calc5, ccm_calc6, ccm_calc7, rgb_data):</span><br><span class="line">    rgb_tmp = torch.zeros_like(rgb_data)</span><br><span class="line">    rgb_tmp[<span class="number">0</span>, :] = ((<span class="number">1024.0</span> - ccm_calc1 - ccm_calc2) * rgb_data[<span class="number">0</span>, :] + ccm_calc1 * rgb_data[<span class="number">1</span>, :] + ccm_calc2 * rgb_data[<span class="number">2</span>, :]) / <span class="number">1024.0</span></span><br><span class="line">    rgb_tmp[<span class="number">1</span>, :] = (ccm_calc3 * rgb_data[<span class="number">0</span>, :] + (<span class="number">1024.0</span> - ccm_calc3 - ccm_calc5) * rgb_data[<span class="number">1</span>, :] + ccm_calc5 * rgb_data[<span class="number">2</span>, :]) / <span class="number">1024.0</span></span><br><span class="line">    rgb_tmp[<span class="number">2</span>, :] = (ccm_calc6 * rgb_data[<span class="number">0</span>, :] + ccm_calc7 * rgb_data[<span class="number">1</span>, :] + (<span class="number">1024.0</span> - ccm_calc6 - ccm_calc7) * rgb_data[<span class="number">2</span>, :]) / <span class="number">1024.0</span></span><br><span class="line">    <span class="keyword">return</span> rgb_tmp</span><br><span class="line"></span><br><span class="line">lr = <span class="number">3</span></span><br><span class="line">num_epochs = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> epoch in range(num_epochs):</span><br><span class="line">    l = squared_loss(net(ccm_calc1, ccm_calc2, ccm_calc3, ccm_calc5, ccm_calc6, ccm_calc7, rgb_data), rgb_target_error)</span><br><span class="line">    l.backward()</span><br><span class="line">    sgd([ccm_calc1, ccm_calc2, ccm_calc3, ccm_calc5, ccm_calc6, ccm_calc7], lr, <span class="number">100</span>)</span><br><span class="line">    ccm_calc1.grad.data.zero_()</span><br><span class="line">    ccm_calc2.grad.data.zero_()</span><br><span class="line">    ccm_calc3.grad.data.zero_()</span><br><span class="line">    ccm_calc5.grad.data.zero_()</span><br><span class="line">    ccm_calc6.grad.data.zero_()</span><br><span class="line">    ccm_calc7.grad.data.zero_()</span><br><span class="line">    print(<span class="string">'epoch %d, loss %f'</span><span class="comment">%(epoch, l))</span></span><br><span class="line"></span><br><span class="line">res = torch.tensor([[<span class="number">1024.0</span> - ccm_calc1 - ccm_calc2, ccm_calc1, ccm_calc2],</span><br><span class="line">                    [ccm_calc3, <span class="number">1024.0</span>-ccm_calc3-ccm_calc5, ccm_calc5],</span><br><span class="line">                    [ccm_calc6, ccm_calc7, <span class="number">1024.0</span>-ccm_calc6-ccm_calc7]], dtype=torch.float32)</span><br><span class="line">print(res);</span><br><span class="line"></span><br><span class="line">rgb_apply_ccm = res.mm(rgb_data)/<span class="number">1024.0</span></span><br><span class="line"></span><br><span class="line">fig1 = plt.<span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">ax1 = fig1.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line">fig2 = plt.<span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">ax2 = fig2.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line">x2 = rgb_data[<span class="number">0</span>]</span><br><span class="line">y2 = rgb_data[<span class="number">1</span>]</span><br><span class="line">z2 = rgb_data[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ax1.<span class="built_in">scatter</span>(x2, y2, z2, marker=<span class="string">'*'</span>, c=<span class="string">'b'</span>, label=<span class="string">'origin RGB'</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_xlim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax1.set_ylim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax1.set_zlim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">'R'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'G'</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">x3 = rgb_target[<span class="number">0</span>]</span><br><span class="line">y3 = rgb_target[<span class="number">1</span>]</span><br><span class="line">z3 = rgb_target[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ax1.<span class="built_in">scatter</span>(x3, y3, z3, marker=<span class="string">'o'</span>, c=<span class="string">'c'</span>, label=<span class="string">'target rgb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> in range(len(x3)):</span><br><span class="line">    ax1.<span class="built_in">plot</span>([x2[<span class="built_in">i</span>], x3[<span class="built_in">i</span>]], [y2[<span class="built_in">i</span>], y3[<span class="built_in">i</span>]], [z2[<span class="built_in">i</span>], z3[<span class="built_in">i</span>]], <span class="string">'k-.'</span>)</span><br><span class="line">ax1.<span class="built_in">legend</span>()</span><br><span class="line"></span><br><span class="line">ax2.set_xlim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax2.set_ylim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax2.set_zlim(<span class="number">-80</span>, <span class="number">360</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">'R'</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'G'</span>)</span><br><span class="line">ax2.set_zlabel(<span class="string">'B'</span>)</span><br><span class="line">ax2.<span class="built_in">scatter</span>(x3, y3, z3, marker=<span class="string">'o'</span>, c=<span class="string">'c'</span>, label=<span class="string">'target rgb'</span>)</span><br><span class="line"></span><br><span class="line">x4 = rgb_apply_ccm[<span class="number">0</span>]</span><br><span class="line">y4 = rgb_apply_ccm[<span class="number">1</span>]</span><br><span class="line">z4 = rgb_apply_ccm[<span class="number">2</span>]</span><br><span class="line">ax2.<span class="built_in">scatter</span>(x4, y4, z4, marker=<span class="string">'^'</span>, c=<span class="string">'b'</span>, label=<span class="string">'apply ccm rgb'</span>)</span><br><span class="line">ax2.<span class="built_in">legend</span>()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>可视化看一下映射后的点与理论点的距离： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ccm4.png"></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDg2MjY0ODA=">https://zhuanlan.zhihu.com/p/108626480<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP Raw 域 AWB</title>
      <link href="/next/2023/Camera/CameraISPRawAWB/"/>
      <url>/next/2023/Camera/CameraISPRawAWB/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色恒常理论">颜色恒常理论</h1><h2 id="人类视觉特性">人类视觉特性</h2><p>人眼中存在一种感应亮度的杆细胞（rod）和三种感应颜色的视锥体细胞（cone）。锥体细集中分布在视网膜（retina）上的中央窝（fovea centralis）区域。中央窝之外全部是杆细胞，总数约有 1200 万，三种视锥体细胞用 L,M,S（或 R,G,B）符号加以区分，总数大约有 600 万～700 万，根据实验结果分析，L 占 64%，M 占 32%，S 占 2%。</p><p>这三种视锥细胞分别感应不同波长范围（频段）的光刺激，响应灵敏度也不同。从下图可以看到，感应蓝光的视锥细胞灵敏度最低（细胞数量最少）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb1.png"></p><p>如果只需要考虑响应的波段问题，而不需要研究灵敏度差异，则经常使用用归一化响应。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb2.png"></p><span id="more"></span><h2 id="颜色恒常理论-1">颜色恒常理论</h2><p>人类视觉系统（Human Visual System, HVS）能够在各种不同的光照条件下识别物体的颜色，这种自动排除光源影响的能力称为颜色恒常（color constancy）。</p><p>根据德国生理学家 Johannes von Kries 于 1902 年提出的猜想，颜色恒常现象总结下来有几个要点：</p><ul><li>视锥细胞会根据周围环境光的情况独立地调整颜色通道的敏感度。举例来说，如果环境光中的长波段（红色）功率较大，则感应长波的 L 视锥细胞的敏感度会下降，但 M 和 S 视锥细胞的敏感度则不会随 L 细胞同步变化。</li><li>在任何光照下，当三种视锥细胞的响应均达到各自的最大值时，激发的知觉都是白色，此时三种视锥细胞的响应组合（Lw,Mw,Sw）称为白场响应。</li><li>如果光照环境不同，白场响应值也不同，即（Lw, Mw, Sw）α ≠（Lw, Mw, Sw）β。</li><li>人类知觉到的颜色取决于三刺激值相对于白场响应的比值，并非完全取决于三刺激值本身。在不同光照下，如果两个颜色在视锥细胞上激发的比值（三刺激值/白场响应）相同，则产生的颜色知觉也（基本）相同。这就为颜色恒常提供了可能。</li><li>要点 4 所描述的比值在现实世界中的对应物（counterpart）其实就是物体表面对光线的反射率（surface reflectance）。如果一个物体表面对光线的反射特性不随光照条件而变化（除了变色龙外大多数物体都满足），那么该表面的光亮度与环境光亮度的比值也恒等，数值上等于视锥细胞的三刺激值与白场响应的比值，因此该表面在各种光照下激发的颜色知觉都（基本）相同。这就是颜色恒常的原理。</li></ul><p>人类视觉对颜色的分辨能力是存在一定的精度限制的，当两个颜色在色度图（chromaticity diagram）上的距离小于颜色宽容量时，人类将无法区分这两个颜色的差异。人类对低色温的颜色表现出更小的颜色宽容量，对高色温的颜色宽容量更大，这个现象对白平衡的精度做出了一定的约束。</p><p>在研究白平衡问题时，有时会把颜色变换到 HCL 空间，其中 H 代表色调 Hue，C 代表色温，L 代表亮度 Luma。在 CIE-1931 xyY 色度图上，中间向下凹的曲线叫普朗克曲线，描述黑体作为光源在各种温度（0, +∞）下呈现的颜色，色温表征光源的冷暖倾向（偏蓝或偏红）。在现实生活中很多人造光源的光谱与黑体光谱差异很大，光源颜色常落在普朗克曲线之外。色度图上与普朗克曲线相交的直线称为相关色温线（CCT），用于定义非黑体光源的等效色温，同时也表征光源的色调倾向（偏绿或偏紫）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb3.png"></p><p>白平衡的作用就是模拟人类的色彩恒常能力，在图像中去除光源引起的偏色。</p><h1 id="cie1931-色域">CIE1931 色域</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb4.png"></p><p>上图是由 CIE 国际照明委员于 1931 年发布的，它们是在 20 世纪 20 年代后期由 William David Wright 和 John Guild 将实验结果合并到 CIE RGB 色彩空间的规范中，从中导出 CIE XYZ 色彩空间。肉眼能够看到的色彩空间就是这些了，但是显示器并没有这么大的空间，和人眼相比，显示器能够显示的色域更小。</p><h2 id="srgb">sRGB</h2><p>sRGB 是最早期的色域标准之一，至今仍有非常重要的影响力。它是由当时的微软（software）与惠普（Hewlett-Packard）共同定制于 1996 年，并且得到了来自业界的 W3C、Exif、Intel、Pantone、Corel 以及其它许多业界厂商的支持。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb5.png"></p><p>上图的三角形就是 sRGB 的范围，相当于 CIE 1931 的一个子集，覆盖面比较小，小 s 的意思是 standard，标准。不过由于 sRGB 标准定制较早，很多技术和概念都不成熟，</p><p>sRGB 色彩空间大概只有当时 CIE 色域标准的 30%，色彩还原度不高，而且观察色域范围你就会发现一个很严重的问题，sRGB 对于绿色部分色域覆盖非常少。这个就导致一个很严重的问题，那就是对花草森林等场景的色彩表现力不足。也正是因为这样，它对显示器的要求不高，所以现在市面上大多数显示器都能达到 sRGB100%。</p><p>对于需要在 sRGB 标准显示器上显示的图像，白平衡算法需要将拍摄场景色温下的白色映射为 D65 色温下的白色。这就相当于实现了人类视觉的颜色恒常特性。白平衡的第一步也是最重要的一步是对拍摄场景进行光源颜色估计（light source color estimation），估计的结果可以用于下一步的色适应（chromatic adaptation）。色适应的作用是去除图像的偏色（color cast），使原始场景中的白色物体在 D65 色温下仍然是白色。</p><h2 id="adobe-rgb">Adobe RGB</h2><p>Adobe RGB 就是由大名鼎鼎的 Adobe 公司所发布的： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb5.png"></p><p>dobe RGB 色域可以说是 sRGB 色域的升级版，因为它主要解决了印刷与电脑显示器显现颜色不同的问题，并且提高了在青绿色系上的显示，也正因为如此，它占据 CIE 色域达 50%之多。目前也只有部分高端显示器能够做到 99%的 Adobe RGB 色域，基本都是用在设计方面。</p><h2 id="dci-p3">DCI-P3</h2><p>DCI-P3 是一款更加注重于视觉冲击，而不是色彩全面性的色域。并且相对其他色彩标准，它拥有更广阔的红色/绿色系色彩范围。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb6.jpeg"></p><h1 id="白平衡算法">白平衡算法</h1><h2 id="灰度世界模型gray-world-model-gw">灰度世界模型（Gray World model, GW）</h2><p>该模型基于灰度世界假设，该假设认为：对于一幅有着大量色彩变化的图像，R,G, B 三个分量的统计平均值趋于同一灰度值。 从物理意义上讲，灰度世界模型假设自然界景物对于光线的反射系数的均值在总体上是个定值，这个定值近似地为“灰色”。 依据灰度世界模型实现的白平衡算法认为图像中 R,G,B 分量的平均值如果偏离 1:1:1 则一定是因为环境光线变化引起的，算法会据此对 R,G,B 增益进行反馈调节以补偿环境光的变化，使三个分量的平均值重新回到 1:1:1。</p><p>在实际应用中这个模型的基本假设经常是不成立的，所以实用的灰度世界模型都会对基本假设做出各种修正以适应假设失效的场景。一种修正的方法是限定 RGB 分量的取值范围，抛弃偏离灰色太远的像素。</p><p>举例来说，像素值（R,G,B）只有满足以下条件才能参与白平衡估计：</p><ul><li>|B-G| &lt; a</li><li>|R-G| &lt; b</li><li>|B-G|+|R-G| &lt; c</li></ul><p>其中 a, b, c 为参数，可以根据标定得到。使用 a,b,c 可以围成下图所示的画线区域。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb7.png"></p><p>还有一种方法是抛弃静态的背景像素，只统计动态的前景像素。这个方法可以过滤大范围单色背景对算法的干扰，但是对于面积较大的单色运动物体则无能为力。</p><h2 id="白点统计模型">白点统计模型</h2><p>该模型假设正常的画面中总会存在一些白色（灰色）区域，这些区域在不同光照条件下会表现出不同的 (R/G,B/G) 比值。在实验室环境下可以事先标定出参考白色在不同色温下的 (R/G,B/G) 比值，实际工作时，ISP 硬件可以将符合白色比值关系的像素区域筛选出来生成统计信息，得到所有白色的平均比值，自动白平衡算法根据硬件报告的平均比值反推当前环境的色温，并根据预测的环境色温选择合适的 RGB 增益和其它色彩控制参数。</p><p>在实际应用中，白点统计模型偶尔也会遇到基本假设不成立的情况，主要存在于画面亮度很低，或者一些比较特殊的场景。 在白点统计模型中，如何定义白色区域是一个主要课题，围绕这个课题衍生了多种方法。一种简单的判据是在 YUV 空间为颜色设置经验阈值，通过阈值过滤掉偏离灰色较远的像素，如下所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb8.png"></p><p>有人提出了一组模糊规则（Fuzzy Rules Model，FRM）用于更好地筛选白点，基本思想是，</p><ul><li>如果像素的亮度 Y 过大或过小，则该像素携带的色度信息较少，应赋予较小的权重。</li><li>在一定范围内，亮度高的像素权重应大于亮度低的像素，因为亮度低的像素受噪声影响更大。</li><li>白平衡统计时通常会把图像划分为 MxN 个分区（zone），如果多个相邻分区的颜色几乎相同，应赋予较小的权重，防止单一物体权重过大引发超调。</li><li>果某颜色的 Cb,Cr 分量同时落在-1.5~-0.5 区间内，则较可能是白色，应赋予较大权重。</li></ul><p>其它一些算法基于不同的原理实现白平衡，如</p><ul><li>WP 算法，假设场景中存在一块白色块（White Patch），它对各个波段的光线都近乎完全反射，因此是图像中最亮的点，其颜色能够反映光源的光谱特性，凭借这一信息可以在图像中去除光源的颜色。</li><li>PRM 算法，与 WP 算法原理类似，假设图像中最亮的像素携带了较多光源本身的信息，是主要的白色参考，称为完美反射模型（Perfect Reflector Model）。</li><li><p>SoG 算法，利用灰阶的特性（Shades of Gray）。 Finlayson 等人发现，灰度世界模型的数学本质是取所有像素的 1-范数，而 WP 模型本质是取所有像素的∞-范数。如果推广起来其实可以一般地考察像素的 p-范数，从而找到最合适的模型，这就是 SoG 算法的基本思想。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/awb9.png"></p></li><li>BP 算法，利用亮像素的特性（Bright Pixels）。</li><li><p>GE 算法，改进的灰度世界模型。</p></li></ul><h1 id="白平衡的评价标准">白平衡的评价标准</h1><p>自动白平衡调整的关键环节，首先是要及时检测出环境光色温的变化，其次是要对环境色温变化及时做出响应。针对这一过程可以有不同的实现方法，而评价一个白平衡算法的性能通常有以下几个维度</p><ul><li>准确性，衡量指标为白平衡稳定后 18 度灰卡实际颜色与理想颜色之间的色差∆C，一般应在 10 以内。</li><li>收敛速度，从场景切换到白平衡稳定所需的时间，以图像帧数来衡量，一般应该 30 帧以内。</li><li>稳定性，在视频序列中，白平衡应保持稳定或平滑过渡，不应出现跳变、振荡等异常现象。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgzNTMwMA==">https://zhuanlan.zhihu.com/p/98835300<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDgxNjIwNzA=">https://zhuanlan.zhihu.com/p/348162070<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> 3A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP 之 AE</title>
      <link href="/next/2023/Camera/CameraISPAE/"/>
      <url>/next/2023/Camera/CameraISPAE/</url>
      
        <content type="html"><![CDATA[<h1 id="自动曝光auto-exposure">自动曝光（Auto Exposure）</h1><h2 id="自动曝光流程">自动曝光流程</h2><ul><li>根据 ISP 硬件生成的图像曝光统计数据评估当前图像的曝光质量。 前主流的 ISP 硬件都会提供关于图像的直方图统计数据，AE 算法可以利用直方图的均值来判断图像是否曝光适当。</li><li>如果曝光质量需要调整，则根据当前的工作参数和理想曝光目标生成下一帧图像的工作参数。 主要调控对象是光圈、sensor 积分时间、sensor 增益（包含模拟增益和数字增益）、ISP 数字增益这四个参数。</li><li>将新的工作参数写入各硬件设备，驱动光圈、sensor 快门及增益到达新的位置。</li></ul><span id="more"></span><h2 id="曝光值-ev">曝光值 EV</h2><p>现在较为流行的是 1960 年代提出的 APEX 曝光系统。APEX 全称是 The Additive System of Photographic Exposure，该系统定义了一个经验公式，基本形式如下：</p><p><span class="math display">\[\frac{t}{N^2} = \frac{K}{L_sS}\]</span></p><p>其中：t 是曝光时间，单位为秒；N 是光圈的 f-stop 值；Ls 是场景照度，可以是任一适当的单位，如 lux；S 是相机敏感度，可以使用 ISO；K 是相机厂家提供的与具体相机配置相关的一个常数，使用该常数能够获得厂家认为最佳的曝光效果。</p><p>APEX 曝光方程总结了曝光时间、光圈、相机感度、场景亮度之间的关系。在此基础上可以定义一个曝光值 （exposure value）参数，代表能够给出同样曝光的所有相机光圈快门组合。它的定义是：</p><p><span class="math display">\[EV = log_2 \frac{N^2}{t}\]</span></p><p>EV0 对应于 ISO100，曝光时间为 1 秒，光圈为 f/1.0，以及与之等效的所有曝光组合，这些组合可以使 18%的中性灰卡在所处光照条件下获得合适的曝光。因此曝光值主要体现了拍摄场景的亮度，同时在一定程度上也能反映相机的灵敏度。</p><p>曝光值每增加 1 称为增加一挡曝光，也就是将曝光量减半，比如将曝光时间或光圈面积减半，因此可以从 EV0 出发，按照光圈、快门加倍或减半的方式推导出其余的曝光档位，一般常用的档位在-6~20 之间。</p><h2 id="曝光三角形-exposure-triangle">曝光三角形 Exposure Triangle</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ae1.png"></p><h1 id="ae-算法的策略">AE 算法的策略</h1><p>AE 算法的策略主要分光圈优先、快门优先、增益优先。</p><ul><li>光圈优先算法会优先调整光圈到合适的位置。当光圈调整到极限后再开始分配曝光时间和增益。</li><li>当 camera 光圈不可调时，AE 算法通常会优先分配曝光时间，再分配 sensor 增益和 ISP 增益。</li><li>增益优先则是优先分配 sensor 增益和 ISP 增益，再分配曝光时间，适合拍摄运动物体的场景。</li></ul><p>增加光圈可以增大 sensor 收集光信号的面积，增加曝光时间可以延长 sensor 积累光信号的时间，这两种途径都有助于积累信号，提高信噪比，所以会提高图像质量。</p><p>sensor 增益实际上存在两种形式，即模拟增益和数字增益。模拟增益在放大信号的同时会等比例地放大噪声，所以对提高信噪比没有好处，但也没有坏处，可以放心地使用。而数字增益由于精度的限制会引入量化噪声，不仅对提高信噪比没有好处，反而会有恶化信噪比，降低图像质量，因此需要慎用。</p><p>ISP 增益是纯数字增益，和 sensor 数字增益是同样的道理，所以通常很少用。</p><h1 id="曝光统计">曝光统计</h1><h2 id="曝光统计分工">曝光统计分工</h2><p>曝光统计需要对图像中的每一个像素进行分类和计算，涉及的计算量非常大，对时序要求非常严格，所以这个工作只能交给硬件流水线去做，不适合 CPU 处理。</p><p>AE 算法中根据统计数据评估图像质量、产生新的控制参数的部分则有逻辑比较复杂、算法经常需要升级、数据吞吐量一般不大等特点，因此非常适合用 CPU 处理。</p><h2 id="ae-统计策略">AE 统计策略</h2><ul><li><strong>全局统计</strong> 是指将图像全部像素都统计进来，像素的权重完全一样。</li><li><strong>中央权重统计</strong> 是指只统计图像中间部分，这主要是因为人们关注的重点通常都位于图像的中间部分；镜头的成像效果也是中央部分清晰度最高，越到边缘清晰度越低。</li><li><strong>中央加背景</strong> 图像中间部分占 50%权重，图像整体作为背景占 50%权重。</li><li><strong>加权平均统计</strong> 是指将图像分为不同的部分，如 9 宫格或者 13~15 个分散的曝光格，每一部分赋予不同的权重，通常中间部分赋予较大权重，相应的边缘部分则赋予较小的权重。</li><li><strong>用户 ROI</strong> 用户通过人机界面划定一个窗口，AE 只统计这个固定窗口内的像素值。</li></ul><h1 id="典型-ae-算法">典型 AE 算法</h1><h2 id="基本思想">基本思想</h2><p>典型的 AE 算法是一种基于负反馈原理的 PID 算法。算法的控制参数分段可调，在不同的区间内算法的收敛速度不同，以期在过渡平滑性和快速响应之间取得较好的平衡。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ae2.png"></p><ul><li>在当前曝光量与目标量差别在 range0 以内的时候，说明当前曝光已经满足要求，不需要进行调整。</li><li>当差别在 range1 的范围内时，则说明当前曝光与要求的光照有差别，但差别不大，只需要用较小的步长来进行调节即可。</li><li>当差别在 range2 的时候，则表明差别较大，需要用较大步长来进行调节。</li></ul><h2 id="控制参数">控制参数</h2><ul><li><strong>当前帧的曝光量</strong> 由 sensor 曝光时间、sensor 增益、ISP 增益组成</li><li><strong>增益系数</strong> g=target/measured, 其中 target 为理想画面亮度，measured 为当前画面亮度的实测值</li></ul><p>因此 AE 算法的核心任务就是计算正确的 g 参数，这个参数能够使画面得到正确的曝光。</p><h2 id="阻尼-damping">阻尼 (damping)</h2><p>当计算出正确的 g 参数后，一般并不会让其立刻在下一帧图像就生效。这是因为如果增益变化较大，图像就会产生闪烁，主观感受不好。通常人们更喜欢画面平滑过渡，因此每帧图像的增益变化不宜过大。实现平滑的方法就是给新的参数人为施加一个阻尼，使其缓慢地向新参数过渡。用数学公式描述就是：</p><p><span class="math display">\[g(n)= (1-s) * g(n-1) +s * g_{target}\]</span></p><h2 id="参数分解">参数分解</h2><p>当根据路径规划策略计算出下一帧的 g 参数后，需要遵循一定的策略和约束把 g 参数进一步映射为 sensor 曝光时间、sensor 增益、ISP 增益等设备控制参数。分解出来的控制参数必须同步生效才能使画面获得预期的曝光。如果某一项参数未能与其他几项同步生效，则画面会因为短暂过亮、过暗等原因出现闪烁，这是需要避免的。</p><p>所有参数都需要在一个特定的时间窗口内生效，即前一帧图像已经结束，新一帧图像尚未开始的这段时间，也就是 sensor 的垂直消隐（vertical blanking）窗口，这个窗口时间很短，典型值在 3~5 毫秒左右，更短的可以到 1ms，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ae3.png"></p><p>现在的 sensor 为了方便使用，缓解配置参数时间窗口过短的压力，往往都支持一组影子（shadow）寄存器，需要同步生效的参数（曝光时间和增益）可以在任何时间点写入 shadow 寄存器，当 sensor 开始捕捉新的一帧图像之前，会自动把 shadow 寄存器的内容同步到实际生效的寄存器，这样就把几个毫秒的时间窗口扩展成一帧时间，极大地缓解了用户压力。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/ae4.png"></p><p>需要注意的是，虽然这个方案为软件争取到了一帧的缓冲时间，但同时也意味着系统的响应延迟（latency）增加了一帧。</p><h1 id="ae-的呼吸效应">AE 的呼吸效应</h1><ul><li><strong>图像质量呼吸</strong> 如果通过调整增益那么会对图像质量产生影响。</li><li><strong>亮度呼吸</strong> 参数设计不合理可能出现亮度震荡。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAzNjk1Mjc=">https://zhuanlan.zhihu.com/p/100369527<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> 3A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP 之 AF</title>
      <link href="/next/2023/Camera/CameraISPAF/"/>
      <url>/next/2023/Camera/CameraISPAF/</url>
      
        <content type="html"><![CDATA[<h1 id="对焦和变焦">对焦和变焦</h1><h2 id="对焦">对焦</h2><p>对焦（聚焦）就是把成的像准确的落在 sensor（camera 传感器）上，对焦有两种：自动对焦，手动对焦。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lens1.png"></p><p>虚线是 sensor 的位置，当虚线落在像的位置上就是对焦完成。</p><span id="more"></span><h2 id="变焦">变焦</h2><ul><li>光学变焦：就是改变透镜的焦距。由于改变了焦距，视场角也就变了，就可以实现拉近拉远的功能。</li><li>数码变焦：数码变焦过的的图像会出现失真，因为放大的过程会对图像进程插值。</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lens2.png"></p><h1 id="反差对焦-cdafcontrast-detection-auto-focus">反差对焦 CDAF(Contrast Detection Auto Focus)</h1><p>光路结构比 PDAF 简单很多。它不需要额外的光学棱镜，不需要微透镜，也不需要额外的电路构造。它用软件算法直接分析 sensor 捕捉的主图像就可以判断图像是否聚焦良好。</p><h2 id="原理">原理</h2><p>CDAF 对一个图像序列进行分析，找到对比度最大的一帧图，这个方法也叫做最大值法（maximum-seeking method）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus1.png"></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus2.png"></p><p>最大值法的优缺点都很明显。其优点是仅需要考虑聚焦点附近一个小区域的像素，因此计算压力比较小，对于手持应用可以节省功耗。其缺点是需要抓拍多帧图像。如果只给一帧图像，CDAF 算法无从知晓当前图像是否聚焦良好，也不知道距离理想的聚焦位置还有多远，甚至不知道正确的方向是 focus near 还是 focus far（PDAF 则刚好可以解决这些问题）。</p><h2 id="爬坡算法">爬坡算法</h2><p>该方法要求清晰度评价函数具有严格的单峰性。搜索过程中只能通过爬坡和下坡来判断出山峰的方向而不能看到山峰的全貌，只有当越过山峰时才能找到山峰。</p><p>为了提高聚焦是速度，在 cdaf 算法中将山坡划分为 3 个不同的区域，分别对应着平坦区域（flat），斜坡区域（slope），陡坡区域（steep）, 不同区域对应着不同的爬坡步长，在平坦区域采用大步走的方式，随着坡度越来越来，步长越来越小，以达到快速精确搜索山峰的目的 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus10.png"></p><h2 id="滤波器的应用">滤波器的应用</h2><p>图像越清晰，说明图像的高频分量越多，用一款滤波器保留图像的高频分量，来对比到底哪张图片更加清晰。基于硬件设计的成本考虑，早期的自动对焦系统都是用一些固定系数高频提取算子比如 sobel，laplace 等作为评价函数。</p><p>因为镜头以及成像系统的光学特性差别很大，这种固定系数高频算子的 ISP 设计不能满足自动对焦系统的需要。比如在低对比度的情形下，图像缺少高频成份，如果滤波器就不能够提取到足够的图像边缘的高频成份，这样对焦算法就无法找到峰值从而实现对焦了。所以后来的自动对焦系统评价函数逐渐采用可以设定系数的 FIR 或者 IIR 滤波器。</p><h1 id="相位对焦-pdafphase-detection-auto-focus">相位对焦 PDAF(Phase Detection Auto Focus)</h1><p>需要在 sensor 上设计一些特别的光学、像素、电路等构造以提供关于聚焦状态的数据。这些特别的像素通常被称为聚焦点（AF points）。</p><h2 id="af-组件">AF 组件</h2><p>一些相机（常见于单反）会设计一个专用的光路（AF 组件）用于检测聚焦状态。典型的光路由一个分光棱镜（beam splitter）和两个微透镜（microlens）组成，每个微透镜后面会有一个专用的 AF sensor（包含若干个像素）用于检测像点的精确位置。如果一个物点所对应的像点落在分光棱镜的合适位置上，则像点会出现在两个 AF sensor 的中间位置，表示聚焦良好；否则就是 too near 或者 too far，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus3.png"></p><p>一些单反相机的 AF 功能采用了类似的原理，但实现方式略有不同。典型的光路如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus4.png"></p><h2 id="pd-sensor">PD sensor</h2><p>以上的 AF 方案通常用于单反相机，以专用 AF 组件的方式出现。在很多其它应用中（如手机）很难有足够的空间容纳专用 AF 组件，所以经常会采用另外一种 PD 原理，即把一部分成像用的像素用不透光的挡住一半（分成左和右两种），设计成如下所示的 AF 相位检测像素， <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus5.png"></p><p>这种特殊的像素以一定密度均匀地分布在像素矩阵中，为 AF 软件提供聚焦参考。而 AF 的工作原理与下节将要介绍的 DP 原理类似。</p><h2 id="dpaf">DPAF</h2><p>Dual Pixel，每个像素分成两个子像素。对焦时，两种像素单独输出，得到 A 像和 B 像，通过 A、B 之间的距离判断失焦相位。正式拍摄时 A、B 像素合并成一体，输出一幅图像。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus6.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus7.png"></p><p>如下图所示，当对焦不良时，A 像和 B 像整体相似，但空间上存在若干个像素的距离。而对焦良好时，A 像和 B 像应完全重合。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus8.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/focus9.png"></p><p>PD sensor 方案使用少量像素帮助对焦，工艺更加简单，但是由于信息较少，对焦所需的时间会更久。DP sensor 方案每个像素都提供对焦信息因此速度更快，但是工艺也更加复杂，成本通常更高一些。</p><h1 id="激光对焦-ldaflaser-detection-auto-focus">激光对焦-LDAF(Laser Detection Auto Focus)</h1><p>激光对焦是通过摄像头旁边的红外激光传感器向被摄物体发射低功率激光，经过反射后被传感器接收，并计算出与被摄物体之间的距离。之后镜间马达便直接将镜片推到相应位置，完成对焦。 和相位对焦一样，同样是一次完成。 激光对焦技术对于微距、弱光环境以及反差不够明显的区域，效果显著，能够有效提高手机在这些情况下的对焦成功率，只是在对焦速度上，激光对焦比较一般。而在光线正常的条件下，激光对焦的速度和相位对焦一样非常之快。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDkwMDAwNTY=">https://zhuanlan.zhihu.com/p/109000056<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAyNjUzNzk=">https://zhuanlan.zhihu.com/p/470265379<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucWlueGluZy54eXovcG9zdHMvNzIwYWQ1MWIv">https://www.qinxing.xyz/posts/720ad51b/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> 3A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP 之 Pipeline</title>
      <link href="/next/2023/Camera/CameraPipeline/"/>
      <url>/next/2023/Camera/CameraPipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-isp">什么是 ISP</h1><p>主流的 CMOS 和 CCD sensor 几乎都是输出 Bayer mosaic 格式的 RAW 数据，这种数据格式是无法直接观看的，必须转换成常见的 RGB 或 YUV 格式才能被主流的图像处理软件支持。对于 camera 产品而言，一般还需要将 RGB 或 YUV 图像进一步转换成 JPEG 格式以方便进行存储。上述图像处理过程统称图像信号处理（Image Signal Processing，ISP），广义的 ISP 包含了 JPEG 和 H.264/265 图像压缩处理，而狭义的 ISP 仅包括从 RAW 格式变换到 RGB 或 YUV 的处理过程。</p><span id="more"></span><p>一个典型的 ISP 流水线由一系列处理模块组成，这些模块首尾相连，在几百 MHz 的时钟驱动下同时高速运转，图像数据不断从一个模块转移至下一个模块，直到完成所有的算法处理，最终以 YUV 或 RGB 的形式从流水线的末级流出 ISP。下图所示的是一个支持常见基本功能的 ISP 流水线。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline1.png"></p><p>从图中可以看到，图像数据在 ISP 内部经历了两次颜色空间变换，第一次变换发生在 Demosaic 模块，它把像素从即 RAW 域变换到 RGB 域，第二次变换发生在 CSC 模块，它把像素从 RGB 变到 YUV 域。下表对 ISP 各模块的作用给予了简要说明。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline2.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline3.png"></p><ul><li>DPC(Defective Pixel Correction) 坏点矫正。 如果图像中存在坏点的话，在进行插值和滤波处理的时候，会影响周围的像素点，因此需要在插值和滤波之前对坏点进行校正。<ul><li>静态坏点校正：静态坏点的校正是基于已有的静态坏点表，比较当前点的坐标是否与静态坏点表中的某个坐标一致，若一致则判定为坏点，然后再计算校正结果对其进行校正。，每个 sensor 的坏点都不一样，需要 sensor 厂商给出每个 sensor 的静态坏点表。sensor 的静态坏点表一旦写入存储，dpc 模块会自动替换坏点表中所示坏点。</li><li>动态坏点校正：动态坏点的校正可以实时的检测和校正 sensor 的亮点与暗点，并且校正的坏点个数不受限制。</li></ul></li><li>BLC(Black Level Compensation) 黑电平补偿 矫正。 黑电平（Black Level Correction）：即黑色数据的最低电平值，通常指感光图像数据为 0 时对应的 sensor 信号电平值。其原因如下：<ul><li>sensor 厂家一般会在 AD 的输入之前加上一个固定的偏移量，使输出的 pixel value 在 5（非固定）~255 之间，目的是为了让暗部的细节完全保留。</li><li>sensor 的电路本身会存在暗电流。 矫正方法：</li><li>目前市场上使用的 ISP 一般采用的方法是在 sensor 输出的图像上减去一个固定数值。</li><li>利用黑电平随温度和 gain 的漂移曲线，利用一次函数的方式进行校正，但是对于不同 sensor，漂移曲线不一样，因此该方案没有作为通用方案。</li></ul></li><li><p>LSC(Lens Shading Correction) 镜头矫正。 由于镜头的原因造成的暗角色散等现象需要对图像做一些矫正，后文再做详细介绍。</p></li><li><p>NR(Noise Reduction) 降噪。 raw 域降噪，由于 sensor 输出的数据会存在各种噪声，而 raw 域是在偏靠近原始数据一端，在这个阶段做降噪可以减少噪声在后续算法中放大和传播，后文再做详细介绍。</p></li><li><p>AWB(Auto White Balance) 自动白平衡。 自动白平衡，监测环境光，尽可能还原物体本来的颜色，后文再做详细介绍。</p></li><li><p>Bayer Demosaic 去马赛克。 raw 数据只有在 CFA 下只有一个颜色的亮度信息，需要根据周围的颜色来差值得到 RGB 颜色，这是 raw 域最后一步，经过这一步图像就变成 RGB 域了。</p></li><li>Gamma 曲线校正。 sensor 对光线的感知是线性的，而人眼对 gamma 的感知是非线性的，因此需要一个映射。其矫正方法如下：<ul><li><strong>LUT 法：</strong> 提前把每个像素值经 gamma 矫正后对应的值求出来，然后把这些数据直接存储到一个数中，到矫正的时候根据输入的值就能直接通过数组下标就能找到对应的矫正后的值，这种方式最大的有点就时快，几乎不消耗硬件资源，因为几乎不用做任何计算的处理，但是这种方式的弊端在于需要大量的内存来存储这么这个表。</li><li><strong>线性插值法：</strong> 线性插值法也很好理解，就是在 gamma 曲线上提取一些采样点，然后把采样点的输入输出作为 xy 存储起来，然后矫正的时候如果在采样点上就接直接输入矫正值，如果不在，那么肯定在某两个采样点之间，那么就可以就可以通过这两个采样点的线性方程求解出该点的校正值。但是这种方式会有一定的误差，因为线性方程并布恩那个完全拟合 gamma 曲线。</li></ul></li><li><p>CCM(Color Correction Matrix) 颜色校正。 由于人眼对色彩的感知曲线和 sensor 对色彩的感知曲线不同，为了更符合人类的视觉需要对 sensor 输出的色彩做一个映射，就是 CCM 模块做的事情。这个后文再做详细介绍。</p></li><li><p>CSC(Color Space Convert) 色彩空间转换。 颜色空间转换，很多算法需要基于 YUV 格式来做，且最重要的 H264、H265 编解码都是基于 YUV 格式的，ISP 需要将图像由 RGB 域转 YUV 域，而该模块就是干这个事情的。</p></li><li><p>NR Luma(Noise Reduction forLuma) 亮度降噪。 对 Y 分量，也就是亮度信息做降噪处理，一般亮度越低信噪比越低。降噪方法一般就是两种在频域和空域里进行降噪，而常用的算法就是就是设计一个滤波窗口然后对图像进行卷积运算。</p></li><li><p>NR Chroma(Noise Reduction for Chroma) 色彩降噪。 对 UV 分量进行降噪处理，这里的噪声会造成色彩的波动，在亮度很低的情况下噪声会很大，造成色彩波动比较大。</p></li><li><p>Edge Enhance 边缘增强。 由于之前的域中会多次进行降噪处理，而降噪不可避免的会将图像中一些细节也捎带着消除了，导致图像模糊。为了将图像细节还原，减少图像损失，需要对其进行增强，但是不能再次引入噪声，就出现了 Edge Enhance 边缘增强这类处理模块。边缘增强和我们日常说的锐化 sharp 是比较相似的。但是二者也有区别：锐化针对图像所有内容增加锐利度，边缘增强只是针对边缘，避免噪声也会锐化放大。后文再详细介绍。</p></li><li>Hue &amp; Saturation 色调饱和度控制。<ul><li>饱和度 Saturation 就是说色彩的鲜艳程度。在 YUV 域中，U、V 分量分别代表蓝和红分量。当 U=V=128 的时候，表示饱和度为 0；当|U-128|和|V-128|的值越大，饱和度也越大。当 U、V 分量的差值与系数 s 相乘，就可以调整饱和度幅度。s=0 表示灰度，s=1 表示原图不调整，0~1 之间表示降低饱和度，大于 1 表示增加饱和度。</li><li>Hue 的意思是色调、色相，表示颜色的相位角。简单理解就是，在一个标准圆中，红色是 0°，绿色是 120°、蓝色是 240°，不同度数表示不同的颜色。后文再详细介绍。</li></ul></li><li>Contrast &amp; Brightness 对比度亮度控制。<ul><li>Brightness 亮度控制是一般摄像头都会有的功能，顾名思义，就是控制亮度来改变图片效果。</li><li>对比度调节 Contrast 也叫做对比度增强 Contrast Enhancement，就是增强图片的对比度。目前对比度增强主要的算法是直方图均衡化（Histogram），根据原始图像的亮度数据进行重新分布，使图片的亮度分布更加均匀 后文再详细介绍。</li></ul></li></ul><h1 id="isp-输入图像的格式">ISP 输入图像的格式</h1><p>目前主流的 CMOS sensor 几乎都是输出 Bayer mosaic 格式的 RAW 数据。Bayer 格式图片是伊士曼·柯达公司科学家 Bryce Bayer（1929 –2012）发明的，拜耳阵列被广泛运用与数字图像处理领域。</p><p>常用的 Bayer 格式有 RGGB,、GRBG、GBRG 等多种，因此需要正确配置 ISP 以反应 sensor 的数据格式。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline4.png"></p><p>RAW 数据的精度常见有 8/10/12/14bit 等规格。安防监控行业较多使用 10/12bit 精度的 sensor，医疗行业则主要使用 12bit 以上精度 sensor，单反和广电行业则主要使用 14bit 精度 sensor。对与一些带宽和存储资源特别紧张的场合，有些 sensor 会支持压缩表示以节约带宽 RawCopmpress。</p><h2 id="图像接入-isp-的方式">图像接入 ISP 的方式</h2><ul><li>在线模式，online mode，sensor 产生的实时数据和时序控制信号以行为单位送入 ISP 进行处理，具备低延迟 (low latency) 的优点。</li><li>离线模式，offline mode，待处理的图像以帧为单位存储于系统内存，需要处理时由一个控制逻辑通过 DMA 从内存中读取数据，并添加模拟 sensor 行为的时序控制信号，然后送给 ISP 进行处理。</li></ul><h2 id="行缓冲-line-buffer">行缓冲 Line Buffer</h2><p>不论是在线模式还是离线模式，ISP 处理图像都是以行为单位的，所以 ISP 模块都会设计一个 line buffer 可以缓存若干行图像。通常这个 line buffer 的大小就决定了这个 ISP 所支持的最大分辨率。举例来说，如果一个 ISP 的 line buffer 可以容纳每行 2048 个像素，则它无法支持超过 2k/1080p 的分辨率规格。</p><h2 id="数据对齐-alignment">数据对齐 Alignment</h2><p>ISP、CODEC 等硬件单元在处理图像时通常都会有粒度（granularity）要求，即必须将 8/16/32/64/128 个像素作为一组来处理，这样就可以通过硬件并行化来提高吞吐率。这个需求称为 ISP 的数据对齐（alignment）需求，多数 sensor 都支持一个 linesize 属性，以保证 sensor 输出的每行数据的宽度符合 ISP 的对齐要求。</p><h2 id="图像压缩">图像压缩</h2><p>4K 分辨率的图像有 800W 个像素，RAW 格式占 1600W 字节，YUV422 格式占 1200W 字节，8K 分辨率，也就是 7680x4320，RAW 格式占 6600W 字节。</p><p>为了减轻传输带宽和存储的压力，支持 4K 以上的芯片都会在 DMA 上设计一个压缩算法。当 DMA 向内存中写入数据时，实际进入内存的是压缩后的数据。当 DMA 从内存中读取数据时，用户得到的是解压缩后的数据。</p><p>Arm 出售的图像压缩技术叫 AFBC，即 Arm Frame Buffer Compression，这是一种基于脉冲编码调制 (Pulse Code Modulation,PCM) 技术实现的无损压缩技术，典型情况下可以实现 50% 左右的压缩率，可以节省存储空间和传输带宽。</p><h1 id="色调映射-tone-mapping">色调映射 Tone Mapping</h1><p>摄像机拍摄室外场景时，晴朗夏天的光照度可以达到 10 万~20 万 lux，理论上拍摄这种场景需要提供高达 5000：1 的动态范围，在摄像机内部则需要使用至少 13 位的数据才能表示 5000：1 的动态范围，在通用 CPU 架构中使用 16 位整数则更加方便。由于数据在处理环节经常涉及除法、开方、指数等浮点运算，所以还需要预留若干个小数位以保持浮点精度，4 位二进制小数可以提供 0.0625 精度，8 位二进制小数可以提供 0.0039 精度。上述的主流 ISP 方案中使用 20 位数据。</p><p>当图像在显示设备上输出时，普通的 LDR 显示器只能提供 256 级灰度，按数量级是 100:1 的动态范围。符合 HDR10 标准的显示器可以提供 1000:1 的动态范围，已经可以较好地还原自然场景的动态。如果摄像机的适配输出设备是 LDR 显示器，则摄像机的 ISP 内部需要完成从 5000:1 到 100:1 的动态范围压缩。</p><p>当 WDR 模块完成多帧合成（frame stitch）后，接下来就需要对数据位宽进行压缩以节约后续步骤的计算资源。比较合理的做法是采取逐级压缩策略，比如在 WDR 模块先压缩到 12 位精度，经过 CCM、Gamma 等颜色处理后进一步压缩到 10 位精度，经过 CSC 模块后进行最后一次压缩得到最终的 8 位精度输出。</p><p>从 16/20 位精度压缩到 12 位精度的过程称为色调映射，这一步骤的主要任务是压缩图像的动态范围，将 HDR 图像映射到 LDR 图像，并尽量保证图像细节不损失。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline5.png"></p><p>色调映射的方法大致分为两类 ，即全局算法和局部算法。</p><h2 id="全局算法global-tone-mappinggtm">全局算法（Global Tone Mapping，GTM）</h2><p>全局算法可以理解为每幅图像有一个颜色映射表，GTM 算法通过查表的方法把一个输入颜色映射为一个输出颜色。有些算法对所有图像都使用固定的表，有些算法则是针对每一帧图像创建不同的表。</p><p>GTM 算法特点 ：</p><ul><li>任意相同颜色的像素点，在映射后，还是相同的颜色。</li><li>全局算法一般较简单，速度快。</li><li>全局算法的性能一般劣于局部方法。</li></ul><p>存在算法 ： 直方图均衡化、Gamma、对数校正、直方图规定化、分段灰度变换</p><p>一种基于 Gamma 的算法叫做 Academy Color Encoding System（ACES），它由美国电影艺术与科学学会提出，有人认为这是目前最好的一种 GTM 算法。ACES 本质上是一个通用的数据交换格式，既可以把不同的输入设备转成 ACES，也可以把 ACES 在不同的显示设备上正确地显示。不管是 LDR 还是 HDR 都可以在 ACES 里表达出来。ACES 的转换曲线如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline6.png"></p><h2 id="局部算法local-tone-mappingltm">局部算法（Local Tone Mapping，LTM）</h2><p>人眼的感知特性具有局部性特点，举例来说，在普通人眼看来下图中的 A 色块的亮度明显低于 B 色块的亮度。而事实真相是，这两个色块的真实像素亮度是一模一样的，人眼感觉 B 更亮，主要是因为 B 的周围是暗色块，而 A 的周围是亮色块，人的知觉系统针对这种场景自动做了对比度提升。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline7.png"></p><p>这种现象在总体上可以归结为人的知觉恒常特性，具体地说就是亮度恒常特性。下图是另外一个亮度恒常的例子。在这个例子中，所有小灰色块的真实亮度都是一样的，但是如果周围环绕的颜色不同，人对灰色块的颜色知觉也不相同。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pipeline8.png"></p><p>局部算法借鉴了人眼的知觉原理，在映射一个像素时，不仅考虑该像素的绝对值，还会考虑该像素周围区域的平均亮度值，将对比度大的像素映射为高亮，对比度小的像素映射为低亮，往往可以取得更好的效果。</p><p>LTM 算法特点 ：</p><ul><li>映射前颜色相同的像素点，映射后颜色可能不同。</li><li>局部算法一般较全局方法更复杂，速度相对较慢。</li><li>局部算法的性能一般优于全局方法。</li><li>会出现光晕等现象。</li></ul><p>存在算法 ： 分块中值直方图，基于 Retinex 原理的算法等</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODgyMDkyNw==">https://zhuanlan.zhihu.com/p/98820927<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTc4MTM0MTc=">https://zhuanlan.zhihu.com/p/397813417<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> ISP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lens 之像差</title>
      <link href="/next/2023/Camera/CameraLensAberration/"/>
      <url>/next/2023/Camera/CameraLensAberration/</url>
      
        <content type="html"><![CDATA[<h1 id="几何像差geometrical-aberration">几何像差（Geometrical Aberration）</h1><p>几何像差分析单波长光线在光学系统（透镜组）中，由于透镜表面不同位置上折光能力的差异造成的成像面上，光点位置产生偏离造成物、像关系不共轭的现象。</p><span id="more"></span><h2 id="spherical-aberration球差">Spherical aberration（球差）</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/Aberration1.png"></p><p>孔径增大后，轴上点大光线和近轴光线在像空间与光轴交点位置不一致，引起的效应就是球差。</p><p>球面像差是发生在经过透镜折射或面镜反射的光线，接近中心与靠近边缘的光线不能将影像聚集在一个点上的现象。当平行的光线由镜片的边缘通过时，它的焦点位置比较靠近镜片，而由镜片的中央通过的光线，它的焦点位置则较远离镜片（这种沿着光轴的焦点错开的量，称为纵向球面像差）。口径愈大的镜头，这种倾向愈明显。</p><ul><li>焦点随离轴高度而改变。</li><li>球差是球面镜的本性。</li><li>镜片组合或非球面可减少球差。</li></ul><p><strong>矫正</strong></p><ul><li>凹凸透镜补偿法：采用增加透镜的方法，增加凹凸面，从而减小球差的大小。</li><li>非球面透镜校正：制作成本高昂。</li></ul><h2 id="coma彗差">Coma（彗差）</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/Aberration2_1.png"></p><p>彗形像差，又称彗星像差，表示上下光线关于主光线的不对称度，即：</p><p><span class="math display">\[K_{T}^{'}  = y{'} - \frac{1}{2}(y_{A}^{'} + y_{B}^{'})\]</span></p><ul><li>焦点随离轴高度而改变。</li><li>轴上物点所发出光线不会产生彗差。</li><li>像的清晰度，使成像的质量降低。</li></ul><p><strong>矫正</strong><br>单一透镜或透镜系统的彗形像差，可以经由选择适当的透镜表面曲率有效的降低（某些情况下可以被消除）以合于应用。目前削减彗形像差最普遍的方法就是使用非球面镜。使用对称的结构，这种方法不仅只对彗差校正，对象散、场曲、和畸变的校正作用也非常有帮助。</p><h2 id="astigmatism像散">Astigmatism（像散）</h2><p>在测试镜头时常会看中间及边缘的成像质素，几乎可以肯定，越接近边缘的影像质素都会下降，这是由于水平面光线和垂直面光线聚焦在不同焦点上所引起。</p><p>根据现代物理学原理，光线以波动能量形式传播，而且相对光线的传播方向，光波震动的方向是四方八面的。如果用向量（Vector）方式理解，一束光线可分为水平方向震动和垂直线方向震动两部分。当光线从偏离中轴的斜角度射入，有机会出现水平面光线和垂直面光线聚焦在主轴不同位置的误差。两个焦点之间所产生的影像会变得模糊，边缘像渗开一样。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/Aberration3.jpg"></p><p>偏离中轴进入镜片的光线可分为水平面光线（橙色）和垂直面光线（绿色） ，各自的焦点却在不同位置。</p><ul><li>光线非对称射入透镜。</li><li>平行和垂直面上的焦点不同。</li><li>子午聚焦面和弧矢聚焦面间距愈长像散愈严重。</li><li>像散仅与光学系统的视场有关，视场越大，像散现象越明显。</li><li>若是发光点在齐明点或是球心位置，无像散。</li></ul><p><strong>矫正</strong></p><ul><li>将镜头成像圈覆盖的范围加大，使成像圈中央部分覆盖感光元件。</li><li>适当缩小镜头光圈。</li></ul><h2 id="petzral-curvaturefield-curvature场曲">Petzral curvature/field curvature（场曲）</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration4.png"></p><p>像场弯曲，简称场曲，是因镜片缺陷，使垂直于主光轴的物平面上发出的光经透镜成像后，清晰的最佳实像面不是平面而是一个曲面的一种像差。1839 年匈牙利物理学家约瑟夫·佩兹瓦尔（英语：Joseph Petzval）最先从物理学角度阐明像场弯曲的原理，为纪念他，像场弯曲也称为佩兹瓦尔像场弯曲。</p><p>当一系统的球差、慧差、像散都修正为零时，系统由不同角度入射所看到的焦距皆相同，因此成像面非平坦，而是一弯曲面，相对于一个平面的感光元件，则会收到中间聚焦而周围失焦，周围聚焦中间失焦的影像。</p><p>曲面成像面会严重影响接收面上成像清晰度，会造成成像的局部清晰、局部模糊的状况。 广角、鱼眼镜头主要相差为场曲，而在针对场曲校正的大部分专利中，通常也会伴随着另一种像差的产生：畸变。</p><p><strong>矫正</strong></p><ul><li>利用散光来部分抵消像场弯曲；十九世纪中叶的一些镜头多用此法；（近代 24X36 毫米相机镜头也用此法）。</li><li>利用厚弯月形镜片组，其两个外镜面的曲率半径大抵相同。</li><li>利用一系列互相隔开较大距离的正、负镜片，为使其消色差，务必大大加强负镜片的度数，这就自然减少佩兹瓦尔和。</li></ul><h2 id="distortion畸变">Distortion（畸变）</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration5.png"></p><p>由理想光学系统导出的理想像高 <span class="math inline">\(\eta{'}\)</span> 与实际主光线高度 <span class="math inline">\(y{'}\)</span> 的差称为畸变（Distortion） 常用的是相对畸变：</p><p><span class="math display">\[DT = \frac{\eta{'} - y{'}}{\eta{'}} \times 100 \%\]</span></p><p>在目视系统中，小于 3%的畸变不易觉察，但机器视觉对畸变的要求比较高。</p><p>畸变按其方向可分为桶形畸变和枕形畸变。在摄影中，一般认为广角镜头容易产生桶形畸变，而长焦镜头容易产生枕形畸变。</p><p><strong>区分场曲和畸变：</strong><br>对于场曲来说，如果像面位于近轴焦平面，则模拟得到的图像中心区域非常清晰，边缘很模糊，如果将像面置于边缘视场焦点处，可得到边缘区域非常清晰，中心区域比较模糊的图像。对于畸变来说，边缘和中心都很清晰，只改变像的形状。</p><h1 id="色散像差chromatic-aberration">色散像差（Chromatic Aberration）</h1><p>分析的是由于不同波长的光在透镜介质中的折射率不同，造成成像面上光点位置产生偏离造成物、像关系不共轭的现象。</p><h2 id="axial-color轴向色差">Axial color（轴向色差）</h2><p>轴向色差，指不同波长的光束通过透镜后焦点位于沿轴不同位置，因为它的形成原因同球差。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration6.png"></p><p>由平行光线产生的色差。</p><h2 id="lateral-color横向色差">Lateral color（横向色差）</h2><p>斜光线产生的色差称放大率色差（transverse chromatic aberration），又称倍率色差或横向色差。斜光线进入镜头，即使假设轴向色差为零，由于色光（不同波长的光线）形成的像大小（放大率）不同，而产生的焦点不一致的现象。由于波长的不同，像的大小差异，在影像上产生色的错位，这种错位称放大率色差。斜光线即使通过的光圈孔径缩成很小的光圈，放大率色差也不会减少。</p><p>由于不同光线波长的折射率不同，导致像平面上不同颜色波长的光线产生横向色散，即不同颜色有不同的放大倍率：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration9.png"></p><p>不同于纵向色差，横向色差不会出现在图像中间，一般出现在图像边缘高对比度的区域。鱼眼、广角和低质量的镜头经常出现蓝紫边现象。</p><h2 id="矫正">矫正</h2><ul><li><p>抵消色散属性的衍射光学器件可以用来矫正色差 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration7.png"></p></li><li><p>胶合透镜 Cemented achromat <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration8.png"></p></li><li><p>空气层双透镜 Air-spaced Achromate <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/aberration10.png"></p></li><li><p>图像处理中的消色差 消色差的方法通常为缩放边缘颜色通道，或减去部分缩放后的边缘通道。</p></li></ul><h1 id="最后">最后</h1><p>当然还有另外一种分类方法：轴上像差与轴外像差，具体可以参考《近代光学系统设计概论》。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLWhhbnMvJUU1JUJEJTk3JUU1JUJEJUEyJUU1JTgzJThGJUU1JUI3JUFF">https://www.wikiwand.com/zh-hans/%E5%BD%97%E5%BD%A2%E5%83%8F%E5%B7%AE<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLyVFNCVCRCVBOSVFNSU4NSVCOSVFNyU5MyVBNiVFNSVCMCU5NCVFNSU4MyU4RiVFNSU5QyVCQSVFNSVCQyVBRiVFNiU5QiVCMg==">https://www.wikiwand.com/zh/%E4%BD%A9%E5%85%B9%E7%93%A6%E5%B0%94%E5%83%8F%E5%9C%BA%E5%BC%AF%E6%9B%B2<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTk2NTI5MjU=">https://zhuanlan.zhihu.com/p/359652925<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLyVFNyU5NSVCOCVFOCVBRSU4QQ==">https://www.wikiwand.com/zh/%E7%95%B8%E8%AE%8A<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGNmZXZlci5jb20vbmV3cy92aWV3Z2xvc3NhcnkucGhwP2dsb3NzYXJ5X2lkPTQ3">https://www.dcfever.com/news/viewglossary.php?glossary_id=47<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9rYi5jb2xvcnNwYWNlLmNvbS5jbi9rYi8yMDIyLzA3LzE4LyVFNiVBOCVBQSVFNSU5MCU5MSVFOCU4OSVCMiVFNSVCNyVBRS8=">https://kb.colorspace.com.cn/kb/2022/07/18/%E6%A8%AA%E5%90%91%E8%89%B2%E5%B7%AE/<i class="fa fa-external-link-alt"></i></span><br>《近代光学系统设计概论》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Lens </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Lens </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lens 之 Vignetting</title>
      <link href="/next/2023/Camera/CameraLensVignetting/"/>
      <url>/next/2023/Camera/CameraLensVignetting/</url>
      
        <content type="html"><![CDATA[<h1 id="自然暗角">自然暗角</h1><h2 id="原因">原因</h2><p>对着亮度均匀的景物，图像画面四角有变暗的现象，叫做失光或暗角（Vignetting）。暗角对于任何镜头都不可避免，这是由于镜头对于光学折射不均匀造成的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens20.png"></p><p><span class="math display">\[I_{A'} = \cos_{\alpha }^{4} I_{o'}\]</span></p><span id="more"></span><p>其中 <span class="math inline">\(\alpha \equiv chief - ray - angle \equiv CRA\)</span> 即主光线角度。需要注意的是，CRA 通常适用于 CMOS 或 CCD 之类的电子元件，对于传统的胶片底片不太受此参数影响，通常光学镜头中， $CRA20^{} $ 。 其中相对照度：</p><p><span class="math display">\[RI = \frac{I_{A'}}{I_{o'}} \]</span></p><p>这是由于光线出瞳后，轴上主光线到成像面的距离短于离轴主光线到成像面的距离，导致在成像面上不同位置光线呈现出相应的强度衰减，在成像面上，会出现中间亮四周暗的现象，称之为暗角（自然暗角）不同视场的相对照度，即是衡量暗角大小的参数。在相同的物面亮度下，通过 RI 与视场角的关系，即可对成像相对照度进行评估，即 $RI - $ 图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens21.png"></p><h2 id="解决">解决</h2><p>可以通过 Autoshading 功能在 CCD 或者 CMOS 中调整不同像素信号的增益值，将均匀光强物面产生的光强信号分布通过调整不同像素的增益值，校正至均匀分布的状态，一定程度上消除自然暗角。代价就是，信噪比稍微降低杂信号增加。所以在 Sensor 的 datasheet 中，会有主光线角 CRA 不得大于某预设值的定义，避免相对照度 RI 超过可调整校正的范围。</p><p>当然还有就是 sensor 和镜头的 CRA 需要匹配。</p><h1 id="光学暗角">光学暗角</h1><p>在光学系统优化中我们经常会遇到这样的情况： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens22.png"></p><p>如红色方框圈出来的光瞳位置，轴上视场（0°）的主光线、边缘光线可以填充满整个光瞳，而离轴角度的视场（&gt;0°），则会出现边缘光线无法填满整个光瞳的现象。我们将离轴光线略微向光瞳边缘平移一下，就可发现这是为什么： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens23.png"></p><p>由于离轴的物点发出的光线超出镜片边缘的部分不被系统所接收，即边缘光线受镜片大小所限使该视场的光线未占满光圈、光圈没有被充分利用，从而造成该视场光强变低。反映在影像上，就是该视场成像的光线数量少、造成像点的光强偏低，产生光学暗角。光学暗角的数值大小由主光线角度 CRA（视场角）与离轴边缘视场的光瞳直径之比定义（等效于轴上视场与轴外视场参与成像的光线数量之比）：</p><p><span class="math display">\[Optical Vignetting = \frac{D_{margin}}{D_{center}}  = \frac{D_{\alpha  = 0}}{D_{\alpha _{Max}}} \]</span></p><p>Optical Vignetting=80%指离轴物点对光圈的利用率只有 80%，20%没有被利用。光学暗角大小是可以通过控制光瞳/光圈大小、透镜直径大小进行人为设计、控制。</p><p>综合这两类暗角影响，描述光学系统成像总体暗角的参数可以定义为，自然暗角与光学暗角相乘：</p><p><span class="math display">\[Vignetting = RI \times Optical Vignetting = \frac{I_{A'}}{I_{O'}}  \frac{D_{\alpha _{Max}}}{D_{\alpha  = 0}}  = (cos^4 \alpha_{Max}) \frac{D_{\alpha _{Max}}}{D_{\alpha  = 0}} \]</span></p><h1 id="人工暗角">人工暗角</h1><p>在以量测为目的的光学成像系统中，某种程度上暗角是我们不希望看到，可以归类为成像缺陷。但是经常出现光在边缘处由于斯涅耳定律的几何光学因素产生边缘视场上的像差： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens24.png"></p><p>以及在优化过程中，边缘处的像差呈发散式、不收敛的状况： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens25.png"></p><p>为消减这部分像差对成像的影响，这时可以选择通过将镜片做小的方式故意产生人工暗角，强行切去部分边缘光线，用以消减边缘光线产生的像差。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjUzNjM5NDU=">https://zhuanlan.zhihu.com/p/365363945<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Lens </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Lens </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lens 之光学基础</title>
      <link href="/next/2023/Camera/CameraLensOpticalBasics/"/>
      <url>/next/2023/Camera/CameraLensOpticalBasics/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>光学系统大的分类：</p><ul><li>几何光学 -&gt; 光线（像磁场线一样，其实不存在为了更好的研究其宏观特性而人为设计出来的）。</li><li>物理光学 -&gt; 光波 （分析光的波函数）。</li><li>量子光学 -&gt; 光子 （em...）。</li></ul><span id="more"></span><h1 id="折射系数-index-of-refraction">折射系数 (index of refraction)</h1><p>在几何光学的模型中，材料的光学性质是由材料的折射系数确定的，我们用字母 n 来代表折射系数。n 是一个关于波长 <span class="math inline">\(\lambda\)</span>的函数，不同波长的 n 不一样，也就是色散 (dispersion)。</p><p>折射系数与光速的关系为：</p><p><span class="math display">\[n = \frac{真空中光速}{介质中光速} = \frac{c}{v}  \]</span></p><p>前提：</p><ul><li>介质是均匀的 (homogenous)，即 n 在介质任意一点都是一样的。</li><li>介质是各向同性的 (isotropic)，即 n 在光传播的任何方向都是相同的。</li></ul><p>因为 <span class="math inline">\(v = \frac{c}{n}\)</span>，我们可以把光从 A 传播到 B 所需的时间写成：</p><p><span class="math display">\[t_{AB} = \int_{A}^{B} \frac{ds}{v} = \frac{1}{c}  \int_{A}^{B}n \cdot ds\]</span></p><p>我们可以把 <span class="math inline">\(\int n \cdot ds\)</span> 称作光程长度 (optical path length), 如果我们有一个点光源（面积无限小的理想化光源），如果有一表面满足等光程长度（传播时间都相等），我们就把这一表面称作几何波前 (geometrical wavefront)。在一个 n 是恒定的介质里，如果满足刚刚说的等光程长度的条件，那么这个波前就是一个球形波前 (spherical wavefront)。</p><h1 id="费马原理-fermats-principle">费马原理 (Fermat's Principle)</h1><p>费马原理（Fermat's principle）最早由法国科学家皮埃尔·德·费马在 1662 年提出：光传播的路径是光程取极值的路径。这个极值可能是极大值、极小值或函数的拐点。 最初提出时，又名“最短时间原理”：光线传播的路径是需时最少的路径。 费马原理更正确的称谓应是“平稳时间原理”：光沿着所需时间为平稳的路径传播。平稳是数学上的微分概念，可以理解为一阶导数为零，它可以是极大值、极小值甚至是拐点。 费马原理是几何光学的基本定理。用微分或变分法可以从费马原理导出以下三个几何光学定律：</p><ul><li>光线在真空中的直线传播。</li><li>光的反射定律 - 光线在界面上的反射， 入射角必须等于出射角。</li><li>光的折射定律（斯涅尔定律）。</li></ul><h1 id="斯涅尔定律-snells-law">斯涅尔定律 (Snell's Law)</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/Snell.png"></p><p>成像公式，即透镜成像公式、高斯成像公式，其形式为 <span class="math inline">\(\frac{1}{f} =\frac{1}{u} +\frac{1}{v}\)</span>。其中 f 为焦距，凸正凹负；u 为物距；v 为像距，实正虚负。</p><h1 id="衍射定律-todo待补充">衍射定律 TODO（待补充）</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/diffraction.png"> 光在传播路径中，遇到不透明或透明的障碍物或者小孔（窄缝），绕过障碍物，产生偏离直线传播的现象称为光的衍射。衍射时产生的明暗条纹或光环，叫衍射图样。包括：单缝衍射、圆孔衍射、圆板衍射及泊松亮斑</p><h1 id="理想光学系统与完美成像">理想光学系统与完美成像</h1><h2 id="理想光学系统">理想光学系统</h2><p>如果物空间中的一个物点 P 发出的发散球面波经过成像系统变换成一个汇聚球面波，球面波中心为 P‘，则此系统称为理想光学系统。</p><p>理想光学系统的物像关系应具备以下特性：</p><ul><li>点成点像：即对于物空间的每一点，在像空间必有一个点与之相对应，且只有一个点与之对应，这样的两个对应点称为物像空间的共轭点。</li><li>线成线像：即对于物空间的每一条直线，在像空间必有一条直线与之相对应，且只有一条直线与之对应，这样的两条对应直线称为物像空间的共轭线。</li><li>平面成平面像：即物空间的每一个平面，在像空间必有一个平面与之相对应，且只有一个平面与之对应，这样的两个对应平面称为物像空间的共轭面。</li></ul><p>共线成像理论是理想光学系统的基础理论，它只是基本假设，实际中是不存在这样的理想光学系统的。显然，理想光学系统是实际光学系统的努力方向。</p><h2 id="完美成像">完美成像</h2><h3 id="高解析度-high-resolution">高解析度 high resolution</h3><p>系统可以分辨较高的空间频率，即光束在通过镜组时衍射现象尽可能的低。分辨解析极限即艾里斑直径要尽可能的小：</p><p><span class="math display">\[d = 2.44 \cdot \lambda \cdot f \#\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/f1.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/f2.png"></p><p>获得高解析度，方法有：</p><ul><li>降低 F-number 或提高 NA 值。</li><li>使用波长更短的光源。</li></ul><h3 id="高对比度-high-contrast">高对比度 high contrast</h3><p><span class="math display">\[C = \frac{I_{Max} - I_{Min}}{I_{Max} + I_{Min}}\]</span></p><h3 id="色彩真实-true-color">色彩真实 true color</h3><p>色彩真实是以人对色彩的感知作为参考基准的。现今对于颜色的描述，均使用数学方式定义色彩。色彩空间（英语：Color space）是对色彩的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定模拟和数字表示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/f3.png"></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTc4MTUwMzQ=">https://zhuanlan.zhihu.com/p/357815034<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzQzMTcyODc=">https://zhuanlan.zhihu.com/p/534317287<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzkzNzk3NTc=">https://zhuanlan.zhihu.com/p/339379757<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLWhhbnMvJUU2JTk2JUFGJUU2JUI2JTg1JUU1JUIwJTk0JUU1JUFFJTlBJUU1JUJFJThC">https://www.wikiwand.com/zh-hans/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9FdGVybmFMU2lsZW5jZS9wb3N0cw==">https://www.zhihu.com/people/EternaLSilence/posts<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Lens </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Lens </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lens 之景深</title>
      <link href="/next/2023/Camera/CameraLensDepthOfField/"/>
      <url>/next/2023/Camera/CameraLensDepthOfField/</url>
      
        <content type="html"><![CDATA[<h1 id="景深的计算">景深的计算</h1><p>相机景深：其指的是在某个物距之间，还能够清晰成像的距离： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens4.png"></p><p>如果 sensor 刚好在像距的位置上，物体的一个点，成的像也就是一个点。如果 sensor 在像距的前面或者后面，这个点也就成了一个圆，专业术语叫弥散圆。当这个圆大到一定的程度的时候，照片也就糊了。</p><span id="more"></span><p>景深公式依据下列 6 个关系式：</p><p><span class="math display">\[d = \frac{f}{N} \tag1\]</span></p><p>其中 d 为光圈直径，f 为焦距，N 代表镜头设定的光圈值（2.8、4、5.6、8、11、22）等。</p><p>光学透镜成像公式（这个在光学原理一节有介绍，要通过相似三角形推导）：</p><p><span class="math display">\[\frac{1}{s} + \frac{1}{v} = \frac{1}{f} \tag2\]</span></p><p>其中 v 代表像距、s 代表物距。</p><p>后物体的成像公式：</p><p><span class="math display">\[\frac{1}{D_N} = \frac{1}{v_N} = \frac{1}{f} \tag3\]</span></p><p>前物体的成像：</p><p><span class="math display">\[\frac{1}{D_F} = \frac{1}{v_F} = \frac{1}{f} \tag4\]</span></p><p><span class="math display">\[\frac{v_N - v}{v_F} = \frac{c}{d}  \tag5\]</span></p><p><span class="math display">\[\frac{v - v_F}{v_F} = \frac{c}{d} \tag6\]</span></p><p>解以上方程组得：</p><p><span class="math display">\[D_F = \frac{s(H - f)}{H - s}  \tag7\]</span></p><p><span class="math display">\[D_N = \frac{s(H - f)}{H - 2f + s}  \tag8\]</span></p><h1 id="景深三要素">景深三要素</h1><h2 id="光圈">光圈</h2><p>光圈值，是镜头的焦距/镜头通光直径得出的相对值（相对孔径的倒数），光圈值越小，光圈越大。相同光圈值，sensor 表面的照度相同。光圈越大，景深越小。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens5.png"></p><p>如图，当光圈减小，虚线位置的弥散圈也在减小。弥散圈越小，成的像就越清晰。原来看不清楚的物体，弥散圈变小了，就能看清了，景深就变大了。夜间摄影的时候，增大光圈可以提高进光量，提升图像质量，但是大光圈也会导致景深太小，这个时候就需要两者权衡。拍人像的时候，我们又会要求景深小，这样就有背景虚化的效果，这个时候就需要大光圈。</p><h2 id="物距">物距</h2><p>物体越近，景深越小 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens6.png"></p><p>物体 123 是等距的，他们成的像分别是像 123，但是像的位置不是等距的。由于 sensor 聚焦好之后只能在一个位置上，在这个位置上能看到更多的物体，就是景深大。物体 1 比较远，我们将 sensor 聚焦在像 1 上，像 2 距离像 1 很近，弥散圈很小，很容易看清楚物体 2。相反的，物体 3 比较近，我们将 sensor 聚焦在像 3 上，像 2 离像 3 比较远，弥散圈大，不容易看清楚物体 2。所以从图中可以很容易的看出，物体越近，景深越小。</p><h2 id="焦距">焦距</h2><p>焦距越长，景深越小。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Lens/lens7.png"></p><p>两个物体 1 和 2，焦距 fa &lt; fb。当焦距为 fa，成的像分别是 1a 和 2a，当焦距为 fb 时，成的像分别为 1b 和 2b。当焦距比较小，为 fa 的时候，可以很明显的看到像 1a 和像 1b 距离很近，由于 sensor 只能固定在一个位置，更容易同时看清两个物体。因此焦距越短，景深越大。</p><table><thead><tr class="header"><th>景深</th><th>光圈</th><th>物距</th><th>焦距</th></tr></thead><tbody><tr class="odd"><td>大</td><td>小</td><td>近</td><td>短</td></tr><tr class="even"><td>小</td><td>大</td><td>远</td><td>长</td></tr></tbody></table><h1 id="景深与-sensor-的关系">景深与 Sensor 的关系</h1><p>我们会有一个直观的理解就是弥散圆小于 cmos 的像原大小那么就不会对成像产生影响，就感觉景深变大了，实际上景深需要转换到等效参数下。 在等效焦距、等效光圈、对焦距离三者相同的条件下，不同尺寸的感光元件景深保持一致。其中焦距和等效焦距、光圈和等效光圈的换算普遍以 135 传感器为标准。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucWlueGluZy54eXovcG9zdHMvYjMxZDM4MWUv">https://www.qinxing.xyz/posts/b31d381e/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Lens </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Lens </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sensor 的特性与噪声</title>
      <link href="/next/2023/Camera/CameraSensorCharacteristic/"/>
      <url>/next/2023/Camera/CameraSensorCharacteristic/</url>
      
        <content type="html"><![CDATA[<h1 id="cmos-sensor-的响应特性">CMOS sensor 的响应特性</h1><p>理想 CMOS sensor 的响应特性下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos1.png"></p><p>横坐标是光强，纵坐标是 cmos 输出信号，直线的斜率决定了单位输入能够激励的响应大小，这个斜率称为增益系数（gain）。sensor 会提供一组接口用于调节实际生效的增益值。</p><span id="more"></span><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos2.png"></p><p>而实际的 sensor 只能是在一段有限的区间内保持线性响应，对于幅度过小或者过大的输入信号会不能如实地表示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos3.png"></p><p>下图是实验测量的输入输出曲线，横坐标是入射到 sensor 的光子数，纵坐标是 sensor 输出的数值（Digital Number, DN）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos4.png"></p><p>以上关系用公式描述就是：</p><p><span class="math display">\[S(N,t) = q(\lambda) \cdot N \cdot  t\]</span></p><p>其中，<span class="math inline">\(S(N, t)\)</span> 是 sensor 的一个像素采集到的电子数， <span class="math inline">\(q(λ)\)</span> 是 sensor 在波长λ处的光电转换效率，N 是单位时间内入射到 sensor 表面的光子数（波长λ的单色光），t 是曝光时间。</p><p>sensor 最终输出的像素值是使用 ADC 对 S(N,t) 进行采样和 AD 转换得到的量化值，该值会有 PV(Pixel Value)，ADU(Analog-Digital Unit)，DN(Digital Number)，Output Code 等多种表述方式，并且</p><p><span class="math display">\[DN = g * S(N,t)\]</span></p><p>其中符号 g 代表增益系数 gain，意义是多少个光子能够激励出 1 个比特的 DN 值。</p><h1 id="势阱容量-saturation-capacity">势阱容量 （Saturation Capacity）</h1><p>势阱容量又称 Full Well Capacity，指一个像素的势阱最多能够容纳多少个光生电子，消费类的 sensor 一般以 2000~4000 较为常见，此值越大则 sensor 的动态性能越好。</p><p>下图是一些单反相机 sensor 的饱和阱容比较。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos7.png"></p><h1 id="噪声-noise">噪声 （Noise）</h1><p>由于电子的无规则热运动产生的噪声在所有电子设备中普遍存在，器件的温度越高，电子的热运动越剧烈，产生的噪声也就越大。</p><p>假设照明强度恒定、均匀，相机拍摄图像中的噪声是测量信号中空间和时间振动的总和。下图以传递函数的形式总结了 CMOS sensor 光、电转换模型以及几种主要噪声的数学模型。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos8.png"></p><p>下图更加细致地描述了 CMOS sensor 成像过程中各种噪声的来源和作用位置。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos9.png"></p><p>sensor 噪声中含有几部分分量：</p><ul><li><p><strong>暗散粒噪声 (σD):</strong> 硅片中电子的热运动会导致一些价电子随机激发至导带中形成暗电流（dark current），所以即使完全没有光子入射，sensor 也会存在一定的信号输出。暗散粒噪声在统计上服从泊松分布，与光信号的高低水平无关，但与传感器的温度有关，一般的规律是温度每升高 8°C 暗电流翻一倍。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos10.png"></p></li><li><p><strong>读出噪声 (σR):</strong> 该噪声是在产生电子信号时生成的。Sensor 中使用 AD 转换器（ADC）将模拟放大器输出的模拟电压采样为数字电压。由于数字信号的精度总是有限的，通常为 10 比特至 14 比特，幅值位于两个相邻数字之间的模拟信号会四舍五入到最接近的数值，所以这个过程会引入量化噪声，这是读出噪声的重要组成部分。该噪声由传感器的设计决定，意义是至少需要多少个电子才能驱动读出电路的 ADC 变化一个比特。它与信号高低水平和传感器温度无关。</p></li><li><p><strong>光子散粒噪声 (σS):</strong> Shot noise, 该噪声是与落于传感器像素上光子相关的统计噪声。在微观尺度下，光子流到达传感器的行为在时间和空间上都是不均匀的，整体上其统计规律符合泊松分布。光子散粒噪声是与被测信号的高低水平有关的，与传感器温度无关。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos11.png"></p></li><li><p><strong>固定模式噪声 (σF):</strong> Fixed-pattern noise（FPN）, CMOS sensor 每个像素内都配置一个电荷电压放大器，每行、每列都有一些晶体管用于控制像素的复位和读出，这些器件的工作参数相对理论值的漂移就构成一种固定模式噪声。另外，坏像素、瑕疵像素也可以视为一种固定模式噪声。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos12.png"></p></li><li><p><strong>复位噪声 (σr):</strong> 卷帘曝光方式需要 先对势阱复位，将势阱中自由积累的电荷全部释放，为后续的读出准备。但是由于暗电流的存在，每次复位后都会残留一些大小随机的噪声信号，即复位噪声，其大小与像素结构、芯片温度、PN 结电容有关，因此也称为 kTC 噪声。像素的复位是需要一定时间的。定量的研究表明，即使是采用较大的复位电流，一般也需要 1ms 以上的时间才能将电荷释放干净，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos13.png"></p><p>实际的复位控制信号通常会短于 1ms，因此下一帧图像多多少少会残存一些上一帧图像的影子，这个残影叫做 image lag，也是噪声的一种形式。</p></li><li><p><strong>1/f 噪声 (σf):</strong> 1/f 噪声是一种低频噪声，在有些文献中也称 flicker noise（闪烁噪声） 或 pink noise（粉红噪声），它广泛存在于半导体器件中。在低频的时候 1/f 噪声一般显著高于电散粒噪声。一种理论认为，半导体晶格中都会存在一些缺陷，这些缺陷能够捕获一些自由电子并将其束缚一段时间，这可以解释 1/f 噪声的一种来源。</p></li><li><p><strong>光响应非均匀性 (σp):</strong> 英文为 PRNU，Photo Response Non-Uniformity。Bayer 格式的 sensor 通常存在四种像素 (R,Gr,Gb,B)，这四种像素的光电转换特性（即增益特性）不可能是完全一样的，不同种像素间存在种间差异，同种像素之间也存在个体差异，如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos14.png"></p></li><li><p><strong>串扰：</strong> 英文为 Crosstalk，在通信领域中指两条信号线之间由于屏蔽不良而发生了的信号耦合，在 sensor 领域，串扰指的是入射到一个像素 A 的光信号没有在这个像素里被捕获，反而被其周围的像素 B 捕获，导致 B 产生了不该有的信号。</p></li></ul><p>在下图例子中，粉色表示的是不透光的像素，不应该有任何输出，黄色表示正常像素，应该有输出。实际上，光子是可以在硅片中穿透一定的距离的，从而有机会进入到粉色像素的感光区，从而变成粉色像素的信号，这就是 CMOS sensor 的串扰机制。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos15.png"></p><p>从下图可以看出，波长越长，串扰越严重，某些像素位置串扰能量可以达到 5%。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos16.png"></p><p>甚至可以进一步将量化噪声吸收到读出噪声中，于是每个像素的总有效噪声是下列所有噪声的总和：</p><p><span class="math display">\[\sigma_{eff} = \sqrt{\sigma_D^2 + \sigma_R^2 + \sigma_S^2}\]</span></p><h1 id="噪声模型">噪声模型</h1><p>PRNU 体现的是红、绿、蓝三种像素的增益差异，对于任一种像素，光信号越强像素值抖动越大，这体现了光信号本身的散粒噪声，光信号为零时，输出幅度最小的像素体现了半导体的暗散粒噪声，而 红、绿、蓝三种像素之间的差异体现了 FPN 噪声。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos17.png"></p><p>尽管像素噪声有多种来源，但每种噪声的贡献程度并不是同等重要的。为了简化计算，实际上经常采用简化的噪声模型，只考虑光散粒噪声、暗散粒噪声、读出噪声、以及 ADC 器件的量化噪声，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos18.png"></p><h1 id="信噪比-snr">信噪比 （SNR）</h1><p>信噪比是一个电子设备或者电子系统中信号与噪声的比例，如下图所示。这里面的信号指的是来自设备外部需要通过这台设备进行处理的电子信号，而噪声是指该设备自行产生的无规则信号，并且该种信号并不随外部输入信号的变化而变化。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos19.png"></p><p>下面分析 sensor 图像的信噪比。如前所述，设 S 为传感器上每个像素上入射光子通量为 N 光子/秒情况下产生的“信号”电子的数量，其中量子效率为 QE，曝光时间为 t 秒，那么：</p><p><span class="math display">\[S = (Q E)Nt\]</span></p><p>通过 S，可以将光子散粒噪声表示为：</p><p><span class="math display">\[\sigma_s = \sqrt{(Q E)Nt}\]</span></p><p>信噪比（SNR）可以由下式进行估算：</p><p><span class="math display">\[SNR = \frac{S}{\sigma_{eff}}\]</span></p><p>前面已经提到：</p><p><span class="math display">\[\sigma_{eff} = \sqrt{\sigma_D^2 + \sigma_R^2 + \sigma_S^2}\]</span></p><p>下图给出了 sensor 信号（光电子数 S）与噪声 (σeff) 之间的关系和变化规律。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos20.png"></p><p>传感器在光子数达到一个阈值后才开始有信号的（图上是在 10 与 100 个光子之间），如果传感器接受的光子数少于某个阈值，就不会有信号输出。这个阈值一般认为是读出噪声。在像素达到饱和前，光电子数随着入射光子数的增加而线性增加，而噪声随入射光子数增加按根号规律增加，噪声增加的速率低于信号增加的速率，因此总的信噪比不断增长。</p><p>当 S 很小时，SNR 主要由σR 决定，即 sensor 暗电流和读出噪声是主要来源。当 S 很大时，SNR 主要由σS 决定，即光信号本身的统计涨落是噪声的主要来源。</p><p>一般认为，SNR=10dB 是可接受（acceptable）的图像质量标准，该值意味着信号幅度是噪声的 3.16 倍。而 SNR=40dB 是优秀（excellent）的图像质量标准，该值意味着信号幅度是噪声的 100 倍，因此至少需要 10000e-饱和阱容。介于中间的是 SNR=30dB，该值要求像素提供 1000e-以上的饱和阱容，这刚好是很多手机 sensor 的指标范围。</p><p>下图是一些单反相机的典型 SNR 对比。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos22.png"></p><p>下图是 Canon 1D3 单反相机在不同 ISO 下的信噪比曲线，横坐标是曝光量，纵坐标是 SNR，都是以"stop"为单位，即以 2 为底的 log-log 坐标。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos23.png"></p><h1 id="动态范围-dynamic-range">动态范围 （Dynamic Range）</h1><p>一个信号系统的动态范围被定义成最大不失真电平和噪声电平的比值，在实际应用中经常用以 10 为底的对数来表示，单位是分贝。对于胶片和感光元件来说，动态范围表示图像中所包含的从“最暗”至“最亮”的取值范围。根据 ISO15739 的定义，“最亮”指的是能够使输出编码值达到特定“饱和值”的亮度；而“最暗”指的是图像信噪比下降至 1.0 时的亮度。</p><p>sensor 动态范围越大，所能表现的层次越丰富，所包含的色彩空间也越广。下图是用来测量 sensor 动态范围性能的常用方法。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos24.jpg"></p><p>前面已经提到，sensor 是由数以百万个甚至更多像素组成的，这些像素在曝光过程中吸收光子转化成电荷。一旦这些像素容量达到饱和，多余的电荷便会溢出导致输出信号不再增加，此时像素的值不能反映光信号的真实强度，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos25.png"></p><p>根据动态范围的定义，sensor 动态范围的分贝表示用以下公式计算：</p><p><span class="math display">\[DR = 20log(\frac{FullWellCapacity}{ReadOutNoise})\]</span></p><p>根据上面的公式可以简单计算出动态范围与 FullWellCapacity 之间的关系。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos26.png"></p><p>显然，目前较好的工艺水平（SONY）可以做到每个像素容纳 10000 ~ 30000 个电子，可以提供 80 ~ 90dB 的极限动态范围，但是更多就不合理也不经济了，因为更大的势阱容量需要更大的像素面积，而像素大到一定程度之后就会遇到成品率瓶颈。</p><p>下图列举了一些典型单反相机 sensor 的动态范围指标，纵坐标可以理解为 AD 转换器的位数。例如 12 位 ADC 能够表示的动态范围是 <span class="math inline">\(2^{12} = 4096\)</span>，而 14 位 ADC 能够表示 <span class="math inline">\(2^{14}=16384\)</span> ，以此类推。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos27.png"></p><p>PS: ADC 位数的选择必须是和 sensor 的动态范围相适配的，ADC 位数高于 sensor 是没有任何意义的性能浪费，低于 sensor 则不能完全发挥出 sensor 的性能优势，也是一种性能浪费。从图中可以看到，单反相机的主流是采用 14 位 ADC，更高端的则采用 16 位 ADC。</p><h1 id="灵敏度-sensitivity">灵敏度 （Sensitivity）</h1><p>CMOS sensor 对入射光功率的响应能力用灵敏度参数衡量，常用的定义是在 1μm2 单位像素面积上，标准曝光条件下 (1Lux 照度，F5.6 光圈），在 1s 时间内积累的光子数能激励出多少 mV 的输出电压。</p><p>在量子效率一定的情况下，sensor 的灵敏度主要取决于电荷/电压转换系数 (Charge/Voltage Factor, CVF)。在下图的例子中，CVF =220uV/e，这意味着阱容 2000e 的像素能够激励出最大 440mV 的电压信号。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos28.png"></p><p>在曝光、增益相同的条件下，灵敏度高的 sensor 信噪比更高，这意味着至少在两个方面可以获得比较优势，</p><ul><li>在图像噪声水平接近的情况下，灵敏度高的 sensor 图像亮度更高、细节更丰富。</li><li>在图像整体亮度接近的情况下，灵敏度高的 sensor 噪声水平更低，图像画质更细腻。</li></ul><p>EMVA 1288 定义了评价 camera 灵敏度的标准，即多少个光子可以引起 camera 像素值变化 1，即一个 DN。根据量子力学的公式：</p><p><span class="math display">\[E_p = \frac{h \cdot c}{\lambda }\]</span></p><p>1 个波长为 540 nm 的绿光光子携带的能量是：</p><p><span class="math display">\[E_p = 3.683 \times  10^{-19}[J]\]</span></p><p>Camera 技术手册中会给出像素灵敏度规格： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/cmos29.png"></p><p>根据此规格即可计算像素值变化 1 需要多少个光子。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDA3NzcxMjE=">https://zhuanlan.zhihu.com/p/100777121<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Sensor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sensor 的结构</title>
      <link href="/next/2023/Camera/CameraSensorStruct/"/>
      <url>/next/2023/Camera/CameraSensorStruct/</url>
      
        <content type="html"><![CDATA[<h1 id="sensor-的硬件结构">sensor 的硬件结构</h1><h2 id="每个像素的结构">每个像素的结构</h2><ul><li><p>Microlens（微透镜）。 每个像素点的最上方有个微透镜，增加透光量。有镜头就有 CRA 的问题，超出一定角度的光线无法被收集，需要和镜头进行匹配。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel.png"></p></li><li>Photodiode（硅感光区）捕获光子，激发光生电子。</li><li>势阱，用电场捕获、存储光生电子。</li><li>电路，将电荷数量变换为电压信号，以及复位、选择、读出逻辑。</li><li><p>滤光膜，选择性透过三种波长中的一种。</p></li></ul><span id="more"></span><h2 id="细说-cra">细说 CRA</h2><p>CRA 是 Chief Ray Angle 的缩写，意思是主光角。从镜头的传感器一侧，可以聚焦到像素上的光线的最大角度被定义为一个参数，称为主光角 (CRA)。对于主光角的一般性定义是：此角度处的像素响应降低为零度角像素响应的 80%。</p><p>我们在挑选 Lens 的时候会有一个 CRA 的参数，在选择 sensor 的时候同样有一个 CRA 的参数，一般我们要求 Lens 的 CRA 曲线与 senosr 的 CRA 曲线完全匹配，如果实在不能匹配，我们也要求在同样的像高位置，CRA 相差不能超过 3 度，而且最好是 Lens 的 CRA 比 sensor 的 CRA 小，否则将会导致成像照度或色彩问题。</p><p>普通的 FSI 的 sensor 都有一个类似光子井的结构用来收集光子： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel9.jpg"></p><p>当 CRA 增加的时候，光线会被金属电路层阻挡掉一部分，导致 sensor 接受光的效能降低。</p><p>对于 BSI 的 sensor，这种影响也会更小： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel10.jpg"></p><p>怎样选择 Sensor 的 CRA：</p><ul><li>广角镜头：这时一般 Lens 的 CRA 比较大，需要选择 CRA 大于 25 度的 Sensor 或者 BSI 的 Sensor；一般用于手机、安防、玩具、网络摄像头等。</li><li>超长焦镜头：这时一般 Lens 的 CRA 比较小，需要选择 CRA 为 0 度的 Sensor；一般用于安防、机器视觉等。</li><li>变焦镜头：这时 Lens 的 CRA 是变化的，一般需要根据实际应用选择，最好采用大 pixel，BSI 的 Sensor；一般用于安防等。</li></ul><h2 id="sensor-的纵向结构">sensor 的纵向结构</h2><p>对于前照式 CMOS，光透过电路会发生反射，造成每个像素点之间的干扰。背照式的结构（感光层在电路的上方）不会受到电路的影响。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel1.png"></p><p>在背照式工艺的基础上又发展出了堆栈式（Stacked）工艺。顾名思义，堆栈式工艺把两片或者更多片硅片上下堆叠在一起，最上层硅片全部用于制造像素的感光区，而 sensor 控制所需的模拟、数字逻辑全部移到下层硅片，所以感光区占 sensor 靶面尺寸的比例可以接近 100%，终于达到了 sensor 效率的巅峰。</p><h2 id="细说-cfacolor-filter-array">细说 CFA(color filter array)</h2><p>每个像素点上覆盖有一种颜色的滤光片，从而去感知每种颜色的亮度。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel2.png"></p><p>Bayer 格式：绿色分量为总像素数的一半，红色蓝色各为总像素的四分之一。</p><h2 id="ad-转换及读出">AD 转换及读出</h2><p>sensor 会使用一个行选信号 (Row Select) 和一个列选信号 (Column Select) 来选中一个存储单元 (Pixel)，被选中的存储单元与输出放大器联通，将其存储的电荷数转换成电压值输出到阵列外部。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel30.png"></p><ul><li>每个像素内置一个电荷/电压放大器（Charge/Voltage Converter, CVC），将像素势阱中电荷的数量转换成电压信号。</li><li>读出逻辑选中某一行，该行所有像素的电荷/电压放大器的输出信号与列输出信号联通。</li><li>读出逻辑继续选中某一列，该列信号与可编程输出放大器（Output Amplifier）联通，被选中的像素的电压信号被放大一定倍数。</li><li>放大后的电压信号经 ADC 转换器后变成数字信号，最后通过一定的接口协议（如 MIPI）输出到外部。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel31.png"></li></ul><blockquote><p>调节相机的 ISO 其实就是调节这里的放大器放大倍率以及经过 AD 转换后的数字量乘以一个倍率，很容易理解模拟放大器的噪声更小，因为 AD 转换器本身存在一定的精度损失以及 AD 固有的噪声都会被数字增益放大。具体在设计的时候根据用户设置的 ISO 将其转换成具体的增益值，然后如果模拟增益足够就只用模拟增益，如果模拟增益不够，那么先将模拟增益拉满再设置数字增益。</p></blockquote><h2 id="总结">总结</h2><p>sensor 会通过微透镜将光线聚在一起（更多的光子照射到感光元件上）然后通过 Bayer Filter 分别获取红绿蓝三原色，这样每个像元上将可以获取一种颜色，再经过感光元件将光子转换成电信号存储起来。然后该信号会经过经过模拟放大器，将信号放大，再经过 AD 转换器获得数字信号，经过 MIPI 等物理接口将信号发送出去（对于集成 ISP 的模组还会经过 ISP 的处理再将信号发送出去）。</p><h1 id="像素类型-pixel-type">像素类型 (Pixel type)</h1><h2 id="被动像素-passive-pixel">被动像素 （Passive pixel）</h2><p>最简单的 Pixel 结构只有一个 PN 结作为感光结构，以及一个与它相连的 reset 晶体管（RS）作为一个开关，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel34.png"></p><ul><li>开始曝光前，像素的行选择地址会上电，于是 RS 使能，连通 PN 结与列选择器（column bus），同时列选择器会上电，使 PN 结上加高反向电压（如 3.3 V），短暂延时后 PN 结内电子空穴对达到平衡，于是 reset 操作完成，RS 信号失效，隔断 PN 结与 column bus 的连通。</li><li>开始曝光时，PN 结内的硅在吸收光子激发出电子-空穴对。受 PN 结内电场的影响，电子会流向 PN 结的 n+端，空穴会流向 PN 结的 p-substrate。因此，曝光后的的 PN 结反向电压会降低。</li><li>曝光结束后，RS 再次使能，读出电路会测量 PN 结内的电压，该电压与原反向电压之间的差值即正比于 PN 结接受到的光子数。</li><li>在读出感光信号后，会对 PN 结进行再次 reset，准备下次曝光。</li></ul><p>这种像素结构因为读出电路完全位于像素外面所以称为 Passive Pixel，其优点是 PN 结可以独占像素面积，缺点是噪声较大，主要有 2 个原因：</p><ul><li>PN 结的电容小于读出电路上的电容，所以对电路噪声很敏感。</li><li>PN 结的信号需要先读出才进行放大，因此读出电路的噪声会被一起放大。</li></ul><p>当 RS 使能且列选择器通高电平时，在电路原理上相当于对 PN 结的电容进行充电，但是充电后得到的电压值却有一定的随机性，一方面每个 PN 结的实际电容大小会服从一定的概率分布，结与结之间存在固定的偏差，这会构成一种固定模式噪声（Fixed Pattern Noise, FPN）；另一方面由于电路中存在暗电流噪声，即使是同一个结每次充电后得到的实际电压也不完全一样，这就构成了另一种模式的噪声，它与 PN 结的结构、温度和结电容大小都有关，称为 kTC 噪声。</p><h2 id="像素-ktc-噪声">像素 kTC 噪声</h2><p>在研究 PN 结的噪声特性时可将其简化为下图所示的由电阻电容形成的低通滤波网络。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel35.png"></p><p>可以证明，由电子热运动引起的宽带热噪声经 PN 结滤波后反应在结电容上的输出噪声功率用 kT/C 描述，其中 T 为 PN 结温度，C 为结电容，k 为常系数，因此合称 kTC 噪声。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel36.png"></p><h2 id="主动像素-active-pixel">主动像素 （Active pixel）</h2><p>目前主流的 CMOS 传感器都采用 Active Pixel 结构设计。下图所示的 Active Pixel 结构称为 3T 结构，每个像素包含一个感光 PN 结和 3 个晶体管，即一个复位管 RST，一个行选择器 RS，一个放大器 SF。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel37.png"></p><p>3T 结构的工作方式是：</p><ul><li>复位：使能 RST 给 PN 结加载反向电压，复位完成后撤销 RST。</li><li>曝光：与 Passive Pixel 原理相同。</li><li>读出：曝光完成后，RS 会被激活，PN 结中的信号被 SF 放大后读出。</li><li>循环：读出信号后，重新复位，曝光，读出，不断输出图像信号。</li></ul><p>基于 PN 结的 Active Pixel 流行与 90 年代中期，它解决了很多噪声问题。但是由 PN 结复位引入的 kTC 噪声却并没有得到解决。</p><h2 id="ppd-结构">PPD 结构</h2><p>为了解决复位 kTC 噪声，减小暗电流，在 3T 结构之后又出现了 PPD 结构（Pinned Photodiode Pixel），包括一个 PN 结感光区和 4 个晶体管，所以也称 4T 结构，它在 3T 结构的基础上增加了一个 TX 三极管起控制电荷转移的作用。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel38.png"></p><p>PPD 的出现是 CMOS 性能的巨大突破，它允许相关双采样（CDS）电路的引入，消除了复位引入的 kTC 噪声，运放器引入的 1/f 噪声和 offset 噪声。 它的工作方式如下：</p><ul><li>曝光。</li><li>复位：曝光结束时使能 RST，将读出区（n+区）复位到高电平。</li><li>读复位电平：读出 n+区的电平，其中包含运放的 offset 噪声，1/f 噪声以及复位引入的 kTC 噪声，将读出的信号存储在第一个电容中。</li><li>电荷转移：使能 TX，将电荷从感光区完全转移到 n+区准备读出，这里的机制类似于 CCD 中的电荷转移。</li><li>读信号电平：将 n+区的电压信号读出到第二个电容。这里的信号包括：光电转换产生的信号，运放产生的 offset，1/f 噪声以及复位引入的 kTC 噪声。</li><li>信号输出：将存储在两个电容中的信号相减（如采用 CDS，即可消除 Pixel 中的主要噪声），得到的信号在经过模拟放大，然后经过 ADC 采样，即可进行数字化信号输出。</li></ul><p>PPD 像素结构有如下优点：</p><ul><li>读出结构（n+区）的 kTC 噪声完全被 CDS 消除。</li><li>运放器的 offset 和 1/f 噪声，都会因 CDS 得到明显改善。</li><li>感光结构因复位引起的 kTC 噪声，由于 PPD 电荷的全转移，变的不再存在。</li><li>光敏感度，它直接取决于耗尽区的宽度，由于 PPD 的耗尽区一直延伸到近 Si−SiO2 界面，PPD 的光感度更高。</li><li>由于 p-n-p 的双结结构，PPD 的电容更高，能产生更高的动态范围。</li><li>由于 Si−SiO2 界面由一层 p+覆盖，减小了暗电流。</li></ul><h2 id="ppd-共享结构">PPD 共享结构</h2><p>PPD 结构有 4 个晶体管，有的设计甚至有 5 个，这大大降低了像素的填充因子（即感光区占整个像素面积的比值），这会影响传感器的光电转换效率，进而影响传感器的噪声表现。为了解决这个问题又出现了 PPD 共享结构，像素的感光区和读出电路由 TX 晶体管隔开，相邻像素之间可以共用读出电路，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel39.png"></p><p>图中 2x2 像素共享一个读出电路，一共使用 7 个晶体管，平均一个像素 1.75 个晶体管。这样可以大大减少每个像素中读出电路占用的面积，提高填充因子。美中不足的是，由于这 2x2 个像素的结构不再一致，会导致固定模式噪声（FPN）的出现，需要在后续 ISP 处理中消除。</p><h2 id="双相关采样cds">双相关采样（CDS）</h2><p>双相关采样即 Correlated Double Samping，其基本思想是进行两次采样，先采样一个参考信号用于评估背景噪声，延迟很短时间后再采集目标信号，从第二次采样中减去参考信号即得到去除了大部分背景噪声的目标信号，其原理模型如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel40.png"></p><p>CDS 成立的条件是在两次采样间背景噪声的幅度变化不大，因此它对去除固定噪声（FPN）和低频噪声效果比较理想，如 1/f 噪声，kTC 噪声等。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel41.png"></p><h1 id="光谱响应曲线">光谱响应曲线</h1><p>下图是 IMX290 每个红绿蓝滤光片的光谱响应曲线。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel3.png"></p><p>这是人眼视锥细胞对光谱的响应曲线 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel4.png"></p><p>由于人眼和 sensor 对光谱的感应曲线不同，同一个物体感知到的颜色不同。因此颜色需要一个转换关系。ISP 中的 CCM（色彩校正矩阵）就此诞生，利用一个 3x3 的矩阵，将 sensor 感知到的 RGB 颜色，校准成我们看到的 RGB 颜色。</p><h1 id="sensor-的曝光">Sensor 的曝光</h1><p>sensor 的曝光时间和快门时间是一个概念，都是 sensor 的感光时间。曝光（快门）时间越长，图像就越亮。</p><p>当控制快门时间，仍然达不到期望的亮度，就需要调节 sensor 的感光度（ISO）。CMOS sensor 的感光度就是它的增益。增益是用模拟或数字的方法进行放大，不可避免的会放大噪声，因此拍摄时一般快门优先。</p><p>当拍摄高速运动的物体或者手抖的时候，容易产生运动模糊，就需要降低快门时间。</p><p>sensor 的曝光方式有两种，卷帘曝光和全局曝光。</p><h2 id="卷帘曝光rolling-shutter">卷帘曝光（rolling shutter）</h2><ul><li>一个 reset 信号负责将某一行像素清零，使其从零开始积累电荷。</li><li>一个 read 信号负责选择某一行，读出该行信号。</li></ul><p>这两个信号的工作时序是 reset 信号在先，read 信号在后，之间相差一个恒定的间隔，这个间隔在空间上看是两个信号前后相差固定的行数，在时间上看是一行像素被清零后，等待固定的时间后即被读出。</p><p>显然，sensor read 信号与 reset 信号之间的时间间隔就是每个像素能够积累光信号的时间，也就是人们所熟知的“曝光时间（exposure time）”，在技术领域则更多会使用“积分时间（integration time）”这个术语，它一般是以行为单位的一个量，能够精确地反映像素曝光过程的物理本质和实现原理。</p><p>下图是卷帘曝光拍摄高速运动的物体的现象。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel7.png"></p><p>这是 IMX290 的 sensor 曝光与输出示意图 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel8.png"></p><p>黄色区域是 sensor 处于感光的时间，蓝色区域是 sensor 每一行数据的输出时间，红色是曝光开始的时间。XHS 是进行每个操作的最小时间单位。</p><p>从时间先后来看，一幅图像是从第一行开始曝光，一个 XHS 之后，再从第二行开始曝光，依次类推。图像的第一行曝光结束后，进行输出，输出数据的时间是一个 XHS，依此类推。</p><p>卷帘曝光带来的问题：</p><ul><li>日光灯下有横条纹。 日光灯属于频闪灯，跟当地的供电频率有关，如果当地的供电是 50Hz 的正弦波（国内），日光灯就会以 100Hz 的频率闪烁。sensor 每行的起始曝光时间是不同的，这就导致了每一行曝光时的亮度不同。因此会出现横条纹 解决方法： - 控制曝光时间是 1/100 的整数倍，这样每行的曝光时间都是一个周期的整数倍，亮度就保持一致了 - 控制帧率为 25/50 帧，不能解决横条纹的问题，但是可以让每帧图像中的横条纹固定在相同的位置。1/25 是 1/100 的整数倍，可以使不同图像中每一行曝光的开始时间都相差四个周期。保证了每张图像中同一行的亮度是一致的</li><li>Rolling shutter（拍摄快速运动的物体会有失真）。 因为每一行曝光开始的时间不同，当物体快速运动时，每行抓拍下来的物体位置都不同，造成了物体的变形。 解决方法： - 加大图像输出的速度（提高帧率也可行，本质上改变的就是输出速度） - 调整抓拍的时间和角度，比如远处的车辆每帧移动的像素点较少，可以去抓拍稍远处的车辆 - 使用全局曝光的 sensor</li></ul><h2 id="interlaced-曝光">Interlaced 曝光</h2><p>为了改善 rolling shutter 曝光方式存在的问题，有人提出了 Interlaced 曝光和读出方式，如下图所示，新的曝光顺序将一帧拆分成 8 组，第一组包含行号 {0,8,16,24...}，第二组包含行号 {1,9,17,25,...} ，以此类推，第八组包含行号 {7,15,23,31,....} 。这种曝光方式的优点是组与组之间的曝光延时为一帧时间的八分之一，以 1080p@30fps 为例，一帧的读出时间大致在 28ms 左右，在新的曝光方式下像素间的最大曝光延时仅为 3.5ms，可以更好地捕捉运动场景。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel33.png"></p><h2 id="工频闪烁-flicker">工频闪烁 (flicker)</h2><p>flicker 的本质是像素曝光起始点相对交流电的相位关系在不断变化。这个问题不仅存在于一帧图像内部，在帧与帧之间也存在同样的问题。</p><p>以电频率 50Hz 为例，如果 sensor 工作在 25 或 50fps（frame per second），则帧频率刚好与电频率同步，每帧图像的 flicker 表现（明暗位置）与上一帧完全相同，所以明暗条纹在视频上是静止不动的。如果 sensor 工作在 30 或 60fps，则每帧的 flicker 与上一帧会产生固定的相移，视频上的明暗条纹图样会在画面垂直方向上缓慢移动。</p><h2 id="全局曝光global-shutter">全局曝光（global shutter）</h2><p>每一行的起始曝光和终止曝光的时间一致，目前只有电警设备上用到，价格昂贵。因为电警设备有爆闪灯，爆闪灯亮的时间很短。如果使用卷帘曝光的 sensor，一幅图像才曝光几行灯就熄灭了，所以必须要用全局曝光的传感器。</p><h1 id="与-ccd-对比">与 CCD 对比</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/pixel32.png"></p><p>CCD 的一个主要优点在于所有像素共享同一个电荷-电压转换器，所以像素一致性非常好。相比之下 CMOS 每个像素都有自己专用的电荷-电压转换器，一致性很不容易控制。</p><p>当 CCD 像素数多于 200 万时，所有像素共用一个电荷-电压转换器会严重影响读出速度，所以此时会考虑把像素设计成两个或四个阵列，每个阵列配备专用的行缓冲和电荷-电压转换器，可以成倍加快读出速度。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucWlueGluZy54eXovcG9zdHMvZTZmMDUyNGEv">https://www.qinxing.xyz/posts/e6f0524a/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDA3NzcxMjE=">https://zhuanlan.zhihu.com/p/100777121<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Sensor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> ISP </tag>
            
            <tag> Sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Odriver 之测速</title>
      <link href="/next/2023/Algorithm/odriverSpeed/"/>
      <url>/next/2023/Algorithm/odriverSpeed/</url>
      
        <content type="html"><![CDATA[<h1 id="传感器">传感器</h1><h2 id="绝对磁编码器">绝对磁编码器</h2><p>绝对磁编码器比较简单，直接读寄存器就可以。实际使用中需要配合径向冲磁的磁铁使用，且最好能远离其他可能造成磁场变化的器件；其次需要注意角度更新频率，动态特性等参数。</p><span id="more"></span><h2 id="线性霍尔传感器">线性霍尔传感器</h2><p>对于线性霍尔传感器一般是需要进行校准的，其使用方法一般是两个传感器呈 80 度对称分布，同样需要配合径向冲磁的磁铁使用。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/linear_hall1.png"></p><p>当磁铁旋转一周的时候，线性霍尔的传感器的输出应该正好是一个正弦信号，但是正弦的幅值需要校准，让传感器旋转一周分别获取最大值和最小值，这样就可以重构一周的信号与位置的关系。单个传感器就可以获取全部位置角度的信息，但是单个传感器存在一个问题，就是在正弦波的极点处值的变化非常小，而在线性区域变化则比较明显，因此使用两个传感器呈 90 度摆放则可以解决这个问题。如下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/linear_hall2.png"></p><p>如果 a 传感器取 sin 值为 hall_sin，b 传感器取 cos 值为 hall_cos，则最终的角度为 atan2f(hall_sin, hall_cos)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Hall Sensor read angle</span></span><br><span class="line"><span class="comment">  * @param None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">LinearHallAngleEncoder::LinearHallSensorGetAngle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> hall_sin = <span class="number">0.0f</span>, hall_cos = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    LinearHallSensorReadValue();</span><br><span class="line"></span><br><span class="line">    hall_sin = (hall_raw_a_ - hall_sensor_calibration_.hall_middle_a_) / \</span><br><span class="line">              hall_sensor_calibration_.hall_amplitude_a_;</span><br><span class="line">    hall_cos = (hall_raw_b_ - hall_sensor_calibration_.hall_middle_b_) / \</span><br><span class="line">              hall_sensor_calibration_.hall_amplitude_b_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::clamp(hall_sin, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">std</span>::clamp(hall_cos, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> atan2f(hall_sin, hall_cos);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math display">\[tan(x) = \frac{sin(a)}{cos(b)}\]</span></p><p>当 sin 在 1 或者-1 附近的时候 cos 值接近 0，因此虽然 sin 值变化很小，但是除以 cos 后就会变化很明显，毕竟 cos 值这个时候是变化最明显的，接近线性状态。同理在 sin 值在 0 附近的时候，cos 在 1 附近，这时 sin 变化明显，sin 值除以一个 1 附近的值仍然是变化明显的。多么美妙的设计啊，神奇的三角函数！</p><h1 id="转子角度和速度的状态估计">转子角度和速度的状态估计</h1><h2 id="状态估计">状态估计</h2><p>估计器有两种状态：位置和速度。位置以编码器计数为单位，速度以计数/秒为单位。由于编码器在我们转完一整圈时不断计数，我们可以想象状态是沿着展开的线而不是角度，因此我们可以谈论位置（以计数为单位）而不是角度。</p><p>因此，鉴于位置和速度这两种状态，我们可以做的最简单的事情就是使用速度来预测随时间变化的位置。这对于在离散计数之间插入编码器位置很重要。也就是说，我们始终以一阶（直线）跟踪预期位置，即使我们处于编码器脉冲之间。这提供了更平滑的控制和更高的有效精度。 预测预期角度的位置也很重要，这样我们就可以预测下一个编码器脉冲何时到来。如果它晚了或早了，这给了我们关于我们高估或低估了速度这一事实的信息。所以：这是该预测的代码，速度的超级简单一阶积分：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Predict current pos</span></span><br><span class="line">rotor-&gt;pll_pos += CURRENT_MEAS_PERIOD * rotor-&gt;pll_vel;</span><br></pre></td></tr></tbody></table></figure><p>好的，现在我们执行检查编码器边缘是早还是晚的部分。这围绕着一个 floor 函数，该函数以全浮点精度获取预测角度（就像编码器计数有很多小数位），并告诉我们应该对应的编码器计数。就像如果预测角度是一个斜坡，编码器计数将是一个阶梯。我们使用 floor 函数来做这个从坡道到楼梯的映射。 如果我们预测的角度有点落后，我们的预测还没有切换到下一个位置，但编码器已经切换到下一个位置，delta_pos 将是 1.0f 是实际位置与预测位置的差值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// discrete phase detector</span></span><br><span class="line"><span class="type">float</span> delta_pos = (<span class="type">float</span>)(rotor-&gt;encoder_state - (<span class="type">int32_t</span>)floorf(rotor-&gt;pll_pos));</span><br></pre></td></tr></tbody></table></figure><p>所以，我们知道我们是早还是晚，现在我们就此采取行动。假设我们迟到了，我们需要加快速度估计，也就是下面第二行。在第二行中，我们加速（以一定速率增加速度）与我们的位置误差成正比：就像质量弹簧系统一样。同样，在没有阻尼的情况下，它会形成谐波振荡器并围绕正确值振荡。所以我们需要添加阻尼。这是通过将位置估计值也更接近测量值来完成的，因此是下面的一行。解释它的另一种方法是我们有一个 PI 循环，其中编码器是我们尝试使用一些有限带宽跟踪的输入信号。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pll feedback</span></span><br><span class="line">rotor-&gt;pll_pos += CURRENT_MEAS_PERIOD * rotor-&gt;pll_kp * delta_pos;</span><br><span class="line">rotor-&gt;pll_vel += CURRENT_MEAS_PERIOD * rotor-&gt;pll_ki * delta_pos;</span><br></pre></td></tr></tbody></table></figure><h2 id="边界处理">边界处理</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we are stopped, make sure we don't randomly drift</span></span><br><span class="line"><span class="keyword">if</span> (snap_to_zero_vel || !config_.enable_phase_interpolation) {</span><br><span class="line">    interpolation_ = <span class="number">0.5f</span>;</span><br><span class="line"><span class="comment">// reset interpolation if encoder edge comes</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This isn't correct. At high velocities the first phase in this count mayvery well not be at the edge.</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (delta_enc &gt; <span class="number">0</span>) {</span><br><span class="line">    interpolation_ = <span class="number">0.0f</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (delta_enc &lt; <span class="number">0</span>) {</span><br><span class="line">    interpolation_ = <span class="number">1.0f</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// Interpolate (predict) between encoder counts using vel_estimate,</span></span><br><span class="line">    interpolation_ += current_meas_period * vel_estimate_counts_;</span><br><span class="line">    <span class="comment">// don't allow interpolation indicated position outside of [enc, enc+1)</span></span><br><span class="line">    <span class="keyword">if</span> (interpolation_ &gt; <span class="number">1.0f</span>) interpolation_ = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (interpolation_ &lt; <span class="number">0.0f</span>) interpolation_ = <span class="number">0.0f</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">float</span> interpolated_enc = corrected_enc + interpolation_;</span><br></pre></td></tr></tbody></table></figure><p>如果速度为 0，则将插值强制设置为 0.5，仅是取一个中间值，实际速度为 0 的可能性很小。当预测误差大于 0 的时候，实际上就是预测值刚好过了传感器测量值的时候，这个时候插值应该很小，当然对于高速转动的时候是不成立的，在低速的时候将插值设置为 0 是可以的。相反当预测误差小于 0 的时候，就是传感器刚好切换到下一个位置的时候，这个时候预测值刚好滞后一个 count（同样只有在低速的时候才成立）这个时候插值应该设置为 1。而当预测误差一个 count 内的时候说明速度比较低，这个时候插值应该根据预测的速度来计算，对预测速度进行积分。但是积分的上下限就是一个 count 即 [0,1]。最后将传感器读出来的值加上插值就是预估的角度。</p><h1 id="参数设计">参数设计</h1><h2 id="调节">调节</h2><p>我们如何选择这些增益？与任何过滤器一样，需要权衡延迟与平滑度。合适的值取决于编码器的分辨率和应用程序。高带宽控制需要高带宽状态估计，但代价是对编码器脉冲的反应更敏锐。 更高分辨率的编码器意味着每个脉冲在“阶梯”中具有更小的幅度，因此您得到的反应不那么尖锐，因此您可以针对系统中相同幅度的噪声/振铃调高带宽。</p><h2 id="理论">理论</h2><h3 id="阻尼比">阻尼比</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/Damped_spring.gif"></p><p>当弹簧质量系统完全没有损耗，质量会一直摆动，不会结束，每一次的摆动振幅都和之前一样，这种理想情形称为无阻尼。 若系统的损耗很大，例如弹簧质量系统放置在黏滞的液体中，系统会慢慢的回到初始位置，甚至不会过冲，这称为过阻尼。 一般而言，在摆动时会出现过冲，再往另一边摆动，再回来，在摆动过程中，系统消耗了一些能量，而摆动振幅也会越来越小，最后回到初始位置，这称为欠阻尼。 在过阻尼及欠阻尼二个条件之间，有一个特定的情形是系统不会过冲，会在最快时间回到初始位置，这称为临界阻尼。临界阻尼和过阻尼都不会过冲，而临界阻尼是最快回到初始位置的那一个阻尼条件。</p><h3 id="阻尼比定义">阻尼比定义</h3><p>阻尼比常用ζ表示，是二阶微分方程步阶响应及频率响应的参数之一。在控制理论及谐振子中相当重要。阻尼比表示系统的阻尼相对于临界阻尼的比值。</p><h3 id="二阶系统相对于阻尼比-ζ-的阶跃响应">二阶系统相对于阻尼比 ζ 的阶跃响应</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/preview.jpg"></p><ul><li>过阻尼振荡。阻尼比大于 1，极点均为负实数。系统在没有振荡的情况下达到稳定状态。随着阻尼比的增加，它达到稳态的速度变慢。</li><li>无阻尼振荡。注意所有的极点都在虚轴上。阻尼比为零，存在无阻尼振荡。</li><li>欠阻尼振荡。阻尼比在 0~1 之间，极点为负实部的复数。当系统达到稳定状态时，振荡逐渐减小到零。</li><li>临界阻尼振荡。在没有振荡的情况下以最快的方式达到稳定状态。这两个极点具有相同的负值。</li></ul><p>更定量地说，越靠左的极点“越快”（更高的带宽）逼近，具有更大虚部的极点以更高的频率振荡。有什么不同？同样，这最好用图片显示：</p><p>请注意，在所有这些中，极点位置的单位可以采用弧度/秒。因此，如果极对位于（-2 ± 5i），那么我们将得到一个频率为 5 弧度/秒的正弦响应，它以 2 弧度/秒的速度衰减。</p><p>所以假设蓝色轨迹是响应输入位置突然增加的位置，即编码器输入变化。假设我们希望过滤后的输出尽可能快地跟踪它，而不会过冲。当两个极点（红色的 X）恰好在彼此的顶部时会发生这种情况：这称为临界阻尼（请参见第一张图片中右下角的示例）。</p><h3 id="极点">极点</h3><p>。</p><h2 id="推导">推导</h2><p>假设我们有一些 P 和 I 增益（ <span class="math inline">\(K_p\)</span> 和 <span class="math inline">\(K_i\)</span>），极点是什么，因此带宽是多少，阻尼是多少？我选择将其导出为一个连续时间系统（用离散时间来近似）。</p><p>所以下面的方程式有两个状态，p 是位置，v 速度。为了清楚起见，我使用了一个变量来 e 表示位置状态和编码器读数之间的误差，后者指定 <span class="math inline">\(p_i\)</span> 为输入位置。因此将两个方程写成矩阵格式。</p><p><span class="math display">\[\dot{p} = v + k_p \cdot  e = v + k_p (p_i - p) \tag{1}\]</span></p><p><span class="math display">\[\dot{v} = k_i \cdot e = k_i (p_i - p) \tag{2}\]</span></p><p>写成矩阵：</p><p><span class="math display">\[\begin{bmatrix}\dot{p}  \\\dot{v}\end{bmatrix} =\begin{pmatrix}-k_p  &amp; 1 \\-k_i  &amp; 0\end{pmatrix}\begin{bmatrix}p \\v\end{bmatrix}+\begin{bmatrix}k_p \\k_i\end{bmatrix} p_i \tag{3}\]</span></p><p>这个系统的极点等于左边矩阵的特征值，系统矩阵，通常称为 A。</p><p>好的，矩阵的特征值是多少？有了现代技术，我们可以让计算机为我们做这些：我们使用 SymPy。在 SymPy 现场亲自尝试输入此命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix([[-x, 1], [-y, 0]]).eigenvals()</span><br></pre></td></tr></tbody></table></figure><p>假装那 x 意味着 <span class="math inline">\(K_p\)</span> 那 y 意味着 <span class="math inline">\(K_i\)</span> 。解决方案是：</p><p><span class="math display">\[p_{ok} = \frac{-k_p}{2} \pm \frac{\sqrt{k_p^2 - 4 k_i}}{2} \cdot  i \tag{4}\]</span></p><p>我们希望极点的实部是某个特定数字，这是我们的带宽（以弧度/秒为单位），我们希望虚部在两个极点上都为零。</p><p><span class="math display">\[k_p = -2 \cdot p_{ok} \tag{5}\]</span></p><p><span class="math display">\[k_i = \frac{k_p^2}{4} \tag{6}\]</span></p><p>这正是代码中的内容：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motor-&gt;rotor.pll_kp = <span class="number">2.0f</span> * rotor_pll_bandwidth;</span><br><span class="line"><span class="comment">// Critically damped</span></span><br><span class="line">motor-&gt;rotor.pll_ki = <span class="number">0.25f</span> * (motor-&gt;rotor.pll_kp * motor-&gt;rotor.pll_kp);</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kaXNjb3Vyc2Uub2RyaXZlcm9ib3RpY3MuY29tL3Qvcm90b3ItZW5jb2Rlci1wbGwtYW5kLXZlbG9jaXR5LzIyNC80">https://discourse.odriverobotics.com/t/rotor-encoder-pll-and-velocity/224/4<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudGkuY29tLmNuL3poLWNuL3NlbnNvcnMvbWFnbmV0aWMtc2Vuc29ycy9saW5lYXItaGFsbC1lZmZlY3Qtc2Vuc29ycy9wcm9kdWN0cy5odG1s">https://www.ti.com.cn/zh-cn/sensors/magnetic-sensors/linear-hall-effect-sensors/products.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudGkuY29tLmNuL3Byb2R1Y3QvY24vRFJWNTA1NQ==">https://www.ti.com.cn/product/cn/DRV5055<i class="fa fa-external-link-alt"></i></span><br><a href="https://figshare.com/articles/figure/_Step_response_of_a_second_order_system_with_respect_to_the_damping_ratio_950_the_poles_are_shown_as_X_/500243">https://figshare.com/articles/figure/<em>Step_response_of_a_second_order_system_with_respect_to_the_damping_ratio_950_the_poles_are_shown_as_X</em>/500243</a><br><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLyVFOSU5OCVCQiVFNSVCMCVCQyVFNiVBRiU5NA==">https://www.wikiwand.com/zh/%E9%98%BB%E5%B0%BC%E6%AF%94<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Odriver </tag>
            
            <tag> Actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odriver 之 SVM</title>
      <link href="/next/2022/Algorithm/odriverSVM/"/>
      <url>/next/2022/Algorithm/odriverSVM/</url>
      
        <content type="html"><![CDATA[<h1 id="源码">源码</h1><p>SVM 函数的 alpha 和 beta 的值是经过了标幺化，基准值为 （最大相电压），也就是说 alpha 和 beta 的范围是 [-1,1]。约束：alpha-beta 向量的大小不得大于 $  $。</p><span id="more"></span><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute rising edge timings (0.0 - 1.0) as a function of alpha-beta</span></span><br><span class="line"><span class="comment">// as per the magnitude invariant clarke transform</span></span><br><span class="line"><span class="comment">// The magnitude of the alpha-beta vector may not be larger than sqrt(3)/2</span></span><br><span class="line"><span class="comment">// Returns true on success, and false if the input was out of range</span></span><br><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="type">float</span>, <span class="type">float</span>, <span class="type">float</span>, <span class="type">bool</span>&gt; <span class="title function_">SVM</span><span class="params">(<span class="type">float</span> alpha, <span class="type">float</span> beta)</span> {</span><br><span class="line">    <span class="type">float</span> tA, tB, tC;</span><br><span class="line">    <span class="type">int</span> Sextant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beta &gt;= <span class="number">0.0f</span>) {</span><br><span class="line">        <span class="keyword">if</span> (alpha &gt;= <span class="number">0.0f</span>) {</span><br><span class="line">            <span class="comment">//quadrant I</span></span><br><span class="line">            <span class="keyword">if</span> (one_by_sqrt3 * beta &gt; alpha)</span><br><span class="line">                Sextant = <span class="number">2</span>; <span class="comment">//sextant v2-v3</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Sextant = <span class="number">1</span>; <span class="comment">//sextant v1-v2</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//quadrant II</span></span><br><span class="line">            <span class="keyword">if</span> (-one_by_sqrt3 * beta &gt; alpha)</span><br><span class="line">                Sextant = <span class="number">3</span>; <span class="comment">//sextant v3-v4</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Sextant = <span class="number">2</span>; <span class="comment">//sextant v2-v3</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (alpha &gt;= <span class="number">0.0f</span>) {</span><br><span class="line">            <span class="comment">//quadrant IV</span></span><br><span class="line">            <span class="keyword">if</span> (-one_by_sqrt3 * beta &gt; alpha)</span><br><span class="line">                Sextant = <span class="number">5</span>; <span class="comment">//sextant v5-v6</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Sextant = <span class="number">6</span>; <span class="comment">//sextant v6-v1</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//quadrant III</span></span><br><span class="line">            <span class="keyword">if</span> (one_by_sqrt3 * beta &gt; alpha)</span><br><span class="line">                Sextant = <span class="number">4</span>; <span class="comment">//sextant v4-v5</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Sextant = <span class="number">5</span>; <span class="comment">//sextant v5-v6</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (Sextant) {</span><br><span class="line">        <span class="comment">// sextant v1-v2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t1 = alpha - one_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t2 = two_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tA = (<span class="number">1.0f</span> - t1 - t2) * <span class="number">0.5f</span>;</span><br><span class="line">            tB = tA + t1;</span><br><span class="line">            tC = tB + t2;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sextant v2-v3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t2 = alpha + one_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t3 = -alpha + one_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tB = (<span class="number">1.0f</span> - t2 - t3) * <span class="number">0.5f</span>;</span><br><span class="line">            tA = tB + t3;</span><br><span class="line">            tC = tA + t2;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sextant v3-v4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t3 = two_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t4 = -alpha - one_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tB = (<span class="number">1.0f</span> - t3 - t4) * <span class="number">0.5f</span>;</span><br><span class="line">            tC = tB + t3;</span><br><span class="line">            tA = tC + t4;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sextant v4-v5</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t4 = -alpha + one_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t5 = -two_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tC = (<span class="number">1.0f</span> - t4 - t5) * <span class="number">0.5f</span>;</span><br><span class="line">            tB = tC + t5;</span><br><span class="line">            tA = tB + t4;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sextant v5-v6</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t5 = -alpha - one_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t6 = alpha - one_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tC = (<span class="number">1.0f</span> - t5 - t6) * <span class="number">0.5f</span>;</span><br><span class="line">            tA = tC + t5;</span><br><span class="line">            tB = tA + t6;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sextant v6-v1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: {</span><br><span class="line">            <span class="comment">// Vector on-times</span></span><br><span class="line">            <span class="type">float</span> t6 = -two_by_sqrt3 * beta;</span><br><span class="line">            <span class="type">float</span> t1 = alpha + one_by_sqrt3 * beta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// PWM timings</span></span><br><span class="line">            tA = (<span class="number">1.0f</span> - t6 - t1) * <span class="number">0.5f</span>;</span><br><span class="line">            tC = tA + t1;</span><br><span class="line">            tB = tC + t6;</span><br><span class="line">        } <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result_valid =</span><br><span class="line">            tA &gt;= <span class="number">0.0f</span> &amp;&amp; tA &lt;= <span class="number">1.0f</span></span><br><span class="line">         &amp;&amp; tB &gt;= <span class="number">0.0f</span> &amp;&amp; tB &lt;= <span class="number">1.0f</span></span><br><span class="line">         &amp;&amp; tC &gt;= <span class="number">0.0f</span> &amp;&amp; tC &lt;= <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">return</span> {tA, tB, tC, result_valid};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数主体上可以分为 2 大块，第一大块是个复合的 if 语句，用于判断扇区，第二个则是个 switch 语句，用于计算定时器的比较值，用于产生不同占空比的 PWM。</p><h1 id="扇区判断">扇区判断</h1><p>对于第一部分扇区判断，以第 1 扇区为例说明。</p><p>如图 1 所示，给定的$ <span class="math inline">\(值使得其合向量蓝色的\)</span>vref<span class="math inline">\(位于第 1 扇区。分析一下位于第 1 扇区的\)</span> <span class="math inline">\(有什么特点，最明显的就是 ，但这应该是位于第一象限的特点，还有 30°的范围不属于第 1 扇区，继续分析。每个扇区都是 60°，因此可以通过三角函数来确定\)</span> <span class="math inline">\(和\)</span> <span class="math inline">\(的关系。过 110 轴上任意点 P 做 100 轴的垂线 PA，则ΔOPA 显然为直角三角形，且∠PAO=90°，∠POA=60°，∠OPA=30°，此时，正好是\)</span> <span class="math inline">\(的合向量恰好位于 110 轴的情形，当\)</span><span class="math inline">\(的值略小或\)</span>$的值略大时，∠POA 都将小于 60°，合向量落入第 1 扇区。从数学上说</p><p><span class="math display">\[\angle POA = arctan \frac{PA}{ OA} = arctan \frac{\beta}{ \alpha} &lt; 60°\]</span></p><p>即可作为 1 扇区判断条件，坏消息是 arctan 在 MCU 上计算得慢，所以得换换思路。</p><p><span class="math display">\[tan \angle POA = \frac{\beta}{ \alpha}\]</span></p><p>这是一个显而易见的结论，当合向量恰好位于 110 轴时$ tan60° =  $ ，也就是$ =  $ ，如果和程序中的表述一致的话，就是<span class="math inline">\(\alpha = \frac{1}{ \sqrt{3}} \beta\)</span> 。当<span class="math inline">\(\beta\)</span>减小<span class="math inline">\(\alpha\)</span>不变或<span class="math inline">\(\alpha\)</span>增大<span class="math inline">\(\beta\)</span>不变时，合向量都将从 110 轴转向 1 扇区，反之则转入 2 扇区。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svm1.png"></p><p>综上所述得到结论，当$&gt; 0, &gt; 0 $ 且 <span class="math inline">\(\beta &gt; \sqrt{3} \alpha\)</span> 合向量落在第 1 扇区； 当$&gt; 0, &gt; 0 $ 且 <span class="math inline">\(\beta &lt; \sqrt{3} \alpha\)</span>，合向量落在第 2 扇区。</p><h1 id="pwm-值计算">PWM 值计算</h1><p>接下来聊一聊 PWM 比较值是如何计算的，这次以第 2 扇区为例，如图 2 所示。</p><p>在第 2 扇区的合向量是需要借助 010 和 110 这两个基本向量合成得到，传入 SVM 函数的参数 alpha 和 beta 的合向量是<span class="math inline">\(Vref\)</span>。然后考虑将 <span class="math inline">\(\alpha\)</span> 和<span class="math inline">\(\beta\)</span>的值都分解到 010 和 110 这两个基本向量上。将<span class="math inline">\(\alpha\)</span> 在 100 轴的端点称为 A 点，<span class="math inline">\(\beta\)</span>端点称为 B 点。</p><p>先试着分解<span class="math inline">\(\alpha\)</span>向量，过 A 点作 110（001）轴的平行线交 101 轴于 C 点。过 A 点作 010（101）轴平行线交 110 轴于 D 点。分析易得$ OAC OAD$ 都是等边三角形。因此，<span class="math inline">\(\alpha\)</span>向量分解到 110 轴的长度也是<span class="math inline">\(\alpha\)</span>，分解到 010 轴的长度是<span class="math inline">\(- \alpha\)</span>。</p><p>然后分解<span class="math inline">\(\beta\)</span>向量，过 B 点作 110 轴平行线交 010 轴于 E 点，过 B 点作 010 轴平行线交 110 轴于 F 点。易分析得 <span class="math inline">\(\bigtriangleup OBE 、 \bigtriangleup OBF\)</span> 为底角为 30°的等腰三角形，需求 OE 和 OF 长度，且 OE=OF=BF=BE。过 E 点作 OB 垂线交于 G，则 <span class="math inline">\(\bigtriangleup EGB\)</span>为直角三角形，且<span class="math inline">\(\angle EBG = 30°\)</span> 则<span class="math inline">\(BE = \frac{2}{\sqrt{3}} BG\)</span> 而<span class="math inline">\(BG = \frac{1}{2} \beta\)</span> 故<span class="math inline">\(BE = \frac{1}{\sqrt{3}} \beta\)</span> 为所求。 可以给结论了，110 轴上产生作用力的时间定义为 t2，010 轴上产生作用力的时间定义为 t3。则有：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svm2.png"></p><p><span class="math display">\[t3 = - \alpha + \frac{1}{\sqrt{3}} \beta\]</span></p><p><span class="math display">\[t2 = \alpha + \frac{1}{\sqrt{3}} \beta\]</span></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDYyNDAwMzA=">https://zhuanlan.zhihu.com/p/506240030<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Odriver </tag>
            
            <tag> Actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOC 电流采样</title>
      <link href="/next/2022/Algorithm/FOCCurrentSampling/"/>
      <url>/next/2022/Algorithm/FOCCurrentSampling/</url>
      
        <content type="html"><![CDATA[<h1 id="采样点">采样点</h1><p>在基尔霍夫定律下，三相电流的合应该等于 0，因此只需要获取亮相电流就可以重构出完整的三相电流。</p><p>对于 STM32 一般通过高级定时器的 channel4 作为 ADC 的触发源，对于下桥臂电流采样，需要在下桥臂 MOS 管导筒的时候才能去采样，而且需要在 MOS 管导通时间以及电流稳定后才能采样到比较可靠的电流。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/r3_2_1.png"></p><span id="more"></span><ul><li>当 <span class="math inline">\(\Delta_1\)</span> 大于两倍的 $T_{dead} + T_{on} + T_{ring} + T_{conv} $ 那么在 PWM Freq Middle 时刻出发 ADC 转换也是足够转换 3 相中任意的一相。</li><li>当 <span class="math inline">\(\Delta_1\)</span> 大于$T_{dead} + T_{on} + T_{ring} + T_{conv} 那么从 CCRmax 之后开始转换也是可以转换 3 相中任意的一相。</li><li>当 <span class="math inline">\(\Delta_2\)</span> &gt; <span class="math inline">\(\Delta_0\)</span> &gt; <span class="math inline">\(\Delta_1\)</span> 那么导通最短的那一相就没有足够的转换时间了，那么只能转换导通时间长的那两相。</li><li><span class="math inline">\(\Delta_1\)</span> &lt; <span class="math inline">\(\Delta_0\)</span> 和 <span class="math inline">\(\Delta_2\)</span> &lt; <span class="math inline">\(\Delta_0\)</span> 没有足够的转换时间，有两相电流不可获取将无法重建三相电流。</li></ul><p>因此需要根据 u、v、w 三相 pwm 的占空比来调整 timer 的 channel 4 比较值来调整触发时刻完成三相电流的重建工作。</p><h1 id="相电流重构">相电流重构</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/r3_2_2.png"></p><ul><li>对于 Sector4 和 5，C 相导通时间最长，相应的就是下桥臂导通时间最短，这个时候应该采集 A 和 B 相电流。</li><li>对于 Sector2 和 3，B 相导通时间最长，相应的就是下桥臂导通时间最短，这个时候应该采集 A 和 C 相电流。</li><li>对于 Sector1 和 6，A 相导通时间最长，相应的就是下桥臂导通时间最短，这个时候应该采集 B 和 C 相电流。</li></ul><h1 id="常用芯片">常用芯片</h1><h2 id="mp6540-电流采样">MP6540 电流采样</h2><p>MP6540H 的内部电流采样电路。其输出可通过外部电阻器 (RTERM) 和参考电压 (VREF) 来设置。两个等值电阻连接到 ADC 电源和地，接地用于终止输出。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/mp6540.png"></p><p>MP6540 的电流采样计算比较简单，这里就不再详细说明了。</p><h2 id="drv8301drv8302-电流采样">DRV8301/DRV8302 电流采样</h2><p>首先将 DRV8301 的框图列出来，大致了解下结构，主要就是通过 SNx 和 SPx 四个引脚之间的电阻来采样电流。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/drv8301_block.png"></p><p>如果我们需要采样一个桥臂的电流，那传统的方式自然是直接在电路上串联一个采样电阻，然后采样两端电压即可。由于电阻是串联进电路的，所以阻值当然是要越低越好。但是这又会带来另一个问题，低阻值导致的采样精度不高，因此需要运放来实现电流的采样。</p><p>我们以 odriver 原理图为例进行计算，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/odriver.png"></p><p>这里 R27 和 R28 电阻就是采样电阻，<span class="math inline">\(500u\Omega(500 * 10^{-6})\Omega\)</span>.</p><p>下面是官方手册给出的电流计算方式。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/drv8301.png"></p><p>这里做如下说明： <span class="math inline">\(SN_x - SN_x\)</span> 是采样电阻两端的电压值，也是我们需要测量的值，得到该值后除以电阻就得到对应的电流值。Vo 是我们 ADC 得到的值。针对官方给出的公式，我们做如下计算：</p><p><span class="math display">\[V_o = \frac{V_{REF}}{2} - G \times (SN_x - SP_x)\]</span></p><p>化简如下：</p><p><span class="math display">\[(SN_x - SP_x) = \frac{(\frac{V_{REF}}{2} - V_o )}{G}\]</span></p><p>这里 G 是 10、20、40、80. <span class="math inline">\(V_{REF}\)</span>一般是 3.3v，那么如下：</p><p><span class="math display">\[(\frac{V_{REF}}{2} - V_o ) = (\frac{3.3}{2} - \frac{ADC}{2^{12}} \times 3.3 ) = \frac{2^{11} - ADC}{2^{12}} \times 3.3\]</span></p><p>得到电流值如下：</p><p><span class="math display">\[(SN_x - SP_x) = I_{measure} \times R_{Isensor} = \frac{2^{11} - ADC}{2^{12}} \times \frac{3.3}{G}\]</span></p><p>得到最终结果为：</p><p><span class="math display">\[I_{measure} = \frac{2^{11} - ADC}{2^{12}} \times \frac{3.3}{G} \times \frac{1}{R_{Isensor}}\]</span></p><h2 id="死区时间的计算">死区时间的计算</h2><p>我们用下列公式计算控制死区时间：</p><p><span class="math display">\[t_{dead} = [(td_{offmax} - td_{onmin}) + (tpdd_{max} - tpdd_{min})] * 1.2\]</span></p><ul><li><span class="math inline">\(td_{offmax}\)</span> ：MOS 管最大关断延迟时间。</li><li><span class="math inline">\(td_{onmin}\)</span>：MOS 管最小开通延迟时间。</li><li><span class="math inline">\(tpdd_{max}\)</span>：驱动器最大传输延迟时间。</li><li><span class="math inline">\(tpdd_{min}\)</span>：驱动器最小传输延迟时间。</li></ul><p>在该公式中，第一项<span class="math inline">\(td_{offmax}-td_{onmin}\)</span>为最大关断延迟时间和最小开通延迟时间之差。这一项主要描述 MOS 管器件结合所用的门极电阻的特性。由于上升和下降时间通常比延迟时间短很多，这里就不考虑它们。另一项<span class="math inline">\(tpdd_{max} - tpdd_{min}\)</span>为由驱动器决定的传输延迟时间之差（延迟时间不匹配）。该参数通常可在驱动器制造商提供的驱动器数据表中查找到。对于基于光耦合器的驱动器，该参数值通常很大。</p><p>对于 csd18540q:</p><p><span class="math inline">\(td_{offmax}\)</span> = 20ns <span class="math inline">\(td_{onmin}\)</span> = 6ns</p><h1 id="stm32-实现双-adc-采样三电阻电流">STM32 实现双 ADC 采样三电阻电流</h1><h2 id="重构采样点">重构采样点</h2><p>STM32 的高级定时器有 6 个 pwm channel，我们可以使用前三个 channel 输出互补的 pwm，第四个 channel 用于触发 adc 的采样时刻。这里主要是根据扇区以及三通道的 pwm 占空比来判断电流采样点时刻。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Configure the ADC for the current sampling related to sector 1.</span></span><br><span class="line"><span class="comment"> *         It means set the sampling point via TIMx_Ch4 value and polarity</span></span><br><span class="line"><span class="comment"> *         ADC sequence length and channels.</span></span><br><span class="line"><span class="comment"> *         And call the WriteTIMRegisters method.</span></span><br><span class="line"><span class="comment"> * @retval none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">R3_2_SetADCSampPointSectX</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint16_t</span> sampling_point;</span><br><span class="line">    <span class="type">uint16_t</span> DeltaDuty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过检查最小占空比验证是否可以在 PWM 中间进行采样 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint16_t</span>)(kMCLowLevelInstance.half_pwm_period - kMCLowLevelInstance.low_duty) &gt; kMCLowLevelInstance.t_after) {</span><br><span class="line">        <span class="comment">/* 当可以在 PWM 周期的中间进行采样时，始终对所有扇区的相同相位（选择 AB）进行采样，以便在偏移量之间存在差异时不会引起电流不连续 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* GetPhaseCurrent 需要的扇区号，采样 A 相和 B 相对应扇区 4 或 5  */</span></span><br><span class="line">        kMCLowLevelInstance.sector = SECTOR_5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在 PWM 周期中间设置采样点触发器 */</span></span><br><span class="line">        sampling_point = kMCLowLevelInstance.half_pwm_period - (<span class="type">uint16_t</span>)<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* 在这种情况下，有必要转换具有最大和可变互补占空比的相位。*/</span></span><br><span class="line">        DeltaDuty = (<span class="type">uint16_t</span>)(kMCLowLevelInstance.low_duty - kMCLowLevelInstance.mid_duty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Definition of crossing point */</span></span><br><span class="line">        <span class="keyword">if</span> (DeltaDuty &gt; (<span class="type">uint16_t</span>)(kMCLowLevelInstance.half_pwm_period - kMCLowLevelInstance.low_duty) * <span class="number">2u</span>) {</span><br><span class="line">            sampling_point = kMCLowLevelInstance.low_duty - kMCLowLevelInstance.t_before;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            sampling_point = kMCLowLevelInstance.low_duty + kMCLowLevelInstance.t_after;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sampling_point &gt;= kMCLowLevelInstance.half_pwm_period) {</span><br><span class="line">                <span class="comment">/* ADC trigger edge must be changed from positive to negative */</span></span><br><span class="line">                kMCLowLevelInstance.adc_external_polarity_injected = (<span class="type">uint16_t</span>)LL_ADC_INJ_TRIG_EXT_FALLING;</span><br><span class="line">                sampling_point = (<span class="number">2u</span> * kMCLowLevelInstance.half_pwm_period) - sampling_point - (<span class="type">uint16_t</span>)<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> R3_2_WriteTIMRegisters(sampling_point);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="重构电流采样">重构电流采样</h2><p>我们可以根据当前扇区以及三通道的 pwm 占空比来选择采样哪两相电流，通常不采样占空比最小的那一通道，而通过基尔霍夫定律来算第三通道的电流，避免采样区间太小造成的采样电流不稳定。具体算法如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  It computes and return latest converted motor phase currents motor</span></span><br><span class="line"><span class="comment"> * @param  pHdl: handler of the current instance of the PWM component</span></span><br><span class="line"><span class="comment"> * @retval Ia and Ib current in Curr_Components format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R3_2_PhaseCurrentsUpdate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int16_t</span> i_a,i_b;</span><br><span class="line">    <span class="type">int32_t</span> aux;</span><br><span class="line">    <span class="type">uint32_t</span> adc_data_reg1, adc_data_reg2;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> sector = (<span class="type">uint8_t</span>)kMCLowLevelInstance.sector;</span><br><span class="line">    TIM_TypeDef* TIMx = kMCLowLevelInstance.TIMx;</span><br><span class="line">    adc_data_reg1 = *kMCLowLevelInstance.adc_data_reg1[sector];</span><br><span class="line">    adc_data_reg2 = *kMCLowLevelInstance.adc_data_reg2[sector];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* disable ADC trigger source */</span></span><br><span class="line">    <span class="comment">// LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4);</span></span><br><span class="line">    LL_TIM_SetTriggerOutput(TIMx, TIM_TRGO_RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sector) {</span><br><span class="line">        <span class="keyword">case</span> SECTOR_4:</span><br><span class="line">        <span class="keyword">case</span> SECTOR_5:</span><br><span class="line">            <span class="comment">/* Current on Phase C is not accessible     */</span></span><br><span class="line">            <span class="comment">/* Ia = phase_a_offset - ADC converted value) */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_a_offset) - (<span class="type">int32_t</span>)(adc_data_reg1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ia */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_a = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_a = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_a = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Ib = phase_b_offset - ADC converted value) */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_b_offset) - (<span class="type">int32_t</span>)(adc_data_reg2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ib */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_b = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_b = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_b = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SECTOR_6:</span><br><span class="line">        <span class="keyword">case</span> SECTOR_1:</span><br><span class="line">            <span class="comment">/* Current on Phase A is not accessible     */</span></span><br><span class="line">            <span class="comment">/* Ib = phase_b_offset - ADC converted value) */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_b_offset) - (<span class="type">int32_t</span>)(adc_data_reg1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ib */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_b = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_b = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_b = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Ia = -Ic -Ib */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(adc_data_reg2) - (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_c_offset); <span class="comment">/* -Ic */</span></span><br><span class="line">            aux -= (<span class="type">int32_t</span>)i_b;                                                     <span class="comment">/* Ia  */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ia */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_a = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_a = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_a = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SECTOR_2:</span><br><span class="line">        <span class="keyword">case</span> SECTOR_3:</span><br><span class="line">            <span class="comment">/* Current on Phase B is not accessible     */</span></span><br><span class="line">            <span class="comment">/* Ia = phase_a_offset - ADC converted value) */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_a_offset) - (<span class="type">int32_t</span>)(adc_data_reg1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ia */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_a = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_a = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_a = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Ib = -Ic -Ia */</span></span><br><span class="line">            aux = (<span class="type">int32_t</span>)(adc_data_reg2) - (<span class="type">int32_t</span>)(kMCLowLevelInstance.phase_c_offset); <span class="comment">/* -Ic */</span></span><br><span class="line">            aux -= (<span class="type">int32_t</span>)i_a;                                                     <span class="comment">/* Ib */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Saturation of Ib */</span></span><br><span class="line">            <span class="keyword">if</span> (aux &gt; INT16_MAX) {</span><br><span class="line">                i_b = INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux &lt; -INT16_MAX) {</span><br><span class="line">                i_b = -INT16_MAX;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i_b = (<span class="type">int16_t</span>)aux;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    kMCLowLevelInstance.current_a = i_a;</span><br><span class="line">    kMCLowLevelInstance.current_b = i_b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> MotorControlLowLevel_t kMCLowLevelInstance = {</span><br><span class="line">    .adc_config1 = {MC_ADC_CHANNEL_2  &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT),</span><br><span class="line">                   MC_ADC_CHANNEL_1  &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT),</span><br><span class="line">                   MC_ADC_CHANNEL_2  &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT)},</span><br><span class="line">    .adc_config2 = {MC_ADC_CHANNEL_12 &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT),</span><br><span class="line">                   MC_ADC_CHANNEL_12 &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT),</span><br><span class="line">                   MC_ADC_CHANNEL_2  &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT),</span><br><span class="line">                   MC_ADC_CHANNEL_12 &lt;&lt; ADC_JSQR_JSQ1_Pos | (LL_ADC_INJ_TRIG_EXT_TIM1_TRGO &amp; ~ADC_INJ_TRIG_EXT_EDGE_DEFAULT)},</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意这里 sector 1 的采样通道是 ADC1 的 MC_ADC_CHANNEL_2 和 ADC2 的 MC_ADC_CHANNEL_12，sector2 的采样通道是 ADC1 的 MC_ADC_CHANNEL_1 和 ADC2 的 MC_ADC_CHANNEL_12。这个表格是根据前面的理论部分以及原理图来计算得到的通道。</p><p>在得到原始的 ADC 值之后可以通过电路原理将 ADC 转换为对应的电流值，这个就跟具体的设计有关了，这里不过多赘述。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9ub2xpdGhpY3Bvd2VyLmNuL2NuL2Rlc2lnbmluZy1hLWJydXNobGVzcy1tb3Rvci1kcml2ZXItY2lyY3VpdC13aXRoLXRoZS1tcDY1NDA=">https://www.monolithicpower.cn/cn/designing-a-brushless-motor-driver-circuit-with-the-mp6540<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudGkuY29tL2xpdC9kcy9zeW1saW5rL2RydjgzMDEucGRmP3RzPTE2NjQ5Nzg2MDEzMTYmcmVmX3VybD1odHRwcyUyNTNBJTI1MkYlMjUyRnd3dy50aS5jb20lMjUyRnByb2R1Y3QlMjUyRkRSVjgzMDE=">https://www.ti.com/lit/ds/symlink/drv8301.pdf?ts=1664978601316&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FDRV8301<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Actuator </tag>
            
            <tag> FOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差速轮运动学解算</title>
      <link href="/next/2022/Algorithm/DifferentialWheelKinematicsSolution/"/>
      <url>/next/2022/Algorithm/DifferentialWheelKinematicsSolution/</url>
      
        <content type="html"><![CDATA[<h1 id="差速轮运动学模型">差速轮运动学模型</h1><h2 id="机器人坐标系下的变换">机器人坐标系下的变换</h2><p>运动特性为两轮差速驱动，其底部后方两个同构驱动轮的转动为其提供动力，前方的随动轮起支撑作用并不推动其运动，如下图两轮差速驱动示意图所示。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/differential_wheel_chassis.png"></p><p>机器人的运动简化模型如图 4-1 所示，X 轴正方向为前进、Y 轴正方向为左平移、Z 轴正方向为逆时针。机器人两个轮子之间的间距为 D，机器人 X 轴和 Z 轴的速度分别为：<span class="math inline">\(V_x\)</span>和<span class="math inline">\(V_z\)</span> ，机器人左轮和右轮的速度分别为：<span class="math inline">\(V_l\)</span> 和<span class="math inline">\(V_r\)</span>。</p><p>假设机器人往一个左前的方向行进了一段距离，设机器人的右轮比左轮多走的距离近似为 K, 以机器人的轮子上的点作为参考点做延长参考线，可得：<span class="math inline">\(θ_1 = θ_2\)</span> 。由于这个<span class="math inline">\(Δ_t\)</span> 很小，因此角度的变化量<span class="math inline">\(θ_1\)</span> 也很小，因此有近似公式：</p><span id="more"></span><p><span class="math display">\[\theta_{2} \approx \sin \left(\theta_{2}\right)=\frac{K}{D}\]</span></p><p>由数学分析可以得到下面的式子：</p><p><span class="math display">\[\begin{equation}\mathrm{K}=\left(\mathrm{V}_{\mathrm{R}}-\mathrm{V}_{\mathrm{L}}\right) * \Delta \mathrm{t}, \quad \omega=\frac{\theta_{1}}{\Delta \mathrm{t}}\end{equation}\]</span></p><p>由上面的公式和式子可以求解出运动学正解的结果：机器人 X 轴方向速度</p><p><span class="math display">\[V_x=(V_l+V_r) / 2\]</span></p><p>机器人 Z 轴方向速度：</p><p><span class="math display">\[V_z=（V_r - V_l）/D\]</span></p><p>由正解直接反推得出运动学逆解的结果：</p><p>机器人左轮的速度：</p><p><span class="math display">\[V_l = V_x -（V_z * D）/2\]</span></p><p>机器人右轮的速度：</p><p><span class="math display">\[V_r = V_x +（V_z * D）/2\]</span></p><h2 id="实现">实现</h2><h3 id="运动学正解">运动学正解</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 轮子线速度到机器人坐标速度的变换</span></span><br><span class="line"><span class="comment"> *        Vx = (Vl + Vr) / 2</span></span><br><span class="line"><span class="comment"> *        Vz = (Vr - Vl) / D</span></span><br><span class="line"><span class="comment"> * @return Eigen::Vector3f 机器人坐标系下的速度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">MotorToRobotSpeed</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Eigen::Vector3f robot_speed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">robot_speed</span>(<span class="number">0</span>) = <span class="number">-0.5f</span> * <span class="built_in">motor_line_speed_measure_</span>(<span class="number">0</span>) + <span class="number">0.5f</span> * <span class="built_in">motor_line_speed_measure_</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">robot_speed</span>(<span class="number">1</span>) = <span class="number">0</span> * <span class="built_in">motor_line_speed_measure_</span>(<span class="number">0</span>) + <span class="number">0</span> * <span class="built_in">motor_line_speed_measure_</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">robot_speed</span>(<span class="number">2</span>) = (<span class="number">0.5f</span> / body_radius_) * (<span class="built_in">motor_line_speed_measure_</span>(<span class="number">0</span>) + <span class="built_in">motor_line_speed_measure_</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> robot_speed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="运动学逆解">运动学逆解</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 机器人坐标速度到轮子线速度的变换</span></span><br><span class="line"><span class="comment"> *        Vl = -Vx + (Vz * D) / 2</span></span><br><span class="line"><span class="comment"> *        Vr = Vx + (Vz * D) / 2</span></span><br><span class="line"><span class="comment"> * @param robot_speed 机器人坐标系下的速度</span></span><br><span class="line"><span class="comment"> * @return None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotToMotorSpeed</span><span class="params">(Eigen::Vector3f&amp; robot_speed)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">motor_line_speed_target_</span>(<span class="number">0</span>) =  <span class="number">-1</span> * <span class="built_in">robot_speed</span>(<span class="number">0</span>)  + <span class="number">0</span> * <span class="built_in">robot_speed</span>(<span class="number">1</span>) + body_radius_ * <span class="built_in">robot_speed</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">motor_line_speed_target_</span>(<span class="number">1</span>) =   <span class="number">1</span> * <span class="built_in">robot_speed</span>(<span class="number">0</span>)  + <span class="number">0</span> * <span class="built_in">robot_speed</span>(<span class="number">1</span>) + body_radius_ * <span class="built_in">robot_speed</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(motor_num_ &gt;= <span class="number">4</span>) {</span><br><span class="line">        <span class="built_in">motor_line_speed_target_</span>(<span class="number">2</span>) = <span class="built_in">motor_line_speed_target_</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">motor_line_speed_target_</span>(<span class="number">3</span>) = <span class="built_in">motor_line_speed_target_</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="坐标系旋转">坐标系旋转</h1><h2 id="全局坐标系到机器人坐标系的变换">全局坐标系到机器人坐标系的变换</h2><p>一个平面坐标系逆时针旋转一个角度后得到另一个坐标系，则同一个点在这两个坐标系之间的几何关系如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/rotate2.png"></p><p>由上图可得：</p><p><span class="math display">\[\begin{equation}\begin{aligned}x^{\prime} &amp;=O B+B C \\&amp;=O D \cos \theta+A D \sin \theta \\&amp;=x \cos \theta+y \sin \theta\end{aligned}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{aligned}y^{\prime} &amp;=A E-C E \\&amp;=A D \cos \theta-O D \sin \theta \\&amp;=y \cos \theta-x \sin \theta\end{aligned}\end{equation}\]</span></p><p>则反过来的关系如下：</p><p><span class="math display">\[\begin{equation}\left[\begin{array}{l}x \\y\end{array}\right]=\left[\begin{array}{cc}\cos \theta &amp; -\sin \theta \\\sin \theta &amp; \cos \theta\end{array}\right]\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]\end{equation}\]</span></p><p>则反过来的关系如下：</p><p><span class="math display">\[\begin{equation}\left[\begin{array}{l}x \\y\end{array}\right]=\left[\begin{array}{cc}\cos \theta &amp; -\sin \theta \\\sin \theta &amp; \cos \theta\end{array}\right]\left[\begin{array}{l}x^{\prime} \\y^{\prime}\end{array}\right]\end{equation}\]</span></p><h2 id="实现-1">实现</h2><h3 id="正解">正解</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 世界坐标到机器人坐标的速度变换</span></span><br><span class="line"><span class="comment"> * @param global_speed 为 Global 坐标的速度向量 xyw</span></span><br><span class="line"><span class="comment"> * @return Eigen::Vector3f Robot 坐标的速度向量 xyw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">GlobalToRobotSpeed</span><span class="params">(Eigen::Vector3f&amp; global_speed)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Eigen::Vector3f robot_speed;</span><br><span class="line">    Eigen::Matrix3f rotate_mat;</span><br><span class="line"></span><br><span class="line">    rotate_mat &lt;&lt;  <span class="built_in">cos</span>(global_coordinat_z_), <span class="built_in">sin</span>(global_coordinat_z_), <span class="number">0.0f</span>,</span><br><span class="line">                  -<span class="built_in">sin</span>(global_coordinat_z_), <span class="built_in">cos</span>(global_coordinat_z_), <span class="number">0.0f</span>,</span><br><span class="line">                  <span class="number">0.0f</span>,                      <span class="number">0.0f</span>,                     <span class="number">1.0f</span>;</span><br><span class="line">    robot_speed = rotate_mat * global_speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> robot_speed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="逆解">逆解</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 机器人坐标到世界坐标的速度变换</span></span><br><span class="line"><span class="comment"> * @param robot_speed Robot 坐标的速度向量 xyw</span></span><br><span class="line"><span class="comment"> * @return Eigen::Vector3f Global 坐标的速度向量 xyw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">RobotToGlobalSpeed</span><span class="params">(Eigen::Vector3f&amp; robot_speed)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Eigen::Vector3f global_speed;</span><br><span class="line">    Eigen::Matrix3f rotate_mat;</span><br><span class="line"></span><br><span class="line">    rotate_mat &lt;&lt; <span class="built_in">cos</span>(global_coordinat_z_), -<span class="built_in">sin</span>(global_coordinat_z_), <span class="number">0.0f</span>,</span><br><span class="line">                  <span class="built_in">sin</span>(global_coordinat_z_),  <span class="built_in">cos</span>(global_coordinat_z_), <span class="number">0.0f</span>,</span><br><span class="line">                  <span class="number">0.0f</span>,                      <span class="number">0.0f</span>,                     <span class="number">1.0f</span>;</span><br><span class="line">    global_speed = rotate_mat * robot_speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> global_speed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3V5dWVob21lLmNvbS8zMzk1Mw==">https://www.guyuehome.com/33953<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xJTkVBUjEwMjQvYXJ0aWNsZS9kZXRhaWxzLzEwNDk1Njc3NA==">https://blog.csdn.net/LINEAR1024/article/details/104956774<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3V5dWVob21lLmNvbS84Mzky">https://www.guyuehome.com/8392<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Odriver </tag>
            
            <tag> Actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valgrind 检测 C++内存泄漏</title>
      <link href="/next/2022/Debug/ValgrindMemleak/"/>
      <url>/next/2022/Debug/ValgrindMemleak/</url>
      
        <content type="html"><![CDATA[<h1 id="valgrind-的介绍">Valgrind 的介绍</h1><p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。在 Linux 可以使用下面的命令安装 Valgrind：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget ftp://sourceware.org/pub/valgrind/valgrind-3.13.0.tar.bz2</span><br><span class="line">$ bzip2 -d valgrind-3.13.0.tar.bz2</span><br><span class="line">$ tar -xf valgrind-3.13.0.tar</span><br><span class="line">$ <span class="built_in">cd</span> valgrind-3.13.0</span><br><span class="line">$ ./configure &amp;&amp; make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></tbody></table></figure><h1 id="检测内存泄漏">检测内存泄漏</h1><h2 id="c-语言">C 语言</h2><p>Valgrind 可以用来检测程序在哪个位置发生内存泄漏，例如下面的程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译程序时，需要加上-g 选项：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o main_c main.c</span><br></pre></td></tr></tbody></table></figure><p>使用 Valgrind 检测内存使用情况：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full  ./main_c</span><br><span class="line">==31416== Memcheck, a memory error detector</span><br><span class="line">==31416== Copyright (C) 2002-2017, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31416== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31416== Command: ./main_c</span></span><br><span class="line"><span class="string">==31416==</span></span><br><span class="line"><span class="string">==31416== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==31416==     in use at exit: 4 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31416==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated</span></span><br><span class="line"><span class="string">==31416==</span></span><br><span class="line"><span class="string">==31416== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1</span></span><br><span class="line"><span class="string">==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span></span><br><span class="line"><span class="string">==31416==    by 0x400537: main (main.c:5)</span></span><br><span class="line"><span class="string">==31416==</span></span><br><span class="line"><span class="string">==31416== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==31416==    definitely lost: 4 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31416==    indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31416==      possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31416==    still reachable: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31416==         suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31416==</span></span><br><span class="line"><span class="string">==31416== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==31416== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span></span><br></pre></td></tr></tbody></table></figure><p>先看看输出信息中的 HEAP SUMMARY，它表示程序在堆上分配内存的情况，其中的 1 allocs 表示程序分配了 1 次内存，0 frees 表示程序释放了 0 次内存，4 bytes allocated 表示分配了 4 个字节的内存。 另外，Valgrind 也会报告程序是在哪个位置发生内存泄漏。例如，从下面的信息可以看到，程序发生了一次内存泄漏，位置是 main.c 文件的第 5 行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==31416== 4 bytes <span class="keyword">in</span> 1 blocks are definitely lost <span class="keyword">in</span> loss record 1 of 1</span><br><span class="line">==31416==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==31416==    by 0x400537: main (main.c:5)</span><br></pre></td></tr></tbody></table></figure><h2 id="c语言">C++语言</h2><p>Valgrind 也可以用来检测 C++ 程序的内存泄漏，下面是一个正常的 C++ 程序，没有发生内存泄漏：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 Valgrind 分析这段程序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./main_cpp</span><br><span class="line">==31438== Memcheck, a memory error detector</span><br><span class="line">==31438== Copyright (C) 2002-2017, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31438== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31438== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==31438==     in use at exit: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==   total heap usage: 2 allocs, 1 frees, 72,736 bytes allocated</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1</span></span><br><span class="line"><span class="string">==31438==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)</span></span><br><span class="line"><span class="string">==31438==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)</span></span><br><span class="line"><span class="string">==31438==    by 0x40104E9: call_init.part.0 (dl-init.c:72)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: call_init (dl-init.c:30)</span></span><br><span class="line"><span class="string">==31438==    by 0x40105FA: _dl_init (dl-init.c:120)</span></span><br><span class="line"><span class="string">==31438==    by 0x4000CF9: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==31438==    definitely lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==      possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==    still reachable: 72,704 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==31438==         suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==31438==</span></span><br><span class="line"><span class="string">==31438== For counts of detected and suppressed errors, rerun with: -v</span></span><br><span class="line"><span class="string">==31438== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span></span><br></pre></td></tr></tbody></table></figure><p>使用 Valgrind 分析 C++ 程序时，有一些问题需要留意。例如，这个程序并没有发生内存泄漏，但是从 HEAP SUMMARY 可以看到，程序分配了 2 次内存，但却只释放了 1 次内存，为什么会这样呢？</p><p>实际上这是由于 C++ 在分配内存时，为了提高效率，使用了它自己的内存池。当程序终止时，内存池的内存才会被操作系统回收，所以 Valgrind 会将这部分内存报告为 reachable 的，需要注意，reachable 的内存不代表内存泄漏，例如，从上面的输出中可以看到，有 72704 个字节是 reachable 的，但没有报告内存泄漏。</p><h1 id="检测越界访问">检测越界访问</h1><p>C++ 程序经常出现的 Bug 就是数组越界访问，例如下面的程序出现了越界访问：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">10</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 Valgrind 分析这段程序，Valgrind 会提示越界访问：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++11 -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==31523== Memcheck, a memory error detector</span><br><span class="line">==31523== Copyright (C) 2002-2017, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31523== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31523== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31523==</span></span><br><span class="line"><span class="string">==31523== Invalid read of size 4</span></span><br><span class="line"><span class="string">==31523==    at 0x400AD7: main (main.cpp:7)</span></span><br><span class="line"><span class="string">==31523==  Address 0x5ab5ca8 is 0 bytes after a block of size 40 alloc'</span>d</span><br><span class="line">==31523==    at 0x4C2E216: operator new(unsigned long) (vg_replace_malloc.c:334)</span><br><span class="line">==31523==    by 0x4010D3: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)</span><br><span class="line">==31523==    by 0x401040: std::allocator_traits&lt;std::allocator&lt;int&gt; &gt;::allocate(std::allocator&lt;int&gt;&amp;, unsigned long) (alloc_traits.h:491)</span><br><span class="line">==31523==    by 0x400F91: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:170)</span><br><span class="line">==31523==    by 0x400E7E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_create_storage(unsigned long) (stl_vector.h:185)</span><br><span class="line">==31523==    by 0x400D1E: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:136)</span><br><span class="line">==31523==    by 0x400C11: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector(unsigned long, int const&amp;, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:291)</span><br><span class="line">==31523==    by 0x400AB9: main (main.cpp:6)</span><br></pre></td></tr></tbody></table></figure><p>Invalid read of size 4 表示越界读取 4 个字节，这个操作出现在 main.cpp 文件的第 7 行。另外可以看到，vector 分配了一块 40 字节的内存，程序越界访问紧急着这块内存之后的 4 个字节。</p><h1 id="检测未初始化的内存">检测未初始化的内存</h1><p>另一种经常出现的 Bug，就是程序访问了未初始化的内存。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"X is zero"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 Valgrind 检测这个程序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++11 -g -o main_cpp main.cpp</span><br><span class="line">$ valgrind --tool=memcheck --leak-check=full ./main_cpp</span><br><span class="line">==31554== Memcheck, a memory error detector</span><br><span class="line">==31554== Copyright (C) 2002-2017, and GNU GPL<span class="string">'d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==31554== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==31554== Command: ./main_cpp</span></span><br><span class="line"><span class="string">==31554==</span></span><br><span class="line"><span class="string">==31554== Conditional jump or move depends on uninitialised value(s)</span></span><br><span class="line"><span class="string">==31554==    at 0x400852: main (main.cpp:6)</span></span><br></pre></td></tr></tbody></table></figure><p>输出中提示了 main.cpp 文件的第 6 行访问了未初始化的内存。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZW5saW56aGFuLmdpdGh1Yi5pby8yMDE3LzEyLzMxL3ZhbGdyaW5kLw==">https://senlinzhan.github.io/2017/12/31/valgrind/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用崩溃调试分析</title>
      <link href="/next/2022/Debug/ApplicationDebug/"/>
      <url>/next/2022/Debug/ApplicationDebug/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>应用崩溃，各种空指针等大概是应用开发过程中最常遇到的问题了。而我们传统的调试利器 syslog 能快速解决 90%的问题，但是对于那些低概率，需要老化几十小时才能复现到的问题通过 syslog 就很难定位到问题了。这时如果可以提供一种情景再现的方式将应用崩溃现场的调用栈以及栈内数据给展现出来那么对于我们定位问题是大有帮助的。而笔者最近就遇到大量这种（基本都是老化过程中遇到的低概率）问题，于是这里尝试提供一种方法来快速定位问题。当然这类问题都是一个路子，掌握这种分析方法以后遇到这类问题就都可以轻松处理了。</p><p>本文提供的一种解决方案是通过 gdb+core dump 文件分析调试方法，具体如下：</p><span id="more"></span><h1 id="开启-core-dump-功能">开启 core dump 功能</h1><p>在 init 脚本的 start_service 中添加</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procd_set_param limits core=<span class="string">"unlimited"</span></span><br></pre></td></tr></tbody></table></figure><p>这样一条代码，例如 xxxapp 中的添加如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/start_core.png"></p><p>或者直接在 shell 中执行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/tmp/core-%e-%p-%t"</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></tbody></table></figure><p>然后执行应用。</p><h1 id="添加添加调试信息和符号表">添加添加调试信息和符号表</h1><h2 id="去掉编译系统的全局-strip由-strip-改为-none">去掉编译系统的全局 strip（由 strip 改为 none）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br><span class="line">    -&gt; Global build settings  </span><br><span class="line">        ---&gt; Binary stripping method (none)  </span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/strip.png"></p><blockquote><p>注意：因为 xxxapp 上存储容量限制，可以在 strip 模式下编译完系统后再改为 none，然后在编译 xxxapp，这样就只有 xxxapp 有符号表和调试信息。</p></blockquote><h2 id="应用中添加符号信息">应用中添加符号信息</h2><p>应用或者库中添加符号信息只需要在 gcc 编译的时候加上-g 选项，一般为了方便调试需要去掉-Ox 选项。例如 xxxapp 调试时的编译选项如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/g.png"></p><h2 id="开启-gdb">开启 gdb</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br><span class="line">    -&gt; Development  </span><br><span class="line">        ---&gt; &lt;*&gt; gdb</span><br></pre></td></tr></tbody></table></figure><h1 id="调试应用崩溃现场">调试应用崩溃现场</h1><p>在小机端使用“gdb 可执行程序 core 文件”开启 gdb，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb /usr/bin/xxxapp /tmp/core-startEventCall-675-1610194273</span><br></pre></td></tr></tbody></table></figure><p>加载完符号表之后，就可以查看程序 dump 时候的栈追溯，命令为 bt</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>如果没有符号表，bt 打印的就只有地址；如果有符号表，bt 的打印如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core1.png"></p><blockquote><p>说明：这个调用栈是从#0 到#12 这个顺序看的，就是说应用是在#0 这个点退出，调用顺序是从#12 到#0,</p></blockquote><p>如果既有符号表，又有 debug 信息，函数的参数会同步打印出来 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core2.png"></p><blockquote><p>说明：添加符号表后会标识出调用函数所在的文件和行数，以及调用的时候的参数，通过调用栈可以知道程序是在#2（BitmapDDAScalerEx）这个点出错，然后进入到了 c 库的崩溃处理函数</p></blockquote><p>进入#2 帧进行调试的命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ frame 2</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core3.png"></p><blockquote><p>说明：通过 pc 端打开 bitmap.c 定位到 1989 行（也可以把文件放到 tf 卡上使用 gdb 同步调试）</p></blockquote><p>这部分的代码如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core4.png"></p><p>对照源码可以打印现场 dp1，dp2 以及 sx 的值 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core5.png"></p><blockquote><p>说明：通过源码可以看出这里的 dp1 已经是一个错误的地址，程序无法访问，接来下就要探索 dp1 的值从哪里来的。</p></blockquote><p>找到该程序的上下文 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core6.png"></p><p>通过源码走读，需要打印的变量如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core7.png"></p><blockquote><p>说明：通过这里我们可以知道这里是要将一个长为 59，宽为 24 的图片，缩放成长为 50，宽为 28 的图片，图片的像素宽度为 4 个字节，但是图片的内容已经被改写没有了。</p></blockquote><p>但是没有有找到 dp1 对应的值的来源，汇编看看：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) disassemble</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core8.png"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) info registers</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/core9.png"></p><blockquote><p>说明：通过现场能够知道 dp1 对应地址为栈上的地址 0xbe973990，这个地址里保存的值为 0x135c，但是这个函数的汇编太长了，追踪内存很耗时先放弃了。</p></blockquote><p>通过在 xxxapp 中查找对应的图片，能够知道目前缩放的图片是电池电量图标的图片，这个是 minigui 里的一个 bug，跟图标刷新有关。这里不再继续下去了。以上就是一个应用崩溃后通过 gdb+core dump 文件对现场进行分析调试过程。以后遇到的应用崩溃问题都可以通过类似分析方法进行分析。</p><h1 id="在-pc-上进行调试">在 pc 上进行调试</h1><p>最近在开发中遇到一个新问题，flash（16M nor flash）满了，机器端 flash 没有空间放 gdb 了，内存、带宽和 cpu 都超极限了，需要对系统进行优化，而优化的改动是很大的，期间非常容易引入各种死机问题，而此时又没有 gdb 了。只能通过 syslog 来调试，一些低概率的老化很久才会出现的问题很难通过 syslog 的打印查找出来，还是需要 gdb+core dump 文件才能快速定位问题。为此我们又研究了在 pc 端使用 gdb 和 core dump 文件的方法。具体差异点如下：</p><h2 id="去掉-gdb">去掉 gdb</h2><p>当然你的 flash 已经容不下 gdb 了，此时。</p><h2 id="设置交叉编译工具链gdb">设置交叉编译工具链（gdb）</h2><p>在~/.bashrc 文件里添加如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/liushuai/workspace/project/prebuilt/gcc/linux-x86/arm/toolchain-sunxi-musl/toolchain/bin</span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝文件-xxxapp-和-core-dump-文件要拷贝带符号表的-xxxapp">拷贝文件 (xxxapp 和 core dump 文件，要拷贝带符号表的 xxxapp)</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/workspace/project/out/v833-perf1/staging_dir/target/rootfs/usr/bin/***app ./</span><br></pre></td></tr></tbody></table></figure><p>将机器端复现到问题后产生的 core 文件拷贝到 pc 端，adb pull /tmp/core****</p><h2 id="运行交叉编译工具链中的-gdb-程序">运行交叉编译工具链中的 gdb 程序</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-openwrt-linux-gdb vegoapp core-startEventCall-675-1610194273</span><br></pre></td></tr></tbody></table></figure><h2 id="在运行-gdb-之后设置系统库路径由于是在-pc-端运行xxxapp-里不包含共享库的内容但是-sdk-路径里是有-rootfs-文件的">在运行 gdb 之后设置系统库路径（由于是在 pc 端运行，xxxapp 里不包含共享库的内容但是 sdk 路径里是有 rootfs 文件的）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) <span class="built_in">set</span> sysroot /home/liushuai/workspace/project/out/v833-perf1/staging_dir/target/rootfs</span><br></pre></td></tr></tbody></table></figure><h2 id="打印追溯栈">打印追溯栈</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) bt</span><br></pre></td></tr></tbody></table></figure><p>剩下的就跟在机器端调试一样了。</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++内存泄露分析过程</title>
      <link href="/next/2022/Debug/CCMemLeakAsync/"/>
      <url>/next/2022/Debug/CCMemLeakAsync/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近在工作中遇到了一些内存泄露问题，虽然泄露速度很慢，但是对于小型嵌入式设备而言资源本身就很紧张而且过 72h 老化测试过不了。于是寻找一些内存泄露检测工具辅助查找内存泄露问题，此处只使用了 leaktracer 这个开源库来帮助查找内存泄露问题。</p><span id="more"></span><h1 id="leaktracer-概述">leaktracer 概述</h1><p>LeakTracer 是在检查 C/C++ 程序内存泄漏时编写的一个小工具。 要使用 LeakTracer，请使用提供的 LeakCheck 脚本运行您的程序。它使用 LD_PRELOAD 特性在你的函数之上“覆盖”一些函数（不需要重新编译）。如果您的平台不支持 LD_PRELOAD，您可以将 LeakTracer.o 对象文件添加到 Makefile 中的对象并运行您的应用程序。 LeakTracer 利用 gdb 去输出发生内存泄露所发生的位置，它是通过 override operator new, operator delete, operator malloc, operator free 来实现检测。</p><h1 id="用法">用法</h1><h2 id="加载-leaktracer-库的-3-种方法">加载 leaktracer 库的 3 种方法：</h2><ul><li>将您的程序链接到 libleaktracer.a。</li><li>将您的程序链接到 <span class="exturl" data-url="aHR0cDovL2xpYmxlYWt0cmFjZXIuc28v">libleaktracer.so<i class="fa fa-external-link-alt"></i></span>。您需要将 -lleaktracer 选项作为链接命令的第一个选项。</li><li>使用 LD_PRELOAD 环境变量以确保它在任何其他库之前加载。</li></ul><h2 id="将-leaktracer-添加到程序中">将 leaktracer 添加到程序中：</h2><ul><li>添加头文件 MemoryTrace.hpp。</li><li>添加 leaktracer::MemoryTrace::GetInstance().startMonitoringAllThreads() 函数，作为起始检测位置。</li><li>添加 leaktracer::MemoryTrace::GetInstance().writeLeaksToFile("/mnt/extsd/leaks.out") 函数，作为结束位置，生成检测报告。</li><li>编译选项中添加-funwind-tables 生成 backtrace 信息表。</li><li>链接选项中添加-Wl,-Bstatic -lleaktracer 静态链接 libleaktracer，最好加上-g3，处理报告时可以显示对应的代码。</li><li>编译后保存生成的 bin 文件，备用。</li></ul><h2 id="生成报告及处理">生成报告及处理：</h2><h3 id="生成的报告中一行信息如下">生成的报告中一行信息如下：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LeakTracer report diff_utc_mono=1588164717.365890</span></span><br><span class="line">leak, time=1434.190531, stack=0x7f05d63801d5 0x7f05d638e594 0x7f05d638d8f8 0x7f05d638c28d 0x7f05d6382738, size=1024, data=***********************************************...</span><br><span class="line">leak, time=1444.194638, stack=0x7f05d70f9c58 0x4027f5 0x7f05d6333830 0x402369, size=100, data=.<span class="string">"%...............................................</span></span><br><span class="line"><span class="string">leak, time=1434.190625, stack=0x4024d7 0x7f05d6333830 0x402369, size=100, data=..................................................</span></span><br><span class="line"><span class="string">leak, time=1444.194222, stack=0x7f05d70f9a5c 0x4027f0 0x7f05d6333830 0x402369, size=100, data=. %...............................................</span></span><br><span class="line"><span class="string">leak, time=1434.190651, stack=0x402500 0x7f05d6333830 0x402369, size=100,</span></span><br></pre></td></tr></tbody></table></figure><ul><li>leak：代表内存泄露。</li><li>time：代表调用分配内存函数的时间（开机到当前的时间）。</li><li>stack：调用栈。</li><li>size：泄露的内存大小。</li><li>data：申请时内存中的数据。</li></ul><p>明显可以看到调用栈，callstack 全是地址，我们以使用 helpers 文件夹中的 leak-analyze-addr2line，leak-analyze-gdb 二个工具进行解析。或者借助 gdb、objdump 或 map 文件等手段得到该泄露源的真正文件/行号或函数范围。</p><h3 id="报告处理">报告处理</h3><ul><li>使用 addr2line 处理 leaks.out，生成可读的调用栈。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leak-analyze-addr2line {bin} leaks.out &gt; leaks.addr2line.txt</span><br></pre></td></tr></tbody></table></figure><p>生成的报告示例如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./helpers/leak-analyze-addr2line memleak_test_so leaks.out </span><br><span class="line">Processing <span class="string">"leaks.out"</span> <span class="built_in">log</span> <span class="keyword">for</span> <span class="string">"memleak_test_so"</span></span><br><span class="line">Matching addresses to <span class="string">"memleak_test_so"</span></span><br><span class="line">found 49 leak(s)</span><br><span class="line">100 bytes lost <span class="keyword">in</span> 1 blocks (one of them allocated at 1444.194222), from following call stack:</span><br><span class="line">??:0</span><br><span class="line">/home/cll/99_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:110</span><br><span class="line">??:0</span><br><span class="line">??:?</span><br><span class="line">400 bytes lost <span class="keyword">in</span> 1 blocks (one of them allocated at 1444.194550), from following call stack:</span><br><span class="line">??:0</span><br><span class="line">/home/cll/99_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:110</span><br><span class="line">??:0</span><br><span class="line">??:?</span><br><span class="line">328 bytes lost <span class="keyword">in</span> 1 blocks (one of them allocated at 1434.190960), from following call stack:</span><br><span class="line">/home/cll/99_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:83</span><br><span class="line">??:0</span><br><span class="line">??:?</span><br></pre></td></tr></tbody></table></figure><p>解析：49 个重复调用，泄露 100 个字节的内存，其中一个泄漏点在 leaks.out 中的时间是 06219.879013，调用栈从下往上看。</p><ul><li>使用 gdb 处理 leaks.out，生成可读的调用栈及源码对应：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leak-analyze-gdb {bin} leaks.out &gt; leaks.gdb.txt</span><br></pre></td></tr></tbody></table></figure><p>生成的报告示例如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./helpers/leak-analyze-gdb memleak_test_so  leaks.out </span><br><span class="line">found 49 leak(s)</span><br><span class="line">(gdb) Reading symbols from memleak_test_so...done.</span><br><span class="line">16 bytes lost <span class="keyword">in</span> 1 blocks (one of them allocated at 1434.190803), from following call stack:</span><br><span class="line">main + 364 <span class="keyword">in</span> section .text</span><br><span class="line">0x4025e4 is <span class="keyword">in</span> main() (memleak_test.cpp:80).</span><br><span class="line">80new_delete_test *p_new_class_no_free =  new new_delete_test;</span><br><span class="line">No symbol matches 0x7f05d6333830.</span><br><span class="line">_start + 41 <span class="keyword">in</span> section .text</span><br><span class="line"> </span><br><span class="line">1 bytes lost <span class="keyword">in</span> 1 blocks (one of them allocated at 1444.194798), from following call stack:</span><br><span class="line">No symbol matches 0x7f05d70f9cee.</span><br><span class="line">main + 893 <span class="keyword">in</span> section .text</span><br><span class="line">0x4027f5 is <span class="keyword">in</span> main() (memleak_test.cpp:111).</span><br><span class="line">111leaktracer::MemoryTrace::GetInstance().stopAllMonitoring();</span><br><span class="line">No symbol matches 0x7f05d6333830.</span><br></pre></td></tr></tbody></table></figure><p>无论是 leak-analyze-addr2line，leak-analyze-gdb 二个工具进行解析。或者借助 gdb、objdump 或 map 文件等手段得到该泄露源的真正文件/行号或函数范围。其中都会碰上各种库引用等问题导致？？？。都会很麻烦，然而 leaktracer 提供了相关源码，我们可以对 leaktracer 进行改造成符合我们的定制化需求。</p><h1 id="原理">原理</h1><h2 id="leaktracer-主要的设计思路为">leaktracer 主要的设计思路为：</h2><ul><li>实现一组内存的分配/释放函数，这组函数的函数原型与系统的那一组完全一样，让被 trace 的 library 对于内存的分配/释放函数的调用都链接到自己实现的这一组函数中以 override 掉系统的那组内存/分配释放函数；</li><li>自己实现的这组函数中的内存分配函数记录分配相关的信息，包括分配的内存的大小，callstack 等，并调用系统本来的内存分配函数去分配内存；</li><li>自己实现的这组函数中的内存释放函数则销毁内存分配的相关记录，并使用系统的内存释放函数真正的释放内存；</li><li>在 trace 结束时，遍历所有保存的内存分配记录的信息，并把这些信息保存进文件以供进一步的分析；</li></ul><h2 id="override-系统内存分配释放函数">override 系统内存分配/释放函数</h2><p>LeakTracer 实现的用于 override 系统内存分配/释放函数的那组函数在 AllocationHandlers.cpp 中定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]</span></span><br><span class="line"><span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LeakTracer</span></span><br><span class="line"><span class="comment">// Contribution to original project by Erwin S. Andreasen</span></span><br><span class="line"><span class="comment">// site: http://www.andreasen.org/LeakTracer/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Added by Michael Gopshtein, 2006</span></span><br><span class="line"><span class="comment">// mgopshtein@gmail.com</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Any comments/suggestions are welcome</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MemoryTrace.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LeakTracer_l.hpp"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* (*lt_malloc)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="built_in">void</span>  (*lt_free)(<span class="type">void</span>* ptr);</span><br><span class="line"><span class="type">void</span>* (*lt_realloc)(<span class="type">void</span> *ptr, <span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span>* (*lt_calloc)(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="type">size_t</span> size) {</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span> *p)</span> </span>{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(p, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="type">void</span> *p) {</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(p, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** -- libc memory operators -- **/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* malloc</span></span><br><span class="line"><span class="comment"> * in some malloc implementation, there is a recursive call to malloc</span></span><br><span class="line"><span class="comment"> * (for instance, in uClibc 0.9.29 malloc-standard )</span></span><br><span class="line"><span class="comment"> * we use a InternalMonitoringDisablerThreadUp that use a tls variable to prevent several registration</span></span><br><span class="line"><span class="comment"> * during the same malloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(ptr, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(ptr);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_REALLOC</span>(ptr, size);</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (p != ptr)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(ptr, <span class="literal">false</span>);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerReallocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line">p = <span class="built_in">LT_CALLOC</span>(nmemb, size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, nmemb*size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存分配函数记录分配相关的信息">内存分配函数记录分配相关的信息</h4><p>registerAllocation 记录每一次内存分配的相关信息：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers new memory allocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting "new" calls */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** registers memory reallocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting realloc calls */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="registerreallocation-记录每一次内存分配的相关信息">registerReallocation 记录每一次内存分配的相关信息：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers memory reallocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting realloc calls */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adds all relevant info regarding current allocation to map</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">MemoryTrace::registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">allocation_info_t</span> *info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!AllMonitoringIsDisabled() &amp;&amp; (__monitoringAllThreads || getThreadOptions().monitoringAllocations) &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line">MutexLock <span class="title function_">lock</span><span class="params">(__allocations_mutex)</span>;</span><br><span class="line">info = __allocations.insert(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line">info-&gt;size = size;</span><br><span class="line">info-&gt;isArray = is_array;</span><br><span class="line">storeTimestamp(info-&gt;timestamp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> <span class="comment">// we store the stack without locking __allocations_mutex</span></span><br><span class="line"><span class="comment">// it should be safe enough</span></span><br><span class="line"><span class="comment">// prevent a deadlock between backtrave function who are now using advanced dl_iterate_phdr function</span></span><br><span class="line"> <span class="comment">// and dl_* function which uses malloc functions</span></span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line">storeAllocationStack(info-&gt;allocStack);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">InternalMonitoringDisablerThreadUp();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line">InternalMonitoringDisablerThreadDown();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// adds all relevant info regarding current allocation to map</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">MemoryTrace::registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!AllMonitoringIsDisabled() &amp;&amp; (__monitoringAllThreads || getThreadOptions().monitoringAllocations) &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line">MutexLock <span class="title function_">lock</span><span class="params">(__allocations_mutex)</span>;</span><br><span class="line"><span class="type">allocation_info_t</span> *info = __allocations.find(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line">info-&gt;size = size;</span><br><span class="line">info-&gt;isArray = is_array;</span><br><span class="line">storeAllocationStack(info-&gt;allocStack);</span><br><span class="line">storeTimestamp(info-&gt;timestamp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">InternalMonitoringDisablerThreadUp();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line">InternalMonitoringDisablerThreadDown();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="内存释放函数则销毁内存分配的相关记录">内存释放函数则销毁内存分配的相关记录</h4><p>registerReallocation 记录每一次内存释放的相关信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers new memory allocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting "new" calls */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removes allocation's info from the map</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">MemoryTrace::registerRelease</span><span class="params">(<span class="type">void</span> *p, <span class="type">bool</span> is_array)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!AllMonitoringIsDisabled() &amp;&amp; __monitoringReleases &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line">MutexLock <span class="title function_">lock</span><span class="params">(__allocations_mutex)</span>;</span><br><span class="line"><span class="type">allocation_info_t</span> *info = __allocations.find(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;isArray != is_array) {</span><br><span class="line">InternalMonitoringDisablerThreadUp();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line">InternalMonitoringDisablerThreadDown();</span><br><span class="line">}</span><br><span class="line">__allocations.release(p);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历所有保存的内存分配记录的信息并把这些信息保存">遍历所有保存的内存分配记录的信息，并把这些信息保存</h4><p>writeLeaksToFile 保存内存分配记录信息到文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** writes report with all memory leaks */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeLeaksToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* reportFileName)</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writes all memory leaks to given stream</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemoryTrace::writeLeaksToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* reportFilename)</span></span><br><span class="line">{</span><br><span class="line">MutexLock <span class="title function_">lock</span><span class="params">(__allocations_mutex)</span>;</span><br><span class="line">InternalMonitoringDisablerThreadUp();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::ofstream oleaks;</span><br><span class="line"><span class="keyword">if</span> (!isFolderExist(reportFilename)) {</span><br><span class="line">createDirectory(reportFilename);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (__allocations.empty()) {</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//no memory leak, not need to create leak file</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">oleaks.open(reportFilename, <span class="built_in">std</span>::ios_base::out);</span><br><span class="line"><span class="keyword">if</span> (oleaks.is_open())</span><br><span class="line">{</span><br><span class="line">writeLeaksPrivate(oleaks);</span><br><span class="line">oleaks.close();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write to \""</span> &lt;&lt; reportFilename &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line">}</span><br><span class="line">InternalMonitoringDisablerThreadDown();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="遍历自定义-mapmemoryinfo-中所有元素">遍历自定义 MapMemoryInfo 中所有元素</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writes all memory leaks to given stream</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemoryTrace::writeLeaksPrivate</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">mono</span>, <span class="title">utc</span>, <span class="title">diff</span>;</span></span><br><span class="line"><span class="type">allocation_info_t</span> *info;</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> precision = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> maxsecwidth;</span><br><span class="line"> </span><br><span class="line">clock_gettime(CLOCK_REALTIME, &amp;utc);</span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &amp;mono);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (utc.tv_nsec &gt; mono.tv_nsec) {</span><br><span class="line">diff.tv_nsec = utc.tv_nsec - mono.tv_nsec;</span><br><span class="line">diff.tv_sec = utc.tv_sec - mono.tv_sec;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">diff.tv_nsec = <span class="number">1000000000</span> - (mono.tv_nsec - utc.tv_nsec);</span><br><span class="line">diff.tv_sec = utc.tv_sec - mono.tv_sec <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">maxsecwidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(mono.tv_sec &gt; <span class="number">0</span>) {</span><br><span class="line">mono.tv_sec = mono.tv_sec/<span class="number">10</span>;</span><br><span class="line">maxsecwidth++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (maxsecwidth == <span class="number">0</span>) maxsecwidth=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">out &lt;&lt; <span class="string">"# LeakTracer report"</span>;</span><br><span class="line">d = diff.tv_sec + (((<span class="type">double</span>)diff.tv_nsec)/<span class="number">1000000000</span>);</span><br><span class="line">out &lt;&lt; <span class="string">" diff_utc_mono="</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::left &lt;&lt; <span class="built_in">std</span>::setprecision(precision) &lt;&lt; d ;</span><br><span class="line">out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"> </span><br><span class="line">__allocations.beginIteration();</span><br><span class="line"><span class="keyword">while</span> (__allocations.getNextPair(&amp;info, &amp;p)) {</span><br><span class="line">d = info-&gt;timestamp.tv_sec + (((<span class="type">double</span>)info-&gt;timestamp.tv_nsec)/<span class="number">1000000000</span>);</span><br><span class="line">out &lt;&lt; <span class="string">"leak, "</span>;</span><br><span class="line">out &lt;&lt; <span class="string">"time="</span>  &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::right &lt;&lt; <span class="built_in">std</span>::setprecision(precision) &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'0'</span>) &lt;&lt; <span class="built_in">std</span>::setw(maxsecwidth+<span class="number">1</span>+precision) &lt;&lt; d &lt;&lt; <span class="string">", "</span>; <span class="comment">// setw(16) ?</span></span><br><span class="line">out &lt;&lt; <span class="string">"stack="</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BACKTRACE_SYMBOLS_USED</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i_depth = <span class="number">0</span>; i_depth &lt; ALLOCATION_STACK_DEPTH; i_depth++) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;allocStack[i_depth] == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (i_depth &gt; <span class="number">0</span>) out &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">out &lt;&lt; info-&gt;allocStack[i_depth];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="type">char</span> **trace_symbols = (<span class="type">char</span> **)backtrace_symbols (info-&gt;allocStack, i_depth);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != trace_symbols) {</span><br><span class="line"><span class="type">size_t</span> name_size = <span class="number">64</span>;</span><br><span class="line"><span class="type">char</span> *name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(name_size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; i_depth; j++) {</span><br><span class="line"><span class="type">char</span> *begin_name = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *begin_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *end_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> *p = trace_symbols[j]; *p; ++p) {</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">'('</span>) {</span><br><span class="line">begin_name = p;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'+'</span> &amp;&amp; begin_name) {</span><br><span class="line">begin_offset = p;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">')'</span> &amp;&amp; begin_offset) {</span><br><span class="line">end_offset = p;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (begin_name &amp;&amp; begin_offset &amp;&amp; end_offset ) {</span><br><span class="line">*begin_name++ = <span class="string">'\0'</span>;</span><br><span class="line">*begin_offset++ = <span class="string">'\0'</span>;</span><br><span class="line">*end_offset = <span class="string">'\0'</span>;</span><br><span class="line"><span class="type">int</span> status = <span class="number">-4</span>;</span><br><span class="line"><span class="type">char</span> *ret = abi::__cxa_demangle(begin_name, name, &amp;name_size, &amp;status);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == status) {</span><br><span class="line">name = ret;</span><br><span class="line">out &lt;&lt; trace_symbols[j] &lt;&lt; <span class="string">":"</span> &lt;&lt; name &lt;&lt; <span class="string">"+"</span> &lt;&lt; begin_offset;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">out &lt;&lt; trace_symbols[j] &lt;&lt; <span class="string">":"</span> &lt;&lt; begin_name &lt;&lt; <span class="string">"()+"</span> &lt;&lt; begin_offset;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">out &lt;&lt; trace_symbols[j];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(trace_symbols);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; ALLOCATION_STACK_DEPTH; i++) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;allocStack[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) out &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">out &lt;&lt; info-&gt;allocStack[i];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">out &lt;&lt; <span class="string">"size="</span> &lt;&lt; info-&gt;size &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"> </span><br><span class="line">out &lt;&lt; <span class="string">"data="</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *data = reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(p);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; PRINTED_DATA_BUFFER_SIZE &amp;&amp; i &lt; info-&gt;size; i++)</span><br><span class="line">out &lt;&lt; (<span class="built_in">isprint</span>(data[i]) ? data[i] : <span class="string">'.'</span>);</span><br><span class="line">out &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>整体来看 LeakTracer 的设计与实现都并不复杂，因而能够 trace 的 memory issue 也就有限。比如，LeakTracer 就无法 trace 多次释放等问题。但我们可以通过源码编写更强大的内存相关的 trace 工具。</p><blockquote><p>注意：对于应用，无论是静态链接或动态链接的库，若想能够生成 callstack，都需要添加-funwind-tables 重新编译一次 leak-analyze-addr2line 和 leak-analyze-gdb 在 libleaktracer.tar.gz 中，需要将其中的 addr2line 和 gdb 改成交叉编译工具链中的 arm-xxx-addr2line 和 arm-xxx-gdb</p></blockquote><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW90aW5nNDUxMjkyNTEwL2FydGljbGUvZGV0YWlscy8xMDU4NTA0MDk=">https://blog.csdn.net/xiaoting451292510/article/details/105850409<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个 oops 分析实例</title>
      <link href="/next/2022/Debug/oops/"/>
      <url>/next/2022/Debug/oops/</url>
      
        <content type="html"><![CDATA[<p>最近出现了比较多的内核崩溃的问题，之前也曾转发过网上一篇关于内核崩溃问题的跟踪方法，我在这里借 xxx 提供的这个死机现场，再给大家描述一下这类问题的分析方法和 debug 过程，也希望能让大家真正掌握这类问题的调试方法。让大家明白，内核崩溃问题的调试方法其实也就是这样一些固定的套路。问题的分析过程如下：</p><span id="more"></span><h1 id="确认死机现场">确认死机现场</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[56400.437450] Unable to handle kernel paging request at virtual address f7fe44a1</span><br><span class="line">[56400.440040] pgd = d112c000</span><br><span class="line">[56400.440040] [f7fe44a1] *pgd=00000000</span><br><span class="line">[56400.440040] Internal error: Oops: 5 [<span class="comment">#1] PREEMPT SMP ARM</span></span><br><span class="line">[56400.440040] Modules linked <span class="keyword">in</span>: 8188eu gt82x mma8452 rtl8150 mcs7830 qf9700 asix sunxi_keyboard sw_device vfe_v4l2 gc2035 gc0307 vfe_subdev vfe_os cci videobuf_dma_contig videobuf_core mali(O) lcd disp nand(O)</span><br><span class="line">[56400.440040] CPU: 0    Tainted: G           O  (3.4.39 <span class="comment">#428)</span></span><br><span class="line">[56400.440040] PC is at cpuacct_charge+0x68/0xa8</span><br><span class="line">[56400.440040] LR is at cpuacct_charge+0x30/0xa8</span><br><span class="line">[56400.440040] pc : [&lt;c004b93c&gt;]    lr : [&lt;c004b904&gt;]    psr: a0000093</span><br><span class="line">[56400.440040] sp : ca25bda0  ip : 0061b000  fp : ca25bdb4</span><br><span class="line">[56400.440040] r10: 00000000  r9 : 00000000  r8 : 000b64fe</span><br><span class="line">[56400.440040] r7 : 00000000  r6 : 000b64fe  r5 : 00000000  r4 : c06e4480</span><br><span class="line">[56400.440040] r3 : f7fe4479  r2 : db506884  r1 : c07312c8  r0 : c06c8a00</span><br></pre></td></tr></tbody></table></figure><p>根据死机现场的打印分析，死机的原因是因为执行 0xc004b93c 处的代码访问数据时，取到一个非法地址：0xf7fe44a1，访问该地址的时候，会导致系统异常；</p><h1 id="反汇编内核代码分析原因">反汇编内核代码，分析原因</h1><p>通过命令"arm-none-linux-gnueabi-objdump -d vmlinux &gt; vmlinux.lst "，可以反汇编出内核的代码。 固件不是在我的机器上编出来的，所以反汇编得到的代码和在机器上实际运行的不是完全一致的，但是，没关系，这不影响我们分析问题。 由于本地的反汇编代码和设备上的不一致，所以不能用 PC 值 0xc004b93c 去定位代码，而是用"PC is at cpuacct_charge+0x68/0xa8"这个信息来确认死机时的代码位置。 "cpuacct_charge+0x68/0xa8"的含义是：函数"cpuacct_charge"的代码为 0xa8 个字节，出错时，PC 位于"cpuacct_charge"偏移 0x68 字节处。 OK，根据此信息，我们来查看反汇编得到的代码。cpuacct_charge 位于 0xc004bab4 处，偏移 0x68 字节，即 0xc004bab4 + 0x68 = 0xc004bb1c 处出现异常。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c004bab4 &lt;cpuacct_charge&gt;:</span><br><span class="line">c004bab4: e92d48f0  push {r4, r5, r6, r7, fp, lr}</span><br><span class="line">。</span><br><span class="line">c004bb0c: e5913000  ldr r3, [r1]</span><br><span class="line">c004bb10: e5933018  ldr r3, [r3, #24]</span><br><span class="line">c004bb14: e3530000  cmp r3, #0</span><br><span class="line">c004bb18: 0a000002  beq c004bb28 &lt;cpuacct_charge+0x74&gt;</span><br><span class="line">c004bb1c: e5931028  ldr r1, [r3, #40] ; 0x28</span><br></pre></td></tr></tbody></table></figure><p>再回头看异常现场：r3 : f7fe4479，发现 r3 + 0x28 = f7fe44a1，代码和异常现场相吻合。 接下来就是尝试分析出错的代码执行过程，这个有一定的难度，需要结合 C 源代码，和对汇编代码的理解来进行分析。</p><h1 id="定位出错位置的源代码">定位出错位置的源代码</h1><p>通过反汇编得知，出错时的 PC 位置在我编出来的 vmlinux 的 0xc004bb1c 地址处，采用命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-linux-gnueabi-addr2line -e vmlinux -f c004bb1c</span><br></pre></td></tr></tbody></table></figure><p>来行源码定位： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kevin@Exdroid6:~/aw1650-47/lichee/linux-3.4$ arm-none-linux-gnueabi-addr2line -e vmlinux -f c004bb1c</span><br><span class="line">cgroup_subsys_state</span><br><span class="line">/home/kevin/aw1650-47/lichee/linux-3.4/include/linux/cgroup.h:508</span><br></pre></td></tr></tbody></table></figure><p></p><p>发现出错的源代码是在操作一个链表上的指针，这些数据不是全局变量，很难分析出其出错的本质原因，所以源码分析一步在这时可以放弃；</p><h1 id="分析出错的汇编代码">分析出错的汇编代码</h1><p>结合"cpuacct_charge"函数的 C 代码实现，再回头看出错时的汇编代码，发现出错的代码其实是位于一个循环体中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c004baf0: ea00000a  b c004bb20 &lt;cpuacct_charge+0x6c&gt;</span><br><span class="line">c004baf4: e794c105  ldr ip, [r4, r5, lsl <span class="comment">#2]</span></span><br><span class="line">c004baf8: e5910010  ldr r0, [r1, <span class="comment">#16]</span></span><br><span class="line">c004bafc: e18020dc  ldrd r2, [r0, ip]</span><br><span class="line">c004bb00: e0922006  adds r2, r2, r6</span><br><span class="line">c004bb04: e0a33007  adc r3, r3, r7</span><br><span class="line">c004bb08: e18020fc  strd r2, [r0, ip]</span><br><span class="line">c004bb0c: e5913000  ldr r3, [r1]</span><br><span class="line">c004bb10: e5933018  ldr r3, [r3, <span class="comment">#24]</span></span><br><span class="line">c004bb14: e3530000  cmp r3, <span class="comment">#0</span></span><br><span class="line">c004bb18: 0a000002  beq c004bb28 &lt;cpuacct_charge+0x74&gt;</span><br><span class="line">c004bb1c: e5931028  ldr r1, [r3, <span class="comment">#40] ; 0x28</span></span><br><span class="line">c004bb20: e3510000  cmp r1, <span class="comment">#0</span></span><br><span class="line">c004bb24: 1afffff2  bne c004baf4 &lt;cpuacct_charge+0x40&gt;</span><br></pre></td></tr></tbody></table></figure><p>出错的代码是："c004bb1c: e5931028 ldr r1, [r3, #40] ; 0x28"，即 r3 的值是错的，我们来尝试分析 r3 这个数据的来源。 从："c004bb1c: e5931028 ldr r1, [r3, #40] ; 0x28"这句代码向前找，发现 r3 数据的直接来源是 r1，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c004bb0c: e5913000  ldr r3, [r1]</span><br><span class="line">c004bb10: e5933018  ldr r3, [r3, <span class="comment">#24]</span></span><br></pre></td></tr></tbody></table></figure><p>再回头看异常现场的 r1 值为"r1 : c07312c8"，以及 r1 所指向的数据：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[56400.440040] R1: 0xc0731248:</span><br><span class="line">[56400.440040] 1248  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">[56400.440040] 1268  00000000 00000000 00000000 00000000 d9833700 00989680 00000000 00000000</span><br><span class="line">[56400.440040] 1288  00000000 00000000 00000000 d9818e40 00000000 00000000 00000000 d9847380</span><br><span class="line">[56400.440040] 12a8  d9800dc0 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">[56400.440040] 12c8  d8dd2018 00000001 00000001 00000000 c06c8a00 c06c5768 00000000 00000000</span><br></pre></td></tr></tbody></table></figure><p>可以看到"c004bb0c: e5913000 ldr r3, [r1]"取到的 r3 值为 0xd8dd2018，再看接下来的一条汇编： "c004bb10: e5933018 ldr r3, [r3, #24]"，即错误的数据是从 0xd8dd2018 + 24 = 0xd8dd2030 处取到的。</p><p>此时如果想再往下分析，就只能借助 Jtag 了。</p><h1 id="jtag-分析">Jtag 分析</h1><p>当前死机的这一台，DS-5 无法打开，所以没有办法直接通过 DS-5 来查看 0xd8dd2030 处的数据是否真的错了。 此时，可以先推断 CPU 模块本身已经出错了，导致 jtag 无法通过 CPU 访问数据。 我们再来尝试一下用 JTAG 的 CSAT 方式，访问一下，发现 CSAT 可以连接上，而且可以读取物理内存的内容。 由于 CSAT 是绕过 CPU 来访问内存的数据，所以无法直接访问"0xd8dd2030"处的内容。但是，我们知道，内核 空间有近 700Mbyte 的是直接映射的，即 0x40000000 -&gt; 0xc0000000，那么 0xd8dd2030 所对应的物理地址应该 为 0x58dd2030，通过 CSAT 查看一下 0x58dd2030 处的数据：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&gt;dmr 0 0x58dc6010 16</span><br><span class="line">0x58DC6010 : 0xC06ED7EC 0xC06ED7EC 0x00000002 0x00000001</span><br><span class="line">0x58DC6020 : 0xD8DC6020 0xD8DC6020 0xD9A32088 0xD9A32088</span><br><span class="line">0x58DC6030 : 0x00000000 0xD9432F70 0x00000000 0x00000000</span><br><span class="line">0x58DC6040 : 0xC07312C8 0x00000000 0x00000000 0x00000000</span><br></pre></td></tr></tbody></table></figure><p>我们发现，0x58dd2030 处的数据是 0x00000000，即：0xd8dd2030 处的数据应该是 0x00000000。</p><p>再回头看把汇编出来的代码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c004bb10: e5933018  ldr r3, [r3, <span class="comment">#24]</span></span><br><span class="line">c004bb14: e3530000  cmp r3, <span class="comment">#0</span></span><br><span class="line">c004bb18: 0a000002  beq c004bb28 &lt;cpuacct_charge+0x74&gt;</span><br><span class="line">c004bb1c: e5931028  ldr r1, [r3, <span class="comment">#40] ; 0x28</span></span><br></pre></td></tr></tbody></table></figure><p>如果 r3 是 0，应该是退出循环，而不是再去取值，因此，可以先推断，出错的原因可能是：</p><ul><li>cpu 本身出错，导致指令执行不正常，从而导致 r3 中的数据出错</li><li>DRAM 访问出错，导致取回到 r3 的数据是错的</li></ul><p>再结合我们之前的推断，CPU 模块本身可能已经出错了，因此，我们更环疑该问题是 CPU 工作不稳定导致的。 我们再来确认一下此时 CPU 的工作频率和电压：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%&gt;dmr 0 0x1c20000 16</span><br><span class="line">0x01C20000 : 0x90001410 0x00000000 0x90034E14 0x00000000</span><br></pre></td></tr></tbody></table></figure><p>根据寄存器的值可以推出 CPU 当前工作频率为 1008Mhz；测得当前的 CPU 工作电压为：1.17v；</p><p>分析下来，并没有真正查明问题的原因，只是初步推测了一个问题可能的方向，后续的实验可以重点观注该方向上的一些实验。</p><h1 id="其他常用命令">其他常用命令</h1><p>根据函数名拿到函数的地址：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-nm vmlinux | grep __cpuinfo_store_cpu</span><br><span class="line">ffffff80100919c0 t __cpuinfo_store_cpu</span><br></pre></td></tr></tbody></table></figure><p>根据出错的位置计算起始和结束地址</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=16;ibase=10;<span class="subst">$((0x80100919c0+0x80)</span>)"</span> | bc -l</span><br><span class="line">8010091A40</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=16;ibase=10;<span class="subst">$((0x80100919c0+0x1d0)</span>)"</span> | bc -l</span><br><span class="line">8010091B90</span><br></pre></td></tr></tbody></table></figure><p>根据起始地址和结束地址 dump 出出错的汇编和源码，结合 oops 现场进行复盘分析</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-objdump -dS vmlinux --start-address=0xffffff80100919c0 --stop-address=0xffffff8010091b90</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计</title>
      <link href="/next/2022/Science/ProbabilityTheoryandMathematicalStatistics/"/>
      <url>/next/2022/Science/ProbabilityTheoryandMathematicalStatistics/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/ProbabilityTheoryandMathematicalStatistics.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjFlMWQ1NTYzNzY4OTIxMjI5OWRhNDU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概率论基本概念">概率论基本概念</h1><h2 id="概率的派别">概率的派别</h2><p>对于概率的定义有几个主流的派别：</p><ul><li><p>频率派： 频率派认为如果频率存在稳定性，即当<span class="math inline">\(n\to\infty\)</span>时下面极限存在（下面这个写法只是示意，后面介绍大数定律的时候会给出严格的定义），就得到了概率（用 Probability 的首字母 P 来表示）： <span class="math display">\[  P（正面）=\lim_{n\to\infty}P_{n}（正面）  \]</span></p></li><li><p>古典派： 如果因为无知，使得我们没有办法判断哪一个结果会比另外一个结果更容易出现，那么应该给予它们相同的概率，此称为不充分理由原则（Insufficient Reason Principle）。以不充分理由原则为基础，经由拉普拉斯：之手，确立了古典概率的定义，即： 未知的概率都为等概率</p></li><li><p>主观派： 最后介绍下主观派，主观派认为概率是信念强度（degree of belief）。比如说，我个人相信 20 年后人类从网络时代进入人工智能时代的概率为 70%.</p></li></ul><p>三个流派大概有以下的区别： <span class="math display">\[\begin{array}{c|c}    \hline    \quad\quad&amp;\quad\color{orange}{频率派}\quad&amp;\quad\color{blue}{古典派}\quad&amp;\quad\color{ForestGreen}{主观派}\quad\\    \hline \\    \quad 理论基础 \quad&amp;\quad 过往事实的归纳总结、quad&amp;\quad 不充分理由原则、quad&amp;\quad 知识和直觉、quad\\    \quad 概率定义 \quad&amp;\quad 频率稳定性、quad&amp;\quad 等概率、quad&amp;\quad 信念强度、quad\\    \\\hline\end{array}\]</span></p><h2 id="概率公理化">概率公理化</h2><p>已知某样本空间<span class="math inline">\(\Omega\)</span>，对于其中任一事件<span class="math inline">\(A\)</span>，定义函数<span class="math inline">\(P\)</span>，满足以下三大公理：</p><ul><li><p>非负性公理： <span class="math display">\[  P(A)\ge 0  \]</span></p></li><li><p>规范性公理： <span class="math display">\[  P(\Omega) = 1  \]</span></p></li><li><p>可加性公理： 设<span class="math inline">\(A_1、A_2、\cdots\)</span>为两两不相容的事件，即<span class="math inline">\(A_i\cap A_j=\varnothing（i\ne j）\)</span>，有： <span class="math display">\[  P(A_1\cup A_2\cup\cdots) = P(A_1)+P(A_2)+\cdots  \]</span></p></li></ul><p>则<span class="math inline">\(P\)</span>称为概率函数，<span class="math inline">\(P(A)\)</span>称为事件 A 的概率。</p><h2 id="事件之间的运算和关系">事件之间的运算和关系</h2><ul><li><p>并运算： 对于事件<span class="math inline">\(A、B\)</span>，并运算定义为（<span class="math inline">\(\equiv\)</span>表示定义）： <span class="math display">\[  A\cup B\equiv\{x|x\in A\ 或 \ x\in B\}  \]</span></p></li><li><p>交运算： 对于事件<span class="math inline">\(A、B\)</span>，交运算定义为： <span class="math display">\[  A\cap B\equiv\{x|x\in A\ 且 \ x\in B\}  \]</span></p></li><li><p>差运算： 对于事件<span class="math inline">\(A、B\)</span>，定义差运算为： <span class="math display">\[  A-B\equiv\{x|x\in A\quad 且、quad x\notin B\}  \]</span></p></li><li><p>补运算： 对于事件 A、B，如果： <span class="math display">\[  A=\Omega-B  \]</span> 则称 B 为 A 的补，记作（其中 c 代表 Complement）： <span class="math display">\[  B=\overline{A}\quad 或、quad B=A^c  \]</span></p></li><li><p>基本运算的性质： <span class="math display">\[\begin{array}{c|c|c}  \hline  \quad\quad&amp;\quad  类比、quad&amp;\quad 改写 \quad\\  \hline  \\  \quad 并 \quad&amp;\quad  +\quad&amp;\quad A\cup B=A+B \quad\\  \quad 交 \quad&amp;\quad  \times\quad&amp;\quad A\cap B=AB \quad\\   \quad 差 \quad&amp;\quad  -\quad&amp;\quad A-B \quad\\  \\  \hline\end{array}\]</span></p></li><li><p>德摩根定律： <span class="math display">\[  \overline{A\cup B}=\overline{A}\cap\overline{B}  \]</span> = $$</p></li><li><p>小结： <span class="math display">\[\begin{array}{c|c|c}  \hline  \quad\quad&amp;\quad 定义、quad&amp;\quad 类比、quad\\  \hline  \\  \quad 并 \quad&amp;\quad A\cup B=\{x|x\in A\ 或 \ x\in B\}\quad&amp;\quad  +\quad\\  \quad 交 \quad&amp;\quad A\cap B=\{x|x\in A\ 且 \ x\in B\}\quad&amp;\quad  \times\quad\\   \quad 差 \quad&amp;\quad A-B=\{x|x\in A\ 且、x\notin B\}\quad&amp;\quad  -\quad\\  \quad 补 \quad&amp;\quad \overline{A}=B\iff B=\Omega - A\\  \\  \hline\end{array}\]</span></p></li><li><p>事件之间的关系：</p></li></ul><p><span class="math display">\[   事件之间的关系=\begin{cases}    包含、\    相等、\    不相容、\    对立\end{cases}\]</span></p><h2 id="条件概率">条件概率</h2><p>设 A 和 B 是样本空间<span class="math inline">\(\Omega\)</span>中的两事件，若<span class="math inline">\(P(B) &gt; 0\)</span>，则称：</p><p><span class="math display">\[P(A|B)=\frac{P(A\cap B)}{P(B)}\]</span></p><p>为“假设条件为 B 时的 A 的概率”，简称条件概率。也常写作：</p><p><span class="math display">\[P(A|B)=\frac{P(AB)}{P(B)}\]</span></p><h4 id="乘法公式">乘法公式</h4><ul><li><p>若<span class="math inline">\(P(B) &gt; 0\)</span>，则： <span class="math display">\[  P(AB)=P(\color{Orange}{B})P(A|\color{Orange}{B})  \]</span></p></li><li><p>若<span class="math inline">\(P(A) &gt; 0\)</span>，则： <span class="math display">\[  P(AB)=P(\color{Magenta}{A})P(B|\color{Magenta}{A})  \]</span></p></li><li><p>若<span class="math inline">\(P(A_1\cdots A_n) &gt; 0\)</span>，则： <span class="math display">\[  P(A_1\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\cdots P(A_n|A_1\cdots A_{n-1})  \]</span></p></li></ul><p>63 4、 贝叶斯与全概率 对于同一样本空间<span class="math inline">\(\Omega\)</span>中的随机事件<span class="math inline">\(A、B\)</span>，若<span class="math inline">\(P(B) \ne 0\)</span>，有： <span class="math display">\[P(A|B)=\frac{P(A)}{P(B)}P(B|A)\]</span></p><p>设<span class="math inline">\(A_1、A_2、\cdots、A_n\)</span>满足： <span class="math display">\[A_i\cap A_j=\varnothing , (i\ne j)\quad 且、quad P(\bigcup_{i=1}^{n}A_i)=1\]</span></p><p>若<span class="math inline">\(P(A_i) &gt; 0,i=1,2,\cdots,n\)</span>，则对任意事件<span class="math inline">\(B\)</span>有： <span class="math display">\[P(B)=\sum_{i=1}^{n}P(A_i)P(B|A_i)\]</span></p><p>有了全概率公式后，可以得到贝叶斯定理真正的样子： 设<span class="math inline">\(A_1、A_2、\cdots、A_n\)</span>为样本空间<span class="math inline">\(\Omega\)</span>的一个分割，则有： <span class="math display">\[\begin{aligned}    P(A_i|B)        &amp;=\frac{P(BA_i)}{P(B)}\\        \\        &amp;=\frac{P(B|A_i)}{P(B)}P(A_i)\\        \\        &amp;=\frac{P(B|A_i)}{\displaystyle\sum_{i=1}^{n}P(A_i)P(B|A_i)}P(A_i)\end{aligned}\]</span></p><p>也就是把<span class="math inline">\(P(B)\)</span>分解到分割<span class="math inline">\(A_1、A_2、\cdots、A_n\)</span>上去了。</p><h2 id="独立事件">独立事件</h2><p>对于两个随机事件<span class="math inline">\(A、B\)</span>，如果满足： <span class="math display">\[P(AB)=P(A)P(B)\]</span></p><p>则称 A 与 B 相互独立，或简称 A 与 B 独立，否则称 A 与 B 不独立或相依。</p><p>设<span class="math inline">\(A_1、A_2、\cdots\)</span>为有限个或者无限个事件，从中任取两个<span class="math inline">\(A_{i1}、A_{i2}\)</span>，若满足： <span class="math display">\[P(A_{i1}A_{i2})=P(A_{i1})P(A_{i2})\]</span></p><p>则称<span class="math inline">\(A_1、A_2、\cdots\)</span>是两两独立。</p><p>若从中任取有限个<span class="math inline">\(A_{j1}、A_{j2}、\cdots、A_{jm}\)</span>，若满足： <span class="math display">\[P(A_{j1}A_{j2}\cdots A_{jm})=P(A_{j1})P(A_{j2})\cdots P(A_{jm})\]</span></p><p>则称<span class="math inline">\(A_1、A_2、\cdots\)</span>是相互独立。</p><h1 id="随机变量及其分布">随机变量及其分布</h1><h2 id="随机变量">随机变量</h2><p>定义在样本空间<span class="math inline">\(\Omega\)</span>上的实值函数： <span class="math display">\[X=X(\omega),\quad \omega\in\Omega\]</span></p><p>称为随机变量。随机变量是一个函数，所以都用大写字母来表示，以示和自变量 x 的区别。</p><h2 id="二项分布">二项分布</h2><h4 id="概率质量函数">概率质量函数</h4><p>如果<span class="math inline">\(p(x)\)</span>满足<span class="math inline">\(（x\in \{x_i\},i=1,2,\cdots）\)</span>：</p><ul><li><p>非负性： <span class="math display">\[  p(x_i) \ge 0  \]</span></p></li><li><p>规范性： <span class="math display">\[  \sum_{i=1}^{\infty}p(x_i)=1  \]</span></p></li></ul><p>则称其为概率质量函数（PMF）。</p><h4 id="伯努利分布">伯努利分布</h4><p>某样本空间只包含两个元素，<span class="math inline">\(\Omega=\{\omega_1,\omega_2\}\)</span>，在其上定义随机变量<span class="math inline">\(X\)</span>： <span class="math display">\[X=X(\omega)=\begin{cases}1,&amp;\omega=\omega_1\\0,&amp;\omega=\omega_2\end{cases}\]</span></p><p>若<span class="math inline">\(0\le p\le 1\)</span>时，有：</p><p><span class="math display">\[p(1)=P(X=1)=p\]</span></p><p><span class="math display">\[p(0)=P(X=0)=1-p\]</span></p><p>或写作：</p><p><span class="math display">\[P(X=x)=p(x)=\begin{cases}p,&amp;x=1\\1-p,&amp;x=0 \end{cases}\]</span></p><p>则此概率分布称作 0-1 分布，也称作伯努利分布。</p><p>在数学中，类似于扔一次硬币这样的“是非题”称为一次伯努利试验，像上面这样独立地重复扔 n 次硬币（做同样的“是非题”n 次），就称为 n 重伯努利试验。</p><h3 id="二项分布-1">二项分布</h3><p>对于 n 重伯努利实验，如果每次得到“是”的概率为 p，设随机变量： <span class="math display">\[X=得到“是”的次数\]</span></p><p>则称： <span class="math display">\[p(k)=P(X=k)={n\choose k}p^k(1-p)^{n-k},\quad k=0,1,\cdots,n\]</span></p><p>为随机变量 X 的二项分布，也可以记作： <span class="math display">\[X\sim b(n,p)\]</span></p><p>当 n=1 的时候，对应的就是伯努利分布，所以伯努利分布也可以记作<span class="math inline">\(b(1,p)\)</span>。</p><h3 id="离散的累积分布函数">离散的累积分布函数</h3><p>设<span class="math inline">\(X\)</span>是一个随机变量，<span class="math inline">\(x\)</span>是任意实数，函数： <span class="math display">\[F(x)=P(X \le x)=\sum_{a\le x}p(a)\]</span></p><p>因为是把概率质量函数累加起来，所以称为累积分布函数（Cumulative Distribution Function，或者缩写为 CDF），也简称为分布函数。</p><p>离散的数学期望 设离散随机变量<span class="math inline">\(X\)</span>的概率质量函数为： <span class="math display">\[p(x_i)=P(X=x_i),i=1,2,\cdots,n,\cdots\]</span></p><p>如果： <span class="math display">\[\sum_{i=1}^{\infty}|x_i|p(x_i) &lt; \infty\]</span> 则称： <span class="math display">\[E(X)=\sum_{i=1}^{\infty}x_ip(x_i)\]</span></p><p>为随机变量 X 的数学期望（expected value，或，expectation），简称期望或均值（mean），也有很多文档会用<span class="math inline">\(\mu_X\)</span>来表示（如果不强调随机变量的话，也可以直接用<span class="math inline">\(\mu\)</span>来表示）： <span class="math display">\[\mu_X=\mu=\sum_{i=1}^{\infty}x_ip(x_i)\]</span></p><p>若级数<span class="math inline">\(\sum_{i=1}^{\infty}|x_i|p(x_i)\)</span>不收敛，则称<span class="math inline">\(X\)</span>的数学期望不存在。</p><p>学期望也称作矩。更准确点说，由于数学期望： <span class="math display">\[E(X)=\sum_{i=1}^{\infty}x_ip(x_i)\]</span> 中<span class="math inline">\(x_i\)</span>是一次项，所以又称作一阶矩。这个称呼经常在统计的书上会遇到，特在此说明。</p><h4 id="数学期望的性质">数学期望的性质</h4><ul><li><p>复合： 假设<span class="math inline">\(g(X)\)</span>为随机变量<span class="math inline">\(X\)</span>的某一函数，则： <span class="math display">\[  E\left[g(X)\right]=\sum_i g(x_i)p(x_i)  \]</span></p></li><li><p>常数： 若 c 为常数，则： <span class="math display">\[  E(c)=c  \]</span></p></li><li>线性组合： 数学期望满足：<ul><li>齐次性，对于任意常数<span class="math inline">\(a\)</span>有： <span class="math display">\[  E(aX)=aE(X)  \]</span></li><li>可加性，对于随机变量的函数<span class="math inline">\(g_1(X)、g_2(X)\)</span>有： <span class="math display">\[  E\left[g_1(X)+g_2(X)\right]=E\left[g_1(X)\right]+E\left[g_2(X)\right]  \]</span></li></ul></li><li><p>伯努利分布和二项分布的期望分别如下： <span class="math display">\[\begin{array}{c|c}  &amp;\qquad 伯努利分布、qquad&amp;\qquad 二项分布、qquad\\  \hline\\  \ PMF\ &amp; p(x)=\begin{cases}p,&amp;x=1\\1-p,&amp;x=0\end{cases} &amp; p(x)={n\choose x}p^x(1-p)^{n-x}\\\\  \hline \\  \quad \mu\quad&amp; p &amp; np \\\end{array}\]</span></p></li></ul><h2 id="方差与标准差">方差与标准差</h2><h3 id="方差">方差</h3><p>代数式： <span class="math display">\[Var(X)=E\left[\Big(X-E(X)\Big)^2\right]\]</span> 称为随机变量 X 的方差（Variance），也可记作<span class="math inline">\(\sigma^2\)</span>或者<span class="math inline">\(\sigma_X^2\)</span>。</p><h3 id="方差的性质">方差的性质</h3><ul><li><p>化简： 可以通过下式来化简运算： <span class="math display">\[  Var(X)=E\left(X^2\right)-\mu^2  \]</span></p></li><li><p>常数： 若 c 为常数，则： <span class="math display">\[  Var(c)=0  \]</span></p></li><li><p>相加与数乘： 若 a、b 为常数，则： <span class="math display">\[  Var(aX+b)=a^2Var(X)  \]</span></p></li></ul><h3 id="标准差">标准差</h3><p>假如随机变量<span class="math inline">\(X\)</span>的方差为<span class="math inline">\(Var(X)\)</span>，则称：</p><p><span class="math display">\[\sigma(X)=\sqrt{Var(X)}\]</span> 为标准差，也可以记作<span class="math inline">\(\sigma\)</span>或者<span class="math inline">\(\sigma_X\)</span>。</p><h3 id="二项分布的方差">二项分布的方差</h3><p><span class="math display">\[\begin{array}{c|c}    &amp;\qquad 伯努利分布、qquad&amp;\qquad 二项分布、qquad\\    \hline    \\    \ PMF\ &amp; p(x)=\begin{cases}p,&amp;x=1\\1-p,&amp;x=0\end{cases} &amp; p(x)={n\choose x}p^x(1-p)^{n-x}\\    \\    \hline    \\    \quad \mu\quad&amp; p &amp; np \\    \\    \hline     \\    \quad Var(X)\quad&amp; p(1-p) &amp; np(1-p) \\    \\\end{array}\]</span></p><h3 id="马尔可夫不等式">马尔可夫不等式</h3><p>设<span class="math inline">\(X\)</span>为取非负值的随机变量，则对于任何<span class="math inline">\(a &gt; 0\)</span>，有： <span class="math display">\[P(X\ge a)\le \frac{E(X)}{a}\]</span></p><h3 id="切比雪夫不等式">切比雪夫不等式</h3><p>设<span class="math inline">\(X\)</span>是一随机变量，均值<span class="math inline">\(\mu\)</span>和方差<span class="math inline">\(\sigma^2\)</span>有限，则对任何<span class="math inline">\(k &gt; 0\)</span>有： <span class="math display">\[P(|X-\mu| \ge k)\le \frac{\sigma^2}{k^2}\]</span></p><h2 id="泊松分布">泊松分布</h2><p>对于随机变量<span class="math inline">\(X\)</span>的概率质量函数： <span class="math display">\[P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},\quad k=0,1,2,\cdots\]</span> 称为随机变量<span class="math inline">\(X\)</span>的泊松分布，也可以记为： <span class="math display">\[X\sim P(\lambda)\]</span></p><p>其数学期望和方差为：</p><p><span class="math display">\[E(X)=\lambda,\quad Var(X)=\lambda\]</span></p><p><strong>条件</strong><br>更一般地，在某一段时间 T 内发生特定事件的次数，如果满足以下假设，都可以看作泊松分布：</p><ul><li>平稳性：在此时间段 T 内，此事件发生的概率相同（在实际应用中大致相同就可以了）。</li><li>独立性：事件的发生彼此之间独立（或者说，关联性很弱）。</li><li>普通性：把 T 切分成足够小的区间、Delta T，在、Delta T 内恰好发生两个、或多个事件的可能性为 0（或者说，几乎为 0）。</li></ul><p>泊松分布是二项分布的极限： <span class="math display">\[\lim_{n\to\infty}{n\choose k}\left(\frac{\mu}{n}\right)^k\left(1-\frac{\mu}{n}\right)^{n-k}=\frac{\mu^k}{k!}e^{-\mu}\]</span></p><p>所以在泊松分布的<span class="math inline">\(\lambda\)</span>固定的情况，二项分布的 n 越大（对应的<span class="math inline">\(p=\frac{\lambda}{n}\)</span>越小），此时两者会非常接近。</p><h2 id="重要的离散分部">重要的离散分部</h2><h3 id="几何分布">几何分布</h3><p>对于 n 重伯努利实验，如果每次得到“是”的概率为 p，设随机变量： <span class="math display">\[X=首次得到“是”时进行的试验次数\]</span></p><p>则称： <span class="math display">\[p(k)=P(X=k)=(1-p)^{k-1}p,\quad k=1,2,\cdots\]</span></p><p>为随机变量 X 的几何分布，也可以记作： <span class="math display">\[X\sim Ge(p)\]</span></p><p>其数学期望和方差为： <span class="math display">\[E(X)=\frac{1}{p},\quad Var(X)=\frac{1-p}{p^2}\]</span></p><h3 id="负二项分布">负二项分布</h3><p>对于 n 重伯努利实验，如果每次得到“是”的概率为 p，设随机变量： <span class="math display">\[X=第 r 次“是”发生时的实验次数\]</span></p><p>则称： <span class="math display">\[p(k)=P(X=k)={k-1\choose r-1}p^r(1-p)^{k-r},k=r,r+1,\cdots\]</span></p><p>为随机变量 X 的负二项分布，也称为帕斯卡分布，也可以记作： <span class="math display">\[X\sim Nb(r,p)\]</span></p><p>其数学期望为： <span class="math display">\[E(X)=\frac{r}{p},\quad Var(X)=\frac{r(1-p)}{p^2}\]</span></p><h3 id="负二项分布与几何分布">负二项分布与几何分布</h3><ul><li><p>几何是负二项的特例 ： 负二项分布是这样的： <span class="math display">\[  p(k)=P(X=k)={k-1\choose r-1}p^r(1-p)^{k-r},k=r,r+1,\cdots  \]</span> r=1 的时候，就得到了几何分布： <span class="math display">\[  p(k)=P(X=k)=(1-p)^{k-1}p,\quad k=1,2,\cdots  \]</span></p></li><li><p>负二项是几何的和： 参数为 r、p 的负二项分布可以表示为如下事件序列： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/negativeBinomial.png"> 图中所示的每一段<span class="math inline">\(X_1、X_2、\cdots、X_r\)</span>都是几何分布，所以有： <span class="math display">\[  X=X_1+X_2+\cdots+X_r\sim Nb(r,p)  \]</span> 所以负二项分布的期望为： <span class="math display">\[  E(X)=E(X_1)+E(X_2)+\cdots+E(X_r)=\frac{r}{p}  \]</span></p></li></ul><h3 id="超几何分布">超几何分布</h3><p>设有 N 件产品，其中有 M 件不合格品，随机抽取 n 件产品，则其中含有 m 件不合格产品的概率为多少？ 假设随机变量： <span class="math display">\[X=随机抽取的 n 件中有 m 件不合格品\]</span> 这个随机变量的概率可以用古典概率来求，首先，样本空间就是从 N 件中随便抽取 n 件，所以：</p><p><span class="math display">\[|\Omega| = {N\choose n}\]</span></p><p>然后有 m 件从不合格品中抽取，剩下的在合格品中抽取，则有：</p><p><span class="math display">\[|X| = {M\choose m}{N-M\choose n-m}\]</span></p><p>所求概率即为：</p><p><span class="math display">\[P(X=m)=\frac{\left(\begin{array}{c}M \\m\end{array}\right)\left(\begin{array}{c}N-M \\n-m\end{array}\right)}{\left(\begin{array}{c}N \\n\end{array}\right)}, m=0,1, \cdots, r\]</span></p><p>其中<span class="math inline">\(r=min(M,n)\)</span>。此时称 X 服从超几何分布，可以记作：</p><p><span class="math display">\[X\sim h(n,N,M)\]</span></p><p>其数学期望和方差为： <span class="math display">\[E(X)=n\frac{M}{N},\quad Var(X)=n\frac{M}{N}\left(1-\frac{M}{N}\right)\left(1-\frac{n-1}{N-1}\right)\]</span></p><h3 id="超几何分布与二项分布">超几何分布与二项分布</h3><p>超几何分布与二项分布类似，都是求抽取 n 次其中有 m 次“是”的概率，只是：</p><ul><li>二项分布：相当于抽取之后放回。</li><li>超几何分布：抽取之后不放回。</li></ul><p>所以在超几何分布中，如果被抽取的总数 N 特别大，那么放回不放回区别也就不大了，此时，那么超几何分布可以近似看作二项分布。 这点从两者的期望、方差也可以看出来： <span class="math display">\[\begin{array}{c|c}    &amp;\qquad 二项分布、qquad&amp;\qquad 超几何分布、qquad\\    \hline    \\    \quad \mu\quad&amp; np &amp; n\frac{M}{N} \\    \\    \hline     \\    \quad \sigma^2\quad&amp; np(1-p) &amp; n\frac{M}{N}\left(1-\frac{M}{N}\right)\left(1-\frac{n-1}{N-1}\right)\\    \\\end{array}\]</span> 令<span class="math inline">\(p=\frac{M}{N}\)</span>，超几何分布的期望和方差可以写作： <span class="math display">\[\mu=n\frac{M}{N}=np\]</span> ^2=n(1-)(1-)=np(1-p)(1-) $$</p><p>对超几何分布而言，当 N 足够大的时候，<span class="math inline">\(\frac{M}{N}\)</span>可看作取出不合格产品的概率，那此时超几何分布可看作二项分布。</p><h3 id="总结">总结</h3><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 伯努利分布、quad&amp;\quad 抛硬币，二选一 \quad\\     \quad 二项分布、quad&amp;\quad n 重伯努利，出现 k 次“是” \quad\\     \quad 泊松分布、quad&amp;\quad 二项分布的极限 \quad\\     \quad 几何分布、quad&amp;\quad n 重伯努利，第 k 次首次出现“是” \quad\\     \quad 负二项分布、quad&amp;\quad 几何分布的和 \quad\\     \quad 超几何分布、quad&amp;\quad 不放回抽样的二项分布 \quad\\     \\    \hline\end{array}\]</span></p><h2 id="概率密度函数">概率密度函数</h2><h3 id="概率密度函数-1">概率密度函数</h3><p>如果函数<span class="math inline">\(p(x)\)</span>满足下列两个条件（对应了概率的三大公理）：</p><ul><li><p>非负性： <span class="math display">\[  p(x) \ge 0  \]</span></p></li><li><p>规范性（暗含了可加性），因为是连续的，所以通过积分相加： <span class="math display">\[  \int_{-\infty}^{+\infty}p(x)\mathrm{d}x=1  \]</span></p></li></ul><p>则称其为概率密度函数（Probability Density Function，简写为 PDF）。</p><h3 id="期望">期望</h3><p>离散随机变量的期望定义为： <span class="math display">\[E(X)=\sum_{i=1}^{\infty}x_ip(x_i)\]</span></p><p>可以用类似的方法定义连续随机变量的期望，当然期望的意义是没有改变的： <span class="math display">\[E(X)=\int_{-\infty}^{+\infty}xp(x)\mathrm{d}x\]</span> 关于期望的几个性质也是成立的：</p><ul><li><p>复合： 假设<span class="math inline">\(g(X)\)</span>为连续随机变量<span class="math inline">\(X\)</span>的某一函数，则： <span class="math display">\[  E\left[g(X)\right]=\int_{-\infty}^{+\infty}g(x)p(x)\mathrm{d}x  \]</span></p></li><li><p>常数： 若 c 为常数，则： <span class="math display">\[  E(c)=c  \]</span></p></li><li>线性： 数学期望满足：<ul><li>齐次性，对于任意常数 a 有： <span class="math display">\[  E(aX)=aE(X)  \]</span></li><li>可加性，对于任意两个函数<span class="math inline">\(g_1(X)、g_2(X)\)</span>有： <span class="math display">\[  E\left[g_1(X)+g_2(X)\right]=E\left[g_1(X)\right]+E\left[g_2(X)\right]  \]</span></li></ul></li></ul><h3 id="方差-1">方差</h3><p>方差的定义依然是： <span class="math display">\[Var(X)=E\left[\Big(X-E(X)\Big)^2\right]\]</span></p><p>相关的性质也是成立的：</p><ul><li><p>化简： 可以通过下式来化简运算： <span class="math display">\[  Var(X)=E\left(X^2\right)-\mu^2  \]</span></p></li><li><p>常数： 若 c 为常数，则： <span class="math display">\[  Var(c)=0  \]</span></p></li><li><p>相加与数乘： 若 a、b 为常数，则： <span class="math display">\[  Var(aX+b)=a^2Var(X)  \]</span></p></li></ul><h3 id="累积分布函数">累积分布函数</h3><p>连续随机变量<span class="math inline">\(X\)</span>的概率密度函数为<span class="math inline">\(p(x)\)</span>，则： <span class="math display">\[F(x)=P(X \le x)=\int_{-\infty}^{x}p(t)\mathrm{d}t\]</span> 称为<span class="math inline">\(X\)</span>的累积分布函数。</p><h2 id="正态分布">正态分布</h2><h3 id="正态分布-1">正态分布</h3><p>如果连续随机变量<span class="math inline">\(X\)</span>的概率密度函数为： <span class="math display">\[p(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}},\quad -\infty &lt; x &lt; +\infty\]</span></p><p>则称<span class="math inline">\(X\)</span>服从正态分布（normal distribution），也称作高斯分布（Gaussian distribution），记作<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>，其累积分布函数为： <span class="math display">\[F(x)=\frac{1}{\sigma\sqrt{2\pi}}\int_{-\infty}^{x}e^{-\frac{(t-\mu)^2}{2\sigma^2}}\mathrm{d}t\]</span></p><p>我们称<span class="math inline">\(\mu=0、\sigma=1\)</span>时的正态分布<span class="math inline">\(N(0,1)\)</span>为标准正态分布。</p><h3 id="期望与方差">期望与方差</h3><p>正态分布<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>的期望和方差为： <span class="math display">\[E(X)=\mu,\quad Var(X)=\sigma^2\]</span></p><h2 id="指数分布">指数分布</h2><p>若随机变量<span class="math inline">\(X\)</span>的概率密度函数为： <span class="math display">\[p(x)=\begin{cases}\lambda e^{-\lambda x}, &amp; x \ge 0\\0,&amp; x &lt; 0\end{cases}\]</span></p><p>其中<span class="math inline">\(\lambda &gt; 0\)</span>，称<span class="math inline">\(X\)</span>服从指数分布，也可以记为： <span class="math display">\[X\sim Exp(\lambda)\]</span></p><p>累积分布函数为： <span class="math display">\[F(x)=\begin{cases}1-e^{-\lambda x}, &amp; x \ge 0\\0,&amp; x &lt; 0\end{cases}\]</span></p><p>指数分布<span class="math inline">\(X\sim Exp(\lambda)\)</span>的期望和方差为： <span class="math display">\[E(X)=\frac{1}{\lambda},\quad Var(X)=\frac{1}{\lambda^2}\]</span></p><h4 id="总结-1">总结</h4><p>首先是一维离散随机变量的概率分布：</p><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 伯努利分布、quad&amp;\quad 抛硬币，二选一 \quad\\     \quad 二项分布、quad&amp;\quad n 重伯努利，出现 k 次“是” \quad\\     \quad 泊松分布、quad&amp;\quad 二项分布的极限 \quad\\     \quad 几何分布、quad&amp;\quad n 重伯努利，第 k 次首次出现“是” \quad\\     \quad 负二项分布、quad&amp;\quad 几何分布的和 \quad\\     \quad 超几何分布、quad&amp;\quad 不放回抽样的二项分布 \quad\\     \\    \hline\end{array}\]</span></p><p>然后是一维连续随机变量的概率分布：</p><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 均匀分布、quad&amp;\quad 古典派中的几何概型 \quad\\     \quad 正态分布、quad&amp;\quad 二项分布的另外一种极限 \quad\\     \quad 指数分布、quad&amp;\quad 泊松分布的间隔，连续的几何分布 \quad\\     \\    \hline\end{array}\]</span></p><h1 id="多维随机变量及其分布">多维随机变量及其分布</h1><h2 id="多维随机变量及其分布-1">多维随机变量及其分布</h2><h3 id="联合概率质量函数">联合概率质量函数</h3><p>如果二维随机向量<span class="math inline">\((X,Y)\)</span>所有可能的取值为<span class="math inline">\((x_i,y_j),i,j=1,2,\cdots\)</span>，这两个随机变量同时发生的概率可以用函数表示如下： <span class="math display">\[p_{ij}=P(X=x_i,Y=y_j)=P(X=x_i\ \color{red}{且}\ Y=y_j),\quad i,j=1,2,\cdots\]</span></p><p>且此函数满足如下性质（即概率的三大公理）：</p><ul><li><p>非负性： <span class="math display">\[  p_{ij}\ge 0  \]</span></p></li><li><p>规范性和可加性： <span class="math display">\[  \sum_{i=1}^{\infty}\sum_{j=1}^{\infty}p_{ij}=1  \]</span></p></li></ul><p>则称此函数为<span class="math inline">\((X,Y)\)</span>的联合概率质量函数（Joint Probability Mass Function），或者称为联合分布列，此定义可以推广到多维离散随机变量上去。</p><h3 id="联合概率密度函数">联合概率密度函数</h3><p>对于某二维随机变量<span class="math inline">\((X,Y)\)</span>存在二元函数<span class="math inline">\(p(x,y)\)</span>满足：</p><ul><li><p>非负性： <span class="math display">\[  p(x,y)\ge 0  \]</span></p></li><li><p>规范性和可加性（连续的都通过积分来相加）： <span class="math display">\[  \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}p(x,y)\mathrm{d}x\mathrm{d}y=1  \]</span></p></li></ul><p>则称此函数为<span class="math inline">\((X,Y)\)</span>的联合概率密度函数（Joint Probability Density Function），此定义可以推广到多维连续随机变量上去。</p><h3 id="联合累积分布函数">联合累积分布函数</h3><p>设<span class="math inline">\((X,Y)\)</span>是二维随机变量，对于任意实数<span class="math inline">\(x、y\)</span>，可以定义一个二元函数来表示两个事件同时发生的概率： <span class="math display">\[F(x,y)=P\Big(\{X\le x\}\ \color{red}{且}\ \{Y\le y\}\Big)=P(X\le x, Y\le y)\]</span></p><p>称为二维随机变量<span class="math inline">\((X,Y)\)</span>的联合累积分布函数（Joint Cumulative Distribution Function），如果混合偏导存在的话，那么：</p><p><span class="math display">\[\frac{\partial F(x,y)}{\partial x \partial y}=p(x,y)\]</span></p><p>得到<span class="math inline">\(p(x,y)\)</span>就是此分布的概率密度函数。此定义和性质可以推广到多维随机变量。</p><h3 id="多维均匀分布">多维均匀分布</h3><p>设<span class="math inline">\(D\)</span>为<span class="math inline">\(R^n\)</span>中的一个有界区域，其度量（直线为长度，平面为面积，空间为体积等）为<span class="math inline">\(S_D\)</span>，如果多维随机变量<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>的联合概率密度函数为： <span class="math display">\[p(x_1,x_2,\cdots,x_n)=\begin{cases}    \frac{1}{S_D},&amp;(x_1,x_2,\cdots,x_n)\in D\\    0,&amp;其它\end{cases}\]</span> 则称<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>服从<span class="math inline">\(D\)</span>上的多维均匀分布，记作：</p><p><span class="math display">\[(X_1,X_2,\cdots,X_n)\sim U(D)\]</span></p><h2 id="边缘分布与随机变量的独立性">边缘分布与随机变量的独立性</h2><h3 id="边缘概率质量函数">边缘概率质量函数</h3><p>如果二维离散随机变量<span class="math inline">\((X,Y)\)</span>的联合概率质量函数为： <span class="math display">\[P(X=x_i,Y=y_j),i,j=1,2,\cdots\]</span></p><p>对<span class="math inline">\(j\)</span>求和所得的函数：</p><p><span class="math display">\[\sum_{j=1}^{\infty}P(X=x_i,Y=y_j)=P(X=x_i)\]</span></p><p>称为<span class="math inline">\(X\)</span>的边缘概率质量函数（Marginal Probability Mass Function），或者称为边缘分布列。类似的对 i 求和所得的函数： <span class="math display">\[\sum_{i=1}^{\infty}P(X=x_i,Y=y_j)=P(Y=y_j)\]</span></p><p>称为<span class="math inline">\(Y\)</span>的边缘概率质量函数。</p><h3 id="边缘概率密度函数">边缘概率密度函数</h3><p>如果二维连续随机变量<span class="math inline">\((X,Y)\)</span>的联合概率密度函数为<span class="math inline">\(p(x,y)\)</span>，则： <span class="math display">\[p_X(x)=\int_{-\infty}^{+\infty}p(x,y)\mathrm{d}y\]</span></p><p>称为<span class="math inline">\(X\)</span>的边缘概率密度函数（Marginal Probability Density Function）。类似的： <span class="math display">\[p_Y(y)=\int_{-\infty}^{+\infty}p(x,y)\mathrm{d}x\]</span></p><p>称为 Y 的边缘概率密度函数。</p><h3 id="边缘累积分布函数">边缘累积分布函数</h3><p>如果二维连续随机变量<span class="math inline">\((X,Y)\)</span>的联合累积分布函数为<span class="math inline">\(F(x,y)\)</span>，如下可以得到<span class="math inline">\(X\)</span>的累积分布函数： <span class="math display">\[F_X(x)=\lim_{y\to+\infty}F(x,y)=P(X\le x,Y &lt; +\infty)=P(X\le x)\]</span></p><p>称为<span class="math inline">\(X\)</span>的边缘累积分布函数（Marginal Cumulative Distribution Function）。可记作： <span class="math display">\[F_X(x)=F(x,+\infty)\]</span></p><p>同理可以得到 Y 的边缘累积分布函数： <span class="math display">\[F_Y(y)=F(+\infty, y)\]</span></p><h2 id="条件分布">条件分布</h2><h3 id="离散的条件分布">离散的条件分布</h3><p>设<span class="math inline">\((X,Y)\)</span>是二维离散型随机变量，对于固定的<span class="math inline">\(j\)</span>，若<span class="math inline">\(P(Y=y_j)\ge 0\)</span>，则称： <span class="math display">\[P\left(X=x_{i} | Y=y_{j}\right)=\frac{P\left(X=x_{i}, Y=y_{j}\right)}{P\left(Y=y_{j}\right)}, i=1,2, \cdots\]</span></p><p>为<span class="math inline">\(Y=y_j\)</span>条件下的随机变量<span class="math inline">\(X\)</span>的条件概率质量函数。同样的对于固定的<span class="math inline">\(i\)</span>，若<span class="math inline">\(P(X=x_i)\ge 0\)</span>，则称： <span class="math display">\[P\left(Y=y_{j} | X=x_{i}\right)=\frac{P\left(X=x_{i}, Y=y_{j}\right)}{P\left(X=x_{i}\right)}, j=1,2, \cdots\]</span></p><p>为<span class="math inline">\(X=x_i\)</span>条件下的随机变量<span class="math inline">\(Y\)</span>的条件概率质量函数。</p><p>条件分布和条件概率没有什么区别，一样可以用于全概率公式、贝叶斯公式。</p><h3 id="连续的条件分布">连续的条件分布</h3><p>设二维连续型随机变量<span class="math inline">\((X,Y)\)</span>的概率密度函数为<span class="math inline">\(p(x,y)\)</span>，若对于固定的<span class="math inline">\(y\)</span>有边缘概率密度函数<span class="math inline">\(p_Y(y) &gt; 0\)</span>，则： <span class="math display">\[p_{X|Y}(x\ |\ y)=\frac{p(x,y)}{p_Y(y)}\]</span> 为<span class="math inline">\(Y=y\)</span>条件下的随机变量<span class="math inline">\(X\)</span>的条件概率密度函数。对应的条件累积分布函数为： <span class="math display">\[F_{X|Y}(x\ |\ y)=\int_{-\infty}^{x}\frac{p(u,y)}{p_Y(y)}\mathrm{d}u\]</span></p><p>同样的道理，以<span class="math inline">\(X=x\)</span>为条件有： <span class="math display">\[p_{Y|X}(y\ |\ x)=\frac{p(x,y)}{p_X(x)}\]</span> F_{Y|X}(y&nbsp;|&nbsp;x)=_{-}^{y}u $$</p><h3 id="连续的全概率和贝叶斯">连续的全概率和贝叶斯</h3><ul><li><p>全概率： <span class="math display">\[  p_{Y}(y)=\int_{-\infty}^{+\infty} p(y | x) p_{X}(x) \mathrm{d} x  \]</span> p_{X}(x)=<em>{-}^{+} p(x | y) p</em>{Y}(y)  y $$</p></li><li><p>贝叶斯： <span class="math display">\[\begin{aligned}   p(x | y)       &amp;=\frac{p(y | x) p_{X}(x)}{p_{Y}(y)} \\      &amp;=\frac{p(y | x) p_{X}(x)}{\int_{-\infty}^{+\infty} p(y | x) p_{X}(x) \mathrm{d} x} \end{aligned}\]</span></p></li></ul><h2 id="多维随机变量函数的分布">多维随机变量函数的分布</h2><h3 id="随机变量的和">随机变量的和</h3><ul><li><p>离散： 设 X、Y 为两个相互独立的离散随机变量，取值范围为<span class="math inline">\(0，1，2，\cdots\)</span>，则其和的概率质量函数为： <span class="math display">\[  P(X+Y=k)=\sum_{i=0}^{k}P(X=i)P(Y=k-i)  \]</span> 这个概率等式称为离散场合下的卷积公式。</p></li><li><p>连续： 设<span class="math inline">\((X,Y)\)</span>为二维连续型随机变量，概率密度函数为<span class="math inline">\(p(x,y)\)</span>，则<span class="math inline">\(Z=X+Y\)</span>仍为连续型随机变量，其概率密度为： <span class="math display">\[  p_{X+Y}(z)=\int_{-\infty}^{+\infty}p(z-y,y)\mathrm{d}y=\int_{-\infty}^{+\infty}p(x,z-x)\mathrm{d}x  \]</span> 若<span class="math inline">\(X、Y\)</span>为相互独立，其边缘密度函数分别为<span class="math inline">\(p_X(x)\)</span>和<span class="math inline">\(p_Y(y)\)</span>，则其和<span class="math inline">\(Z=X+Y\)</span>的概率密度函数为： <span class="math display">\[  p_Z(z)=\int_{-\infty}^{+\infty}p_X(z-y)p_Y(y)\mathrm{d}y=\int_{-\infty}^{+\infty}p_X(x)p_Y(z-x)\mathrm{d}x  \]</span> 上面两个概率等式称为连续场合下的卷积公式。</p></li></ul><h1 id="随机变量的数字特征">随机变量的数字特征</h1><h2 id="数学期望">数学期望</h2><h3 id="数学期望的定义">数学期望的定义</h3><p>离散随机变量的数学期望定义为： <span class="math display">\[E(X)=\sum_{i=1}^{\infty}x_ip(x_i)\]</span></p><p>连续随机变量的数学期望定义为： <span class="math display">\[E(X)=\int_{-\infty}^{+\infty}xp(x)\mathrm{d}x\]</span></p><h3 id="函数的数学期望">函数的数学期望</h3><ul><li><p>一维随机变量： 设<span class="math inline">\(Y\)</span>是随机变量<span class="math inline">\(X\)</span>的函数<span class="math inline">\(Y=g(X)\)</span>(g 是连续函数）。</p><ul><li>若<span class="math inline">\(X\)</span>为离散随机变量，则（设下式中的级数绝对收敛）： <span class="math display">\[  E(Y)=E\left[g(X)\right]=\sum_i g(x_i)p(x_i)  \]</span></li><li>若<span class="math inline">\(X\)</span>为连续随机变量，则（设下式中的积分绝对收敛）： <span class="math display">\[  E(Y)=E\left[g(X)\right]=\int_{-\infty}^{+\infty}g(x)p(x)\mathrm{d}x  \]</span></li></ul></li><li><p>多维随机变量： 设<span class="math inline">\(Z\)</span>是随机变量<span class="math inline">\((X,Y)\)</span>的函数<span class="math inline">\(Z=g(X,Y)\)</span>(g 是连续函数）。</p><ul><li>若<span class="math inline">\((X,Y)\)</span>为离散随机变量，则（设下式中的级数绝对收敛）： <span class="math display">\[  E(Z)=E\left[g(X,Y)\right]=\sum_j\sum_i g(x_i,y_j)p(x_i,y_j)  \]</span></li><li>若<span class="math inline">\((X,Y)\)</span>为连续随机变量，则（设下式中的积分绝对收敛）： <span class="math display">\[  E(Z)=E\left[g(X,Y)\right]=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)p(x,y)\mathrm{d}x\mathrm{d}y  \]</span></li></ul></li></ul><h3 id="线性的数学期望">线性的数学期望</h3><p>数学期望满足：</p><ul><li><p>齐次性，对于任意常数 a 有： <span class="math display">\[  E(aX)=aE(X)  \]</span></p></li><li><p>可加性，对于任意两个函数<span class="math inline">\(g_1(X)、g_2(X)\)</span>有： <span class="math display">\[  E\left[g_1(X)+g_2(X)\right]=E\left[g_1(X)\right]+E\left[g_2(X)\right]  \]</span></p></li></ul><p>对于多维也成立： <span class="math display">\[E(X+Y)=E(X)+E(Y)\]</span> E(X_1+X_2++X_n)=E(X_1)+E(X_2)++E(X_n) $$</p><h3 id="施瓦茨不等式">施瓦茨不等式</h3><p>对任意随机变量<span class="math inline">\(X\)</span>与<span class="math inline">\(Y\)</span>都有： <span class="math display">\[\Big[E(XY)\Big]^2 \le E(X^2)E(Y^2)\]</span></p><h3 id="独立的数学期望">独立的数学期望</h3><p>设<span class="math inline">\((X,Y)\)</span>为二维独立随机变量，则有： <span class="math display">\[E(XY)=E(X)E(Y)\]</span> 这个结论可以推广到 n 维独立随机变量： <span class="math display">\[E\left(X_{1} X_{2} \cdots X_{n}\right)=E\left(X_{1}\right) E\left(X_{2}\right) \cdots E\left(X_{n}\right)\]</span></p><h2 id="方差与标准差-1">方差与标准差</h2><h3 id="方差与标准差的定义">方差与标准差的定义</h3><p>方差定义为（因为直接通过数学期望定义的，所以没有区分离散和连续）： <span class="math display">\[Var(X)=E\left[\Big(X-E(X)\Big)^2\right]\]</span></p><p>为了写的简单一点，也常常令<span class="math inline">\(E(X)=\mu\)</span>，那么上式可以改写为： <span class="math display">\[Var(X)=E\left[(X-\mu)^2\right]\]</span></p><p>之前也介绍过，由于方差里面含有平方，在实际应用中需要开平方才能保持单位一致，这就是标准差：</p><p><span class="math display">\[\sigma(X)=\sqrt{Var(X)}\]</span></p><h3 id="线性的方差">线性的方差</h3><p>若<span class="math inline">\(a、b\)</span>为常数，则： <span class="math display">\[Var(aX+b)=a^2Var(X)\]</span></p><h3 id="独立的方差">独立的方差</h3><p>设<span class="math inline">\((X,Y)\)</span>为二维独立随机变量，则有： <span class="math display">\[Var(X\pm Y)=Var(X)+Var(Y)\]</span></p><p>这个结论可以推广到 n 维独立随机变量：</p><p><span class="math display">\[Var\left(X_{1}\pm X_{2}\pm \cdots\pm X_{n}\right)=Var\left(X_{1}\right) +Var\left(X_{2}\right)+\cdots+Var\left(X_{n}\right)\]</span></p><h2 id="协方差">协方差</h2><h3 id="协方差的定义">协方差的定义</h3><p>设<span class="math inline">\((X,Y)\)</span>是一个二维随机变量，若<span class="math inline">\(E\Big[(X-\mu_X)(Y-\mu_Y)\Big]\)</span>存在，则称此数学期望为<span class="math inline">\(X\)</span>与<span class="math inline">\(Y\)</span>的协方差（Covariance），记作： <span class="math display">\[Cov(X,Y)=E\Big[(X-\mu_X)(Y-\mu_Y)\Big]\]</span></p><p>特别地有<span class="math inline">\(Cov(X,X)=Var(X)\)</span>。</p><p>很显然会有：</p><ul><li><span class="math inline">\(Cov(X,Y) &gt; 0\)</span>时，<span class="math inline">\(X、Y\)</span>正相关，即两者有同时增加或者减少的倾向。</li><li><span class="math inline">\(Cov(X,Y) &lt; 0\)</span>时，<span class="math inline">\(X、Y\)</span>负相关，即两者有反向增加或者减少的倾向。</li><li><span class="math inline">\(Cov(X,Y) = 0\)</span>时，<span class="math inline">\(X、Y\)</span>不相关，不过和独立还是有区别的，这点我们后面再论述。</li></ul><h3 id="协方差的性质">协方差的性质</h3><ul><li><p>化简： 可以通过下式来化简运算： <span class="math display">\[  Cov(X,Y)=E(XY)-E(X)E(Y)  \]</span> 据此马上可以得到一个推论： <span class="math display">\[  Cov(X,Y)=Cov(Y,X)  \]</span></p></li><li><p>方差： 对于任意的二维随机变量<span class="math inline">\((X,Y)\)</span>有： <span class="math display">\[  Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)  \]</span> Var(X-Y)=Var(X)+Var(Y)-2Cov(X,Y) <span class="math display">\[  所以当$(X,Y)$为二维不相关随机变量时，有：  \]</span> Var(XY)=Var(X)+Var(Y) $$</p></li><li><p>分配律： <span class="math display">\[  Cov(X_1+X_2,Y)=Cov(X_1, Y)+Cov(X_2,Y)  \]</span></p></li><li><p>数乘： <span class="math display">\[  Cov(aX+c,bY+d)=abCov(X, Y)  \]</span></p></li></ul><h3 id="独立与不相关">独立与不相关</h3><ul><li><p>独立必不相关： 根据刚才的性质： <span class="math display">\[  Cov(X,Y)=E(XY)-E(X)E(Y)  \]</span> 如果 X、Y 独立，则有： <span class="math display">\[  E(XY)=E(X)E(Y)\implies Cov(X,Y)=0  \]</span> 所以： <span class="math display">\[  独立、implies 不相关  \]</span></p></li><li><p>不相关不能推出独立： 不相关只能说明 X、Y 之间没有正相关规律，也没有负相关规律，但可能还有很多别的规律，所以： <span class="math display">\[  不相关、\mathrel{\rlap{\hskip .5em/}}\Longrightarrow\ 独立  \]</span></p></li></ul><h3 id="相关系数">相关系数</h3><p>对于二维随机变量<span class="math inline">\((X,Y)\)</span>，各自的方差为： <span class="math display">\[Var(X)=\sigma^2_X,\quad Var(Y)=\sigma^2_Y\]</span> 则： <span class="math display">\[\rho_{XY}=\frac{Cov(X,Y)}{\sigma_X\sigma_Y}\]</span> 称为随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的相关系数。</p><p>对于任意的二维随机变量<span class="math inline">\((X,Y)\)</span>，若相关系数存在，则： <span class="math display">\[-1\le\rho_{XY}\le 1\]</span></p><p>有界性让比较有了一个范围，我们可以得到如下结论：</p><ul><li><span class="math inline">\(\rho &gt; 0\)</span>：正相关，且<span class="math inline">\(\rho=1\)</span>的时候，正相关性最大，称为完全正相关。</li><li><span class="math inline">\(\rho &lt; 0\)</span>：负相关，且<span class="math inline">\(\rho=-1\)</span>的时候，负相关性最大，称为完全负相关。</li><li><span class="math inline">\(\rho = 0\)</span>：不相关。</li></ul><h3 id="二维正态分布">二维正态分布</h3><p>如果二维随机变量<span class="math inline">\((X,Y)\)</span>的联合概率密度函数为： <span class="math display">\[\begin{aligned}     p(x, y)=        &amp; \frac{1}{2 \pi \sigma_{1} \sigma_{2} \sqrt{1-\rho^{2}}} \exp \left\{-\frac{1}{2\left(1-\rho^{2}\right)}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}\right.\right.\\         &amp;-\frac{2 \rho\left(x-\mu_{1}\right)\left(y-\mu_{2}\right)}{\sigma_{1} \sigma_{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}} ] \} \end{aligned}\]</span></p><p>则称<span class="math inline">\((X,Y)\)</span>服从二维正态分布，记作： <span class="math display">\[(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\]</span></p><p>它含有五个参数<span class="math inline">\(\mu_1，\mu_2，\sigma_1^2，\sigma_2^2\)</span>和<span class="math inline">\(\rho\)</span>，取值范围分别为： <span class="math display">\[-\infty&lt;\mu_{1}&lt;\infty,-\infty&lt;\mu_{2}&lt;\infty, \sigma_{1}&gt;0, \sigma_{2}&gt;0,-1 \leqslant \rho \leqslant 1\]</span> 并且<span class="math inline">\(\mu_1，\mu_2\)</span>分别是<span class="math inline">\(X、Y\)</span>的期望；<span class="math inline">\(\sigma_1^2，\sigma_2^2\)</span>分别是<span class="math inline">\(X、Y\)</span>的方差；<span class="math inline">\(\rho\)</span>是<span class="math inline">\(X、Y\)</span>的相关系数。</p><h1 id="大数定律及中心极限定理">大数定律及中心极限定理</h1><h2 id="大数定律">大数定律</h2><h3 id="伯努利大数定律">伯努利大数定律</h3><p>整个概率论的得以存在的基础是，其所研究的随机现象虽然结果不确定，但又有规律可循。这个基础在概率论中被称为大数定律（Law of large numbers）。大数定律是一系列的定律，先来介绍伯努利大数定律：</p><p>设<span class="math inline">\(n_A\)</span>是<span class="math inline">\(n\)</span>次重复独立实验中事件<span class="math inline">\(A\)</span>发生的次数，<span class="math inline">\(p\)</span>是事件<span class="math inline">\(A\)</span>在每次实验中发生的概率，则对于任意正数<span class="math inline">\(\epsilon &gt; 0\)</span>，有： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\frac{n_\text{A}}{n}-p\right| &lt; \epsilon \right) = 1\]</span></p><p>或： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\frac{n_\text{A}}{n}-p\right| \ge \epsilon \right) = 0\]</span></p><p>这里需要注意不能直接用： <span class="math display">\[\lim_{n\to \infty}\frac{n_\text{H}}{n}=p\]</span> 而必须在外面套上一个概率函数，<span class="math inline">\(\frac{n_\text{H}}{n}\)</span>并不是一个数列，而是随机变量。因此它不具备进行极限运算的前提。</p><h3 id="依概率收敛">依概率收敛</h3><p>因为<span class="math inline">\(\frac{n_\text{H}}{n}\)</span>是随机变量，所以要表示它和<span class="math inline">\(p\)</span>接近，只能表示为事件： <span class="math display">\[“频率 P_n 越来越接近概率 p”=\Big\{\left|\frac{n_\text{H}}{n}-p\right| &lt; \epsilon\Big\}\]</span> 然后套上概率函数<span class="math inline">\(P\)</span>，对该函数求<span class="math inline">\(n\)</span>趋于无穷时的极限： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\frac{n_\text{H}}{n}-p\right| &lt; \epsilon \right) = 1\]</span></p><p>这个极限同样表达了“随着<span class="math inline">\(n\)</span>的增大，频率<span class="math inline">\(P_n\)</span>会越来越接近概率<span class="math inline">\(p\)</span>”的意思，但是因为套上了概率函数，所以也称为<span class="math inline">\(P_n\)</span>依概率收敛于<span class="math inline">\(p\)</span>，记作： <span class="math display">\[\frac{n_\text{H}}{n}\xrightarrow{\quad P \quad}p,\quad n\to\infty\]</span></p><h3 id="辛钦大数定律">辛钦大数定律</h3><p>伯努利大数定律局限于伯努利分布，下面介绍辛钦大数定律就没有这个限制，只是要求遵循相同的分布： 设有随机变量： <span class="math display">\[X_1,X_2,\cdots,X_n\]</span> 这些随机变量相互独立，服从同一分布，且具有相同的数学期望： <span class="math display">\[E(X_i)=\mu,\quad i=1,2,\cdots,n\]</span> 令： <span class="math display">\[\overline{X}=\frac{X_1+X_2+\cdots+X_n}{n}\]</span> 则对于任意<span class="math inline">\(\epsilon &gt; 0\)</span>有： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\overline{X}-\mu\right| &lt; \epsilon \right) = 1\]</span> 或： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\overline{X}-\mu\right| \ge \epsilon \right) = 0\]</span> 也可以表述为： <span class="math display">\[\overline{X}\xrightarrow{\quad P \quad}\mu,\quad n\to\infty\]</span></p><h3 id="切比雪夫大数定律">切比雪夫大数定律</h3><p>相同的分布也算比较严格的限制，下面介绍切比雪夫大数定律对于分布就更加宽松，只要各自的方差有共同上界即可： 设有随机变量： <span class="math display">\[X_1,X_2,\cdots,X_n\]</span> 这些随机变量两两不相关，若每个随机变量<span class="math inline">\(X_i\)</span>的方差存在，且有共同的上界，即： <span class="math display">\[Var(X_i)\le c,\quad i=1,2,\cdots,n\]</span> 令： <span class="math display">\[\overline{X}=\frac{X_1+X_2+\cdots+X_n}{n},\quad \mu=E(\overline{X})\]</span> 则对于任意<span class="math inline">\(\epsilon &gt; 0\)</span>有： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\overline{X}-\mu\right| &lt; \epsilon \right) = 1\]</span> 或： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\overline{X}-\mu\right| \ge \epsilon \right) = 0\]</span> 也可以表述为： <span class="math display">\[\overline{X}\xrightarrow{\quad P \quad}\mu,\quad n\to\infty\]</span></p><h3 id="总结-2">总结</h3><p>这里总共介绍了三个大数定律，主要区别如下： <span class="math display">\[\begin{array}{c|c}    \hline    \quad \quad &amp;\quad 分布、quad&amp;\quad 独立性、quad&amp;\quad 方差、quad\\    \hline    \\    \quad 伯努利大数、quad &amp; \quad 伯努利分布、quad &amp; \quad 独立、quad &amp; \quad 无要求、quad\\    辛钦大数 &amp; 同分布 &amp; 独立 &amp; 无要求 \\    切比雪夫大数 &amp; 无要求 &amp; 不相关 &amp; 同上界、\    \\    \hline\end{array}\]</span></p><h3 id="强大数定律">强大数定律</h3><p>前面介绍的大数定律又称为弱大数定律（Weak Law of large numbers），有弱就自然就有强，下面就来介绍强大数定律（Strong Law of large numbers）： 设有随机变量： <span class="math display">\[X_1,X_2,\cdots,X_n\]</span> 这些随机变量相互独立，服从同一分布，且具有相同的数学期望： <span class="math display">\[E(X_i)=\mu,\quad i=1,2,\cdots,n\]</span> 令： <span class="math display">\[\overline{X}=\frac{X_1+X_2+\cdots+X_n}{n}\]</span> 则对于任意<span class="math inline">\(\epsilon &gt; 0\)</span>有： <span class="math display">\[P\left(\lim_{n\to \infty}\left|\overline{X}-\mu\right| &lt; \epsilon \right) = 1\]</span> 或： <span class="math display">\[P\left(\lim_{n\to \infty}\left|\overline{X}-\mu\right| \ge \epsilon \right) = 0\]</span></p><p>这个强大数定律和之前的辛钦大数定律非常接近：</p><ul><li><p>弱大数定律（辛钦大数定律），极限符号在 P 函数外面： <span class="math display">\[\lim_{n\to \infty}P\left(\left|\overline{X}-\mu\right| &lt; \epsilon \right) = 1\]</span></p></li><li><p>强大数定律，极限符号在 P 函数里面： <span class="math display">\[P\left(\lim_{n\to \infty}\left|\overline{X}-\mu\right| &lt; \epsilon \right) = 1\]</span> 仔细体会这两则之间的区别^ _ ^。</p></li></ul><h2 id="中心极限定理">中心极限定理</h2><h3 id="棣莫弗-拉普拉斯定理">棣莫弗-拉普拉斯定理</h3><p>设随机变量<span class="math inline">\(X\sim b(n,p)\)</span>，则对任意 x 有： <span class="math display">\[\lim_{n\to\infty}P\left(\frac{X-np}{\sqrt{np(1-p)}}\le x\right)=\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{-\frac{t^2}{2}}\mathrm{d}t\]</span></p><h3 id="林德伯格-莱维定理">林德伯格-莱维定理</h3><p>设随机变量： <span class="math display">\[X_i,\quad i=1,2,\cdots,n\]</span> 相互独立，服从同一分布，且有相同的数学期望和方差： <span class="math display">\[E(X_i)=\mu,\quad Var(X_i)=\sigma^2\]</span> 则随机变量： <span class="math display">\[Y=\frac{X_1+X_2+\cdots+X_n-n\mu}{\sigma\sqrt{n}}\]</span> 对于任意实数<span class="math inline">\(y\)</span>有： <span class="math display">\[\lim_{n\to\infty}F_Y(y)=\lim_{n\to\infty}P(Y\le y)=\Phi(y)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{y}e^{-\frac{t^2}{2}}\mathrm{d}t\]</span></p><h1 id="参考文献">参考文献</h1><p>《马同学的概率论与数理统计》<br>感兴趣的可以购买他的课程，写的很好（强烈推荐）！！！</p>]]></content>
      
      
      <categories>
          
          <category> Science Thought </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/next/2022/Science/linearAlgebra/"/>
      <url>/next/2022/Science/linearAlgebra/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/LinearAlgebra.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjFlMWQzMzYzNzY4OTIxMjI5OWQ5ZTY=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="向量空间">向量空间</h1><h2 id="向量">向量</h2><p>n 个有序的数<span class="math inline">\(a_1,a_2,...,a_n\)</span>所组成的数组称为<span class="math inline">\(n\)</span> 维向量，这<span class="math inline">\(n\)</span>个数称为该向量的<span class="math inline">\(n\)</span>个分量，第<span class="math inline">\(i\)</span>个数<span class="math inline">\(a_i\)</span>称为第<span class="math inline">\(i\)</span>个分量。<span class="math inline">\(n\)</span>维向量可写成一行，也可写成一列。分别称为行向量和列向量：</p><ul><li>n 维列向量：</li></ul><p><span class="math display">\[\begin{pmatrix}a_1\\a_2\\\vdots\\a_n\end{pmatrix}\]</span></p><ul><li>与 n 维行向量：</li></ul><p><span class="math display">\[(a_1,a_2,...,a_n)\quad 或、quad \begin{pmatrix}a_1&amp;a_2&amp;\cdots&amp;a_n\end{pmatrix}\]</span></p><p><span class="math inline">\(n\)</span>也称为该向量的维数。</p><h2 id="向量的基本运算法则">向量的基本运算法则</h2><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 加法、quad &amp; \quad\begin{aligned} 交换律、\ 结合律 \end{aligned}\quad &amp; \quad\begin{aligned}\boldsymbol{v}+\boldsymbol{u}=\boldsymbol{u}+\boldsymbol{v}\qquad\quad\\ \boldsymbol{u}+\boldsymbol{v}+\boldsymbol{w}=\boldsymbol{u}+(\boldsymbol{v}+\boldsymbol{w}) \end{aligned}\quad\\    \\    \hline    \\    \quad 数乘、quad &amp; \quad\begin{aligned} 交换律、\ 结合律、\分配律 \end{aligned}\quad &amp; \quad\begin{aligned}k\cdot\boldsymbol{u}=\boldsymbol{u}\cdot k\qquad\ \ \\ k\cdot m\cdot\boldsymbol{u}=k\cdot(m\cdot\boldsymbol{u})\\k(\boldsymbol{u}+\boldsymbol{v})=k\boldsymbol{u}+k\boldsymbol{v}\ \  \end{aligned}\quad\\    \\    \hline\end{array}\]</span></p><h2 id="线性组合">线性组合</h2><ul><li><p>向量组： 若干同维数的列向量（或者同维数的行向量）所组成的集合，叫做向量组。比如同维数 的向量<span class="math inline">\(\boldsymbol{a_1},\boldsymbol{a_2},...\boldsymbol{a_m}\)</span>，可 以组成向量组<span class="math inline">\(\mathcal{A}\)</span>，通常记作：</p><p><span class="math display">\[  \mathcal{A}:\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol   {a_m}\quad 或、quad \mathcal{A}=\{\boldsymbol{a_1},\boldsymbol  {a_2},...,\boldsymbol{a_m}\}  \]</span></p></li><li><p>线性相关： 给定向量组<span class="math inline">\(\mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},..., \boldsymbol{a_m}\}\)</span>和向量<span class="math inline">\(\boldsymbol{b_{}}\)</span>，如果存在一组实数<span class="math inline">\(k_1, k_2,...k_m\)</span>，使：</p><p><span class="math display">\[  \boldsymbol{b_{}}=k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+...   +k_m\boldsymbol{a_m}  \]</span></p><p>则称向量<span class="math inline">\(\boldsymbol{b_{}}\)</span>能由向量组<span class="math inline">\(\mathcal{A}\)</span> 线性表示，或称向量 <span class="math inline">\(\boldsymbol{b_{}}\)</span>是向量组<span class="math inline">\(\mathcal{A}\)</span>的线性组合。</p></li><li><p>线性相关和线性无关： 给定向量组<span class="math inline">\(\mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},..., \boldsymbol{a_m}\}\)</span>，如果存在不全为零的实数<span class="math inline">\(k_1,k_2,...k_m\)</span>，使：</p><p><span class="math display">\[  k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+...+k_m\boldsymbol{a_m} =\boldsymbol{0}  \]</span></p><p>则称向量组<span class="math inline">\(\mathcal{A}\)</span>是线性相关的，否则称它为线性无关。</p></li></ul><h2 id="向量空间-1">向量空间</h2><p>设<span class="math inline">\(\mathcal{V}\)</span>为一向量组，如果<span class="math inline">\(\mathcal{V}\)</span>非空，且<span class="math inline">\(\mathcal{V}\)</span>对于向量的加法及数乘两种运算封闭，那么就称<span class="math inline">\(\mathcal{V}\)</span>为向量空间。</p><p>所谓封闭，是指在<span class="math inline">\(\mathcal{V}\)</span>中向量进行数乘和加减，其结果依然在<span class="math inline">\(\mathcal{V}\)</span>中。具体的说，就是：</p><ul><li>若<span class="math inline">\(\boldsymbol{a}\in \mathcal{V},\boldsymbol{b}\in \mathcal{V}\)</span>，则<span class="math inline">\(\boldsymbol{a}+\boldsymbol{b} \in \mathcal{V}\)</span>。</li><li>若<span class="math inline">\(\boldsymbol{a}\in \mathcal{V},k\in \mathbb{R}\)</span>，则<span class="math inline">\(k\boldsymbol{a} \in \mathcal{V}\)</span>。</li></ul><h2 id="张成空间">张成空间</h2><h3 id="张成空间的定义">张成空间的定义</h3><p>某向量组<span class="math inline">\(\mathcal{A}=\{\boldsymbol{v_1},\boldsymbol{v_2},...,\boldsymbol{v_p}\}\)</span>，其所有线性组合构成的集合为向量空间，也称为向量组<span class="math inline">\(\mathcal{A}\)</span>的张成空间，记为<span class="math inline">\(span(\boldsymbol{v_1},\boldsymbol{v_2},...,\boldsymbol{v_p})\)</span>，即：</p><p><span class="math display">\[span(\boldsymbol{v_1},\boldsymbol{v_2},...,\boldsymbol{v_p})=\{k_1\boldsymbol{v_1}+k_2\boldsymbol{v_2}+...+k_p\boldsymbol{v_p},k_{1,2,...,p}\in\mathbb{R}\}\]</span></p><p>也称<span class="math inline">\(span(\boldsymbol{v_1},\boldsymbol{v_2},...,\boldsymbol{v_p})\)</span>为向量组<span class="math inline">\(\mathcal{A}\)</span>所张成。</p><h3 id="等价向量组">等价向量组</h3><p>设有两个向量组<span class="math inline">\(\mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_m}\}\)</span>及<span class="math inline">\(\mathcal{B}=\{\boldsymbol{b_1},\boldsymbol{b_2},...,\boldsymbol{b_n}\}\)</span>，若向量组<span class="math inline">\(\mathcal{B}\)</span>中的每个向量都能由向量组<span class="math inline">\(\mathcal{A}\)</span>线性表示，则称向量组<span class="math inline">\(\mathcal{B}\)</span>能由向量组<span class="math inline">\(\mathcal{A}\)</span>线性表示。</p><p>若向量组<span class="math inline">\(\mathcal{A}\)</span>与向量组<span class="math inline">\(\mathcal{B}\)</span>能相互线性表示，则称这两个向量组等价，也可以说<span class="math inline">\(\mathcal{A}\)</span>和<span class="math inline">\(\mathcal{B}\)</span>是等价向量组。</p><h3 id="最大无关组">最大无关组</h3><p>设有向量组<span class="math inline">\(\mathcal{A}\)</span>，如果在<span class="math inline">\(\mathcal{A}\)</span>中能选出<span class="math inline">\(r\)</span>个向量<span class="math inline">\(\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_r}\)</span>满足：</p><ul><li>向量组<span class="math inline">\(\mathcal{A}_0=\{\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_r}\}\)</span>线性无关。</li><li>向量组<span class="math inline">\(\mathcal{A}\)</span>中任意<span class="math inline">\(r+1\)</span>个向量（如果<span class="math inline">\(\mathcal{A}\)</span>中有<span class="math inline">\(r+1\)</span>个向量的话）都线性相关，那么称向量组<span class="math inline">\(\mathcal{A}_0\)</span>是向量组<span class="math inline">\(\mathcal{A}\)</span>的一个最大线性无关组，简称最大无关组。</li></ul><h3 id="向量组的秩">向量组的秩</h3><p>假设向量组<span class="math inline">\(A\)</span>的最大无关组为： <span class="math display">\[\mathcal{A}_0=\{a_1,a_2,\cdots,a_r\}\]</span></p><p><span class="math inline">\(\mathcal{A}_0\)</span>的向量个数<span class="math inline">\(r\)</span>称为向量组<span class="math inline">\(\mathcal{A}\)</span>的秩，记做<span class="math inline">\(rank(\mathcal{A})\)</span>，有时也记作<span class="math inline">\(r(\mathcal{A})\)</span>。</p><h2 id="向量空间的基">向量空间的基</h2><ul><li><p>基： 已知<span class="math inline">\(\mathcal{V}\)</span>为向量空间，如果其中的某向量组：</p><p><span class="math display">\[  \mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},...\boldsymbol  {a_n}\}  \]</span></p><p>是<span class="math inline">\(\mathcal{V}\)</span>的最大无关组，那么向量组<span class="math inline">\(\mathcal{A}\)</span>被称为向量空间 <span class="math inline">\(\mathcal{V}\)</span>的一个基。</p></li><li><p>坐标： 假设<span class="math inline">\(\mathcal{A}=\{\boldsymbol{a_1},\boldsymbol{a_2},...,\boldsymbol{a_n}\}\)</span>是向量空间<span class="math inline">\(\mathcal{V}\)</span>的一个基，则<span class="math inline">\(\mathcal{V}\)</span>中每个向量<span class="math inline">\(\boldsymbol{x}\)</span>可唯一地表示为： <span class="math display">\[  \boldsymbol{x}=k_1\boldsymbol{a_1}+k_2\boldsymbol{a_2}+\cdots  +k_n\boldsymbol{a_n}  \]</span> 上式的系数可以组成向量： <span class="math display">\[  [\boldsymbol{x}]_\mathcal{A}=\begin{pmatrix}k_1\\k_2\\\vdots\\k_n\end{pmatrix}  \]</span> 我们将其称为<span class="math inline">\(\boldsymbol{x}\)</span>在基<span class="math inline">\(\mathcal{A}\)</span>下的坐标向量，或者简称为<span class="math inline">\(\boldsymbol{x}\)</span>在基<span class="math inline">\(\mathcal{A}\)</span>下的坐标。</p></li><li><p>维度： 假设向量空间<span class="math inline">\(\mathcal{V}\)</span>的基为： <span class="math display">\[  \mathcal{A}=\{a_1,a_2,\cdots,a_r\}  \]</span> 则<span class="math inline">\(\mathcal{A}\)</span>的秩<span class="math inline">\(r\)</span>称为该向量空间的维度，或者称<span class="math inline">\(\mathcal{V}\)</span>为<span class="math inline">\(r\)</span>维向量空间。</p></li></ul><h2 id="数量积点积">数量积（点积）</h2><h3 id="点积的定义">点积的定义</h3><p>向量<span class="math inline">\(\boldsymbol{x}=\begin{pmatrix}x_1\\\vdots\\x_n\end{pmatrix}\)</span>和 <span class="math inline">\(\boldsymbol{y}=\begin{pmatrix}y_1\\\vdots\\y_n\end{pmatrix}\)</span>的点积<span class="math inline">\((dot product)\)</span>，或称内积<span class="math inline">\((inner product)\)</span>，定义为：</p><p><span class="math display">\[\boldsymbol{x}\cdot\boldsymbol{y}=x_1y_1+\cdots+x_ny_n=\displaystyle\sum_{i=1}^{n}x_iy_i\]</span></p><p>点积还可以称为数量积或者标量积，这是因为两个向量通过点积运算之后的结果是数量（标量）。</p><h3 id="点积的性质">点积的性质</h3><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 交换律、quad&amp;\quad \boldsymbol{a}\cdot\boldsymbol{b}=\boldsymbol{b}\cdot\boldsymbol{a}\quad\\    \quad 数乘结合律、quad&amp;\quad (k\boldsymbol{a})\cdot\boldsymbol{b}=k(\boldsymbol{b}\cdot\boldsymbol{a})\quad\\    \quad 分配律、quad&amp;\quad (\boldsymbol{a}+\boldsymbol{b})\cdot\boldsymbol{c}=\boldsymbol{a}\cdot\boldsymbol{c}+\boldsymbol{b}\cdot\boldsymbol{c}\quad\\    \\    \hline\end{array}\]</span></p><h1 id="矩阵和矩阵运算">矩阵和矩阵运算</h1><h2 id="矩阵的定义">矩阵的定义</h2><p>由<span class="math inline">\(m\times n\)</span>个数<span class="math inline">\(a_{ij}(i=1,2,...m;j=1,2...n)\)</span>排成的<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列的数表称为<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列矩阵<span class="math inline">\(（Matrix）\)</span>，简称<span class="math inline">\(m\times n\)</span>矩阵。为表示这些数字是一个整体，总是加一个括弧，下面就表示了矩阵<span class="math inline">\(A\)</span>：</p><p><span class="math display">\[A=\underbrace{\begin{pmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\...&amp;...&amp;&amp;...\\a_{m1}&amp;a_{m2}&amp;...&amp;a_{mn}\end{pmatrix}}_{\large n 列}\left.\begin{aligned}\\\\\\\\\end{aligned}\right\}m 行\]</span></p><p>可以用<span class="math inline">\(a_{ij}\)</span>或<span class="math inline">\(a_{i,j}\)</span>来表示该矩阵<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列的数字，刚才的矩阵还可以简记为：</p><p><span class="math display">\[A=(a_{ij})=(a_{i,j})\]</span></p><p>为了表示矩阵的行数和列数，<span class="math inline">\(m\times n\)</span>矩阵<span class="math inline">\(A\)</span>也记作<span class="math inline">\(A_{m\times n}\)</span>。</p><h2 id="高斯消元法">高斯消元法</h2><ul><li>行阶梯形矩阵： 非零矩阵若满足：<ul><li>非零行在零行（如果存在的话）的上面</li><li>非零行最左边的首非零元素在上一行（如果存在的话）的首非零元素的右面</li></ul><p>所以称为行阶梯形矩阵（Row echelon form），非零行最左边的首非零元素称为主元（Pivot element）。</p></li><li><p>对角矩阵： 若 n 阶方阵如下： <span class="math display">\[  \Lambda_{n}=\begin{pmatrix}\lambda_1&amp;0&amp;...&amp;0\\0&amp;\lambda_2&amp;...&amp;0\\...&amp;...&amp;&amp;...\\  0&amp;0&amp;...&amp;\lambda_n\end{pmatrix}  \]</span> 对角线以外的元素都是 0，这种方阵称为对角矩阵（Diagonal matrix），简称对角阵，也记作： <span class="math display">\[  \Lambda_{n}=diag(\lambda_1,\lambda_2,...,\lambda_n)  \]</span></p></li><li><p>单位阵： 如果 n 阶对角阵的对角线上的元素全为 1： <span class="math display">\[  I_n=\begin{pmatrix}1&amp;0&amp;...&amp;0\\0&amp;1&amp;...&amp;0\\...&amp;...&amp;&amp;...\\  0&amp;0&amp;...&amp;1\end{pmatrix}  \]</span> 该对角阵称为 n 阶单位矩阵（Identity matrix），或者简称为单位阵。在国内教材中，单位阵一般用 E 表示。</p></li><li>行最简形矩阵： 若 A 是行阶梯形矩阵，并且还满足：<ul><li>主元为 1</li><li>除主元外，其所在列的其它元素均为 0</li></ul><p>则称 A 为行最简形矩阵（Reduced row echelon form）.</p></li><li><p>初等行变换和初等行矩阵： 完成高斯消元法只需要三种操作，这三种操作是作用在矩阵的行上的，所以又称为初等行变换（Elementary row operations）。在单位阵上应用这三种初等行变换一次得到的矩阵称为初等行矩阵（Elementary row matrix），也就是下列表格中最右的矩阵： <span class="math display">\[  \begin{array}{c|c|c}      \hline      \quad 初等行变换、quad &amp;\quad 操作、quad &amp;\quad 初等行矩阵、quad\\      \hline      \\      \quad \begin{aligned}\color{SkyBlue}{倍加变换}  \qquad\qquad\quad\\\text{row-addition transformations}\end    {aligned}\quad &amp;\quad \boldsymbol{r_1}'=\boldsymbol{r_1}    +k\boldsymbol{r_2}\quad &amp;\quad \begin{pmatrix}1&amp;{\color{red}    {k}}&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{pmatrix}\quad      \\      \hline      \\      \quad \begin{aligned}\color{Goldenrod}{倍乘变换}    \qquad\qquad\quad\\\text{row-multiplying transformations}   \end{aligned}\quad &amp;\quad \boldsymbol{r_1}'=k\boldsymbol   {r_1} (k\neq 0)\quad &amp;      \quad \begin{pmatrix}{\color{red}{k}}&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end {pmatrix}\quad \\      \\      \hline      \\      \quad \begin{aligned}\color{orange}{对换变换}   \qquad\qquad\quad\\\text{row-switching transformations}\end    {aligned}\quad &amp;\quad \boldsymbol{r_1}\leftrightarrow   \boldsymbol{r_2}\quad &amp;      \quad \begin{pmatrix}{\color{red}{0}}&amp;{\color{red}{1}}&amp; {\color{red}{0}}\\      {\color{red}{1}}&amp;{\color{red}{0}}&amp;{\color{red}{0}}\\0&amp;0&amp;    1\end{pmatrix}\quad \\      \\      \hline  \end{array}  \]</span></p><p>初等行矩阵乘上矩阵 A，就相当于在矩阵 A 上实施了对应的初等行变换。</p></li></ul><h2 id="矩阵的加法与乘法">矩阵的加法与乘法</h2><p>两个矩阵的行数相等、列数也相等时，就称它们是同型矩阵。</p><ul><li><p>加法： 设有两个<span class="math inline">\(m\times n\)</span>矩阵<span class="math inline">\(A=(a_{ij})\)</span>和<span class="math inline">\(B=(b_{ij})\)</span>，那么矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的和记做<span class="math inline">\(A+B\)</span>，规定为： <span class="math display">\[  A+B=\begin{pmatrix}a_{11}+b_{11}&amp;a_{12}+b_{12}&amp;...&amp;a_{1n}+b_{1n}\\a_{21}+b_{21}&amp;a_{22}+b_{22}&amp;...&amp;a_{2n}+b_{2n}\\  ...&amp;...&amp;&amp;...\\a_{m1}+b_{m1}&amp;a_{m2}+b_{m2}&amp;...&amp;a_{mn}+b_{mn}\end{pmatrix}  \]</span></p></li><li><p>矩阵加法运算规律： <span class="math display">\[  \begin{array}{c|c}      \hline      \\      \quad 交换律、quad&amp;\quad A+B=B+A\quad\\      \quad 结合律、quad&amp;\quad (A+B)+C=A+(B+C)\quad\\      \\      \hline  \end{array}  \]</span></p></li><li><p>矩阵数乘： 数<span class="math inline">\(k\)</span>与矩阵<span class="math inline">\(A\)</span>的乘积记作： <span class="math display">\[  kA\quad 或、quad Ak  \]</span> 规定为： <span class="math display">\[  kA=Ak=  \begin{pmatrix}      ka_{11}&amp;ka_{12}&amp;\cdots&amp;ka_{1n}\\      ka_{21}&amp;ka_{22}&amp;\cdots&amp;ka_{2n}\\      \cdots&amp;\cdots&amp; &amp;\cdots\\      ka_{m1}&amp;ka_{m2}&amp;\cdots&amp;ka_{mn}\end{pmatrix}  \]</span></p></li><li><p>数乘的运算规律： <span class="math display">\[  \begin{array}{c|c}      \hline      \\      \quad 结合律、quad&amp;\quad (\lambda\mu) A=\lambda(\mu A)\quad\\      \\      \quad 分配律、quad&amp;\quad \begin{aligned}(\lambda+\mu)    A=\lambda A+\mu A\\\lambda(A+B)=\lambda A+\lambda B\end    {aligned}\quad\\      \\      \hline  \end{array}  \]</span></p></li><li><p>矩阵乘法的定义： 设<span class="math inline">\(A=(a_{ij})\)</span>是一个<span class="math inline">\(m\times s\)</span>矩阵，<span class="math inline">\(B=(b_{ij})\)</span>是一个<span class="math inline">\(s\times n\)</span>矩阵，那么规定<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>的乘积是一个<span class="math inline">\(m\times n\)</span>矩阵<span class="math inline">\(C=(c_{ij})\)</span>，其中： <span class="math display">\[     c_{ij}=\boldsymbol{a}_{i*}\cdot\boldsymbol{b}_{*j}=a_{i1}b_{1j} +a_{i2}b_{2j}+...+a_{is}b_{sj}=\displaystyle \sum_{k=1}^s a_{ik} b_{kj}  (i=1,\cdots,m;j=1,\cdots,n)  \]</span> 并把乘积记作： <span class="math display">\[  C=AB  \]</span></p></li><li><p>矩阵乘法运算规律： <span class="math display">\[  \begin{array}{c|c}      \hline      \\      \quad 交换律、quad&amp;\quad 不一定满足、quad\\      \quad 数乘交换律、quad&amp;\quad \lambda(AB)=(\lambda A)B=A  (\lambda B)（其中、lambda 是数）\quad\\      \quad 结合律、quad&amp;\quad (AB)C=A(BC)\quad\\      \quad 分配律、quad&amp;\quad A(B+C)=AB+AC\quad\\      \\      \hline  \end{array}  \]</span></p></li></ul><h2 id="矩阵的幂与转置">矩阵的幂与转置</h2><p>类似于<span class="math inline">\(x^n\)</span>称为<span class="math inline">\(x\)</span>的幂运算，矩阵也有幂运算，也称为矩阵的幂： 设<span class="math inline">\(A\)</span>是方阵，定义：</p><p><span class="math display">\[A^1=A,\quad A^2=A^1A^1,\quad\cdots,\quad A^{k+1}=A^kA^1\]</span></p><p>其中 k 为正整数。</p><ul><li><p>矩阵的转置： 把矩阵<span class="math inline">\(A\)</span>的行换成同序数的列，该操作称为矩阵的转置运算。转置运算后可以得到一个新矩阵，该矩阵称为 A 的转置矩阵，记作<span class="math inline">\(A^\mathrm{T}\)</span>。或者用符号表示如下： <span class="math display">\[  A=(a_{ij}),\quad A^\mathrm{T}=(a_{ji})  \]</span></p></li><li><p>转置的性质： <span class="math display">\[ (A^\mathrm{T})^\mathrm{T}=A \]</span> (AB)<sup>=B</sup>A<sup> <span class="math display">\[ (A^\mathrm{T})^n=(A^n)^\mathrm{T} \]</span> (A+B)</sup>=A<sup>+B</sup> <span class="math display">\[ 对于两个同维向量$\boldsymbol{x}$和$\boldsymbol{y}$，有： \]</span> ^=() $$</p></li><li><p>对称矩阵与反对称矩阵： 若： <span class="math display">\[  A^T=A  \]</span> 则矩阵 A 称为对称矩阵。</p><p>若： <span class="math display">\[  A^T=-A  \]</span> 则矩阵 A 称为反对称矩阵。</p></li></ul><h2 id="矩阵函数">矩阵函数</h2><p>其实，任给一个 RGB 都可以如上转为对应的<span class="math inline">\(YP_rP_b\)</span>。为了表明这一点，我们用未知向量<span class="math inline">\(\boldsymbol{x}、\boldsymbol{y}\)</span>来替换常向量<span class="math inline">\(\boldsymbol{a}、\boldsymbol{b}\)</span>：</p><p><span class="math display">\[\underbrace{\begin{pmatrix}0.299&amp;0.587&amp;0.114\\0.5&amp;-0.418688&amp;-0.081312\\-0.168736&amp;-0.331264&amp;0.5\end{pmatrix}}_{\large \boldsymbol{A}}\ \underbrace{\begin{pmatrix}R\\G\\B\end{pmatrix}}_{\large \boldsymbol{x}}\ =\ \underbrace{\begin{pmatrix}Y\\P_r\\P_b\end{pmatrix}}_{\large \boldsymbol{y}}\]</span></p><p>这样就得到了函数<span class="math inline">\(\boldsymbol{A}\boldsymbol{x}=\boldsymbol{y}（）\)</span>，也称为矩阵函数，其输入为<span class="math inline">\(\boldsymbol{x}\)</span>，输出为<span class="math inline">\(\boldsymbol{y}\)</span>：</p><h2 id="矩阵函数的性质">矩阵函数的性质</h2><p><span class="math display">\[\begin{array}{c|c}    \hline    \\    \quad 交换律、quad&amp;\quad 不一定满足、quad\\    \quad 数乘交换律、quad&amp;\quad \lambda(AB)=(\lambda A)B=A(\lambda B)（其中、lambda 是数）\quad\\    \quad 结合律、quad&amp;\quad (AB)C=A(BC)\quad\\    \quad 分配律、quad&amp;\quad A(B+C)=AB+AC\quad\\    \\    \hline\end{array}\]</span></p><h1 id="矩阵的秩">矩阵的秩</h1><h2 id="行秩和列秩">行秩和列秩</h2><h3 id="列空间">列空间</h3><p>矩阵 A 的列向量为：</p><p><span class="math display">\[A=\begin{pmatrix}    {\color{green}{a_{11}}}&amp;{\color{blue}{a_{12}}}&amp;\cdots&amp;{\color{purple}{a_{1n}}}\\    {\color{green}{a_{21}}}&amp;{\color{blue}{a_{22}}}&amp;\cdots&amp;{\color{purple}{a_{2n}}}\\    \vdots&amp;\vdots&amp;\quad&amp;\vdots\\    {\color{green}{a_{m1}}}&amp;{\color{blue}{a_{m2}}}&amp;\cdots&amp;{\color{purple}{a_{mn}}}\end{pmatrix}=({\color{green}{\boldsymbol{c_1}}},{\color{blue}{\boldsymbol{c_2}}},\cdots,{\color{purple}{\boldsymbol{c_n}}})\]</span></p><p>包含所有列向量的向量组称为列向量组，即：</p><p><span class="math display">\[列向量组：\{\boldsymbol{c_1},\boldsymbol{c_2},\cdots,\boldsymbol{c_n}\}\]</span></p><p>列向量组的张成空间称为列空间，记作<span class="math inline">\(colsp(A)\)</span>，即：</p><p><span class="math display">\[\begin{aligned}    colsp(A)        &amp;=span(\{\boldsymbol{c_1},\boldsymbol{c_2},\cdots,\boldsymbol{c_n}\})\\        &amp;=x_1\boldsymbol{c_1}+x_2\boldsymbol{c_2}+\cdots+x_n\boldsymbol{c_n},\quad x_{1,2,\cdots,n}\in\mathbb{R}\end{aligned}\]</span></p><p>列向量组的秩，也就是列空间的维度，称为列秩，即：</p><p><span class="math display">\[列秩=rank(colsp(A))\]</span></p><p>如果列向量组线性无关，就称为列满秩。</p><h3 id="行空间">行空间</h3><p>矩阵 A 的行向量为：</p><p><span class="math display">\[A=\begin{pmatrix}    {\color{green}{a_{11}}}&amp;{\color{green}{a_{12}}}&amp;\cdots&amp;{\color{green}{a_{1n}}}\\    {\color{blue}{a_{21}}}&amp;{\color{blue}{a_{22}}}&amp;\cdots&amp;{\color{blue}{a_{2n}}}\\    \vdots&amp;\vdots&amp;\quad&amp;\vdots\\    {\color{purple}{a_{m1}}}&amp;{\color{purple}{a_{m2}}}&amp;\cdots&amp;{\color{purple}{a_{mn}}}\end{pmatrix}=\begin{pmatrix}{\color{green}{\boldsymbol{r_1}^\mathrm{T}}}\\{\color{blue}{\boldsymbol{r_2}^\mathrm{T}}}\\\vdots\\{\color{purple}{\boldsymbol{r_m}^\mathrm{T}}}\end{pmatrix}\]</span></p><p>包含所有行向量的向量组称为行向量组，即：</p><p><span class="math display">\[行向量组：\{\boldsymbol{r_1}^\mathrm{T},\boldsymbol{r_2}^\mathrm{T},\cdots,\boldsymbol{r_m}^\mathrm{T}\}\]</span></p><p>行向量组的张成空间称为行空间，记作<span class="math inline">\(rowsp(A)\)</span>，即：</p><p><span class="math display">\[\begin{aligned}    rowsp(A)        &amp;=span(\{\boldsymbol{r_1}^\mathrm{T},\boldsymbol{r_2}^\mathrm{T},\cdots,\boldsymbol{r_m}^\mathrm{T}\})\\        &amp;=x_1\boldsymbol{r_1}^\mathrm{T}+x_2\boldsymbol{r_2}^\mathrm{T}+\cdots+x_m\boldsymbol{r_m}^\mathrm{T},\quad x_{1,2,\cdots,m}\in\mathbb{R}\end{aligned}\]</span></p><p>行向量组的秩，也就是行空间的维度，称为行秩，即：</p><p><span class="math display">\[行秩=rank(rowsp(A))\]</span></p><p>如果行向量组线性无关，就称为行满秩。</p><h2 id="秩">秩</h2><ul><li><p>矩阵的秩的定义： 对于任意矩阵，始终有列秩等于行秩，所以统称为矩阵的秩，即： <span class="math display">\[  矩阵的秩=列秩=行秩  \]</span></p><p>矩阵 A 的秩记作<span class="math inline">\(rank(A)\)</span>，有时也简写为<span class="math inline">\(r(A)\)</span>。</p></li><li><p>秩的几何意义： 根据自然定义域下，矩阵函数的值域可知，在自然定义域下</p><ul><li>列向量矩阵函数<span class="math inline">\(A\boldsymbol{x}=\boldsymbol{y}\)</span>的值域的维度是列秩</li><li>行向量矩阵函数<span class="math inline">\(\boldsymbol{x}^\mathrm{T}A=\boldsymbol{y}^\mathrm{T}\)</span>的值域的维度是行秩</li></ul><p>因为行秩=列秩=秩，所以当在自然定义域下时，秩就是矩阵函数的值域的维度。下面来看几个例子。</p></li><li><p>满秩： 如果某个矩阵，既是列满秩，又是行满秩，那么就称该矩阵为满秩矩阵，或者简称为满秩。满秩矩阵必为方阵。</p></li><li>秩的性质：<ul><li><p>秩的取值范围： <span class="math display">\[  0\le rank(A_{m\times n})\le\min(m,n)  \]</span></p></li><li><p>转置矩阵的秩： <span class="math display">\[  rank(A)=rank(A^\mathrm{T})  \]</span></p></li><li><p>复合函数的秩： <span class="math display">\[  rank(AB)\leq\min\Big(rank(A),rank(B)\Big)  \]</span></p></li><li><p>满秩矩阵复合的秩。假设 P、Q 为满秩矩阵，那么： <span class="math display">\[  rank(PA)=rank(AQ)=rank(PAQ)=rank(A)  \]</span></p></li><li><p>矩阵相加的秩。假设 A、B 为同型矩阵，那么： <span class="math display">\[  rank(A+B)\le rank(A)+rank(B)  \]</span></p></li></ul></li></ul><h2 id="逆矩阵">逆矩阵</h2><h3 id="逆矩阵的定义">逆矩阵的定义</h3><p>若存在两个<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(\boldsymbol{A}、\boldsymbol{C}\)</span>，两者的乘积为<span class="math inline">\(n\)</span>阶单位阵<span class="math inline">\(\boldsymbol{I}\)</span>：</p><p><span class="math display">\[\boldsymbol{A}\boldsymbol{C}=\boldsymbol{I}\qquad 且、qquad \boldsymbol{C}\boldsymbol{A}=\boldsymbol{I}\]</span></p><p>那么<span class="math inline">\(\boldsymbol{C}\)</span>就是<span class="math inline">\(\boldsymbol{A}\)</span>的逆矩阵，即有<span class="math inline">\(\boldsymbol{A}^{-1}=\boldsymbol{C}\)</span>，且<span class="math inline">\(\boldsymbol{A}^{-1}\)</span>是唯一的。</p><p>如果可以通过一系列初等行矩阵<span class="math inline">\(\boldsymbol{E}_i\)</span>，将矩阵<span class="math inline">\(\boldsymbol{A}\)</span>变换成单位阵<span class="math inline">\(\boldsymbol{I}\)</span>，则<span class="math inline">\(\boldsymbol{A}\)</span>的逆矩阵就是这些初等行矩阵的乘积：</p><p><span class="math display">\[\underbrace{\boldsymbol{E}_1\boldsymbol{E}_2...\boldsymbol{E}_n}_{\boldsymbol{A}^{-1}}\boldsymbol{A}=\boldsymbol{I}\]</span></p><h3 id="逆矩阵的运算规律">逆矩阵的运算规律</h3><p>若<span class="math inline">\(\boldsymbol{A}\)</span>可逆，则<span class="math inline">\(\boldsymbol{A}^{-1}\)</span>也可逆，且：</p><p><span class="math display">\[(\boldsymbol{A}^{-1})^{-1}=\boldsymbol{A}\]</span></p><p>若<span class="math inline">\(\boldsymbol{A}\)</span>可逆，数<span class="math inline">\(\lambda\ne 0\)</span>，则<span class="math inline">\(\lambda\boldsymbol{A}\)</span>可逆，且：</p><p><span class="math display">\[(\lambda\boldsymbol{A})^{-1}=\frac{1}{\lambda}\boldsymbol{A}^{-1}\]</span></p><p>若<span class="math inline">\(\boldsymbol{A}、\boldsymbol{B}\)</span>为同阶方阵且均可逆，则<span class="math inline">\(\boldsymbol{A}\boldsymbol{B}\)</span>也可逆，且：</p><p><span class="math display">\[(\boldsymbol{A}\boldsymbol{B})^{-1}=\boldsymbol{B}^{-1}\boldsymbol{A}^{-1}\]</span></p><p>若<span class="math inline">\(\boldsymbol{A}\)</span>可逆，则<span class="math inline">\(\boldsymbol{A}^\mathrm{T}\)</span>也可逆，且：</p><p><span class="math display">\[(\boldsymbol{A}^\mathrm{T})^{-1}=(\boldsymbol{A}^{-1})^\mathrm{T}\]</span></p><h2 id="线性方程组的求解">线性方程组的求解</h2><ul><li>解的存在性 对于线性方程组<span class="math inline">\(\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}\)</span>，它的增广矩阵为<span class="math inline">\(\boldsymbol{B}=(\boldsymbol{A}\ |\ \boldsymbol{b_{}})\)</span>，那么：<ul><li>有解，当且仅当<span class="math inline">\(rank(\boldsymbol{A})=rank(\boldsymbol{B})\)</span></li><li>无解，当且仅当<span class="math inline">\(rank(\boldsymbol{A}) &lt; rank(\boldsymbol{B})\)</span></li></ul><p>行满秩矩阵一定有解</p></li><li>解的个数判别法： 对于线性方程组<span class="math inline">\(\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}\)</span>，它的增广矩阵为<span class="math inline">\(\boldsymbol{B}=(\boldsymbol{A}\ |\ \boldsymbol{b_{}})\)</span>，如果<span class="math inline">\(\boldsymbol{A}\)</span>为<span class="math inline">\(m\times n\)</span>的矩阵，那么：<ul><li>有唯一解，当且仅当<span class="math inline">\(rank(\boldsymbol{A})=rank(\boldsymbol{B})=n\)</span></li><li>有无数解，当且仅当<span class="math inline">\(rank(\boldsymbol{A})=rank(\boldsymbol{B})&lt;n\)</span></li></ul><p>满秩矩阵解有唯一解</p></li></ul><h1 id="行列式">行列式</h1><h2 id="行列式定义">行列式定义</h2><h3 id="二阶行列式">二阶行列式</h3><p>假设有二阶方阵<span class="math inline">\(\boldsymbol{A}=\begin{pmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{pmatrix}\)</span>，那么刚才定义的运算规则称为该二阶方阵<span class="math inline">\(\boldsymbol{A}\)</span>对应的行列式<span class="math inline">\(|\boldsymbol{A}|\)</span>，也称为二阶行列式：</p><p><span class="math display">\[|\boldsymbol{A}|=\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}\]</span></p><p>上述定义只要求<span class="math inline">\(\boldsymbol{A}\)</span>是方阵，不要求是满秩矩阵。</p><h3 id="三阶行列式">三阶行列式</h3><p>假设有三阶方阵<span class="math inline">\(\boldsymbol{A}=\begin{pmatrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{pmatrix}\)</span>，那么刚才定义的运算规则称为该三阶方阵<span class="math inline">\(\boldsymbol{A}\)</span>对应的行列式<span class="math inline">\(|\boldsymbol{A}|\)</span>，也称为三阶行列式：</p><p><span class="math display">\[\begin{aligned}    |\boldsymbol{A}|        &amp;=\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}\\        &amp;=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}\end{aligned}\]</span></p><p>上述定义也只要求、boldsymbol{A}是方阵，不要求是满秩矩阵。</p><h3 id="全排列">全排列</h3><p>把 n 个不同的元素排成一列，叫做这 n 个元素的全排列。</p><h3 id="逆序数">逆序数</h3><p>在一个排列（也就是数列）中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为该排列的逆序数。逆序数为奇数的排列称为奇排列，逆序数为偶数的排列称为偶排列。</p><h3 id="行列式定义-1">行列式定义</h3><p>对于<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(\boldsymbol{A}=(a_{ij})\)</span>，其行列式定义为：</p><p><span class="math display">\[    |\boldsymbol{A}|=|a_{ij}|=\begin{vmatrix}        a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\        a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\        \vdots&amp;\vdots&amp;\quad&amp;\vdots\\        a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}    \end{vmatrix}=\sum(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}\]</span></p><p>其中，<span class="math inline">\(t\)</span>为排列<span class="math inline">\(p_1p_2\cdots p_n\)</span>的逆序数，<span class="math inline">\(\sum\)</span>表示对<span class="math inline">\(“1,2,\cdots,n”\)</span>的全排列<span class="math inline">\(“p_1p_2\cdots p_n”\)</span>求和。</p><h2 id="向量积">向量积</h2><p>向量积<span class="math inline">\(\boldsymbol{S}\)</span>投影到了各个平面：</p><p><span class="math display">\[\boldsymbol{S}\xrightarrow{\quad 投影、quad}\begin{cases}    \boldsymbol{S_{xoy}}\\    \boldsymbol{S_{yoz}}\\    \boldsymbol{S_{zox}}\end{cases}\]</span></p><p>将这些投影加起来就得到了向量积<span class="math inline">\(\boldsymbol{S}\)</span>：</p><p><span class="math display">\[\begin{aligned}    \boldsymbol{S}        &amp;=\boldsymbol{b}\times\boldsymbol{c}\\        \quad\\        &amp;=\boldsymbol{S_{xoy}}+\boldsymbol{S_{yoz}}+\boldsymbol{S_{zox}}\\        \quad\\        &amp;=\begin{vmatrix}b_1&amp;c_1\\b_2&amp;c_2\end{vmatrix}\boldsymbol{e_3}+\begin{vmatrix}b_2&amp;c_2\\b_3&amp;c_3\end{vmatrix}\boldsymbol{e_1}+\begin{vmatrix}b_3&amp;c_3\\b_1&amp;c_1\end{vmatrix}\boldsymbol{e_2}\\        \quad\\        &amp;=\begin{vmatrix}b_2&amp;c_2\\b_3&amp;c_3\end{vmatrix}\boldsymbol{e_1}+\begin{vmatrix}b_3&amp;c_3\\b_1&amp;c_1\end{vmatrix}\boldsymbol{e_2}+\begin{vmatrix}b_1&amp;c_1\\b_2&amp;c_2\end{vmatrix}\boldsymbol{e_3}\end{aligned}\]</span></p><p>为了方便记忆，上面的式子往往如下书写，这就是向量积的定义： <span class="math display">\[\boldsymbol{b}\times\boldsymbol{c}=\begin{vmatrix}b_2&amp;c_2\\b_3&amp;c_3\end{vmatrix}\boldsymbol{e_1}-\begin{vmatrix}b_1&amp;c_1\\b_3&amp;c_3\end{vmatrix}\boldsymbol{e_2}+\begin{vmatrix}b_1&amp;c_1\\b_2&amp;c_2\end{vmatrix}\boldsymbol{e_3}\]</span></p><h2 id="子式和余子式">子式和余子式</h2><h3 id="子式">子式</h3><p>在<span class="math inline">\(m\times n\)</span>矩阵<span class="math inline">\(\boldsymbol{A}\)</span>中，任取 k 行与 k 列<span class="math inline">\(（k\le m,k\le n）\)</span>，位于这些行、列交叉处的<span class="math inline">\(k^2\)</span>个元素，不改变它们在<span class="math inline">\(\boldsymbol{A}\)</span>中所处的位置次序而得的 k 阶行列式，称为矩阵<span class="math inline">\(\boldsymbol{A}\)</span>的 k 阶子式（Minor）。</p><p>设<span class="math inline">\(\boldsymbol{A}\)</span>是<span class="math inline">\(m\times n\)</span>的矩阵，<span class="math inline">\(I\)</span>是集合<span class="math inline">\(\{1,...,m\}\)</span>的一个<span class="math inline">\(k\)</span>元子集，<span class="math inline">\(J\)</span>是集合<span class="math inline">\(\{1,...,n\}\)</span>的一个<span class="math inline">\(k\)</span>元子集，<span class="math inline">\(|\boldsymbol{A}|_{I,J}\)</span>是<span class="math inline">\(\boldsymbol{A}\)</span>的<span class="math inline">\(k\)</span>阶子式，其中抽取的 k 行的行号是 I 中所有元素，<span class="math inline">\(k\)</span>列的列号是<span class="math inline">\(J\)</span>中所有元素。那么：</p><ul><li>如果<span class="math inline">\(I=J\)</span>，称<span class="math inline">\(|\boldsymbol{A}|_{I,J}为、boldsymbol{A}\)</span>的<span class="math inline">\(k\)</span>阶主子式（Principal minor）。</li><li>如果<span class="math inline">\(I=J=\{1,\cdots,k\}\)</span>所取的是左起前 k 列和上起前<span class="math inline">\(k\)</span>行），称<span class="math inline">\(|\boldsymbol{A}|_{I,J}\)</span>为<span class="math inline">\(\boldsymbol{A}\)</span>的<span class="math inline">\(k\)</span>阶顺序主子式（Leading principal minor）。</li></ul><p>设在矩阵<span class="math inline">\(\boldsymbol{A}\)</span>中有一个不等于 0 的 r 阶子式<span class="math inline">\(|\boldsymbol{B}_{r}|\)</span>，且所有<span class="math inline">\(r+1\)</span>阶子式（如果存在的话）全等于 0，那么<span class="math inline">\(|\boldsymbol{B}_{r}|\)</span>称为矩阵<span class="math inline">\(\boldsymbol{A}\)</span>的最高阶非零子式，数 r 称为矩阵<span class="math inline">\(\boldsymbol{A}\)</span>的秩。（不适合求矩阵的秩，太麻烦）</p><h3 id="余子式">余子式</h3><p>在 n 阶行列式中，把<span class="math inline">\(a_{ij}\)</span>所在的第 i 行和第 j 列划去后，留下来的 n-1 阶行列式叫做<span class="math inline">\(a_{ij}\)</span>的余子式，记做<span class="math inline">\(\boldsymbol{M}_{ij}\)</span>.</p><h3 id="代数余子式">代数余子式</h3><p>在<span class="math inline">\(a_{ij}\)</span>的余子式<span class="math inline">\(M_{ij}\)</span>的基础上，还可以定义<span class="math inline">\(A_{ij}\)</span>，称为<span class="math inline">\(a_{ij}\)</span>的代数余子式： <span class="math display">\[A_{ij}=(-1)^{i+j}M_{ij}\]</span></p><h3 id="总结">总结</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/math_sub_formula.png"></p><h2 id="行列式的性质">行列式的性质</h2><ul><li><p>行列式转置： 对于 n 阶方阵<span class="math inline">\(\boldsymbol{A}=(a_{ij})\)</span>，有： <span class="math display">\[  |\boldsymbol{A}|=      \begin{vmatrix}          a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\          a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\          \vdots&amp;\vdots&amp;\quad&amp;\vdots\\          a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}      \end{vmatrix},\quad  |\boldsymbol{A}^\mathrm{T}|=      \begin{vmatrix}          a_{11}&amp;a_{21}&amp;\cdots&amp;a_{n1}\\          a_{12}&amp;a_{22}&amp;\cdots&amp;a_{n2}\\          \vdots&amp;\vdots&amp;\quad&amp;\vdots\\          a_{1n}&amp;a_{2n}&amp;\cdots&amp;a_{nn}      \end{vmatrix}  \]</span></p><p>行列式<span class="math inline">\(|\boldsymbol{A}^\mathrm{T}|\)</span>称为行列式<span class="math inline">\(|\boldsymbol{A}|\)</span>的转 置行列式。可以证明： <span class="math display">\[  |\boldsymbol{A}|=|\boldsymbol{A}^\mathrm{T}|  \]</span></p></li><li><p>满秩、可逆与行列式： 对于方阵<span class="math inline">\(\boldsymbol{A}\)</span>有： <span class="math display">\[  |\boldsymbol{A}|\ne 0\iff \boldsymbol{A}\ 满秩、iff \boldsymbol{A}\ 可逆  \]</span></p></li><li><p>行列式的数乘： 行列式乘以 k 倍，等于某行（列）乘以 k，该性质也可以称为行列式的数乘： <span class="math display">\[{\color {blue}k}\begin{vmatrix}  a_{11}&amp;a_{12}&amp;\dots &amp;a_{1n}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}  a_{11}&amp;a_{12}&amp;\dots&amp;a_{1n}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  {\color {blue}k}a_{i1}&amp;{\color{blue}k}a_{i2}&amp;\dots&amp;{\color{blue}k}a_{in}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}  a_{11}&amp;\dots&amp;{\color {blue}k}a_{1j}&amp;\dots &amp;a_{1n}\\  \vdots &amp;\dots&amp;{\color {blue}k}a_{2j} &amp;\dots &amp;\vdots \\  \vdots &amp;\ddots&amp;\vdots&amp;\ddots &amp;\vdots   \\a_{n1}&amp;\dots&amp;{\color {blue}k}a_{nj}&amp;\dots &amp;a_{nn}\end{vmatrix}  \]</span></p></li><li><p>行或列互换： 行列式中的行（列）互换后，行列式正负号发生改变： <span class="math display">\[\begin{vmatrix}  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\  {\color{blue}{a_{i1}}}&amp;{\color{blue}{a_{i2}}}&amp;\dots&amp;{\color{blue}{a_{in}}}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\  {\color{ForestGreen}{a_{j1}}}&amp;{\color{ForestGreen}{a_{j2}}}&amp;\dots&amp;{\color{ForestGreen}{a_{jn}}}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\\end{vmatrix}=-\begin{vmatrix}  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\  {\color{ForestGreen}{a_{j1}}}&amp;{\color{ForestGreen}{a_{j2}}}&amp;\dots&amp;{\color{ForestGreen}{a_{jn}}}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\  {\color{blue}{a_{i1}}}&amp;{\color{blue}{a_{i2}}}&amp;\dots&amp;{\color{blue}{a_{in}}}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\\end{vmatrix}\]</span></p></li><li><p>行列式的倍加： 将一行（列）的 k 倍加进另一行（列）里，行列式的值不变，该性质也可以称为行列式的倍加： <span class="math display">\[  \begin{vmatrix}  \vdots &amp;\vdots &amp;\vdots &amp;\vdots \\  a_{i1}&amp;a_{i2}&amp;\dots &amp;a_{in}\\  a_{j1}&amp;a_{j2}&amp;\dots &amp;a_{jn}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots\end{vmatrix}=\begin{vmatrix}  \vdots &amp;\vdots &amp;\vdots &amp;\vdots\\  a_{i1}&amp;a_{i2}&amp;\dots &amp;a_{in}\\  a_{j1}{\color{blue}{+ka_{i1}}}&amp;a_{j2}{\color{blue}{+ka_{i2}}}&amp;\dots&amp;a_{jn}{\color{blue}{+ka_{in}}}\\  \vdots &amp;\vdots &amp;\vdots &amp;\vdots\end{vmatrix}\]</span></p></li><li><p>行列式的加法： 在行列式中，某一行（列）的每个元素是两数之和，则此行列式可拆分为两个相加的行列式，该性质也可以称为行列式的加法： <span class="math display">\[ \begin{vmatrix}  a_{11}&amp;a_{12}&amp;\dots &amp;a_{1n}\\  \vdots &amp;\vdots &amp;\dots &amp;\vdots\\  {\color{blue}{a_{i1}}}+{\color{ForestGreen}{b_{i1}}}&amp;{\color{blue}a_{i2}}+{\color{ForestGreen}{b_{i2}}}&amp;\dots&amp;{\color{blue}{a_{in}}}+{\color{ForestGreen}{b_{in}}}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix} =\begin{vmatrix}  a_{11}&amp;a_{12}&amp;\dots &amp;a_{1n}\\  \vdots &amp;\vdots &amp;\dots &amp;\vdots\\  {\color{blue}{a_{i1}}}&amp;{\color{blue}{a_{i2}}}&amp;\dots&amp;{\color{blue}{a_{in}}}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix} +\begin{vmatrix}  a_{11}&amp;a_{12}&amp;\dots &amp;a_{1n}\\  \vdots &amp;\vdots &amp;\dots &amp;\vdots   \\{\color{ForestGreen}{b_{i1}}}&amp;{\color{ForestGreen}{b_{i2}}}&amp;\dots &amp;{\color{ForestGreen}{b_{in}}}\\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix}  \]</span></p></li><li><p>行列式的乘法： 对于同阶方阵<span class="math inline">\(\boldsymbol{A},\boldsymbol{B}\)</span>，有： <span class="math display">\[  |\boldsymbol{A}\boldsymbol{B}|=|\boldsymbol{A}||\boldsymbol{B}|  \]</span> 该性质又称为行列式的乘法。</p></li><li><p>三角行列式的计算法： <span class="math display">\[|\boldsymbol{A}|=\begin{vmatrix}  a_{11}&amp;&amp;&amp;\\  a_{21}&amp;a_{22}&amp;&amp;0\\  \vdots &amp;\vdots &amp;\ddots &amp;\\  a_{n1}&amp;a_{n2}&amp;\dots &amp;a_{nn}\end{vmatrix}= a_{11}a_{22}\cdots a_{nn}\]</span></p></li><li><p>三角分块行列式的计算法： 设有分块矩阵： <span class="math display">\[  \boldsymbol{A}=\begin{pmatrix}\boldsymbol{B}&amp;\boldsymbol{O}\\\boldsymbol{C}&amp;\boldsymbol{D}\end{pmatrix}  \]</span> 则有： <span class="math display">\[  |\boldsymbol{A}|=|\boldsymbol{B}||\boldsymbol{D}|  \]</span> 该性质也称为三角分块行列式的计算法。</p></li><li><p>拉普拉斯展开： n 阶方阵<span class="math inline">\(\boldsymbol{A}=(a_{ij})\)</span>的行列式可以表示成关于该方阵<span class="math inline">\(\boldsymbol{A}\)</span>的某一行的各元素与其对应的代数余子式乘积之和，即： <span class="math display">\[  |\boldsymbol{A}|=a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in}\quad (i=1,2,...,n)  \]</span> 或表示成关于该方阵 A 的某一列的各元素与其对应的代数余子式乘积之和： <span class="math display">\[  |\boldsymbol{A}|=a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj}\quad (j=1,2,...,n)  \]</span> 这种计算行列式的方法称为拉普拉斯展开（Laplace expansion）。</p></li></ul><h2 id="克拉默法则">克拉默法则</h2><p>有 n 个未知数，n 个方程所组成的线性方程组，它的系数矩阵是 n 阶方阵<span class="math inline">\(\boldsymbol{A}\)</span>。如果对应的行列式<span class="math inline">\(|\boldsymbol{A}|\)</span>不等于 0，即：</p><p><span class="math display">\[|\boldsymbol{A}|=\begin{vmatrix}a_{11}&amp;\cdots&amp;a_{1n}\\\vdots&amp;&amp;\vdots\\a_{n1}&amp;\cdots&amp;a_{nn}\end{vmatrix}\neq 0\]</span></p><p>则方程组有唯一解，并且解为：</p><p><span class="math display">\[\displaystyle x_1=\frac{|\boldsymbol{A}_1|}{|\boldsymbol{A}|},\quad     x_2=\frac{|\boldsymbol{A}_2|}{|\boldsymbol{A}|},\quad...,\quad x_n=\frac{|\boldsymbol{A}_n|}{|\boldsymbol{A}|}\]</span></p><p>其中<span class="math inline">\(\boldsymbol{A}_j(j=1,2,...,n)\)</span>是把系数矩阵<span class="math inline">\(\boldsymbol{A}\)</span>中第 j 列的元素用方程组右端的常数项代替后所得到的 n 阶矩阵，即：</p><p><span class="math display">\[\boldsymbol{A}_j=\begin{pmatrix}    a_{11}&amp;\cdots&amp;a_{1,j-1}&amp;{\color{red}{b_1}}&amp;a_{1,j+1}&amp;\cdots&amp;a_{1n}\\    \vdots&amp;&amp;\vdots&amp;{\color{red}{\vdots}}&amp;\vdots&amp;&amp;\vdots\\    a_{n1}&amp;\cdots&amp;a_{n,j-1}&amp;{\color{red}{b_n}}&amp;a_{n,j+1}&amp;\cdots&amp;a_{nn}    \end{pmatrix}\]</span></p><p>这就是克拉默法则（Cramer's Rule），也称为克莱姆法则。</p><h1 id="相似矩阵">相似矩阵</h1><h2 id="基变换">基变换</h2><p>已知两个基<span class="math inline">\(\boldsymbol{m_1},\boldsymbol{m_2},\ldots,\boldsymbol{m_s}\)</span>以及<span class="math inline">\(\boldsymbol{n_1},\boldsymbol{n_2},\ldots,\boldsymbol{n_s}\)</span>，当且仅当它们是同一个向量空间的基时，那么存在唯一的矩阵 P，使得下式成立： <span class="math display">\[(\boldsymbol{n_1},\boldsymbol{n_2},\ldots,\boldsymbol{n_s})=(\boldsymbol{m_1},\boldsymbol{m_2},\ldots,\boldsymbol{m_s})P\]</span> 该矩阵 P 称为由基<span class="math inline">\(\boldsymbol{m_1},\boldsymbol{m_2},\ldots,\boldsymbol{m}_s\)</span>到基<span class="math inline">\(\boldsymbol{n_1},\boldsymbol{n_2},\ldots,\boldsymbol{n_s}\)</span>的过渡矩阵（Transition matrix），而上述公式称为基变换公式（Change of basis formula）。</p><p>过渡矩阵是满秩矩阵。</p><h2 id="坐标变换">坐标变换</h2><p>已知<span class="math inline">\(P\)</span>为由基<span class="math inline">\(\mathcal{M}=\{\boldsymbol{m_1},\boldsymbol{m_2},\ldots,\boldsymbol{m}_s\}\)</span>到基<span class="math inline">\(\mathcal{N}=\{\boldsymbol{n_1},\boldsymbol{n_2},\ldots,\boldsymbol{n_s}\}\)</span>的过渡矩阵：</p><p><span class="math display">\[(\boldsymbol{n_1},\boldsymbol{n_2},\ldots,\boldsymbol{n_s})=(\boldsymbol{m_1},\boldsymbol{m_2},\ldots,\boldsymbol{m_s})P\]</span></p><p>又知向量<span class="math inline">\(\boldsymbol{x}在基、mathcal{M}\)</span>下的坐标为<span class="math inline">\([\boldsymbol{x}]_\mathcal{M}\)</span>以及在基<span class="math inline">\(\mathcal{N}\)</span>下的坐标为<span class="math inline">\([\boldsymbol{x}]_\mathcal{N}\)</span>，则有坐标变换公式（Change of coordinates formula）：</p><p><span class="math display">\[[\boldsymbol{x}]_\mathcal{N}=P^{-1}[\boldsymbol{x}]_\mathcal{M},\quad [\boldsymbol{x}]_\mathcal{M}=P[\boldsymbol{x}]_\mathcal{N}\]</span></p><p>基变换和坐标变换的区别在于，前者是右乘过渡矩阵<span class="math inline">\(P\)</span>，后者是左乘<span class="math inline">\(P^{-1}\)</span>：</p><h2 id="相似矩阵-1">相似矩阵</h2><p>设<span class="math inline">\(A,B\)</span>都是<span class="math inline">\(n\)</span>阶方阵，若有可逆矩阵<span class="math inline">\(P\)</span>，使得：</p><p><span class="math display">\[B=P^{-1}AP\]</span></p><p>则称 P 为相似变换矩阵（Similarity transformation matrix），称 B 是 A 的相似矩阵（Similar matrix），记作：</p><p><span class="math display">\[A\simeq B\]</span></p><p>相似矩阵其实就是改变矩阵函数的基</p><h2 id="相似矩阵的性质">相似矩阵的性质</h2><p>若<span class="math inline">\(A\simeq B\)</span>，则：</p><p><span class="math display">\[A^k\simeq B^k,\quad k\in\mathbb{Z}^+\]</span></p><p><span class="math display">\[A^\mathrm{T}\simeq B^\mathrm{T}\]</span></p><p>若<span class="math inline">\(A\simeq B\)</span>，且<span class="math inline">\(A、B\)</span>可逆，则：</p><p><span class="math display">\[A^{-1}\simeq B^{-1}\]</span></p><p><span class="math display">\[A^*\simeq B^*\]</span></p><p>若<span class="math inline">\(A\simeq B，B\simeq C\)</span>，那么：</p><p><span class="math display">\[A\simeq C\]</span></p><h1 id="特征值与特征向量">特征值与特征向量</h1><h2 id="特征值与特征向量-1">特征值与特征向量</h2><h3 id="定义">定义</h3><p>设 A 是 n 阶方阵，<span class="math inline">\(\boldsymbol{x}\)</span>为非零向量，若存在数<span class="math inline">\(\lambda\)</span>使得下式成立：</p><p><span class="math display">\[A\boldsymbol{x}=\lambda\boldsymbol{x}\]</span></p><p>那么将数<span class="math inline">\(\lambda\)</span>称为 A 的特征值（Eigenvalue），非零向量<span class="math inline">\(\boldsymbol{x}\)</span>称为<span class="math inline">\(A\)</span>的对应于<span class="math inline">\(\lambda\)</span>的特征向量（Eigenvector）。</p><h3 id="求解">求解</h3><p>求解步骤还是比较简单，就是通过解下列方程组来求出特征值和特征向量：</p><p><span class="math display">\[\begin{cases}|A-\lambda I| = 0\\\\(A-\lambda I)\boldsymbol{x} = \boldsymbol{0} \end{cases}\Longrightarrow \begin{cases}\lambda = ? \\\\ \boldsymbol{x} = ?\end{cases}\]</span></p><p>更具体的步骤是，先通过第一个式子求出特征值：</p><p><span class="math display">\[|A-\lambda I| = 0\implies \lambda_1,\lambda_2,\cdots,\lambda_i,\cdots\lambda_n\]</span></p><p>然后将、lambda_i 代入 (A-I)=求出该线性方程组的解集：</p><p><span class="math display">\[(A-\lambda_i I)\boldsymbol{x}=\boldsymbol{0}\implies \boldsymbol{x}=?\]</span></p><p>该解集必然为向量空间，因为其中都是特征值为、lambda_i 的特征向量（零向量除外），所以也称为特征值为<span class="math inline">\(\lambda_i\)</span>的特征空间（Eigenspace）。</p><h3 id="特征多项式与特征方程">特征多项式与特征方程</h3><p>假设： <span class="math display">\[A=\begin{pmatrix}a_{11}&amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22}&amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{pmatrix}\]</span></p><p>那么<span class="math inline">\(|A-\lambda I| = 0\)</span>可以写作：</p><p><span class="math display">\[|A-\lambda I|=\begin{vmatrix}    a_{11}-\lambda &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22}-\lambda &amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}-\lambda\end{vmatrix}=0\]</span></p><p>其中<span class="math inline">\(|A-\lambda I|\)</span>展开后就是关于特征值<span class="math inline">\(\lambda\)</span>的多项式，所以称为特征多项式（Characteristic polynomial）：</p><p><span class="math display">\[\underbrace{\left|\begin{array}{cccc}a_{11}-\lambda &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22}-\lambda &amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}-\lambda\end{array}\right|}_{|A-\lambda I|}=c_0\lambda^{n}+c_1\lambda^{n-1}+\cdots+c_n\]</span></p><p>进而<span class="math inline">\(|A-\lambda I| = 0\)</span>被称为特征方程（Characteristic equation）。</p><p>已知<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>是<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(A\)</span>相异的特征值，以及<span class="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2,\cdots,\boldsymbol{v}_m\)</span>是<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>对应的特征向量，则向量组<span class="math inline">\(\{\boldsymbol{v}_1,\boldsymbol{v}_2,\cdots,\boldsymbol{v}_m\}\)</span>线性无关。</p><p>不同特征值的特征向量是线性无关的。</p><h2 id="对角化">对角化</h2><p>如果<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量<span class="math inline">\(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}\)</span>，那么如下矩阵：</p><p><span class="math display">\[P=(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n})\]</span></p><p>可以使得：</p><p><span class="math display">\[A=P\Lambda P^{-1}\]</span></p><p>其中<span class="math inline">\(\Lambda\)</span>为如下对角阵</p><p><span class="math display">\[\Lambda=\left(\begin{array}{llll}\lambda_{1} &amp; &amp; &amp; \\ &amp; \lambda_{2} &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; \lambda_{n}\end{array}\right)\]</span></p><p>其中的<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span>为特征向量<span class="math inline">\(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}\)</span>对应的特征值，该过程称为对角化（Diagonalizable）。</p><h2 id="正交矩阵">正交矩阵</h2><p>已知<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2,\cdots,\boldsymbol{p}_r\)</span>是向量空间<span class="math inline">\(V\)</span>的一个基，如果两两正交，即满足：</p><p><span class="math display">\[\boldsymbol{p}_i\cdot\boldsymbol{p}_j=0,\quad i\ne j\]</span></p><p>那么称其为正交基（Orthogonal basis）。如果还满足长度均为 1，即：</p><p><span class="math display">\[\boldsymbol{p}_1\cdot\boldsymbol{p}_1=\boldsymbol{p}_2\cdot\boldsymbol{p}_2=\cdots=\boldsymbol{p}_r\cdot\boldsymbol{p}_r=1\]</span></p><p>那么，就称为标准正交基（Orthonormal basis）。</p><p>假设<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2,\cdots,\boldsymbol{p}_n\)</span>是向量空间<span class="math inline">\(\mathbb{R}^n\)</span>的一个标准正交基，那么由它们构造的<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(P\)</span>也称为正交矩阵（Orthogonal Matrix）：</p><p><span class="math display">\[P=(\boldsymbol{p}_1,\boldsymbol{p_2},\cdots,\boldsymbol{p}_n)\]</span></p><p>该方阵 P 必然满足：</p><p><span class="math display">\[P^\mathrm{T}P=P^{-1}P=I\]</span></p><p>即<span class="math inline">\(P^\mathrm{T}\)</span>就是<span class="math inline">\(P\)</span>的逆矩阵。</p><h2 id="施密特正交化">施密特正交化</h2><p>如果<span class="math inline">\(\boldsymbol{x}_1,\boldsymbol{x_2},\cdots\boldsymbol{x_n}\)</span>是某向量空间的基，那么通过下述方法就可以找到该向量空间的正交基<span class="math inline">\(\boldsymbol{v}_1,\boldsymbol{v_2},\cdots\boldsymbol{v_n}\)</span>，该方法被称为施密特正交化（Gram–Schmidt process）：</p><p><span class="math display">\[\boldsymbol{x_1},\cdots,\boldsymbol{x_n}\xrightarrow{\quad\text{施密特正交化}\quad}\begin{cases}    \boldsymbol{v_1}=\boldsymbol{x_1}\\    \quad\\    \boldsymbol{v_2}=\boldsymbol{x_2}-\frac{\boldsymbol{x_2}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}\\    \quad\\    \boldsymbol{v_3}=\boldsymbol{x_3}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}-\frac{\boldsymbol{x_3}\cdot\boldsymbol{v_2}}{\boldsymbol{v_2}\cdot\boldsymbol{v_2}}\boldsymbol{v_2}\\    \quad\\    \qquad\qquad\vdots\\    \\    \boldsymbol{v_n}=\boldsymbol{x_n}-\frac{\boldsymbol{x_n}\cdot\boldsymbol{v_1}}{\boldsymbol{v_1}\cdot\boldsymbol{v_1}}\boldsymbol{v_1}-\cdots-\frac{\boldsymbol{x_n}\cdot\boldsymbol{v_{n-1}}}{\boldsymbol{v_{n-1}}\cdot\boldsymbol{v_{n-1}}}\boldsymbol{v_{n-1}}\end{cases}\]</span></p><h2 id="正交对角化">正交对角化</h2><p>如果矩阵<span class="math inline">\(A\)</span>是对称阵，且其中的每一个元素都是实数，那么称之为实对称阵（Real symmetric matrices）。此时有如下性质：</p><p>若<span class="math inline">\(\lambda_1,\lambda_2\)</span>是实对称阵 A 相异的特征值，<span class="math inline">\(\boldsymbol{p}_1,\boldsymbol{p}_2\)</span>是<span class="math inline">\(\lambda_1,\lambda_2\)</span>对应的特征向量，则有<span class="math inline">\(\boldsymbol{p}_1\)</span>与<span class="math inline">\(\boldsymbol{p}_2\)</span>正交，即：</p><p><span class="math display">\[\boldsymbol{p_1}\cdot\boldsymbol{p_2}=0\]</span></p><p>对于<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(A\)</span>，如果存在正交矩阵<span class="math inline">\(P\)</span>和对角阵<span class="math inline">\(\Lambda\)</span>使得：</p><p><span class="math display">\[A=P\Lambda P^{-1}=P\Lambda P^\mathrm{T}\]</span></p><p>那么就称该方阵<span class="math inline">\(A\)</span>可正交对角化（Orthogonal diagonalizable）。</p><p>正交对角化是对角化的一种特殊情况，这里进行一下对比：</p><ul><li>n 阶方阵 A 可对角化，当且仅当有 n 个线性无关的特征向量</li><li>n 阶方阵 A 可正交对角化，当且仅当有 n 个正交的特征向量，此时这 n 个特征向量必然也线性无关</li></ul><p>可以证明 A 可正交对角化的充要条件是 A 为对称阵，即： <span class="math display">\[A\ 可正交对角化、iff A\ 是对称阵\]</span></p><h2 id="相似矩阵中的不变量">相似矩阵中的不变量</h2><p>如果 A 和 B 是相似矩阵，那么两者的特征值相同：</p><p><span class="math display">\[A\simeq B\implies A,B 的特征值相同\]</span></p><p>如果<span class="math inline">\(\boldsymbol{A}\)</span>和<span class="math inline">\(\boldsymbol{B}\)</span>是相似矩阵，那么两者的行列式相同：</p><p><span class="math display">\[\boldsymbol{A}\simeq \boldsymbol{B}\implies |\boldsymbol{A}|=|\boldsymbol{B}|\]</span></p><p>对于<span class="math inline">\(n\)</span>阶方阵<span class="math inline">\(\boldsymbol{A}\)</span>，其主对角线（从左上方至右下方的对角线）的元素之和称为迹（Trace），记作<span class="math inline">\(tr(\boldsymbol{A})\)</span>： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/math_trace.png"></p><h1 id="参考文献">参考文献</h1><p>《马同学的线性代数》<br>感兴趣的可以购买他的课程，写的很好（强烈推荐）！！！</p>]]></content>
      
      
      <categories>
          
          <category> Science Thought </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分（下）</title>
      <link href="/next/2022/Science/CalculusPart2/"/>
      <url>/next/2022/Science/CalculusPart2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/advanced_mathematics.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjExZTM0N2U0MDFmZDU4N2IzYTIxZGU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="多元函数微分">多元函数微分</h1><h2 id="多元函数及其邻域">多元函数及其邻域</h2><p>二元函数的严格定义： 假设<span class="math inline">\(D\)</span>是二维向量<span class="math inline">\((x,y)\)</span>的集合，<span class="math inline">\(D\)</span>上的二元函数<span class="math inline">\(\ f\)</span>是一个映射法则，它对<span class="math inline">\(D\)</span>内的每一个有序对<span class="math inline">\((x,y)\)</span>指定唯一的一个实数：</p><p><span class="math display">\[z=f(x,y),\quad (x,y)\in D\]</span></p><p>如果用<span class="math inline">\(P\)</span>来代替<span class="math inline">\((x,y)\)</span>的话，也可以写作：</p><p><span class="math display">\[z=f(P),\quad P\in D\]</span></p><p><span class="math inline">\(D\)</span>称为<span class="math inline">\(f\)</span>的定义域，<span class="math inline">\(x、y\)</span>（或<span class="math inline">\((x,y)\)</span>，或<span class="math inline">\(P\)</span>）称为<span class="math inline">\(f\)</span>的自变量，<span class="math inline">\(z\)</span>称为<span class="math inline">\(f\)</span>的因变量。</p><p>如果定义域<span class="math inline">\(D\)</span>是更高维的向量的集合，也就是说自变量为更高维的向量，那么 <span class="math inline">\(f\)</span>可以称为多元函数，也叫作多变量函数。</p><h4 id="邻域和去心邻域">邻域和去心邻域：</h4><p>二维向量的邻域要比一维向量的复杂。对于二维向量<span class="math inline">\(P_0(x_0,y_0)\)</span>而言，半径为<span class="math inline">\(\delta\)</span> 邻域可以表示为平面点集：</p><p><span class="math display">\[U(P_0,\delta)=\{(x,y)\ |\ (x-x_0)^2 + (y-y_0)^2 &lt; \delta^2\}\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/math_area.png"></p><h2 id="多元函数极限和连续">多元函数极限和连续</h2><ul><li><p>聚点： 如果对于任意给定的<span class="math inline">\(\delta &gt; 0\)</span>，点<span class="math inline">\(P\)</span>的去心邻域<span class="math inline">\(\mathring{U}(P,\delta)\)</span>内总有平面点集<span class="math inline">\(E\)</span>中的点，那么称点<span class="math inline">\(P\)</span>为<span class="math inline">\(E\)</span>的聚点。 定义聚点是为了保证，从<span class="math inline">\(P_0(x_0,y_0)\)</span>的某去心邻域内的某一点<span class="math inline">\(P(x,y)\)</span>出发，至少能找到一串完全在 E 中的点来靠近<span class="math inline">\(P_0\)</span></p></li><li><p>二元函数极限的定义： 设二元函数<span class="math inline">\(f(x,y)\)</span>的定义域为<span class="math inline">\(D，P_0(x_0,y_0)\)</span>是<span class="math inline">\(D\)</span>的聚点。如果存在常数<span class="math inline">\(L\)</span>，对于任意给定的正数<span class="math inline">\(\epsilon\)</span>，总存在正数<span class="math inline">\(\delta\)</span>，使得当点<span class="math inline">\(P(x,y)\)</span>满足下列条件时： <span class="math display">\[  (x,y)\in D\cap \mathring{U}(P_0,\delta)  \]</span> 都有： <span class="math display">\[  |f(x,y)-L| &lt; \epsilon  \]</span> 成立，那么就称常数<span class="math inline">\(L\)</span>为函数<span class="math inline">\(f(x,y)\)</span>当<span class="math inline">\((x,y)\to(x_0,y_0)\)</span>时的极限，记作： <span class="math display">\[  \lim_{(x,y)\to(x_0,y_0)}f(x,y)=L\quad 或、quad f(x,y)\to L\ \big(\ (x,y)\to(x_0,y_0)\ \big)  \]</span> 因为这是二元函数的极限，所以也称作二重极限。</p></li><li><p>连续： 设二元函数<span class="math inline">\(f(x,y)\)</span>的定义域为<span class="math inline">\(D\)</span>，<span class="math inline">\(P_0(x_0,y_0)\)</span>是<span class="math inline">\(D\)</span>的聚点，且<span class="math inline">\(P_0\in D\)</span>，如果： <span class="math display">\[  \lim_{(x,y)\to(x_0,y_0)}f(x,y)=f(x_0,y_0)  \]</span> 那么称函数<span class="math inline">\(f(x,y)\)</span>在点<span class="math inline">\(P_0(x_0,y_0)\)</span>连续。</p></li></ul><h2 id="全微分">全微分</h2><p>设函数<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>的某邻域内有定义，假设：</p><p><span class="math display">\[\Delta x=x-x_0,\quad \Delta y=y-y_0\]</span></p><p>如果函数<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>的全增量：</p><p><span class="math display">\[\Delta z=f(x_0+\Delta x, y_0+\Delta y)-f(x_0, y_0)\]</span></p><p>可以表示为：</p><p><span class="math display">\[\Delta z=A\Delta x+B\Delta y+o(\rho)=A\Delta x+B\Delta y+\epsilon_1\Delta x+\epsilon_2\Delta y\]</span></p><p>其中<span class="math inline">\(A、B\)</span>不依赖于<span class="math inline">\(\Delta x、\Delta y\)</span>，且：</p><p><span class="math display">\[\rho=\sqrt{(\Delta x)^2+(\Delta y)^2},\quad \lim_{\Delta x\to 0}\epsilon_1=0,\quad \lim_{\Delta y\to 0}\epsilon_2=0\]</span></p><p>那么称<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>处可微分，而<span class="math inline">\(A\Delta x+B\Delta y\)</span>称为<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>处的全微分（或称为切平面），记作<span class="math inline">\(\mathrm{d}z\)</span>，即：</p><p><span class="math display">\[\mathrm{d}z=A\mathrm{d}x+B\mathrm{d}y\]</span></p><p>可以类比单变量微分的定义，单变量微积分是以直线代替曲线，双变量全微分是以平面代替曲线。</p><h2 id="偏导数">偏导数</h2><ul><li><p>关于<span class="math inline">\(x\)</span>的偏导数： <span class="math display">\[  \left.\frac{\partial f}{\partial x}\right|_{(x_0,y_0)}=\left.\frac{\mathrm{d}}{\mathrm{d}x}f(x,y_0)\right|_{x=x_0}=\lim_{h\to 0}\frac{f(x_0+h,y_0)-f(x_0,y_0)}{h}  \]</span></p></li><li><p>关于<span class="math inline">\(y\)</span>的偏导数： <span class="math display">\[  \left.\frac{\partial f}{\partial y}\right|_{(x_0,y_0)}=\left.\frac{\mathrm{d}}{\mathrm{d}y}f(x_0,y)\right|_{y=y_0}=\lim_{h\to 0}\frac{f(x_0,y_0+h)-f(x_0,y_0)}{h}  \]</span></p></li><li><p>与全微分的关系： 如果函数<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>可微分，那么该函数在点<span class="math inline">\((x_0,y_0)\)</span>的偏导数<span class="math inline">\(f_x(x_0,y_0)、f_y(x_0,y_0)\)</span>必定存在，且<span class="math inline">\(z=f(x,y)\)</span>在点<span class="math inline">\((x_0,y_0)\)</span>的全微分为： <span class="math display">\[  \mathrm{d}z=f_x(x_0,y_0)\mathrm{d}x+f_y(x_0,y_0)\mathrm{d}y  \]</span></p></li></ul><h2 id="方向导数与梯度">方向导数与梯度</h2><p>对于二元函数<span class="math inline">\(z=f(x,y)\)</span>，沿某单位向量：</p><p><span class="math display">\[\boldsymbol{u}=\begin{pmatrix}u_1\\u_2\end{pmatrix}\]</span></p><p>在<span class="math inline">\((x_0,y_0)\)</span>点的方向导数为：</p><p><span class="math display">\[\left.\frac{\partial f}{\partial u}\right|_{(x_0,y_0)}=\lim_{t\to 0}\frac{f(x_0+tu_1, y_0+tu_2)-f(x_0,y_0)}{t},\quad t\in\mathbb{R}\]</span></p><p>单位向量还可以用该向量的方向余弦<span class="math inline">\(\cos\alpha\)</span>和<span class="math inline">\(\cos\beta\)</span>表示，即：</p><p><span class="math display">\[\boldsymbol{u}=\begin{pmatrix}u_1\\u_2\end{pmatrix}=\begin{pmatrix}\cos\alpha\\\cos\beta\end{pmatrix}\]</span></p><p>所以方向导数也常表示为：</p><p><span class="math display">\[\left.\frac{\partial f}{\partial u}\right|_{(x_0,y_0)}=\lim_{t\to 0}\frac{f(x_0+t\cos\alpha, y_0+t\cos\beta)-f(x_0,y_0)}{t},\quad t\in\mathbb{R}\]</span></p><ul><li>模长：该方向向量的模长是方向导数的最大值。</li><li>方向：该方向向量的方向正是取得最大方向导数的方向。</li><li>投影：它向某单位向量<span class="math inline">\(\boldsymbol{u}\)</span>的投影就是对应的方向导数。</li></ul><p>该方向向量就称为梯度，记作：</p><p><span class="math display">\[\nabla f(x_0,y_0)=grad f(x_0,y_0)=\begin{pmatrix}f_x(x_0,y_0)\\f_y(x_0,y_0)\end{pmatrix}=f_x(x_0,y_0)\boldsymbol{i}+f_y(x_0,y_0)\boldsymbol{j}\]</span></p><p>直观的理解就是：</p><ul><li>沿着梯度向量方向走，能以最快的速度到达山顶。</li><li>逆着梯度向量方向走，能以最快的速度到达山脚。</li><li>和梯度向量方向垂直，此时坡度为 0，即不上山也不下山。</li></ul><h2 id="全导数">全导数</h2><p>若<span class="math inline">\(z=f(x,y)\)</span>是可微分的，而 x 和 y 是 t 的可导函数，则 z 是 t 的可导函数，并且：</p><p><span class="math display">\[\frac{\mathrm{d}z}{\mathrm{d}t}=\frac{\partial z}{\partial x}\frac{\mathrm{d}x}{\mathrm{d}t}+\frac{\partial z}{\partial y}\frac{\mathrm{d}y}{\mathrm{d}t}\]</span></p><p>这个导数可以看作过切点的曲线的导数，所以又被称为全导数。</p><p>总结： <span class="math display">\[\begin{array}{c|c}    \hline    \quad \quad&amp;\quad 描述、quad &amp;\quad 公式 \quad\\    \hline    \\    \quad 偏导数 \quad&amp;\quad \begin{aligned}y=y_0\ 和、x=x_0\ 两平面、\ \\与曲面相交所得曲线的导数、end{aligned}\quad&amp;\quad f_x=\frac{\partial f}{\partial x},f_y=\frac{\partial f}{\partial y}\quad \\    \\    \hline    \\    \quad 方向导数 \quad&amp;\quad\begin{aligned}垂直于 xy 的平面、quad\quad\ \ \\与曲面相交所得曲线的导数、\ \end{aligned}\quad&amp;\quad \frac{\partial f}{\partial u}=f_x\cos\alpha+f_y\cos\beta\quad\\    \\    \hline    \\    \quad 全导数 \quad&amp;\quad\begin{aligned}垂直于 xy 的曲面、quad\quad\ \ \\与曲面相交所得曲线的导数、\ \end{aligned}\quad&amp;\quad\frac{\mathrm{d}z}{\mathrm{d}t}=\frac{\partial z}{\partial x}\frac{\mathrm{d}x}{\mathrm{d}t}+\frac{\partial z}{\partial y}\frac{\mathrm{d}y}{\mathrm{d}t}\quad\\    \\    \hline\end{array}\]</span></p><h2 id="雅可比矩阵">雅可比矩阵</h2><ul><li><p>二元函数的导数： 二元函数<span class="math inline">\(z=f(x,y)\)</span>的微分，微分在<span class="math inline">\(\mathrm{d}x\mathrm{d}y\mathrm {d}z\)</span>坐标系中的方程为：</p><p><span class="math display">\[  \mathrm{d}z=f_x\mathrm{d}x+f_y\mathrm{d}y  \]</span></p><p>可以改写为矩阵的形式： <span class="math display">\[  \underbrace{\begin{pmatrix}\mathrm{d}z\end{pmatrix}}_   {\boldsymbol{d_z}}\quad=\quad\underbrace{\begin{pmatrix}   f_x&amp;f_y\end{pmatrix}}_{T}\quad\underbrace{\begin{pmatrix}  \mathrm{d}x\\\mathrm{d}y\end{pmatrix}}_{\boldsymbol{d_{xy}    }}  \]</span></p><p>或者写作：</p><p><span class="math display">\[  \boldsymbol{d_z}=T\boldsymbol{d_{xy}}  \]</span></p></li><li><p>一般的多元函数： <span class="math display">\[  y=f(x_1,x_2,\cdots,x_n),\quad (y,x_1,x_2,\cdots,    x_n\in\mathbb{R})  \]</span></p><p>如果可微的话，那么微分方程为：</p><p><span class="math display">\[  \mathrm{d}y=f_{x_1}\mathrm{d}x_1+f_{x_2}\mathrm{d}x_2   +\cdots+f_{x_n}\mathrm{d}x_n  \]</span></p><p>可以改写为矩阵的形式：</p><p><span class="math display">\[  \underbrace{\begin{pmatrix}\mathrm{d}y\end{pmatrix}}_   {\boldsymbol{d_y}}\quad=\quad\underbrace{\begin{pmatrix}f_ {x_1}&amp;f_{x_2}&amp;\cdots&amp;f_{x_n}\end{pmatrix}}_{T}   \quad\underbrace{\begin{pmatrix}\mathrm{d}x_1\\\mathrm{d}  x_2\\\vdots\\\mathrm{d}x_b\end{pmatrix}}_{\boldsymbol{d_  {x}}}  \]</span></p><p>或者写作：</p><p><span class="math display">\[  \boldsymbol{d_y}=T\boldsymbol{d_{x}}  \]</span></p><p>其中矩阵 T 就是该多元函数的导数。</p></li><li><p>二元方程组的导数： <span class="math display">\[  \begin{cases}      \mathrm{d}z=\frac{\partial f}{\partial x}\mathrm{d}x    +\frac{\partial f}{\partial y}\mathrm{d}y\\      \\      \mathrm{d}w=\frac{\partial g}{\partial x}\mathrm{d}x    +\frac{\partial g}{\partial y}\mathrm{d}y  \end{cases}  \]</span> 可以写成矩阵的形式： <span class="math display">\[  \underbrace{\begin{pmatrix}\mathrm{d}z\\\mathrm{d}w\end{pmatrix}}_{\boldsymbol{d_{v}}}\quad=\quad\underbrace{\begin{pmatrix}\frac{\partial f}{\partial x}&amp;\frac{\partial f}{\partial y}\\\frac{\partial g}{\partial x}&amp;\frac{\partial g}{\partial y}\end{pmatrix}}_{T}\quad\underbrace{\begin{pmatrix}\mathrm{d}x\\\mathrm{d}y\end{pmatrix}}_{\boldsymbol{d_{u}}}  \]</span> 或者写作： <span class="math display">\[  \boldsymbol{d_{v}}=T\boldsymbol{d_{u}}  \]</span> 其中矩阵 T 就是该方程组所代表的函数的导数。</p></li><li><p>雅可比矩阵（多元方程组的导数矩阵）： 假如<span class="math inline">\(f_1,f_2,\cdots,f_n\)</span>都是<span class="math inline">\(x_1,x_2,\cdots,x_m\)</span>的函数，并且相对于各个自变量的偏微分都存在，那么定义 T 为： <span class="math display">\[  T=\frac{\partial (f_1,f_2,\cdots,f_n)}{\partial (x_1,x_2,\cdots,x_m)}=\begin{pmatrix}\frac{\partial f_1}{\partial x_1}&amp;\frac{\partial f_1}{\partial x_2}&amp;\cdots&amp;\frac{\partial f_1}{\partial x_m}\\\frac{\partial f_2}{\partial x_1}&amp;\frac{\partial f_2}{\partial x_2}&amp;\cdots&amp;\frac{\partial f_2}{\partial x_m}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\\frac{\partial f_n}{\partial x_1}&amp;\frac{\partial f_n}{\partial x_2}&amp;\cdots&amp;\frac{\partial f_n}{\partial x_m}\end{pmatrix}  \]</span> 该矩阵<span class="math inline">\(T\)</span>称为雅可比矩阵。因为雅可比矩阵的英文名为 Jacobian Matrix，所以上述矩阵又常写作： <span class="math display">\[  J=\frac{\partial (f_1,f_2,\cdots,f_n)}{\partial (x_1,x_2,\cdots,x_m)}  \]</span></p></li><li><p>海森矩阵： 一元导数<span class="math inline">\(y=f(x)\)</span>的二阶导数就是连续两次使用<span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d}x}\)</span>： <span class="math display">\[  \frac{\mathrm{d}^2y}{\mathrm{d}x^2}=\frac{\mathrm{d}}{\mathrm{d}x}\left(\frac{\mathrm{d}y}{\mathrm{d}x}\right)  \]</span> 类似的，二元函数<span class="math inline">\(z=f(x,y)\)</span>的二阶导数就是连续两次计算雅可比矩阵： <span class="math display">\[  \frac{\partial^2 z}{\partial(x,y)^2}=\frac{\partial }{\partial(x,y)}\left(\frac{\partial z}{\partial(x,y)}\right)=\begin{pmatrix}f_{xx}&amp;f_{xy}\\f_{yx}&amp;f_{yy}\end{pmatrix}  \]</span> 二阶导数又称为海森矩阵（Hessian Matrix），所以常用 H 来表示这个矩阵： <span class="math display">\[  H=\frac{\partial^2 z}{\partial(x,y)^2}=\begin{pmatrix}f_{xx}&amp;f_{xy}\\f_{yx}&amp;f_{yy}\end{pmatrix}  \]</span> 海森矩阵可以判断图像的凹凸性。</p></li></ul><p>此外关于隐函数的求导，多元函数的极值求法这里不再列出，详细可以参考相关书籍。</p><h1 id="重积分">重积分</h1><h2 id="二重积分">二重积分</h2><p>设<span class="math inline">\(f(x,y)\)</span>是有界闭区域<span class="math inline">\(D\)</span>上的有界函数，将闭区域<span class="math inline">\(D\)</span>任意分成<span class="math inline">\(n\)</span>个小闭区域：</p><p><span class="math display">\[\Delta A_1,\Delta A_2,\cdots,\Delta A_i,\cdots,\Delta A_n\]</span></p><p>其中<span class="math inline">\(\Delta A_i\)</span>表示第<span class="math inline">\(i\)</span>个小闭区域，也表示它的面积，规定<span class="math inline">\(\Delta A_i\)</span>中最长的直径（一个闭区域的直径是指区域上任意两点间距离的最大者）为<span class="math inline">\(\lambda\)</span>，在每个<span class="math inline">\(\Delta A_i\)</span>内任取一点<span class="math inline">\((x_i,y_i)\)</span>，可以得到级数：</p><p><span class="math display">\[\sum_{i=0}^{n}f(x_i,y_i)\Delta A_i\]</span></p><p>如果当<span class="math inline">\(\lambda\to 0\)</span>时，无论如何划分闭区域<span class="math inline">\(D\)</span>，无论怎样选取<span class="math inline">\((x_i,y_i)\)</span>，该级数的极限总是存在，那么称此极限为函数<span class="math inline">\(f(x,y)\)</span>在闭区域<span class="math inline">\(D\)</span>上的二重积分，记作：</p><p><span class="math display">\[\iint_{D} f(x, y) \mathrm{d} A=\lim _{\lambda \rightarrow 0} \sum_{i=0}^{n} f\left(x_{i}, y_{i}\right) \Delta A_{i}\]</span></p><p>其中<span class="math inline">\(f(x,y)\)</span>称为被积函数，<span class="math inline">\(\mathrm{d}A\)</span>称为面积微分，<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>称为积分变量，<span class="math inline">\(D\)</span>称为积分区域。</p><h2 id="二重积分的性质">二重积分的性质</h2><p>设<span class="math inline">\(f(x,y)，g(x,y)\)</span>都是有界闭区域<span class="math inline">\(D\)</span>上的有界函数，<span class="math inline">\(\alpha、\beta\)</span>为常数，则：</p><ul><li><p>齐次性： <span class="math display">\[  \iint_{D} \alpha f(x, y) \mathrm{d} A=\alpha \iint_{D} f(x, y)  \mathrm{d} A  \]</span></p></li><li><p>可加性： <span class="math display">\[  \iint_{D}(f(x, y)+g(x, y)) \mathrm{d} A=\iint_{D} f(x, y) \mathrm{d} A+\iint_{D} g(x, y) \mathrm{d} A  \]</span></p></li><li><p>推论： <span class="math display">\[  \iint_{D}(\alpha f(x, y) \pm \beta g(x, y)) \mathrm{d} A=\alpha \iint_{D} f(x, y) \mathrm{d} A \pm \beta \iint_{D} g(x, y) \mathrm{d} A  \]</span></p></li><li><p>区域可加性： 如果闭区域<span class="math inline">\(D\)</span>被有限条曲线分为有限个部分闭区域，那么<span class="math inline">\(D\)</span>上的二重积分等于各部分闭区域上的二重积分之和。</p></li><li><p>二重积分中值定理： 设函数<span class="math inline">\(f(x,y)\)</span>在闭区域<span class="math inline">\(D\)</span>上连续，<span class="math inline">\(A\)</span>是区域<span class="math inline">\(D\)</span>的面积，则在<span class="math inline">\(D\)</span>上至少存在一点<span class="math inline">\((\xi,\mu)\)</span>，使得： <span class="math display">\[  \iint_{D} f(x, y) \mathrm{d} A=f(\xi, \mu) A  \]</span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/DoubleIntegralMeanValueTheorem.png"></p></li></ul><h2 id="二重积分法">二重积分法</h2><h3 id="弱富比尼定理">弱富比尼定理</h3><p>设有矩形区域<span class="math inline">\(R\)</span>：</p><p><span class="math display">\[R=\{(x,y)|a\le x\le b,c\le y\le d\}\]</span></p><p>若<span class="math inline">\(f(x,y)\)</span>在区域<span class="math inline">\(R\)</span>上连续，则：</p><p><span class="math display">\[\iint_{R} f(x, y) \mathrm{d} A=\int_{c}^{d}\left[\int_{a}^{b} f(x, y) \mathrm{d} x\right] \mathrm{d} y=\int_{a}^{b}\left[\int_{c}^{d} f(x, y) \mathrm{d} y\right] \mathrm{d} x\]</span></p><p>将二重积分变为，先积 x 后积 y（或先积 y 后积 x）的二次积分。</p><h3 id="强富比尼定理">强富比尼定理</h3><p>若<span class="math inline">\(f(x,y)\)</span>在区域<span class="math inline">\(D\)</span>上连续：</p><ul><li>若区域 D 为<span class="math inline">\(a \le x \le b, g_1(x) \le y \le g_2(x)\)</span>，其中<span class="math inline">\(g_1、g_2\)</span>在<span class="math inline">\([a,b]\)</span>上连续，则：</li></ul><p><span class="math display">\[\iint_{D} f(x, y) \mathrm{d} A=\int_{a}^{b}\left[\int_{g_{1}(x)}^{g_{2}(x)} f(x, y) \mathrm{d} y\right] \mathrm{d} x\]</span></p><ul><li>若区域 D 为<span class="math inline">\(c \le y \le d, h_1(y) \le x \le h_2(y)\)</span>，其中<span class="math inline">\(h_1、h_2\)</span>在<span class="math inline">\([c,d]\)</span>上连续，则：</li></ul><p><span class="math display">\[\iint_{D} f(x, y) \mathrm{d} A=\int_{c}^{d}\left[\int_{h_{1}(y)}^{h_{2}(y)} f(x, y) \mathrm{d} x\right] \mathrm{d} y\]</span></p><p>可见，和富比尼定理的较弱形式不一样，这里是不能交换积分顺序的。</p><h3 id="坐标系变换">坐标系变换</h3><p>有时候切换一下坐标系问题会变得简单的多，为此研究在坐标变换后的多重积分也是很有价值的。</p><p>在区域 D 上，如果<span class="math inline">\(xy\)</span>直角坐标系和<span class="math inline">\(uv\)</span>直角坐标系之间存在如下的坐标变换函数，且<span class="math inline">\(x(u,v)、y(u,v)\)</span>在区域 D 上有一阶连续偏导数（这是为了保证可以找到最佳线性近似）：</p><p><span class="math display">\[\begin{cases}    x=x(u,v)\\    y=y(u,v)\end{cases}\]</span></p><p>如果雅可比行列式存在且不为 0：</p><p><span class="math display">\[|J|=|\frac{\partial(x,y)}{\partial(u,v)}|=\begin{vmatrix}\frac{\partial x}{\partial u }&amp;\frac{\partial x}{\partial v}\\\frac{\partial y}{\partial u}&amp;\frac{\partial y}{\partial v}\end{vmatrix}\ne 0\]</span></p><p>则区域 D 上在<span class="math inline">\(xy\)</span>直角坐标系下的面积为：</p><p><span class="math display">\[\iint_{D} \mathrm{~d} x \mathrm{~d} y=\iint_{D}\|J\| \mathrm{d} u \mathrm{~d} v\]</span></p><p>所以，<span class="math inline">\(z=f(x,y)\)</span>在区域 D 上的体积为（在<span class="math inline">\(xyz\)</span>直角坐标系下的体积）：</p><p><span class="math display">\[\iint_{D} f(x, y) \mathrm{d} x \mathrm{~d} y=\iint_{D} f(x(u, v), y(u, v))\|J\| \mathrm{d} u \mathrm{~d} v\]</span></p><h2 id="三重积分">三重积分</h2><p>设<span class="math inline">\(f(x,y,z)\)</span>是有界闭区域<span class="math inline">\(\Omega\)</span>上的有界函数，将闭区域<span class="math inline">\(\Omega\)</span>任意分成<span class="math inline">\(n\)</span>个小闭区域：</p><p><span class="math display">\[\Delta V_1,\Delta V_2,\cdots,\Delta V_i,\cdots,\Delta V_n\]</span></p><p>其中<span class="math inline">\(\Delta V_i\)</span>表示第<span class="math inline">\(i\)</span>个小闭区域，也表示它的体积，规定<span class="math inline">\(\Delta V_i\)</span>中最大的体积为<span class="math inline">\(\lambda\)</span>：</p><p><span class="math display">\[\lambda=\max(\Delta V_i)\]</span></p><p>在每个<span class="math inline">\(\Delta V_i\)</span>内任取一点<span class="math inline">\((\xi_i,\mu_i,\zeta_i)\)</span>，可以得到级数：</p><p><span class="math display">\[\sum_{i=0}^{n}f(\xi_i,\mu_i,\zeta_i)\Delta V_i\]</span></p><p>如果当<span class="math inline">\(\lambda\to 0\)</span>时，无论如何划分闭区域<span class="math inline">\(\Omega\)</span>，无论怎样选取<span class="math inline">\((\xi_i,\mu_i,\zeta_i)\)</span>，该级数的极限总是存在，那么称此极限为函数<span class="math inline">\(f(x,y,z)\)</span>在闭区域<span class="math inline">\(\Omega\)</span>上的三重积分，记作：</p><p><span class="math display">\[\iiint_{\Omega} f(x, y, z) \mathrm{d} V=\lim _{\lambda \rightarrow 0} \sum_{i=0}^{n} f\left(\xi_{i}, \mu_{i}, \zeta_{i}\right) \Delta V_{i}\]</span></p><p>其中<span class="math inline">\(f(x,y,z)\)</span>称为被积函数，<span class="math inline">\(\mathrm{d}V\)</span>称为体积微分，<span class="math inline">\(x、y\)</span>以及<span class="math inline">\(z\)</span>称为积分变量，<span class="math inline">\(\Omega\)</span>称为积分区域。</p><h2 id="三重积分法">三重积分法</h2><h3 id="富比尼定理">富比尼定理</h3><p>区域 E 可以表示为： <span class="math display">\[E=\{(x,y,z)|a\le x\le b,g_1(x)\le y\le g_2(x), u_1(x,y)\le z\le u_2(x,y)\}\]</span></p><p>那么通过富比尼定理，函数<span class="math inline">\(f(x,y,z)\)</span>在区域 E 上的三重积分可以如下计算：</p><p><span class="math display">\[\begin{aligned}\iiint_{E} f(x, y, z) \mathrm{d} V &amp;=\iint_{D}\left[\int_{u_{1}(x, y)}^{u_{2}(x, y)} f(x, y, z) \mathrm{d} z\right] \mathrm{d} A \\&amp;=\int_{a}^{b} \int_{g_{1}(x)}^{g_{2}(x)} \int_{u_{1}(x, y)}^{u_{2}(x, y)} f(x, y, z) \mathrm{d} z \mathrm{~d} y \mathrm{~d} x\end{aligned}\]</span></p><p>这样就将三重积分划为了方便计算的三次积分。</p><h3 id="坐标系变换-1">坐标系变换</h3><p>同样变换坐标系是为了简化问题。这里直接给出坐标系变换积分公式：</p><ul><li><p>柱面坐标系的体积微分： 通过雅可比行列式<span class="math inline">\(|J|\)</span>，可得柱面坐标系函数<span class="math inline">\(w=f(\rho,\theta,z)\)</span>在区域 <span class="math inline">\(\Omega\)</span>上的三重积分为：</p><p><span class="math display">\[  \begin{aligned}  \iiint_{\Omega} f(\rho, \theta, z) \mathrm{d} V &amp;=\iiint_   {\Omega} f(\rho, \theta, z)\|J\| \mathrm{d} \rho \mathrm{d}    \theta \mathrm{d} z \\  &amp;=\iiint_{\Omega} f(\rho, \theta, z) \rho \mathrm{d} \rho   \mathrm{d} \theta \mathrm{d} z  \end{aligned}  \]</span></p><p>其中<span class="math inline">\(\rho\mathrm{d}\rho\mathrm{d}\theta\mathrm{d}z\)</span>称为柱面坐标系的 体积微分。</p></li><li><p>球面坐标系的体积微分： 通过雅可比行列式<span class="math inline">\(|J|\)</span>，可得球面坐标系函数<span class="math inline">\(w=f(r,\varphi,\theta)\)</span>在区域<span class="math inline">\(\Omega\)</span>上的三重积分为： <span class="math display">\[  \begin{aligned}  \iiint_{\Omega} f(r, \varphi, \theta) \mathrm{d} V &amp;=\iiint_    {\Omega} f(r, \varphi, \theta)\|J\| \mathrm{d} r \mathrm{~d}    \varphi \mathrm{d} \theta \\  &amp;=\iint_{\Omega} \iint(r, \varphi, \theta) r^{2} \sin \varphi   \mathrm{d} r \mathrm{~d} \varphi \mathrm{d} \theta  \end{aligned}  \]</span></p><p>其中<span class="math inline">\(r^2\sin\varphi\mathrm{d}r\mathrm{d}\varphi\mathrm{d}\theta\)</span>称为球面坐标系的体积微分。</p></li></ul><h1 id="曲线积分与曲面积分">曲线积分与曲面积分</h1><h2 id="第一类曲线积分">第一类曲线积分</h2><p>设<span class="math inline">\(L\)</span>为<span class="math inline">\(xOy\)</span>面内的一条光滑曲线弧，函数<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\(L\)</span>上有界。在<span class="math inline">\(L\)</span>上任意插入一点列<span class="math inline">\(P_0、P_1，\cdots、P_{n}\)</span>，把<span class="math inline">\(L\)</span>分成<span class="math inline">\(n\)</span>个小段。设第<span class="math inline">\(k\)</span>个小段的长度为<span class="math inline">\(\Delta s_k\)</span>。又<span class="math inline">\((\xi_k,\eta_k)\)</span>为第<span class="math inline">\(k\)</span>个小段上任意取定的一点，做乘积<span class="math inline">\(f(\xi_k,\eta_k)\Delta s_k\)</span>，并作和：</p><p><span class="math display">\[\sum_{k=1}^{n}f(\xi_k,\eta_k)\Delta s_k\]</span></p><p>如果当各小弧段的长度的最大值<span class="math inline">\(\lambda\to 0\)</span>时，这和的极限总是存在，且与曲线<span class="math inline">\(L\)</span>的分法及点<span class="math inline">\((\xi_k,\eta_k)\)</span>的取法无关，那么称此极限为函数<span class="math inline">\(f(x,y)\)</span>在曲线<span class="math inline">\(L\)</span>上的第一类曲线积分，记作：</p><p><span class="math display">\[\int_L f(x,y)\mathrm{d}s=\lim_{\lambda\to 0}\sum_{k=1}^{n}f(\xi_k,\eta_k)\Delta s_k\]</span></p><p>其中<span class="math inline">\(\mathrm{d}s\)</span>称为弧微分。</p><ul><li><p>物理意义： 第一类曲线积分的物理意义还是很明显的，之前介绍过，如果<span class="math inline">\(\mu(x,y)\)</span>是曲线<span class="math inline">\(L\)</span>的密度函数时，如下计算的是曲线质量： <span class="math display">\[  m=\int_L \mu(x,y)\mathrm{d}s  \]</span> 而如果<span class="math inline">\(\delta(x,y)\)</span>是曲线<span class="math inline">\(L\)</span>的电荷密度函数，那么如下计算的就是曲线的电荷量： <span class="math display">\[  c=\int_L \delta(x,y)\mathrm{d}s  \]</span></p></li><li><p>几何意义： 第一类曲线积分<span class="math inline">\(\int_L f(x,y)\mathrm{d}s\)</span>的几何意义就是求曲线 L 与曲面<span class="math inline">\(z=f(x,y)\)</span>之间的面积：</p></li><li>性质：<ul><li><p>性质 1：设<span class="math inline">\(\alpha、\beta\)</span>为常数，则： <span class="math display">\[  \int_L[\alpha f(x,y)+\beta g(x,y)]\mathrm{d}s=\alpha\int_L f(x,y)\mathrm{d}s+\beta\int_L g(x,y)\mathrm{d}s  \]</span></p></li><li><p>性质 2：设光滑曲线<span class="math inline">\(L\)</span>可分为两个光滑曲线<span class="math inline">\(L_1\)</span>和<span class="math inline">\(L_2\)</span>，则： <span class="math display">\[  \int_L f(x,y)\mathrm{d}s=\int_{L_1} f(x,y)\mathrm{d}s+\int_{L_2} f(x,y)\mathrm{d}s  \]</span></p></li><li><p>性质 3：设在光滑曲线 L 上有<span class="math inline">\(f(x,y)\le g(x,y)\)</span>，则： <span class="math display">\[  \int_L f(x,y)\mathrm{d}s\le\int_{L} g(x,y)\mathrm{d}s  \]</span></p></li></ul></li></ul><h2 id="第二类曲线积分">第二类曲线积分</h2><p>设<span class="math inline">\(L\)</span>为<span class="math inline">\(xOy\)</span>面内从<span class="math inline">\(A\)</span>点到<span class="math inline">\(B\)</span>点的一条光滑曲线弧，函数<span class="math inline">\(P(x,y)、Q(x,y)\)</span>在<span class="math inline">\(L\)</span>上有界。在<span class="math inline">\(L\)</span>上任意插入一点列<span class="math inline">\(P_0、P_1，\cdots、P_{n}\)</span>，把<span class="math inline">\(L\)</span>分成<span class="math inline">\(n\)</span>个有向小弧段：</p><p><span class="math display">\[\overbrace{P_{k-1} P_{k}}, \quad\left(k=1,2, \cdots, n, P_{0}=A, P_{n}=B\right)\]</span></p><p>设<span class="math inline">\(\Delta x_k=x_k-x_{k-1}，\Delta y_k=y_k-y_{k-1}\)</span>，点<span class="math inline">\((\xi_k,\eta_k)\)</span>为<span class="math inline">\(\overbrace{P_{k-1} P_{k}}\)</span>上任意取定的点，做乘积<span class="math inline">\(P(\xi_k,\eta_k)\Delta x_i\)</span>，并作和：</p><p><span class="math display">\[\sum_{k=1}^{n}P(\xi_k,\eta_k)\Delta x_k,\quad \sum_{k=1}^{n}Q(\xi_k,\eta_k)\Delta y_k\]</span></p><p>如果当各小弧段的长度的最大值<span class="math inline">\(\lambda\to 0\)</span>时，和的极限总是存在，且与曲线<span class="math inline">\(L\)</span>的分法及点<span class="math inline">\((\xi_k,\eta_k)\)</span>的取法无关，就称这两个极限为<span class="math inline">\(P(x,y)\)</span>在有向曲线<span class="math inline">\(\ L\)</span> 上对坐标<span class="math inline">\(\ x\)</span> 的曲线积分：</p><p><span class="math display">\[\int_L P(x,y)\mathrm{d}x=\lim_{\lambda\to 0}\sum_{k=1}^{n}P(\xi_k,\eta_k)\Delta x_k\]</span></p><p>以及<span class="math inline">\(Q(x,y)\)</span>在有向曲线<span class="math inline">\(\ L\)</span> 上对坐标<span class="math inline">\(\ y\)</span> 的曲线积分：</p><p><span class="math display">\[\int_L Q(x,y)\mathrm{d}y=\lim_{\lambda\to 0}\sum_{k=1}^{n}Q(\xi_k,\eta_k)\Delta y_k\]</span></p><p>以上两个积分也称为第二类曲线积分。</p><ul><li>性质：<ul><li><p>性质 1：设<span class="math inline">\(\alpha、\beta\)</span>为常数，则： <span class="math display">\[  \int_L[\alpha\boldsymbol{F_1}(x,y)+\beta\boldsymbol{F_2}(x,y)]\cdot\mathrm{d}\boldsymbol{s}=\alpha\int_L\boldsymbol{F_1}(x,y)\cdot\mathrm{d}\boldsymbol{s}+\beta\int_L\boldsymbol{F_2}(x,y)\cdot\mathrm{d}\boldsymbol{s}  \]</span></p></li><li><p>性质 2：设有向光滑曲线<span class="math inline">\(L\)</span>可分为两个光滑有向曲线<span class="math inline">\(L_1\)</span>和<span class="math inline">\(L_2\)</span>，则： <span class="math display">\[  \int_L \boldsymbol{F}(x,y)\cdot\mathrm{d}\boldsymbol{s}=\int_{L_1} \boldsymbol{F}(x,y)\cdot\mathrm{d}\boldsymbol{s}+\int_{L_2}\boldsymbol{F}(x,y)\cdot\mathrm{d}\boldsymbol{s}  \]</span></p></li><li><p>性质 3：设<span class="math inline">\(L\)</span>是有向光滑曲线，<span class="math inline">\(L^-\)</span>是<span class="math inline">\(L\)</span>的反向曲线，则： <span class="math display">\[  \int_L \boldsymbol{F}(x,y)\cdot\mathrm{d}\boldsymbol{s}=-\int_{L^-} \boldsymbol{F}(x,y)\cdot\mathrm{d}\boldsymbol{s}  \]</span></p></li></ul></li></ul><h2 id="两类曲线积分的关系">两类曲线积分的关系</h2><h3 id="区别">区别</h3><ul><li>第一类曲线积分针对的是曲线，而第二类曲线积分针对的是有向曲线。</li><li>第一类曲线积分，作用在曲线上的是标量；而第二类曲线积分，作用在曲线上的是向量。</li></ul><h3 id="联系">联系</h3><p>因为弧微分和有向弧微分的关系为<span class="math inline">\(\boldsymbol{\tau}\mathrm{d}s=\mathrm{d}\boldsymbol{s}\)</span>，所以：</p><p><span class="math display">\[\int_L \boldsymbol{F}\cdot\boldsymbol{\tau}\mathrm{d}s=\int_L \boldsymbol{F}\cdot\mathrm{d}\boldsymbol{s}\]</span></p><p>左边为第一类曲线积分，右边为第二类曲线积分，可见这两类积分是可以互相转化的。</p><h2 id="二维的散度和旋度">二维的散度和旋度</h2><h3 id="通量">通量</h3><p>在连续向量场<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}\)</span>中的光滑闭曲线<span class="math inline">\(L\)</span>，<span class="math inline">\(\boldsymbol{n}\)</span>为光滑闭曲线<span class="math inline">\(L\)</span>的单位法向量（指向闭曲线外部），则<span class="math inline">\(\boldsymbol{F}\)</span>穿过<span class="math inline">\(L\)</span>的流量，即通量为：</p><p><span class="math display">\[\oint_{L} \boldsymbol{F}\cdot\boldsymbol{n}\mathrm{d}s=\oint_{L}P\mathrm{d}y-Q\mathrm{d}x\]</span></p><p>需要注意的是，上式从第一类曲线积分变为了第二类曲线积分，曲线的方向为逆时针。</p><h3 id="散度">散度</h3><p>已知水流量为向量场<span class="math inline">\(\boldsymbol{F}\)</span>。用曲线<span class="math inline">\(L_A\)</span>来表示 A 圆，那么 A 圆的通量为：</p><p><span class="math display">\[T_A=\oint_{L_A} \boldsymbol{F}\cdot\boldsymbol{n}\mathrm{d}s\]</span></p><p>假设 A 圆对应的面积为<span class="math inline">\(\Omega_A\)</span>，圆缩到最小即<span class="math inline">\(\Omega_A\to 0\)</span>，同时再除上面积<span class="math inline">\(\Omega_A\)</span>，就得到了<span class="math inline">\(A\)</span>点在向量场<span class="math inline">\(\boldsymbol{F}\)</span>中的通量密度，也称为 A 点在向量场<span class="math inline">\(\boldsymbol{F}\)</span>中的散度，即：</p><p><span class="math display">\[\operatorname{div}\boldsymbol{F}(A)=\lim_{\Omega_A\to 0}\frac{1}{\Omega_A}\oint_{L_A} \boldsymbol{F}\cdot\boldsymbol{n}\mathrm{d}s\]</span></p><p>同样的，也可以算出 C 点的散度<span class="math inline">\(\operatorname{div}\boldsymbol{F}(C)\)</span>，两者谁大，就说明哪个水龙头的出水量更大。</p><h3 id="环量">环量</h3><p>在连续向量场<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}\)</span>中的光滑闭曲线<span class="math inline">\(L\)</span>，<span class="math inline">\(\boldsymbol{\tau}\)</span>为光滑闭曲线<span class="math inline">\(L\)</span>的单位切向量<span class="math inline">\(\boldsymbol{\tau}\)</span>（指向逆时针方向），则<span class="math inline">\(\boldsymbol{F}\)</span>对于<span class="math inline">\(L\)</span>的环量为：</p><p><span class="math display">\[\oint_{L} \boldsymbol{F}\cdot\boldsymbol{\tau}\mathrm{d}s=\oint_{L}P\mathrm{d}x+Q\mathrm{d}y\]</span></p><p>需要注意的是，上式从第一类曲线积分变为了第二类曲线积分，曲线的方向为逆时针。</p><h3 id="旋度">旋度</h3><p>已知水流量为向量场<span class="math inline">\(\boldsymbol{F}\)</span>。用曲线<span class="math inline">\(L_A\)</span>来表示<span class="math inline">\(A\)</span>圆，那么<span class="math inline">\(A\)</span>圆的环量为：</p><p><span class="math display">\[H_A=\oint_{L_A} \boldsymbol{F}\cdot\boldsymbol{\tau}\mathrm{d}s\]</span></p><p>可见，环量会受到圆的大小的影响，所以来排除掉这个影响。假设 A 圆对应的面积为<span class="math inline">\(\Omega_A\)</span>，圆缩到最小即<span class="math inline">\(\Omega_A\to 0\)</span>，同时再除上面积<span class="math inline">\(\Omega_A\)</span>，就得到了<span class="math inline">\(A\)</span>点在向量场<span class="math inline">\(\boldsymbol{F}\)</span>中的环量密度，也称为<span class="math inline">\(A\)</span>点在向量场<span class="math inline">\(\boldsymbol{F}\)</span>中的旋度，即：</p><p><span class="math display">\[\operatorname{curl}\boldsymbol{F}(A)=\lim_{\Omega_A\to 0}\frac{1}{\Omega_A}\oint_{L_A} \boldsymbol{F}\cdot\boldsymbol{\tau}\mathrm{d}s\]</span></p><h2 id="格林公式">格林公式</h2><h3 id="格林公式的通量形式">格林公式的通量形式：</h3><p>某光滑闭曲线 L 围成闭区域 D，定义在闭区域 D 上的向量场<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}\)</span>，它的分量具有一阶连续偏导数，则<span class="math inline">\(\boldsymbol{F}\)</span>关于 L 的通量，可通过闭区域 D 上的散度求出：</p><p><span class="math display">\[\underbrace{\oint_{L} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} s=\oint_{L} P \mathrm{~d} y-Q \mathrm{~d} x}_{\text {闭曲线的通量 }}=\underbrace{\iint_{D} \frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y} \mathrm{~d} x \mathrm{~d} y}_{\text {闭曲线围成区域的通量之和 }}\]</span></p><h3 id="格林公式的环量形式">格林公式的环量形式：</h3><p>某光滑闭曲线 L 围成闭区域 D，定义在闭区域 D 上的向量场<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}\)</span>，它的分量具有一阶连续偏导数，则<span class="math inline">\(\boldsymbol{F}\)</span>关于 L 的环量，可通过闭区域 D 上的旋度求出：</p><p><span class="math display">\[\underbrace{\oint_{L} \boldsymbol{F} \cdot \boldsymbol{\tau} \mathrm{d} s=\oint_{L} P \mathrm{~d} x+Q \mathrm{~d} y}_{\text {闭曲线的环量 }}=\underbrace{\iint_{D} \frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y} \mathrm{~d} x \mathrm{~d} y}_{\text {闭曲线围成区域的环量之和 }}\]</span></p><h3 id="二重积分的基本定理">二重积分的基本定理</h3><p><span class="math display">\[\iint_{D} \frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y} \mathrm{~d} x \mathrm{~d} y=\oint_{\partial D} P \mathrm{~d} y-Q \mathrm{~d} x\]</span></p><h2 id="第一类曲面积分">第一类曲面积分</h2><p>设<span class="math inline">\(\Sigma\)</span>为三维空间中的一个光滑曲面，函数<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\(\Sigma\)</span>上有界。把<span class="math inline">\(\Sigma\)</span>上任意分为<span class="math inline">\(n\)</span>个小曲面，第<span class="math inline">\(k\)</span>个小曲面为<span class="math inline">\(\Delta S_k\)</span>（该小曲面的面积也同样由<span class="math inline">\(\Delta S_k\)</span>来表示）。设 (<span class="math inline">\(\xi_k,\eta_k\)</span>) 是<span class="math inline">\(\Delta S_k\)</span>上任意取的一点，做乘积<span class="math inline">\(f(\xi_k,\eta_k)\Delta S_k\)</span>，并作和：</p><p><span class="math display">\[\sum_{k=1}^{n}f(\xi_k,\eta_k)\Delta S_k\]</span></p><p>如果当各小曲面的面积的最大值<span class="math inline">\(\lambda\to 0\)</span>时，和的极限总是存在，且与曲面<span class="math inline">\(\Sigma\)</span>的分法及点<span class="math inline">\((\xi_k,\eta_k)\)</span>的取法无关，就称这此极限为<span class="math inline">\(f(x,y)\)</span>在曲面<span class="math inline">\(\Sigma\)</span>上的第一类曲面积分：</p><p><span class="math display">\[\iint_{\Sigma} f(x, y) \mathrm{d} S=\lim _{\lambda \rightarrow 0} \sum_{k=1}^{n} f\left(\xi_{k}, \eta_{k}\right) \Delta S_{k}\]</span></p><p>其中<span class="math inline">\(\mathrm{d}S\)</span>称为曲面微分。</p><h2 id="第二类曲面积分">第二类曲面积分</h2><p>假设太阳表面为闭球面<span class="math inline">\(\Sigma\)</span>，将所有的小曲面的通量加起来就得到闭球面<span class="math inline">\(\Sigma\)</span>的通量，也就是太阳的通量：</p><p><span class="math display">\[\iint_{\Sigma} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} S\]</span></p><p>其中单位法向量<span class="math inline">\(\boldsymbol{n}\)</span>和面积微分<span class="math inline">\(\mathrm{d}S\)</span>组成了有向曲面，也称为有向面积微分：</p><p><span class="math display">\[\boldsymbol{n}\mathrm{d}S=\mathrm{d}\boldsymbol{S}\]</span></p><p>所以闭球面<span class="math inline">\(\Sigma\)</span>的通量又可以写作：</p><p><span class="math display">\[\iint_{\Sigma} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} S=\iint_{\Sigma} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{S}\]</span></p><p>上述积分是向量场<span class="math inline">\(\boldsymbol{F}\)</span>在有向面积<span class="math inline">\(\Sigma\)</span>上的积分，称为第二类曲面积分。</p><h2 id="三维的散度和旋度">三维的散度和旋度</h2><h3 id="散度-1">散度</h3><p>假设闭曲面<span class="math inline">\(\Sigma\)</span>围成的体积为<span class="math inline">\(V\)</span>，和二维的情况一样，通量的密度就是散度：</p><p><span class="math display">\[\operatorname{div} \boldsymbol{F}=\lim _{V \rightarrow 0} \frac{1}{V} \oiint_{\Sigma} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} S\]</span></p><p>假设向量场为<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}+R\boldsymbol{k}\)</span>，可以证明散度还有一个偏导形式（较复杂，证明略）：</p><p><span class="math display">\[\operatorname{div}\boldsymbol{F}=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\]</span></p><h3 id="旋度-1">旋度</h3><p>假设三维向量场为<span class="math inline">\(\boldsymbol{F}=P\boldsymbol{i}+Q\boldsymbol{j}+R\boldsymbol{k}\)</span>，那么以下向量就为三维空间中的旋度：</p><p><span class="math display">\[\operatorname{curl}\boldsymbol{F}=\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right)\boldsymbol{i}+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right)\boldsymbol{j}+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)\boldsymbol{k}\]</span></p><p>该向量的模就是环量密度，方向就是旋转轴向量。</p><h2 id="格林公式新形式">格林公式新形式</h2><p>通过<span class="math inline">\(\nabla\)</span>算子，格林公式的通量形式可以改写为：</p><p><span class="math display">\[\oint_{\partial D} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} s=\iint_{D} \nabla \cdot \boldsymbol{F} \mathrm{d} A\]</span></p><p>环量形式可以改写为：</p><p><span class="math display">\[\oint_{\partial D} \boldsymbol{F} \cdot \boldsymbol{\tau} \mathrm{d} s=\iint_{D} \nabla \times \boldsymbol{F} \cdot \boldsymbol{k} \mathrm{d} A\]</span></p><p>环量公式中的<span class="math inline">\(\boldsymbol{k}\mathrm{d}A\)</span>，其中<span class="math inline">\(\mathrm{d}A\)</span>指的是<span class="math inline">\(xy\)</span>面上的平面，<span class="math inline">\(\boldsymbol{k}\)</span>是<span class="math inline">\(z\)</span>轴的单位方向向量，也就是<span class="math inline">\(\mathrm{d}A\)</span>的单位法向量：</p><p>因此<span class="math inline">\(\boldsymbol{k}\mathrm{d}A\)</span>其实表示的是有向平面：</p><p><span class="math display">\[\boldsymbol{k}\mathrm{d}A=\mathrm{d}\boldsymbol{A}\]</span></p><p>进而，格林公式的环量形式还可以改写为第二类曲面积分的形式：</p><p><span class="math display">\[\oint_{\partial D} \boldsymbol{F} \cdot \boldsymbol{\tau} \mathrm{d} s=\iint_{D} \nabla \times \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{A}\]</span></p><h2 id="高斯公式和斯托克斯公式">高斯公式和斯托克斯公式</h2><h3 id="高斯公式">高斯公式</h3><p>存在有向光滑闭曲面（或者由几片有向光滑曲面组成）<span class="math inline">\(\partial\Omega\)</span>，该曲面的正方向<span class="math inline">\(\boldsymbol{n}\)</span>指向外部。闭曲面<span class="math inline">\(\partial\Omega\)</span>围成空间闭区域<span class="math inline">\(\Omega\)</span>，在该闭区域<span class="math inline">\(\Omega\)</span>上定义有向量函数<span class="math inline">\(\boldsymbol{F}\)</span>，它的各个分量具有一阶连续偏导数。那么有：</p><p><span class="math display">\[\underbrace{\int_{\boldsymbol{F}} \boldsymbol{F} \cdot \boldsymbol{n d} S}_{\partial \int_{\text {闭曲面的通量 }}}=\underbrace{\iiint_{\Omega} \operatorname{div} \boldsymbol{F} \mathrm{d} V=\iiint_{\Omega} \nabla \cdot \boldsymbol{F} \mathrm{d} V}_{\text {闭曲面围成区域的通量之和 }}\]</span></p><p>该定理称为高斯公式或者散度定理。</p><h3 id="斯托克斯公式">斯托克斯公式</h3><p>假设存在有向光滑闭曲线（或者由几个有向光滑曲线组成）<span class="math inline">\(\partial\Sigma\)</span>，该有向曲线<span class="math inline">\(\partial\Sigma\)</span>为有向光滑曲面（或者由几个有向光滑曲面组成）<span class="math inline">\(\Sigma\)</span>的边界，且有向曲线<span class="math inline">\(\partial\Sigma\)</span>的方向<span class="math inline">\(\boldsymbol{\tau}与、Sigma\)</span>的正向<span class="math inline">\(\boldsymbol{n}\)</span>符合右手法则。在该有向曲面<span class="math inline">\(\Sigma\)</span>上定义有向量函数<span class="math inline">\(\boldsymbol{F}\)</span>，它的各个分量具有一阶连续偏导数。那么有：</p><p><span class="math display">\[\underbrace{\oint_{\partial \Sigma} \boldsymbol{F} \cdot \boldsymbol{d} s}_{\text {有向闭曲线的环量 }}=\underbrace{\iint_{\Sigma} \operatorname{curl} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{S}=\iint_{\Sigma} \nabla \times \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{S}}_{\text {有向闭曲线围成有向曲面的环量之和 }}\]</span></p><p>该定理称为斯托克斯公式。</p><h1 id="小结">小结</h1><p>在二维平面中，格林公式有两种形式，通量形式和环量形式：</p><p><span class="math display">\[\begin{gathered}\oint_{\partial D} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} s=\iint_{D} \operatorname{div} \boldsymbol{F} \mathrm{d} A=\iint_{D} \nabla \cdot \boldsymbol{F} \mathrm{d} A \\\oint_{\partial D} \boldsymbol{F} \cdot \boldsymbol{\tau} \mathrm{d} s=\iint_{D} \operatorname{curl} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{A}=\iint_{D} \nabla \times \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{A}\end{gathered}\]</span></p><p>在三维空间中，通量形式扩展为了高斯公式：</p><p><span class="math display">\[\oiint_{\partial \Omega} \boldsymbol{F} \cdot \boldsymbol{n} \mathrm{d} S=\iiint_{\Omega} \operatorname{div} \boldsymbol{F} \mathrm{d} V=\iiint_{\Omega} \nabla \cdot \boldsymbol{F} \mathrm{d} V\]</span></p><p>环量形式扩展为了斯托克斯公式：</p><p><span class="math display">\[\oint_{\partial \Sigma} \boldsymbol{F} \cdot \boldsymbol{\tau} \mathrm{d} s=\iint_{\Sigma} \operatorname{curl} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{S}=\iint_{\Sigma} \nabla \times \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{S}\]</span></p><blockquote><p>关于无穷级数这里不列出了，后面在数学物理方法中再列出。</p></blockquote><h1 id="参考文献">参考文献</h1><p>《马同学的多变量微积分课程》<br>感兴趣的可以购买他的课程，写的很好（强烈推荐）！！！</p>]]></content>
      
      
      <categories>
          
          <category> Science Thought </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分（上）</title>
      <link href="/next/2022/Science/CalculusPart1/"/>
      <url>/next/2022/Science/CalculusPart1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/advanced_mathematics.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjExZTM0N2U0MDFmZDU4N2IzYTIxZGU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="极限">极限</h1><h2 id="魏尔斯特拉斯的数列极限">魏尔斯特拉斯的数列极限</h2><p>设<span class="math inline">\({x_n}\)</span>为一数列，如果存在实数 L，对于任意给定的正实数<span class="math inline">\(\epsilon\)</span>（不论它多么小），总存在正整数 N，使得对所有的 n &gt; N 时，有：</p><p><span class="math display">\[\left|x_{n}-L\right|&lt;\epsilon\]</span></p><p>那么就称 L 是数列<span class="math inline">\({x_n}\)</span>的极限，或者称数列<span class="math inline">\({x_n}\)</span>收敛于 L，记为：</p><p><span class="math display">\[\begin{gathered}\lim _{n \rightarrow \infty} x_{n}=L \end{gathered}\]</span> 或 <span class="math display">\[\begin{gathered}x_{n} \rightarrow L(n \rightarrow \infty)\end{gathered}\]</span></p><h2 id="一般函数的极限定义">一般函数的极限定义</h2><p>设函数 f(x) 在<span class="math inline">\(\mathring{U}(x_0)\)</span>上有定义。 如果存在常数 L，对任意给定的正数<span class="math inline">\(\epsilon\)</span>（不论它多么小），总存在正数<span class="math inline">\(\delta\)</span>，使得当 x 满足不等式<span class="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>时，对应的函数值 f(x) 都满足不等式：</p><p><span class="math display">\[\left|f(x)-L\right|&lt;\epsilon\]</span></p><p>那么常数 L 就叫做函数 f(x) 当<span class="math inline">\(x\to x_0\)</span>的极限，记作：</p><p><span class="math display">\[\lim _{x \rightarrow x_{0}} f(x)=L \text { 或 } f(x) \rightarrow L\left(\text { 当 } x \rightarrow x_{0}\right)\]</span></p><h2 id="趋于pminfty的函数极限定义">趋于<span class="math inline">\(\pm\infty\)</span>的函数极限定义</h2><p>如果存在常数 L，对于任意给定的正数<span class="math inline">\(\epsilon\)</span>（不论它多么小），总存在着正数 X，使得当 x 满足不等式<span class="math inline">\(|x| &gt; X\)</span>时，对应的函数值 f(x) 满足不等式：</p><p><span class="math display">\[\left|f(x)-L\right|&lt;\epsilon\]</span></p><p>那么常数 L 就叫做函数 f(x) 当<span class="math inline">\(x\to\pm\infty\)</span>时的极限，记做：</p><p><span class="math display">\[\lim _{x \rightarrow \pm \infty} f(x)=L\]</span></p><h2 id="无穷小与无穷大">无穷小与无穷大</h2><p>对于数列<span class="math inline">\(a={a_n}\)</span>，如果满足：</p><p><span class="math display">\[\lim _{n \rightarrow \infty} a_{n}=0\]</span></p><p>则称数列 a 为<span class="math inline">\(n\to\infty\)</span>时的无穷小。</p><p>对于函数<span class="math inline">\(f(x)\)</span>，如果满足：</p><p><span class="math display">\[\lim f(x)=0\]</span></p><p>则称函数<span class="math inline">\(f(x)\)</span>为此自变量变化过程（指<span class="math inline">\(x\to x_0,x\to+\infty\)</span>等）的无穷小。</p><p>设函数<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>的某一去心邻域内有定义，如果对于任意给定的正数 M（不论它多么大），总存在正数<span class="math inline">\(\delta\)</span>，只要<span class="math inline">\(x\)</span>适合不等式<span class="math inline">\(0 &lt; |x-x_0| &lt; \delta\)</span>，对应的函数值<span class="math inline">\(f(x)\)</span>总满足不等式</p><p><span class="math display">\[f(x) &gt; M\]</span></p><p>那么有：</p><p><span class="math display">\[\lim _{x \rightarrow x_{0}} f(x)=+\infty\]</span></p><blockquote><p>这里有一个怪胎 0，0 到底是不是无穷小呢？在同济大学的高等数学教材里将 0 视为无穷小。因为它把常数 0 看作常值函数<span class="math inline">\(f(x)\equiv 0\)</span>。但是我个人非常不喜欢把 0 视为无穷小，第一：无穷小不是一个实数，不然就可以通过除以二得到比他更接近 0 的数，而无穷小是最接近 0 的。第二：我们在微积分中分母经常出现无穷小，需要单独说明将 0 排除，很不爽。但是有很多时候可以将无穷小直接用 0 代替，使用上又很方便。</p></blockquote><h2 id="夹逼定理">夹逼定理</h2><p>有时候极限的求取没那么容易，这时有一种解决方案就是夹逼定理可以帮我们更好的找到数列或函数的极限：</p><p>如果满足下面两个条件：</p><p><span class="math display">\[\exists \delta&gt;0, \forall x \in \stackrel{O}{U}\left(x_{0}, \delta\right), g(x) \leq f(x) \leq h(x)\]</span></p><p><span class="math display">\[\lim _{x \rightarrow x_{0}} g(x)=\lim _{x \rightarrow x_{0}} h(x)=L\]</span></p><p>那么：</p><p><span class="math display">\[\lim _{x \rightarrow x_{0}} f(x)=L\]</span></p><p>当然数列的夹逼定理定义也类似，这里不再列出。</p><h2 id="连续和间断的定义">连续和间断的定义</h2><p>设函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>的某一邻域内有定义，如果： <span class="math display">\[\lim _{x \rightarrow x_{0}} f(x)=f\left(x_{0}\right)\]</span></p><p>那么就称函数<span class="math inline">\(f(x)\)</span>在点<span class="math inline">\(x_0\)</span>连续。</p><p>连续讨论的前提是<span class="math inline">\(f(x)\)</span>在邻域上有定义，而间断讨论的前提是<span class="math inline">\(f(x)\)</span>在去心邻域上有定义。在此前提下，如果函数有下列三种情况之一：</p><ul><li>在<span class="math inline">\(x=x_0\)</span>没有定义。</li><li>虽在<span class="math inline">\(x=x_0\)</span>有定义，但<span class="math inline">\(\lim_{x\to x_0}f(x)\)</span>不存在。</li><li>虽在<span class="math inline">\(x=x_0\)</span>有定义，且<span class="math inline">\(\lim_{x\to x_0}f(x)\)</span>存在，但<span class="math inline">\(\lim_{x\to x_0}f(x)\neq f(x_0)\)</span>。</li></ul><p>那么函数<span class="math inline">\(f(x)\)</span>在点<span class="math inline">\(x_0\)</span>为不连续，而点<span class="math inline">\(x_0\)</span>称为函数<span class="math inline">\(f(x)\)</span>的不连续点或间断点。</p><blockquote><p>所有的基本初等函数都是连续函数。基本初等函数进行有限次的四则运算和有限次的复合，得到的函数称为初等函数，初等函数也都是连续函数。</p></blockquote><h2 id="总结">总结</h2><p>在微积分中核心思想就是对自变量进行无线细分，以直代曲、无线逼近，而这些都设计无穷小量，为了对无穷小量进行定义，首先需要研究极限，无穷小量就是通过极限来定义的。极限的定义经历了柯西极限定义，直到魏尔斯特拉斯给出严格的数学定义，分为离散变量（数列）和连续变量（函数）的定义；有了极限就可以定义无穷小和无穷大。进而研究了无穷小和无穷大相关性质，最后给出研究微积分非常重要的条件连续的定义，这一切都离不开极限的定义，可以说极限的定义为微积分铺平了道路，后面的微积分你会发现无一不是极限。</p><h1 id="微分">微分</h1><h2 id="微分的定义">微分的定义</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/math_tangent.png"></p><p>一条曲线上某点的割线，当另一个交点逐渐靠近这点时，取极限就是切线，即割线的极限是切线。由上图可知：</p><p><span class="math display">\[切线的斜率 = \lim _{x \rightarrow x_{0}} \frac{f(x)-f\left(x_{0}\right)}{x-x_{0}}\]</span></p><p>这个极限就被称为导数：</p><p>设函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>的某个邻域内有定义，当自变量<span class="math inline">\(x\)</span>在<span class="math inline">\(x_0\)</span>处取得增量<span class="math inline">\(\Delta x\)</span>（点<span class="math inline">\(x_0+\Delta x\)</span>仍在该邻域内）时，相应的，因变量取得增量<span class="math inline">\(\Delta y=f(x_0+\Delta x)-f(x_0)\)</span>。 如果<span class="math inline">\(\Delta y\)</span>与<span class="math inline">\(\Delta x\)</span>之比当<span class="math inline">\(\Delta x\to 0\)</span>时的极限存在，那么称函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>处可导，并称这个极限为函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>处的导数，记为<span class="math inline">\(f'(x_0)\)</span>，即：</p><p><span class="math display">\[f^{\prime}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\]</span></p><p>有了导数<span class="math inline">\(f'(x_0)\)</span>之后，再知道切点<span class="math inline">\(A=(x_0,f(x_0))\)</span>，就可以用直线的点斜式得到切线函数：</p><p><span class="math display">\[g(x)=f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+f\left(x_{0}\right)\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/Derivative.png"></p><p><span class="math inline">\(\textrm{d}y\)</span>被称为线性增量，同理<span class="math inline">\(\Delta y\)</span>被称为曲线增量，定义了线性增量和曲线增量后，切线对曲线的近似用一个代数式就可以清楚表示：</p><p><span class="math display">\[\Delta y-\mathrm{d} y=o(\Delta x)\]</span></p><p>这个代数换个形式就是：</p><p><span class="math display">\[\lim _{\Delta x \rightarrow 0}[\Delta y-\mathrm{d} y]=0\]</span></p><p>这个代数式的意思就是，随着<span class="math inline">\(\Delta x\)</span>缩小，<span class="math inline">\(\textrm{d}y\)</span>和<span class="math inline">\(\Delta y\)</span>会无限接近：</p><p>到这里我们终于可以给出微分的定义：</p><p>设函数<span class="math inline">\(y=f(x)\)</span>在某区间内有定义，<span class="math inline">\(x_0\)</span>及<span class="math inline">\(x_0+\Delta x\)</span>在此区间内，如果函数增量：</p><p><span class="math display">\[\Delta y=f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)\]</span></p><p>可表示为：</p><p><span class="math display">\[\Delta y=A \Delta x+o(\Delta x)\]</span></p><p>其中<span class="math inline">\(A\)</span>是不依赖于<span class="math inline">\(\Delta x\)</span>的常数，那么称函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>是可微的，而<span class="math inline">\(A\Delta x\)</span>叫作函数<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x_0\)</span>相应于自变量增量<span class="math inline">\(\Delta x\)</span>的微分，记作<span class="math inline">\(\textrm{d}y\)</span>，即：</p><p><span class="math display">\[\mathrm{d} y=A \Delta x\]</span></p><h2 id="导函数">导函数</h2><p>设函数<span class="math inline">\(y=f(x)\)</span>在开区间<span class="math inline">\(I\)</span>内的每点处都可导，则称函数<span class="math inline">\(y=f(x)\)</span>在开区间<span class="math inline">\(I\)</span>内可导。 这时，对于任意<span class="math inline">\(x\in I\)</span>，都对应着<span class="math inline">\(f(x)\)</span>的一个确定的导数值，这就构成了新的函数，这个函数叫作<span class="math inline">\(y=f(x)\)</span>的导函数，记作<span class="math inline">\(y'\)</span>或<span class="math inline">\(f'(x)、\frac{\textrm{d}y}{\textrm{d}x}、\frac{\textrm{d}f(x)}{\textrm{d}x}\)</span>，定义式为：</p><p><span class="math display">\[y^{\prime}=\lim _{\Delta x \rightarrow 0} \frac{f(x+\Delta x)-f(x)}{\Delta x}\]</span></p><p>导数是某一点切线的斜率，导函数就是区间内所有点的切线的斜率构成的函数：</p><p>有了导函数后，就可以得到函数的微分：</p><p><span class="math display">\[\mathrm{d} y=f^{\prime}(x) \mathrm{d} x\]</span></p><p>所以函数的微分实际上是一个二元函数，注意区分<span class="math inline">\(x\)</span>和<span class="math inline">\(dx\)</span>，或许写成这样更明确：</p><p><span class="math display">\[\mathrm{d} y=f^{\prime}(x) \mathrm{d} x \Longrightarrow h(x, \mathrm{~d} x)=f^{\prime}(x) \mathrm{d} x\]</span></p><h2 id="求导以及导数的运算法则">求导以及导数的运算法则</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/DerivativesOfElementaryFunctions.png"></p><p>微分是导数和<span class="math inline">\(dx\)</span>的乘积，因此导数的求取及其运算法则就相当重要，关于初等函数求导法则这里不做详述，会查表即可。下面列出导数的运算法则：</p><ul><li><p>和差： <span class="math display">\[  [u(x) \pm v(x)]^{\prime}=u^{\prime}(x) \pm v^{\prime}(x)  \]</span></p></li><li><p>积： <span class="math display">\[  [u(x) v(x)]^{\prime}=u^{\prime}(x) v(x)+u(x) v^{\prime}(x)  \]</span></p></li><li><p>商： <span class="math display">\[  \left[\frac{u(x)}{v(x)}\right]^{\prime}=\frac{u^{\prime}    (x) v(x)-u(x) v^{\prime}(x)}{v^{2}(x)}(v(x) \neq 0)  \]</span></p></li><li><p>复合函数求导（链式法则）： 如果<span class="math inline">\(u=g(x)\)</span>在点<span class="math inline">\(a\)</span>可导，而<span class="math inline">\(y=f(u)\)</span>在点<span class="math inline">\(b=g(a)\)</span>可导，那么复合函 数<span class="math inline">\(y=f[g(x)]\)</span>在点<span class="math inline">\(a\)</span>可导，且其导数为：</p><p><span class="math display">\[  \frac{\mathrm{d} y}{\mathrm{~d} x}=f^{\prime}(b) g^ {\prime}(a)  \]</span></p><p>或</p><p><span class="math display">\[  \frac{\mathrm{d} y}{\mathrm{~d} x}=\frac{\mathrm{d} y}  {\mathrm{~d} u} \cdot \frac{\mathrm{d} u}{\mathrm{~d} x}  \]</span></p></li><li><p>反函数求导： 如果函数<span class="math inline">\(y=f(x)\)</span>在区间<span class="math inline">\(I\)</span>内单调、可导且<span class="math inline">\(f'(x)\neq 0\)</span>，那么它的反 函数<span class="math inline">\(f^{-1}(x)\)</span>在区间<span class="math inline">\(\{y=f(x), x\in I\}\)</span>内也可导。且：</p><p><span class="math display">\[  \left[f^{-1}(y)\right]^{\prime}=\frac{1}{f^{\prime}(x)}  \]</span></p></li><li>隐函数求导：<ul><li>第一步，对方程两边求关于 <span class="math inline">\(x\)</span>的微分，这样就可以得到一个关于 <span class="math inline">\(y'\)</span> 的 方程；</li><li>第二步，在微分后的方程中求解<span class="math inline">\(y'\)</span>既可。</li></ul></li><li><p>参数方程求导： 对于参数方程：</p><p><span class="math display">\[  \left\{\begin{array}{l}  x=x(t) \\  y=y(t)  \end{array}\right.  \]</span></p><p>其中<span class="math inline">\(x(t)\)</span>和<span class="math inline">\(y(t)\)</span>可导，且<span class="math inline">\(x(t)\)</span>单调， <span class="math inline">\(x'(t)\neq 0\)</span>，则：</p><p><span class="math display">\[  \frac{\mathrm{d} y}{\mathrm{~d} x}=\frac{y^{\prime}(t)}{x^  {\prime}(t)}  \]</span></p></li></ul><p>关于高阶导数定义和运算这里不再列出。</p><h2 id="微分相关性质">微分相关性质</h2><p>前面我们已经提到微分以及导数的定义以及如何求取，下面就是关于微分相关性质的研究了，其中最重要的就是几个中值定理。</p><ul><li><p>费马引理： <span class="math display">\[  \left.\begin{array}{c}  f(a) \text { 为极值点 } \\  x=a \text { 点可导 }  \end{array}\right\} \Longrightarrow f^{\prime}(a)=0  \]</span></p><p>这就是费马引理。</p><p>其中极值点的定义如下：</p>已知函数<span class="math inline">\(y=f(x)\)</span>，则：<ul><li><span class="math inline">\(f(a)\)</span>是极大值，当且仅当<span class="math inline">\(\exists\delta &gt; 0，\forall x\in \mathring{U}(a,\delta)\)</span>，有<span class="math inline">\(f(x) &lt; f(a)\)</span></li><li><span class="math inline">\(f(a)\)</span>是极小值，当且仅当<span class="math inline">\(\exists\delta &gt; 0，\forall x\in \mathring{U}(a,\delta)\)</span>，有<span class="math inline">\(f(x) &gt; f(a)\)</span></li></ul></li><li>罗尔中值定理： 设函数满足以下三个条件：<ul><li><span class="math inline">\(f(x)\)</span>在闭区间<span class="math inline">\([a,b]\)</span>上连续</li><li><span class="math inline">\(f(x)\)</span>在开区间<span class="math inline">\((a,b)\)</span>上可导</li><li><span class="math inline">\(f(a)=f(b)\)</span> 则存在<span class="math inline">\(\xi \in (a,b)\)</span>，使得<span class="math inline">\(f'(\xi)=0\)</span></li></ul></li><li><p>微分中值定理： 设函数满足以下两个条件：</p><ul><li><span class="math inline">\(f(x)\)</span>在闭区间<span class="math inline">\([a,b]\)</span>上连续</li><li><span class="math inline">\(f(x)\)</span>在开区间<span class="math inline">\((a,b)\)</span>上可导</li></ul><p>则存在<span class="math inline">\(\xi\in (a,b)\)</span>，使得<span class="math inline">\(f'(\xi)=\frac{f(b)-f(a)}{b-a}\)</span></p><p>这个定理的几何意义就是，至少存在一点的切线与端点的连线平行；物理意义 是，至少存在一点的速度与平均速度相等：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/differentialMeanValueTheorem.png"></p></li><li><p>柯西中值定理： 设函数<span class="math inline">\(f(x),g(x)\)</span>满足以下条件：</p><ul><li><span class="math inline">\(f(x),g(x)\)</span>在闭区间<span class="math inline">\([a,b]\)</span>上连续</li><li><span class="math inline">\(f(x),g(x)\)</span>在开区间<span class="math inline">\((a,b)\)</span>上可导</li><li><span class="math inline">\(\forall x\in(a,b)\)</span>有：<span class="math inline">\(g'(x)\neq 0\)</span></li></ul><p>则存在<span class="math inline">\(\xi \in (a,b)\)</span>，使等式：</p><p><span class="math display">\[  \frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f'(\xi)}{g'(\xi)}  \]</span></p><p>成立。</p><p>直观理解：对于参数方程 <span class="math display">\[  \left\{\begin{array}{l}  x=g(t) \\  y=f(t)  \end{array}\right.  \]</span> 如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/CauchysMeanValueTheorem.png"> 此时，<span class="math inline">\(\boldsymbol{a}\)</span>所在直线的斜率： <span class="math display">\[  \frac{f(b)-f(a)}{g(b)-g(a)}  \]</span> 以及<span class="math inline">\(\boldsymbol{v}\)</span>所在直线的斜率（根据参数方程的求导法则）： <span class="math display">\[  \frac{f'(\xi)}{g'(\xi)}  \]</span> 必然相等： <span class="math display">\[  \frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f'(\xi)}{g'(\xi)}  \]</span></p></li><li>洛必达法则： <span class="math inline">\(\frac{0}{0}\)</span>型：设：<ul><li><span class="math inline">\(\lim_{x\to a}f(x)=\lim_{x\to a}g(x)=0\)</span></li><li>某<span class="math inline">\(\mathring{U}(a)\)</span>内，<span class="math inline">\(f'(x)\)</span>及<span class="math inline">\(g'(x)\)</span>都存在，且<span class="math inline">\(g'(x)\neq 0\)</span></li><li><span class="math inline">\(\displaystyle\lim_{x\to a}\frac{f'(x)}{g'(x)}\)</span>存在（或为无穷大） 则： <span class="math display">\[  \lim_{x\to a}\frac{f(x)}{g(x)}=\lim_{x\to a}\frac{f'(x)}{g'(x)}  \]</span></li></ul><span class="math inline">\(\frac{\infty}{\infty}\)</span>型：设：<ul><li><span class="math inline">\(\lim_{x\to a}f(x)=\pm\infty，\lim_{x\to a}g(x)=\pm\infty\)</span></li><li>某<span class="math inline">\(\mathring{U}(a)\)</span>内，<span class="math inline">\(f'(x)\)</span>及<span class="math inline">\(g'(x)\)</span>都存在，且<span class="math inline">\(g'(x)\neq 0\)</span></li><li><span class="math inline">\(\displaystyle\lim_{x\to a}\frac{f'(x)}{g'(x)}\)</span>存在（或为无穷大） 则： <span class="math display">\[  \lim_{x\to a}\frac{f(x)}{g(x)}=\lim_{x\to a}\frac{f'(x)}{g'(x)}  \]</span></li></ul></li><li><p>牛顿插值法： 关于牛顿插值法的思想请参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyMzIwNDA4">https://www.zhihu.com/question/22320408<i class="fa fa-external-link-alt"></i></span> 马同学的回答，这里不再列出。</p></li><li><p>泰勒公式： 设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x=x_0\)</span>处<span class="math inline">\(k\)</span>阶可导，则对于任何在 0 到<span class="math inline">\(k\)</span>之间的整数<span class="math inline">\(n\)</span>，可以生成 n 阶泰勒多项式： <span class="math display">\[  \begin{aligned}  p_{n}(x)=&amp; f\left(x_{0}\right)+f^{\prime}\left(x_{0}    \right)\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left    (x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2} \\  &amp;+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_    {0}\right)^{n}  \end{aligned}  \]</span> 特别的，如果在<span class="math inline">\(x=0\)</span>处生成的泰勒多项式，也称为 n 阶麦克劳林多项式： <span class="math display">\[  p_n(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x^2+\cdots+\frac{f^{(n)}(0)}{n!}x^n  \]</span> 泰勒公式是牛顿插值法的进阶。</p></li></ul><h1 id="积分">积分</h1><h2 id="定积分">定积分</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/math_integral.png"></p><p>直观理解积分就是，以每个小方形面积取代曲边形面积，当 x 取极限时每个小长方形的面积就是微分，而所有的长方形面积之和就是积分。 下面是定积分的定义：</p><p>设函数<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有定义，对于<span class="math inline">\([a,b]\)</span>上的任意划分<span class="math inline">\(P\)</span>，<span class="math inline">\(\xi_k\)</span>为子区间<span class="math inline">\([x_{k-1},x_k]\)</span>上任意选取的数，子区间<span class="math inline">\([x_{k-1},x_k]\)</span>的长度为<span class="math inline">\(\Delta x_k\)</span>，记：</p><p><span class="math display">\[\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}\]</span></p><p>如果当<span class="math inline">\(\lambda\to 0\)</span>时</p><p><span class="math display">\[S=\sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}\]</span></p><p>的极限总是存在，且与闭区间<span class="math inline">\([a,b]\)</span>的分法及点<span class="math inline">\(\xi_i\)</span>的取法无关，那么称这个极限 I 为函数<span class="math inline">\(f(x)\)</span>在区间<span class="math inline">\([a,b]\)</span>上的定积分，记做<span class="math inline">\(\int_{a}^{b}f(x)dx,\)</span>即：</p><p><span class="math display">\[\int_{a}^{b} f(x) \mathrm{d} x=I=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}\]</span></p><p>其中 a 为积分下限，b 为积分上限，<span class="math inline">\(I\)</span>为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上的定积分，x 为积分变量。</p><h2 id="定积分的性质">定积分的性质</h2><ul><li>可积条件：<ul><li>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上连续，则<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上可积</li><li>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上有界，且只有有限个间断点，则<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上可积</li></ul></li><li><p>齐次性： <span class="math display">\[  \int_{a}^{b}cf(x)\textrm{d}x=c\int_{a}^{b}f(x)\textrm{d}x,c\in\mathbb{R}  \]</span></p></li><li><p>可加性： <span class="math display">\[  \int_{a}^{b}[f(x)+g(x)]\textrm{d}x=\int_{a}^{b}f(x)\textrm{d}x+\int_{a}^{b}g(x)\textrm{d}x  \]</span></p></li><li><p>积分中值定理： 如果函数<span class="math inline">\(f(x)\)</span>在积分区间<span class="math inline">\([a,b]\)</span>连续，那么在<span class="math inline">\([a,b]\)</span>上至少存在一点<span class="math inline">\(\xi\)</span>，使下式成立： <span class="math display">\[  \int_a^bf(x)dx=f(\xi)(b-a),\xi\in[a,b]  \]</span></p></li></ul><h2 id="微积分基本定理">微积分基本定理</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Science/Math/integralUpperLimitFunction.png"></p><p>b 端点变成一个变量，定积分就变成关于该变量的积分上限函数，如下：</p><p><span class="math display">\[A(x)=\int_a^x f(x)\textrm{d}x\]</span></p><p>因为<span class="math inline">\(x\)</span>又表示积分函数，又表示积分变量，为了避免混淆，所以一般如下表示：</p><p><span class="math display">\[A(x)=\int_a^x f(t)\textrm{d}t\]</span></p><p><strong>牛顿-莱布尼兹公式</strong> <span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上连续，<span class="math inline">\(F(x)\)</span>是<span class="math inline">\(f(x)\)</span>的一个原函数，那么：</p><p><span class="math display">\[\int_a^b f(x)\textrm{d}x=F(b)-F(a)\]</span></p><p>也可以记作：</p><p><span class="math display">\[\int_a^b f(x)\textrm{d}x=[F(x)]_a^b\]</span></p><p>可以这样理解，<span class="math inline">\(F(x)\)</span>对 x 求导代表的是在 x 点的变化率，而对于<span class="math inline">\(f(x)\)</span>在 x 点的变化量正好就是<span class="math inline">\(F(x)\)</span>在 x 点的变化率在 x 取极限的情况下。</p><h2 id="不定积分">不定积分</h2><p>如果<span class="math inline">\(F(x)\)</span>是<span class="math inline">\(f(x)\)</span>在区间<span class="math inline">\(I\)</span>上的一个原函数，那么<span class="math inline">\(F(x)+C\)</span>就是<span class="math inline">\(f(x)\)</span>的不定积分，即：</p><p><span class="math display">\[\int f(x)\textrm{d}x=F(x)+C,C\in\mathbb{R}\]</span></p><p>并且不定积分<span class="math inline">\(\int f(x)dx\)</span>表示了<span class="math inline">\(f(x)\)</span>的所有原函数。</p><h4 id="积分表">积分表</h4><p><span class="math display">\[\begin{array}{c|c|c|c}    \hline\\    \quad \int k\textrm{d}x= kx+C\quad&amp;    \quad \int \cos x\textrm{d}x=\sin x+C\quad\\    \quad \int x^n\textrm{d}x=\frac{x^{n+1}}{n+1}+C,(n\neq -1)\quad&amp;    \quad \int\sin x\textrm{d}x=-\cos x+C\quad\\        \quad \int\frac{1}{x}\textrm{d}x=\ln |x|+C\quad&amp;    \quad \int\sec^2x\textrm{d}x=\tan x+C\quad\\    \quad \int\frac{1}{\sqrt{a^2-x^2}}\textrm{d}x=\arcsin \frac{x}{a}+C\quad&amp;    \quad \int\csc^2x\textrm{d}x=-\cot x+C\quad\\    \quad \int e^x\textrm{d}x=e^x+C\quad&amp;    \quad \int\sec x\tan x\textrm{d}x=\sec x+C\quad\\    \quad \int a^x\textrm{d}x=\frac{a^x}{\ln a}+C\quad&amp;    \quad \int\csc x\cot x\textrm{d}x=-\csc x+C\quad\\    \quad \int\frac{1}{a^2+x^2}\textrm{d}x=\frac{1}{a}\arctan\frac{x}{a}+C\quad&amp;    \quad \int\tan x\textrm{d}x=\ln|\sec x|+C\quad\\    \\    \hline\end{array}\]</span></p><h2 id="积分方法">积分方法</h2><ul><li><p>线性性质： 设函数<span class="math inline">\(f(x)\)</span>及<span class="math inline">\(g(x)\)</span>的原函数存在，则（可加性）：</p><p><span class="math display">\[  \int[f(x)+g(x)]dx=\int f(x)dx+\int g(x)dx\qquad (1)  \]</span></p><p><span class="math inline">\(k\)</span>为非零常数（齐次性）：</p><p><span class="math display">\[  \int kf(x)dx=k\int f(x)dx\qquad (2)  \]</span></p></li><li><p>第一类换元法： 设<span class="math inline">\(f(u)\)</span>具有原函数<span class="math inline">\(F(u)\)</span>，<span class="math inline">\(u=u(x)\)</span>可导，则有换元公式：</p><p><span class="math display">\[  \int f[\underbrace{u(x)}_{\color{skyblue}{u}}]\underbrace   {u'(x)\textrm{d}x}_{\color{salmon}{\textrm{d}u}}=\int f    (\color{skyblue}{u})\color{salmon}{\textrm{d}u}=F(u)+C  \]</span></p></li><li><p>第二类换元法： 设<span class="math inline">\(x=x(t)\)</span>是单调的可导函数，且<span class="math inline">\(x'(t)\neq 0\)</span>，则<span class="math inline">\(t\)</span>可以用<span class="math inline">\(x\)</span>来表示，即有反函数： <span class="math display">\[  t=t(x)  \]</span> 如果有： <span class="math display">\[  \int f(x)\textrm{d}x\xrightarrow{\quad 换元 x=x(t)\quad}\int f[x(t)]x'(t)\textrm{d}t=F(t)+C  \]</span> 则： <span class="math display">\[  \int f(x)\textrm{d}x=F(t(x))+C  \]</span></p></li><li>定积分的换元： 假设函数<span class="math inline">\(f(x)\)</span>在区间<span class="math inline">\([a,b]\)</span>上连续，函数<span class="math inline">\(x=g(t)\)</span>满足条件：<ul><li><span class="math inline">\(g(\alpha)=a,g(\beta)=b\)</span></li><li><span class="math inline">\(g(t)\)</span>在<span class="math inline">\([\alpha,\beta]\)</span>（或<span class="math inline">\([\beta,\alpha]\)</span>) 上具有连续导数，且其值域<span class="math inline">\(R_{g}=[a,b]\)</span>，则有： <span class="math display">\[  \int_{a}^{b}f(x)dx=\int_{\alpha}^{\beta}f[g(t)]g'(t)dt  \]</span></li></ul>定积分的换元和不定积分的换元的不同之处在于：<ul><li>定积分换元时，需要变量与积分限同时换</li><li>在定积分换元后，利用牛顿-莱布尼茨公式可以直接计算出结果，不需要回代</li></ul></li><li><p>分部积分法： <span class="math inline">\(f(x),g(x)\)</span>皆为可导函数，有： <span class="math display">\[  \int f(x)g'(x)dx=f(x)g(x)-\int g(x)f'(x)dx  \]</span> 或设<span class="math inline">\(u=f(x),v=g(x)\)</span>，上式可以写作： <span class="math display">\[  \int udv=uv-\int vdu  \]</span></p></li></ul><h1 id="微分方程">微分方程</h1><p>方程简单而言就是含有未知量的等式；特别地，含有未知函数及其导函数的方程称为微分方程：</p><p><span class="math display">\[\begin{array}{c|c|c}     \hline    &amp;\quad 未知数、quad&amp;\quad 例子、quad\\\hline    \quad\color{SkyBlue}{方程}\quad&amp;\quad x\quad&amp;\quad 2x+1=3\quad\quad\\    \hline     \quad\color{orange}{微分方程}\quad&amp;\quad y\quad&amp;\quad\frac{\mathrm{d}y}{\mathrm{d}x}+xy=2x\quad\\    \hline\end{array}\]</span></p><h2 id="可分离变量的微分方程">可分离变量的微分方程</h2><p>如果一阶微分方程可以写成： <span class="math display">\[g(y)\mathrm{d}y=f(x)\mathrm{d}x\]</span> 的形式，这就是可分离变量的微分方程。</p><p>可以直接对两边求不定积分，比较简单。</p><p>如果一阶微分方程可以写成： <span class="math display">\[\frac{\mathrm{d}y}{\mathrm{d}x}=\varphi\left(\frac{y}{x}\right)\]</span></p><p>的形式，那么称此方程为齐次方程。这个方程是可以通过 换元变换为可分离变量的微分方程的。</p><h2 id="线形微分方程">线形微分方程</h2><h3 id="定义">定义</h3><p><span class="math display">\[\mathcal{L}=a_0+a_1D+a_2D^2+a_3D^3+\cdots+a_nD^n\]</span> 也是矩阵，也是线性函数，多项式组合、mathcal{L}称为微分算子。</p><p>对于微分算子：</p><p><span class="math display">\[\mathcal{L}=a_0+a_1D+a_2D^2+a_3D^3+\cdots+a_nD^n\]</span></p><p>下式：</p><p><span class="math display">\[\mathcal{L}(y)=f(x)\]</span></p><p>称为线性微分方程。如果<span class="math inline">\(f(x)\)</span>： - 等于 0：齐次线性微分方程。 - 不等于 0：非齐次线性微分方程。</p><p>如果系数<span class="math inline">\(a_0,a_1,\cdots,a_n：\)</span></p><ul><li>是常数：常系数线性微分方程。</li><li>是函数：变系数线性微分方程。</li></ul><h3 id="线性微分方程解的结构">线性微分方程解的结构</h3><p>如果<span class="math inline">\(\boldsymbol{p_1}、\boldsymbol{p_2}\)</span>是齐次线性方程组： <span class="math display">\[A\boldsymbol{x}=\boldsymbol{0}\]</span></p><p>的解，那么它们的线性组合：</p><p><span class="math display">\[\boldsymbol{p_3}=C_1\boldsymbol{p_1}+C_2\boldsymbol{p_2}(C_1,C_2\in\mathbb{R})\]</span></p><p>也是此线性方程组的解。</p><p>如果<span class="math inline">\(\boldsymbol{p_1},\boldsymbol{p_2},\cdots,\boldsymbol{p_n}\)</span>是 n 维齐次线性方程组：</p><p><span class="math display">\[A\boldsymbol{x}=\boldsymbol{0}\]</span></p><p>的解，并且它们线性无关，那么线性组合：</p><p><span class="math display">\[\boldsymbol{p}=C_1\boldsymbol{p_1}+C_2\boldsymbol{p_2}+\cdots+C_n\boldsymbol{p_n}(C_1,C_2,\cdots,C_n\in\mathbb{R})\]</span></p><p>是此方程组的通解。</p><p>如果： <span class="math display">\[\boldsymbol{p}=C_1\boldsymbol{p_1}+C_2\boldsymbol{p_2}+\cdots+C_n\boldsymbol{p_n}(C_1,C_2,\cdots,C_n\in\mathbb{R})\]</span></p><p>是齐次线性方程组：</p><p><span class="math display">\[A\boldsymbol{x}=\boldsymbol{0}\]</span></p><p>的通解。<span class="math inline">\(\boldsymbol{p^*}\)</span>是非齐次线性方程组：</p><p><span class="math display">\[A\boldsymbol{x}=\boldsymbol{b}\]</span></p><p>的一个解，也称为特解，那么：</p><p><span class="math display">\[\boldsymbol{p}+\boldsymbol{p^*}\]</span></p><p>是非齐次线性方程组的所有解。</p><h3 id="常系数线性微分方程">常系数线性微分方程</h3><p>微分算子<span class="math inline">\(\mathcal{L}\)</span>是 D 的多项式组合： <span class="math display">\[\mathcal{L}=a_0+a_1D+a_2D^2+a_3D^3+\cdots+a_nD^n\]</span> 如果系数<span class="math inline">\(a_0,a_1,\cdots,a_n\)</span>是常数，那么： <span class="math display">\[\mathcal{L}(y)=f(x)\]</span></p><p>就是常系数微分方程。根据线性微分方程解的结构，我们可以来看齐次解。 某二阶常系数齐次线性微分方程： <span class="math display">\[y''+py'+qy=0\]</span></p><p>其中<span class="math inline">\(p、q\)</span>是常数。大神欧拉发现不论<span class="math inline">\(p、q\)</span>是什么，通解都具有以下形式：</p><p><span class="math display">\[Y=C_1e^{r_1x}+C_2e^{r_2x}\]</span></p><p><span class="math inline">\(r_1、r_2\)</span>是复数。那么可以合理假设<span class="math inline">\(y=e^{rx}\)</span>，得到：</p><p><span class="math display">\[y'=re^{rx},\quad y''=r^2e^{rx}\]</span></p><p>回代到微分方程中，得到：</p><p><span class="math display">\[(r^2+pr+q)e^{rx}=0\]</span></p><p>那么上面等式要成立，只能是：</p><p><span class="math display">\[r^2+pr+q=0\]</span></p><p>这是一个一元二次方程，也被称为此微分方程的特征方程。</p><p>可以用公式：</p><p><span class="math display">\[r_{1,2}=\frac{-p\pm\sqrt{p^2-4q}}{2}\]</span></p><p>求出 r_1、r_2</p><h3 id="变系数线性微分方程">变系数线性微分方程</h3><ul><li><p>一阶变系数线性微分方程： 一阶变系数线性微分方程经过变形之后都可以写成如下的形式： <span class="math display">\[  \frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=Q(x)  \]</span> 可以先写为齐次方程，然后对两边进行积分求解。然后再求解非齐次方程的解。</p></li><li><p>伯努利微分方程： <span class="math display">\[  \frac{\mathrm{d}y}{\mathrm{d}x}+P(x)y=Q(x)y^n\quad (n\ne 0, 1)  \]</span> 叫做伯努利微分方程。 可以变成了一阶变系数线性微分方程来求解。</p></li><li><p>欧拉方程： <span class="math display">\[  x^ny^{(n)}+p_1x^{n-1}y^{(n-1)}+\cdots+p_{n-1}xy'+p_ny=f(x)  \]</span> 称为欧拉方程。 欧拉方程也可以转为常系数线性微分方程。</p></li></ul><p>这里没有将具体的解法列出来，而只是以提纲的方式将概念理出来，具体的解法可以参考相关参考书。</p><h1 id="参考文献">参考文献</h1><p>《马同学的单变量微积分课程》<br>感兴趣的可以购买他的课程，写的很好（强烈推荐）！！！</p>]]></content>
      
      
      <categories>
          
          <category> Science Thought </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++设计模式（一）基于 Policy 的 class 设计</title>
      <link href="/next/2022/Program/C++DesignPatternsPart1/"/>
      <url>/next/2022/Program/C++DesignPatternsPart1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/BasePolicyclassDesigned.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMzMjA5NDYzNzY4OTA4MmYwNDEwNDk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>这一章将介绍所谓 policies 和 policy classes 它们是一种重要的 classes 设计技术，能够增加程序库的弹性并提高复用性，这正是 Loki 的目标所在。简言之，具备复杂功能的 policy based class 由许多小型 classes（称为 policies）组成。每一个这样的小型 class 都只负责单纯如行为或结构的某一方面（ behavioral or structural aspect）。一如名称所示，一个 policy 会针对特定主题建立个接口。在“遵循 policy 接口”的前提下，你可以用任何适当的方法来实作 policies。</p><p>由于你可以混合并匹配各种 policies，所以藉由小量核心基础组件（ core elementary components）的组合，你可完成一个“行为集”（ behaviors set）。</p><h1 id="软件设计的多样性multiplicity">软件设计的多样性（Multiplicity）</h1><p>让我们考虑一个简単的入门级程序维型：-个 Smart Pointer（智能指针）。这种 class 可被用于单线程或多线程之中，可以运用不同的 ownership（拥有权）策略，可以在安全与速度之间协调，可以支持或不支持“自动转为内部指针以上这些特性都可以被自由组合起来而所谓解答，就是最适合你的应用程序的那个方案。</p><h1 id="全功能型do-it-all接口的失败">全功能型（Do-It-All）接口的失败</h1><p>如果程序库将不同的设计实作为各个小型 classes，每个 class 代表一个特定的罐装解法，如何？例如在 smart pointer 例中你会看到 Singlethreaded Smartptr， Multithreadedsmartptr、Refcountedsmartptr、 Reflinkedsmartptr 等等。 这种做法的问题是会产生大量设计组合。例如上述提到的四个 classes 必然导致诸如 singlethreadedrefcountedsmartptr 这样的组合。如果再加一个设计选项（例如支持型別转换），会产生更多澘在组合。这最终会让程序库实作者和使用者受不了。很明显地，这并不是个好方法。面对这么多的潜在组合（近乎指数爬升），千万別企图使用暴力枚举法。 这样的程序库不只造成大量的智力负荷，也是极端的严苛而死板。一点点轻微不可测的定制行为（例如试着以一个特定值为预先构造好的 smart pointers 设初值）都会导致整个精心制作的 library classes 没有用处。 设计是为了厉行 constraints（约束条件、规范）。因此，以设计为目标的程序库必须帮助使用者精巧完成设计，以实现使用者自己的 constraints，而不是实现预先定义好的 constraints。罐装设计不适用于以设计为目标用途的程序库，就像术数字不适用于ー般代码一样。当然啦，一些“最普遍的、受推荐的”罐装解法将受到大众欢迎只要客端程序员必要时能够改变它们。</p><h1 id="多重继承-multiple-inheritance是救世主">多重继承（ Multiple Inheritance）是救世主？</h1><p>藉由多重继承机制来组合多项功能，会产生如下问题：</p><ul><li>关于技术（ Mechanics）。目前并没有一成不变即可套用的代码，可以在某种受控情况下将继承而来的 classes 组合（ assemble）起来。唯一可组合 Basesmartptr， Multithreaded 和 Refcounted 的工具是语言提供的“多重继承”机制：仅仅只是将被组合的 base classes 结合在一起并建立一组用来访问其成员的简单规则。除非情况极为单纯，否则结果难以让人接受。大多数时候你得小心协调继承而来的 classes 的运转，让它们得到所需的行为。</li><li>关于型别信息（ Type information）。 Based classes 并没有足够的型信息来继续完成它们的工作。例如，想象一下，你正试着藉由继承一个 Deepcopy class 来为你的 smart pointer 实作出深层拷贝（ deep copy）。但 Deepcopy 应该具有怎样的接口呢？它必须产生一个对象，而其型别目前未知。</li><li>关于状态处理（ State manipulation） base classes 实作之各种行为必须操作相同的 state（译注：意指数据）。这意味着他们必须虚继承一个持有该 state 的 base class 由于总是由 user classes 继承 library classes（而非反向），这会使设计更加复杂而且变得更没有弹性。</li></ul><p>虽然本质上是组合（ combinatorial），但多重继承无法单独解决设计时的多样性选择。</p><h1 id="templates-带来曙光">Templates 带来曙光</h1><p>templates 是一种很适合“组合各种行为”的机制，主要因为它们是“依赖使用者提供的型别信息”并且“在编译期才产生”的代码。 和一般的 class 不同， class templates 可以以不同的方式定制。如果想要针对特定情况来设计 class 你可以在你的 class template 中特化其成员函数来因应。举个例子，如果有一个 Smartart<t>你可以针对 SmartPtr<widget>特化其任何成员函数，这可以为你在设计特定行为时提供良好粒度（granular）。 犹有进者，对于带有多个参数的 class templates 你可以采用 partial template specialization（偏特化）。它可以让你根据部分参数来特化一个 class template。例如，下面是个 template 定义：</widget></t></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, Class U&gt; <span class="keyword">class</span> <span class="title class_">Smartptr</span> {...};</span><br></pre></td></tr></tbody></table></figure><p>你可以令 SmartPtr&lt;T，U&gt;针对 widget 及其他任意型别加以特化，定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">class</span> <span class="title class_">SmartPtr</span>&lt;Widget, U&gt; {...};</span><br></pre></td></tr></tbody></table></figure><p>template 的编译期特性以及“可互相组合”特性，使它在设计期非常引人注目。然而一旦你开始尝试实作这些设计，你会遭遇一些不是那么浅白的问题。</p><ul><li>你无法特化结构。单单使用 templates，你无法特化“ class 的结构”（我的意思是其数据成员），你只能特化其成员函数。</li><li>成员函数的特化并不能“依理扩张”。你可以对“单一 template 参数”的 class template 特化其成员函数，却无法对着“多个 template 参数”的 class template 特化其个别成员函数。例如：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Okay: specialization of a member function of widget</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> Widget&lt;<span class="type">char</span>&gt;:: <span class="built_in">fun</span>() </span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是，下面是我被告知的错误。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">class</span> <span class="title class_">Gadget</span></span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Error! cannot partially specialize a member function of Gadget</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="type">void</span> Gadget&lt;<span class="type">char</span>,U&gt;::<span class="built_in">fun</span>()</span><br><span class="line">{</span><br><span class="line">  ..specialized implementation</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>仅对一个成员函数进行部分特化是不可能的，而必须对整个类进行部分特化。这就是 C++中的工作方式。</p><p>原因是您不能拥有部分专门的功能，而成员功能本身就是功能。通过部分地专用整个类，成员函数将“看起来”像具有较少类型的模板（在该部分专用类中）。</p><ul><li>程序库撰写者不能够提供多笔缺省值。理想情况下 class template 的作者可以对每个成员函数提供一份缺省实作品，却不能对同一个成员函数提供多份缺省实作品。</li></ul><p>现在让我们比较一下多重继承和 templates 之间的缺点。有趣的是两者互补。多重继承欠缺技术（ mechanics）， templates 有丰富的技术。多重继承缺乏型别信息，而那东西在 templates 里大量存在。 Templates 的特化无法扩张（ scales），多重继承却很容易扩张。你只能为 template 成员函数写一份缺省版本，但你可以写数量无限的 base classes 根据以上分析，如果我们将 templates 和多重继承组合起来，将会产生非常具弹性的设备（ device），应该很适合用来产生程序库中的“设计元素”（ design elements）。</p><h1 id="policies-和-policy-classes">Policies 和 Policy Classes</h1><p>Policies 和 Policy Classes 有助于我们设计出安全、有效率且具高度弹性的“设计元素”。所谓 policy，乃用来定义一个 class 或 class template 的接口，该接口由下列项目之一或全部组成：内隐型别定义（ inner type definition）、成员函数和成员变量</p><p>Policies 也被其他人用于 traits（ Alexandrescu2000a），不同的是后者比较重视行为而非型别。Policies 也让人联想到设计模式 Strategy（ Gamma et a.195），只不过 policies 吃紧于编译期（所谓 compile-time bound）。 举个例子，让我们定义一个 policy 用以生成对象： Creator policy 是一个带有型别 T 的 class template，它必须提供一个名为 Create 的函数给外界使用，此函数不接受引数，传回-个 pointer-to-T。就语义而言，每当 Create（）被调用就必须传回一个指针，指向新生的 T 对象。至于对象的精确生成模式（ creation mode），留给 policy 实作品作为回旋余地。 让我们来定义一个可实作出 Creator policy 的 class 产生对象的可行办法之一就是表达式 new 另一个办法是以 malloc（）加上 placement new 操作符（ Meyers1998b）。此外，还可以采用复制（ cloning）方式来产生新对象。下面是三种做法的实呈现：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OpNewCreator</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MallocCreator</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">void</span>* buf = std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">        <span class="keyword">if</span> (!buf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(buf) T;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrototypeCreator</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">PrototypeCreator</span>(T* pObj = <span class="number">0</span>)</span><br><span class="line">        :<span class="built_in">pPrototype_</span>(pObj)</span><br><span class="line">    {}</span><br><span class="line">    <span class="function">T* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> pPrototype_ ? pPrototype_-&gt;<span class="built_in">Clone</span>() : <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">T* <span class="title">GetPrototype</span><span class="params">()</span> </span>{ <span class="keyword">return</span> pPrototype_; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPrototype</span><span class="params">(T* pObj)</span> </span>{ pPrototype_ = pObj; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* pPrototype_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>任何一个 policy 都可以有无限多份实作品。实作出 policy 者使称为 policy classes，这个东西并不意图被单独使用，它们主要用于继承或被内含于其他 classes。 这里有一个重要观念： policies 接口和一般传统的 classes 接口（纯虚函数集）不同，它比较松散，为 policy 是语法导向（ syntax oriented）而非标记导向（ signature oriented）換句话说， Creator 明确定义的是“怎样的语法构造符合其所规范的 class”，而非“必须实作出哪些函数”。例如 Creator policy 并没有规范 Create（）必须是 static 还是 virtual，它只要求 class 必须定义出 Create（）。此外， Creator 也只规定 create）应该（但非必须）传回一个指向新对象的指针因此 Create（）也许会传回 0 或丢出异常一这都极有可能。 面对一个 policy，你可以实作出数个 policy classes 它们全都必须遵守 policy 所定义的接口。稍后你会看到一个例子，使用者选择了一个 policy 并应用到较大结构中。 先前定义的三个 policy classes 各有不同的实作方式，甚至连接也有些不同（例如 Prototypecreator 多了两个函数 GetPrototype（）和 Setprototype（）。尽管如此，它们全都定义 Create（）并带有必要的返回型別，所以它们都符合 Creator policy 现在让我们看看如何设计一个 class 得以利用 Creator policy，它以复合或继承的方式使用先前所定义的三个 classes 之，如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Library code</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span>: <span class="keyword">public</span> CreationPolicy</span><br></pre></td></tr></tbody></table></figure><p>如果 class 采用一个或多个 policies，我们称其为 hosts 或 host classes。上例的 WidgetManager 使是“采用了个 policy'”的 host class. Hosts 负责把 policies 提供的结构和行为组成一个更复杂的结构和行为。 当客户端将 WidgetManager template 具现化（ Instantiating）时，必须传进一个他所期望的 policy：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application code</span></span><br><span class="line"><span class="keyword">typedef</span> WidgetManager&lt; Opnewcreator&lt;Widget&gt; MyWidgetMgr;</span><br></pre></td></tr></tbody></table></figure><p>让我们分析整个来龙去脉。无论何时，当个 MyWidgetMgr 对象需要产生一个 Widget 对象时它便调用它的 policy 了对象 OpNewCreator<widget>所提供的 Create（）选择“生成策略（ Creation policy）是 WidgetManager 使用者的权利。藉由这样的设计，可以让 WidgetManager 使用者自行装配他所需要的机能。这便是 policy-based class 的设计主旨。</widget></p><h2 id="运用-template-template-参数实作-policy-classes">运用 Template Template 参数实作 Policy Classes</h2><p>如同先前例子所示， policy 的 template 引数往往是余的。使用者每每需要传入 template 引数给 Opnewcreator，这很笨拙。一般来说， host class 已经知道 policy class 所需的参数，或是轻易使可推导出来。上述例子中 WidgetManager 总是操作 Widget 对象，这种情况下还要求使用者“把 Widget 型别传给 Opnewcreator”就显得多余而且危险。 这候程序库可以使用“ template template 参数”来描述 policies，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Library code</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;classCreated&gt; <span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span>: <span class="keyword">public</span> Creatlonpollcy&lt;Widget&gt;</span><br><span class="line"><span class="comment">//译注： Created 是 CreationPolicy 的参数， CreationPolicy 则是 WidgetManager</span></span><br><span class="line"><span class="comment">//的参数。 Widget 已经写入上述程序库中，所以使用时不需要再传一次参数给 policys</span></span><br></pre></td></tr></tbody></table></figure><p>尽管露了脸，上述 Created 也并未对 WidgetManager 有任何贡献。你不能在 WidgetManager 中使用 Created，它只是 CreationPolicy（而非 Wi dgetManager）的形式引数（ formal argument），此可以省略。 应用端现在只需在使用 WidgetManager 时提供 template 名称即可：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application code</span></span><br><span class="line"><span class="keyword">typedef</span> WidgetManager&lt;OpNewCreator&gt; MyWidgetMgr;</span><br></pre></td></tr></tbody></table></figure><p>搭配 policy class 使用“ template template 参数”，并不单纯只为了方便。有时候这种用法不可或缺，以便 host class 可藉由 templates 产生不同型别的对象。举个例子，假设 WidgetManager 想要以相同的生成策略产生一个 Gadget 对象，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Library code</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> <span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">CreationPolicy</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetManager</span>: <span class="keyword">public</span> CreationPolicy&lt;Widget&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dosomething</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Gadget* pw=<span class="built_in">CreationPolicy</span>&lt;Gadget&gt;().<span class="built_in">Create</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 policies 是否会为我们带来一些优势呢？作看之下并不太多。首先， Creator policy 的实作木来就十分简短。当然， WidgetManager 的作者应该会把“生成对象”的那份代码写成 inline 函数，并避开“将 WidgetManager 建立为一个 template”时可能遭遇的问题。</p><p>然而， policy 的确能够带给 WidgetManager 非常大的弹性。第一，当你准备具现化（ instantiating） WidgetManager 时，你可以从外部变更 policies，就和改变 template 引数一样简单。第二，你可以根据程序的特殊需求，提供自己的 policies。你可以采用 new 或 malloc 或 prototypes 或一个专用于你自己系统上的罕见内存分配器。 WidgetManager 就像一个小型的“代码生成引擎”（ code generation engine），你可以自行设定代码的产生方式。 为了让应用程序开发入员的日子更轻松， WidgetManager 的作者应该定义一些常用的 policies，并且以“ template 缺省引数”的形式提供最常用的 policy</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Creation</span>=Opnewcreator&gt; </span><br><span class="line"><span class="keyword">class</span> WidgetManager...</span><br></pre></td></tr></tbody></table></figure><p>注意， policies 和虚函数有很大不同。虽然虚函数也提供类似效果： class 作者以基本的（ primitive）虚函数来建立高端功能，并允许使用者改写这些基本虚函数的行为。然而如前所示， policies 因为有丰富的型别信息及静态连接等特性，所以是建立“设计元素”时的本质性东西。不正是“设计”指定了“执行前型别如何互相作用、你能够做什么、不能够做什么”的完整规则吗？ Policies 可以让你在型别安全（ typesafe）的前提下藉由组合各个简单的需求来产出你的设计。此外，由于编译期才将 host class 和其 policies 结合在一起，所以和手工打造的程序比较起来更加牢固并且更有效率。 当然，也由于 policies 的特质，它们不适用于动态连结和二进位接口，所以本质上 policies 和传统接口并不互相争。</p><h2 id="运用-template-成员函数实作-policy-classes">运用 Template 成员函数实作 Policy Classes</h2><p>另外一种使用“ template template 参数”的情况是把 template 成员函数用来连接所需的简单类。也就是说，将 policy 实作为一般 class（“一般”是相对于 class template 而言），但有一个或数个 templated members. 例如，我们可以重新定义先前的 Creator policy 成为一个 non-template class，其内提供一个名为 create<t>的 template 函数。如此一来， policy class 看起来像下面这个样子。</t></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OpNewCreator</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种方式所定义并实作出来的 policy，对于旧式编译器有较佳兼容性。但从另一方面来说，这样的 policy 难以讨论、定义、实作和运用。</p><h1 id="更丰富的-policies">更丰富的 Policies</h1><p>Creator policy 只指定了一个 Create（）成员函数。然而 Prototypecreator 却多定义了两个函数，分别为 GetPrototype（）和 Setprotorype（）。让我们来分析一下。由于 WidgetManager 继承了 policy class，而且 GetPrototype() 和 Setprototype（）是 Prototype Creator 的 public 成员，所以这两个函数使被加至 WidgetManager，并且可以直接被使用者取用。 然而 WidgetManager 只要求 Create（）；那是 WidgetManager 切所需，也是用来保证它自己机能的唯一要求。不过使用者可以开发出更丰富的接口。 prototype-based Creator policy class 的使用者可以写出下列代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> WidgetManager&lt;Prototypecreator&gt; MyWidqetManager</span><br><span class="line">...</span><br><span class="line">Widget* prototype = ...;</span><br><span class="line">MyWidqetManager mri;</span><br><span class="line">mgr.<span class="built_in">Setprototype</span>(prototype);</span><br><span class="line">...use mgr...</span><br></pre></td></tr></tbody></table></figure><p>如果此后使用者决定采用一个不支持 prototypes 的生成策略，那么编译器会指出问题： prototype 专属接口已经被用上了。这正是我们希望获得的坚固设计。 如此的结果是很受欢迎的。使用者如果需要扩充 policies，可以在不影响 host class 原本功能的前提下，从更丰富的功能中得到好处。别忘了，决定“哪个 policy 被使用”的是使用者而非程序库自身。和般多重接口不同的是， policies 给予使用者一种能力，在型别安全（ typesafe 的前提下扩增 host class 的功能。</p><h2 id="policy-classes-的析构函数-destructors">Policy Classes 的析构函数 ( Destructors)</h2><p>有一个关于建立 policy classes 的要细节。大部分情况下 host class 会以 public 继承”方式从某些 policies 派生而来。因此，使用者可以将一个 host class 自动转为一个 policy class（译注：向上转型），并于稍后 delete 该指针。除非 policy class 定义了一个虚析构函数（ virtual destructor），否则 delete 个指向 policy class f 的指针，会产生不可预期的结果 4，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> WidgetManager&lt;Prototypecreator&gt; MyWidgetManager;</span><br><span class="line">MyWidgetManager wm;</span><br><span class="line">PrototypeCreator&lt;Widget&gt;* pCreator = &amp;wm; <span class="comment">// dubious, but legal</span></span><br><span class="line"><span class="keyword">delete</span> pCreator;    <span class="comment">// compiles fine, but has undefined behavior</span></span><br></pre></td></tr></tbody></table></figure><p>然而如果为 policy 定义了一个虚析构函数，会妨碍 policy 的静态连结特性，也会影响执行效率。</p><p>许多 policies 并无任何数据成员，纯粹只规范行为。第一个虚函数被加入后会为对象大小带来额外开销（译注：因为引入一份 vptr），所以虚析构函数应该尽可能避免。 一个解法是，当 host class 自 policy class 派生时，采用 protected 继承或 private 继承。然而这样会失去丰富的 policies 特性。 policies 应该采用一个轻便而有效率的解法一定义一个 non-virtual protected 析构函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OpNewCreator</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    ~<span class="built_in">Opnewcreator</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于析构函数属于 protected 层级，所以只有派生而得的 classes 才可以摧毁这个 policy 对象。这样一来外界就不可能 delete 一个指向 policy class 的指针。而由于析构函数并非虚函数，所以不会有大小或速度上的额外开销。</p><h1 id="参考文献">参考文献</h1><p>《Modern C++ Design-C++设计新思维》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Design Patters </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（六）nullptr 与 Lambda</title>
      <link href="/next/2022/Program/CPP11Part6/"/>
      <url>/next/2022/Program/CPP11Part6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP1ChangeThinkType.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMzMWNjZDBlM2U3NDA3ZGE1M2NlMTg=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="nullptr">nullptr</h1><h2 id="nullptrnull-和-0">nullptr、NULL 和 0</h2><p>般情况下，NULL 是一个宏定义。在传统的 C 头文件（ stddef.h）里我们可以找到如下代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL O</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，NULL 可能被定义为字面常量 0，或者是定义为无类型指针（void*）常量。不过无论采用什么样的定义，我们在使用空值的指针时，都不可避免地会遇到一些麻烦。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"int"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"ptr"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);                   <span class="comment">// int</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);                <span class="comment">// int，本意是调用指针函数，实际却调用了 int 函数</span></span><br><span class="line">    <span class="built_in">func</span>((<span class="type">void</span>*)<span class="number">0</span>);            <span class="comment">// ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上的代码中 func(NULL); 本意是调用指针函数，实际却调用了 int 函数，因为 NULL 被定义成了 0。虽然在前面加上 (void*) 强制转换能解决这个问题，但是某些编译器缺会在产生这种二义性时报错，多以对于代码移植来说会有一定限制。于是 C++11 中新增了 nullptr 来代表指针空值，以上问题就得到了解决：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);                   <span class="comment">// int</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);             <span class="comment">// ptr</span></span><br><span class="line">    <span class="built_in">func</span>((<span class="type">void</span>*)<span class="number">0</span>);            <span class="comment">// ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="nullptr-和-nullptr_t">nullptr 和 nullptr_t</h2><p>同时，C++11 还定义了指针空值类型 nullptr_t，就是说指针空值并非只有 nullptr 一个实例，也可以通过 nullptr_t 来声明一个空指针类型的变量，虽然好像没什么用。另外，nullptr_t 也规定了一些规则：</p><ul><li>所有定义为 nullptr_t 类型的数据都是等价的，行为也完全一致。</li><li>nullptr_t 类型数据可以隐式转换成任意一个指针类型。</li><li>nullptr_t 类型数据不能转换成非指针类型。</li><li>nullptr_t 类型数据不适用于算术运算表达式。</li><li>nullptr_t 类型数据可以用于关系运算表达式，但是只能和 nullptr_t 类型或者指针类型进行比较。</li></ul><p>nullptr_t 类型还是比较有意思的，它的定义是从 nullptr 反推而来，从这点又能看出 C++11 用法的灵活性：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="默认函数的控制">默认函数的控制</h1><p>在 C++中声明自定义的类之后，编译器会默认生成一些成员函数，这些函数被称为默认函数。包括构造函数、拷贝构造函数、拷贝赋值构造函数、移动构造函数、移动拷贝函数、析构函数。另外，编译器还会默认生成一些操作符函数，包括 operator ,、operator &amp;、operator &amp;&amp;、operator 、operator -&gt;、operator -&gt;、operator new、operator delete。</p><h2 id="显式缺省函数-default">显式缺省函数 (= default)</h2><p>但是如果实现了这些函数的自定义版本后，编译器就不会去生成默认的版本。有时候我们需要声明带参数的构造函数，此时就不会生成默认的构造函数，这样会导致类不再是 POD 类型，从而影响类的优化：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> i) : <span class="built_in">data</span>(i) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; std::is_pod &lt;Example&gt;::value &lt;&lt; std::endl;  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C++11 中提供了新的机制来控制默认函数生成来避免这个问题，我们在声明时在函数末尾加上”= default”来显式地指示编译器去生成该函数的默认版本，这样就保证了类还是 POD 类型：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> i) : <span class="built_in">data</span>(i) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; std::is_pod &lt;Example&gt;::value &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="显式删除函数-delete">显式删除函数 (= delete)</h2><p>另一方面，有时候可能需要限制一些默认函数的生成，例如需要禁止拷贝构造函数的使用。原来，通过把拷贝构造函数声明为 private 成员，这样一旦使用编译器就会报错。而在 C++11 中，在函数的定义或者声明后面加上”= delete”就能实现这个效果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; ex) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Example ex;</span><br><span class="line">    <span class="function">Example <span class="title">ex1</span><span class="params">(ex)</span></span>;   <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="其他用法">其他用法</h2><p>= default 和= delete 能够更加精准的控制类的默认函数版本。其中，= default 同样也能在类外的定义中修饰成员函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Example::<span class="built_in">Example</span>(<span class="type">const</span> Example&amp; ex) = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure><p>这样的好处是，能够为一个类实现多个版本，只要我们在头文件里声明同样的函数，而在不同的 cpp 文件中用不同的方法实现，当选择不同的 cpp 编译时产生的版本就不同。</p><p>关于= delete，它不仅局限于限制生成默认函数，还能避免编译器做一些不必要的隐式数据转换：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> i) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Example <span class="title">ex</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Example <span class="title">ex1</span><span class="params">(<span class="string">'a'</span>)</span></span>;     <span class="comment">// 编译成功，char 会隐式装换成 int 型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有时候我们不想要这种隐式转换：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> i) {}</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">char</span> c) = <span class="keyword">delete</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Example <span class="title">ex</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Example <span class="title">ex1</span><span class="params">(<span class="string">'a'</span>)</span></span>;  <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法也能用于普通函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>{}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> c)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">'a'</span>);   <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，还有很多用法，例如显示删除 new 操作符来避免在堆上分配对象、显示删除析构函数用于构建单例模式等等。</p><h1 id="lambda">Lambda</h1><h2 id="什么是-lambda-表达式">什么是 Lambda 表达式？</h2><p>Lambda 表达式是 C++11 提出的新特性，主要用来实现代码中<strong>函数的内嵌</strong>，简化了编程，提高了效率。</p><p>它的基本格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [捕获参数](函数参数){函数体};</span><br></pre></td></tr></tbody></table></figure><p>例如这个 Hello Lambda：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [](){ std::cout &lt;&lt; <span class="string">"Hello Lambda"</span> &lt;&lt; std::endl; };</span><br></pre></td></tr></tbody></table></figure><p>Lambda`本质上是一个<strong>内联函数</strong>，只是定义和使用的方式与普通的函数有些不同，下面来具体介绍下它的基本语法。</p><h2 id="基本语法">基本语法</h2><h3 id="最简单的-lambda">最简单的 Lambda</h3><p>后面不加 () 的 Lambda 表达式相当于<strong>函数指针</strong>，加上 ()`就相当于调用这个 Lambda 函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  [](){ cout &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; endl; };</span><br><span class="line"></span><br><span class="line">  [](){ cout &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; endl; }();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lambda-可以赋值">Lambda 可以赋值</h3><p>可以将 Lambda 表达式赋值给一个变量，之后这个变量可以当作函数指针来调用，需要加上 ()。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">auto</span> fun = [](){ cout &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; endl; };</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="为-lambda-传递参数">为 Lambda 传递参数</h3><p>可以为 Lambda 指定函数参数，该参数也具有副本机制。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun = [](<span class="type">int</span> num){ num = <span class="number">5</span>; cout &lt;&lt; num &lt;&lt; endl; };</span><br><span class="line">  <span class="built_in">fun</span>(num);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取-lambda-的返回值">获取 Lambda 的返回值</h3><p>Lambda 的返回值类型可以进行类型转换或者使用 decltype 自动推导。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = [](<span class="type">int</span> a, <span class="type">int</span> b){ <span class="keyword">return</span> a + b; }(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num2 = [](<span class="type">double</span> a, <span class="type">double</span> b)-&gt;<span class="type">int</span>{ <span class="keyword">return</span> a + b; }(<span class="number">1.2</span>, <span class="number">2.1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> num3 = [](<span class="type">double</span> a, <span class="type">double</span> b)-&gt;<span class="keyword">decltype</span>(a + b){ <span class="keyword">return</span> a + b; }(<span class="number">1.2</span>, <span class="number">2.1</span>);</span><br><span class="line">  cout &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="的使用方法">[ ] 的使用方法</h3><p>Lambda 表达式的 [] 用来确定捕获参数：</p><ol type="1"><li>[=]：捕获的局部变量只可读不可写，捕获范围是当前 Lambda 表达式之前的作用域。</li><li>[&amp;]：捕获的局部变量可读可写。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun1 = [=](){ cout &lt;&lt; num &lt;&lt; endl; };</span><br><span class="line">  <span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun2 = [&amp;num](){ num = <span class="number">200</span>; cout &lt;&lt; num &lt;&lt; endl; };</span><br><span class="line">  <span class="built_in">fun2</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lambda-是-const-函数">Lambda 是 const 函数</h3><p>Lambda 默认是 const 函数，不能修改引用的变量，使用 mutable 可以取消该属性，但是 mutable 修改的只是副本。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun = [=]() <span class="keyword">mutable</span> { num = <span class="number">200</span>; cout &lt;&lt; num &lt;&lt; endl; };</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lambda-没有地址">Lambda 没有地址</h3><p>Lambda 表达式是内联展开的，没有实际的地址，这是与普通函数的一个很大的区别。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  string str;</span><br><span class="line">  <span class="keyword">auto</span> fun = [](string str){cout &lt;&lt; str &lt;&lt; endl; };</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  <span class="built_in">fun</span>(str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lambda-在-class-中的使用">Lambda 在 class 中的使用</h3><p>Lambda 在 C++ class 中的使用需要知道如何捕获 this。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::function</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun1 = [<span class="keyword">this</span>](<span class="type">int</span> v){cout &lt;&lt; v + <span class="keyword">this</span>-&gt;num &lt;&lt; endl; };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fun2 = [&amp;](<span class="type">int</span> v){cout &lt;&lt; v + <span class="keyword">this</span>-&gt;num &lt;&lt; endl; };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="lambda-与仿函数">Lambda 与仿函数</h2><p>Lambda 与仿函数有些类似，仿函数是编译器实现 Lambda 的一种方式，编译器会将 Lambda 转换为一个仿函数对象，Lambda 可以视为仿函数的等价形式，编译器在发现 Lambda 函数出现语法错误的时候，会报出一些与构造函数相关的信息。</p><p>下面是一个仿函数例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TestLambda</span>(<span class="type">float</span> f) : <span class="built_in">x</span>(f) {}</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> price)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> price * (<span class="number">1</span> - x / <span class="number">100</span>);</span><br><span class="line">  }</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以看到调用仿函数和 Lambda 是很类似的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">float</span> f = <span class="number">5.5f</span>;</span><br><span class="line">  <span class="function">TestLambda <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> fun = [f](<span class="type">float</span> price)-&gt;<span class="type">float</span>{ <span class="keyword">return</span> price * (<span class="number">1</span> - f / <span class="number">100</span>);};</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> p1 = <span class="built_in">t</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> p2 = <span class="built_in">fun</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Lambda 是 C++11 提出的新特性，简化了我们的代码，提高了编程的效率，应该了解并学会使用它。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dpemFyZHRvSC9hcnRpY2xlL2RldGFpbHMvODExNjQ3NDA=">https://blog.csdn.net/WizardtoH/article/details/81164740<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dpemFyZHRvSC9hcnRpY2xlL2RldGFpbHMvODExNjk1NzA=">https://blog.csdn.net/WizardtoH/article/details/81169570<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMjAwYTJkYWI5NjA=">https://www.jianshu.com/p/a200a2dab960<i class="fa fa-external-link-alt"></i></span><br>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（五）constexpr、原子与线程存储</title>
      <link href="/next/2022/Program/CPP11Part5/"/>
      <url>/next/2022/Program/CPP11Part5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP11ImprovePerformanceAndAbility.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyZmQ4YTU2NTNiYjA3NGIyMzI4NTk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="常量表达式constexpr">常量表达式（constexpr）</h1><p>常量表达式机制是为了：</p><ul><li>提供一种更加通用的常量表达式。</li><li>允许用户自定义的类型成为常量表达式。</li><li>提供了一种保证在编译期完成初始化的方法（可以在编译时期执行某些函数调用）。</li></ul><p>考虑下面这段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Flags</span> { good=<span class="number">0</span>, fail=<span class="number">1</span>, bad=<span class="number">2</span>, eof=<span class="number">4</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="keyword">operator</span>|(Flags f1, Flags f2)</span><br><span class="line">{ <span class="keyword">return</span> <span class="built_in">Flags</span>(<span class="built_in">int</span>(f1)|<span class="built_in">int</span>(f2)); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Flags x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">switch</span> (x) {</span><br><span class="line">    <span class="keyword">case</span> bad:         <span class="comment">/* … */</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> eof:         <span class="comment">/* … */</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> bad|eof:     <span class="comment">/* … */</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:          <span class="comment">/* … */</span> <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然“bad|eof”是一个表达式，但是因为这两个参数都是常量，在编译时期，就可以计算出它的结果，因而可以作为常量对待，可以在编译时期被动地计算表达式的值。</p><p>constexpr 并不是 const 的通用版，反之亦然：</p><ul><li>const 主要用于表达“对接口的写权限控制”，即“对于被 const 修饰的量名（例如 const 指针变量），不得通过它对所指对象作任何修改”。（但是可以通过其他接口修改该对象）。</li><li>constexpr 的主要功能则是让更多的运算可以在编译期完成，并能保证表达式在语义上是类型安全的。（译注：相比之下，C 语言中#define 只能提供简单的文本替换，而不具任何类型检查能力）。</li></ul><h2 id="constexpr-修饰普通变量">constexpr 修饰普通变量</h2><p>使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。</p><h2 id="constexpr-修饰函数">constexpr 修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p><p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件：</p><ul><li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li><li>该函数必须有返回值，即函数的返回值类型不能是 void。</li><li>函数在使用之前，必须有对应的定义语句。</li><li>return 返回的表达式必须是常量表达式。</li></ul><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><h2 id="constexpr-修饰类的构造函数">constexpr 修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此程序是无法通过编译的，编译器会抛出“constexpr 不能修饰自定义类型”的异常。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> {</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt { <span class="string">"zhangsan"</span>, <span class="number">10</span> };</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> {</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age){</span>};</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt { <span class="string">"zhangsan"</span>, <span class="number">10</span> };</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p><h2 id="constexpr-修饰模板函数">constexpr 修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p><h1 id="变长模板">变长模板</h1><h2 id="变长函数和变长的模板参数">变长函数和变长的模板参数</h2><p>printf 则使用了 C 语言的函数变长参数特性，通过使用变长函数（ variadic funciton）， printf 的实现能够接受任何长度的参数列表。不过无论是宏，还是变长参数，整个机制的设计上，没有任何一个对于传递参数的类型是了解的。我们可以看看变长函数的例子。通常情况下，一个变长函数可以如下代码所示。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sumoffloat</span><span class="params">(<span class="type">int</span> count,...)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">double</span> sum =<span class="number">0</span></span><br><span class="line">    <span class="built_in">va_start</span>(ap, count);            <span class="comment">//获得变长列表的句柄 ap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>: i &lt; count: i++)</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(ap， <span class="type">double</span>);   <span class="comment">//一次获得一个参数</span></span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"f% \n"</span>, <span class="built_in">Sumoffloat</span>(<span class="number">3</span>, <span class="number">1.2f</span>, <span class="number">3.4</span>, <span class="number">5.6</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上述代码中，我们声明了一个名为 Sumoffloat 变长函数。变长函数的第一个参数 count 表示的是变长参数的个数，这必须由 Sumoffloat 的调用者传递进来。而在被调用者中，则需要通过一个类型为 va_list 的数据结构 ap 来辅助地获得参数。可以看到，这里代码首先使用 va_star 函数对 ap 进行初始化，使得 ap 成为被传递的变长参数的一个“句柄”（ handler）。而后代码再使用 va_arg 函数从 ap 中将参数一取出用于运算。由于这里是计算浮点数的和，所以每次总是给 va_arg 传递一个 double 类型作为参数。下图显示了一种变长函数的可能的实现方式，即以句柄 ap 为指向各个变长参数的指针，而 va_arg 则通过改变指针的方式（每次增加 sizeof（ double）字节）来返回下一个指针所指向的对象。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/performace1.png"></p><p>可以看到，在本例中，只有使用表达式 va_arg（ap，double）的时候，我们才按照类型（实际是按类型长度）去变长参数列表中获得指定参数。而如何打印则得益于传递在字符串中的形如“s% d%”这样的转义字，以及传递的 count 参数。事实上，函数“本身”完全无法知道参数数量或者参数类型。因此，对于一些没有定义转义字的非 POD 的数据来说，使用变长函数就会导致未定义的程序行为。比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *msg = <span class="string">"hello %s"</span>;</span><br><span class="line"><span class="built_in">printf</span>(msg, std::<span class="built_in">string</span>(<span class="string">"world"</span>));</span><br></pre></td></tr></tbody></table></figure><p>这样的代码就会导致 printf 出错。 从另一个角度讲，变长函数这种实现方式，对于 C++这种强调类型的语言来说相当于开了一个“不规范”的后门。这是 C++标准中所不愿意看到的（即使它能够工作）。因此，客观上，C++需要引入一种更为“现代化”的变长参数的实现方式，即类型和变量同时能够传递给变长参数的函数。一个好的方式就是使用 C++的函数模板</p><p>此外在一些情况下，类也需要不定长度的模板参数。最为典型的就是 C++11 标准库中的 tuple 类模板。如果读者熟悉 C++98 中的 pair 类模板的话，那么理解 tuple 也就不困难了。具体来讲，pair 是两个不同类型的数据的集合。比如 pair&lt;int，double&gt;就能够容纳 int 类型和 double 类型的两种数据。一些如 std::map 的标准库容器，其成员就需要是类模板 pair 的。在 C++11 中， tuple 是 pair 类的一种更为泛化的表现形式。比起 pair， tuple 是可以接受任意多个不同类型的元素的集合。比如我们可以通过：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">double</span>, <span class="type">char</span>, std::string&gt; collections;</span><br></pre></td></tr></tbody></table></figure><p>来声明一个 tuple 模板类。该 collections 变量可以容纳 double、char、std::string 三种类型的数据。当然，读者还可以用更多的参数来声明 collection，因为 tuple 可以接受任意多的参数。此外，和 pair 类似地，我们也可以更为简单地使用 C++11 的模板函数 make_tuple 来创造一个 tuple 模板类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std: <span class="built_in">make_tuple</span>(<span class="number">9.8</span>, <span class="string">'g'</span>, <span class="string">"gravity"</span>);</span><br></pre></td></tr></tbody></table></figure><p>由于 tuple 包含的类型数量可以任意地多，那么在客观上，就需要类模板能够接受变长的参数。因此，在 C++11 中我们就看到了所谓的变长模板（ variadic template）的实现。</p><h2 id="变长模板模板参数包和函数参数包">变长模板：模板参数包和函数参数包</h2><p>我们先看看变长模板的语法，还是以前面提到的 tuple 为例，我们需要以下代码来声明 tuple 是一个变长类模板</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Elements&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们在标示符 Elements 之前的使用了省略号（三个“点”）来表示该参数是变长的。在 C++11 中， Elements 被称作是一个“模板参数包"（ template parameter pack）这是一种新的模板参数类型。有了这样的参数包，类模板 tuple 就可以接受任意多个参数作为模板参数。对于以下实例化的 tuple 模板类：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">double</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>编译器则可以将多个模板参数打包成为“单个的”模板参数包 Elements，即 Element 在进行模板推导的时候，就是一个包含 int、char 和 double 三种类型类型集合。</p><p>与普通的模板参数类似，模板参数包也可以是非类型的，比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span>...A&gt; <span class="keyword">class</span> <span class="title">Nontypevariadictemplate</span><span class="params">()</span></span>;</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt;</span><br></pre></td></tr></tbody></table></figure><p>就定义了接受非类型参数的变长模板 Nontypevariadictemplate。这里，我们实例化一个三参数（1，0，2）的模板实例 ntvt。该声明方式相当于：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="keyword">class</span> <span class="title class_">Nontypevariadictemplate</span>:</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt:</span><br></pre></td></tr></tbody></table></figure><p>这样的类模板定义和实例化。 除了类型的模板参数包和非类型的模板参数包，模板参数包实际上还是模板类型的，不过这样的声明会比较复杂，我们在后面再讨论一个模板参数包在模板推导时会被认为是模板的单个参数（虽然实际上它将会打包任意数量的实参）。为了使用模板参数包，我们总是需要将其解包（ unpack）。在 C++11 中，这通常是通过一个名为包扩展（ pack expansion）的表达式来完成。比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>: <span class="keyword">private</span> B&lt;A...&gt;{};</span><br></pre></td></tr></tbody></table></figure><p>这里的表达式 A...（即参数包 A 加上三个“点”）就是一个包扩展。直观地看，参数包会在包扩展的位置展开为多个参数。比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="keyword">class</span> <span class="title class_">B</span>{};</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>: <span class="keyword">private</span> B&lt;A...&gt;{}:</span><br><span class="line">Template&lt;X, Y&gt; xy;</span><br></pre></td></tr></tbody></table></figure><p>这里我们为类模板声明了一个参数包 A，而使用参数包 A... 则是在 Template 的私有基类 B&lt;A...&gt;中，那么最后一个表达式就声明了一个基类为 B&lt;X，Y&gt;的模板类 Template&lt;X，Y&gt;的对象 xy。其中 X、Y 两个模板参数先是被打包为参数包 A，而后又在包扩展表达式 A... 中被还原。读者可以体会一下这样的使用方式。</p><p>不过上面对象 xy 的例子是基于类模板 B 总是接受两个参数的前提下的。倘若我们在这里声明了一个 Template&lt;X，Y，Z&gt;，就必然会发生模板推导的错误。这跟我们之前提到的“变长”似乎没有任何关系。那么如何才能利用模板参数包及包扩展，使得模板能够接受任意多的模板参数，且均能实例化出有效的对象呢？</p><p>事实上，在 C++11 中，实现 tuple 模板的方式给出了一种使用模板参数包的答案。这个思路是使用数学的归纳法，转换为计算机能够实现的手段则是递归。通过定义递归的模板偏特化定义，我们可以使得模板参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止。下面的例子是一个用变长模板实现 tuple（简化的 tuple 实现）的代码，如下代码所示。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Elements&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;  <span class="comment">//变长模板的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>...Tail&gt;    <span class="comment">//递归的偏特化定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;: <span class="keyword">private</span> tuple&lt;Tail...&gt;{</span><br><span class="line">    Head head;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;    <span class="comment">//边界条件</span></span><br></pre></td></tr></tbody></table></figure><p>在代码中，我们声明了变长模板类 tuple，其只包含一个模板参数，即 Elements 模板参数包。此外，我们又偏特化地定义了一个双参数的 tuple 的版本。该偏特化版本的 tuple 包含了两个参数，一个是类型模板参数 Head，另一个则是模板参数包 Tail 在代码的实现中，我们将 Head 型的数据作为 tuple&lt;Head，Tail...&gt;的第一个成员，而将使用了包扩展表达式的模板类 tuple&lt;Tail...&gt;作为 tuple&lt;Head，Tail...&gt;的私有基类。这样来，当程序员实例化一个形如 tuple &lt;double，int，char， float&gt;的类型时，则会引起基类的递归构造，这样的递归在 tuple 的参数包为 0 个的时候会结束。这是由于我们定义了边界条件或者说初始条件，即 tuples&lt;&gt;这样不包含参数的偏特化版本而造成的。在代码中， tuples&lt;&gt;偏特化版本是一个没有成员的空类型。这样一来，编译器将从 tuples 建造出 tuple&lt;float...&gt;，继而造出 tuple&lt;char，foat&gt;、 tuple&lt;int，char，foat&gt;，最后就建造出了 tuple&lt;double，int，char，foa&gt;类型。 下图是 tuple&lt;double，in，char，nioa&gt;实例化后的继承结构示意图。我们用方框表示类型，而方框内的方框则表示类型由其内部的方框所代表的类型私有派生而来。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/performace2.png"></p><p>这种变长模板的定义方式稍显复杂，不过却有效地解决了模板参数个数这样的向题。当然，这样做的前提是模板类/函数的定义要具有能够递推的结构。</p><p>除了变长的模板类，在 C++11 中，我们还可以声明变长模板的函数。对于变长模板函数而言，除了声明可以容纳变长个模板参数的模板参数包之外，相应地，变长的函数参数也可以声明成函数参数包（ function parameter pack）。比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T...args)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>这个例子中，由于 T 是个变长模板参数（类型），因此 args 则是对应于这些变长类型的数据，即函数参数包。值得注意的是，在 C++11 中，标准要求函数参数包必须唯一，且是函数的最后一个参数（模板参数包没有这样的要求）。 有了模板参数包和函数参数包两个概念，我们就可以实现 C 中变长函数的功能了。</p><h1 id="原子类型与原子操作">原子类型与原子操作</h1><h2 id="并行编程多线程与-c11">并行编程、多线程与 C++11</h2><p>在 C++11 之前，在 C/C++中程序中使用线程却并非鲜见。这样的代码主要使用 POSIX 线程（ pthread）和 OpenMP 编译器指令两种编程模型来完成程序的线程化。而在 C++11 中，标准的一个相当大的变化就是引入了多线程的支持，这使得 C/C++语言在进行线程编程时，不必依赖第三方库和标准。而 C++对线程的支持，一个最为重要的部分，就是在原子操作中引入了原子类型的概念。</p><h2 id="原子操作与-c11-原子类型">原子操作与 C++11 原子类型</h2><p>通常情况下，原子操作都是通过“互斥”（ mutual exclusive）的访问来保证的。借助 POSIX 标准的 pthread 库中的互斥锁（ mutex）也可以做到。不过显而易见地，基于 pthread 的方法虽然可行，但代码编写却很麻烦。程序员需要为共享变量创建互斥锁，并在进入临界区前后进行加锁和解锁的操作。不过在 C++11 中，通过对并行编程更为良好的抽象，要实现同样的功能就简单了很多。我们可以看看下面的例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_llong total = <span class="number">0</span>;            <span class="comment">// atomic_llong 相当于 long long，但是本身就拥有原子性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000LL</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        total += i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;     <span class="comment">// 9999999900000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，使用了原子类型 atomic_llong 之后，不需要使用额外的互斥接口来保证 total 的同步。除了 atomic_llong 类型，C++11 还提供了其他的原子类型。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/performace3.png"></p><p>当我们去看这些类型的定义时会发现，起始它们都是用 atomic<t>模板来定义的。例如 std::atomic_llong 就是用 std::atomic<long long="">来定义的。</long></t></p><p>C++11 中将原子操作定义为 atomic 模板类的成员函数，包括了大多数类型的操作，比如读写、交换等。对于内置类型，主要通过重载全局操作符来实现。下面列出所有 atomic 类型及其支持的相关操作列表： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/performace4.png"></p><p>列表中的 atomic-intergral-type 以及 atomic<intergral-type>就是前面的原子类型列表中的类型，class-type 是自定义类型。对于大部分原子类型，都支持读 (load)、写 (store)、交换 (exchange) 等操作。</intergral-type></p><h2 id="内存模型顺序一致性和-memory_order">内存模型、顺序一致性和 memory_order</h2><p>了解这一小节的内容之前，先看一段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; std::endl;     <span class="comment">// 不定</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; std::endl;   <span class="comment">// 1,2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上的代码，在主线程中打印 a 和 b 结果必定是 1,2，而在线程 func2 中打印结果就不一定了，可能是 0,0 或者 1,2 或者 1,0。因为线程的执行并不能保证先创建的一定先运行，两者运行顺序存在多种可能。但是对于原子类型来说，func2 中的打印不可能出现 0,2 的情况，因为原子类型的变量在线程中总是保持顺序执行的特性（顺序一致性）。</p><p>不过在 C++11 中顺序一致性只是多种内存模型中的一种，代码并非必须按照顺序执行，因为顺序往往意味着最低效的同步方式。在了解其他内存模型之前，我们需要先了解一些处理器和编译器相关的知识。现代的处理器并不是逐条处理机器指令的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Load    reg3, <span class="number">1</span>;           <span class="comment">// 将立即数 1 放入寄存器 reg3</span></span><br><span class="line"><span class="number">2</span>: Move    reg4,reg3;         <span class="comment">// 将 reg3 的数据放入 reg4</span></span><br><span class="line"><span class="number">3</span>: Store   reg4, a;           <span class="comment">// 将 reg4 的数据存入内存地址 a</span></span><br><span class="line"><span class="number">4</span>: Load    reg5, <span class="number">2</span>;           <span class="comment">// 将立即数 2 放入寄存器 reg5</span></span><br><span class="line"><span class="number">5</span>: Store   reg5, b;           <span class="comment">// 将 reg5 的数据存入内存地址 b</span></span><br></pre></td></tr></tbody></table></figure><p>以上的伪汇编代码代表了 temp = 1; a = temp; b = 2，通常情况下指令都是按照 1~5 的顺序执行，这种内存模型称为强顺序 (strong ordered)。不过可以看到，指令 1、2、3 和指令 4、5 的运行顺序不影响结果，有一些处理器可能会将指令的顺序打乱，例如按照 1-4-2-5-3 的顺序执行，这种内存模型称为弱顺序 (weak ordered)。</p><p>介绍了硬件内存模型后，再来说说 C++11 中定义的内存模型和顺序一致性和硬件中的关系。高级语言和机器指令是通过编译器来进行转换的，而编译器处于代码优化的考虑，会将指令进行移动。对于 C++11 的内存模型而言，要保证代码的顺序一致性，需要同时做到以下几点：</p><ul><li>编译器保证原子操作的指令间顺序不变，即产生的读写原子类型变量的机器指令和代码编写顺序是一样的。</li><li>处理器对原子操作的汇编指令的执行顺序不变。这对于 x86 这样的强顺序的体系结构而言没有任何问题，而对于一些弱顺序的平台则需要每个原子操作之后要加入内存栅栏。</li></ul><p>对于上文打印 a，b 的代码来说，如果只需要在主线程中打印结果，那么代码的执行顺序并不重要。但是 atomic 原子类型默认的顺序一致性会要求编译器禁用优化，这无疑增加了性能开销。于是 C++11 中，设计了能够对原子类型指定内存顺序 memory_order。我们把上文打印 a，b 的代码中的 func1 做一下修改：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    a.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>, std::memory_order_relaxed);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码使用了 store 函数进行赋值，store 函数接受两个参数，第一个是要写入的值，第二个是名为 memory_order 的枚举值。这里使用了 std::memory_order_relaxed，表示松散内存顺序，该枚举值代表编译器可以任由编译器重新排序或则由处理器乱序处理。这样 a 和 b 的赋值执行顺序性就被解除了，对于 func2 中的打印语句，打印出 0,2 的结果也就是合理的了。在 C++11 中一共有 7 种 memory_order 枚举值，默认按照 memory_order_seq_cst 执行： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/performace5.png"></p><p>需要注意的是，不是所有的 memory_order 都能被 atomic 成员使用：</p><ul><li>store 函数可以使用 memory_order_seq_cst、memory_order_release、memory_order_relaxed。</li><li>load 函数可以使用 memory_order_seq_cst、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li><li>需要同时读写的操作，例如 test_and_flag、exchange 等操作。可以使用 memory_order_seq_cst、memory_order_rel、memory_order_release、memory_order_acquire、memory_order_consume、memory_order_relaxed。</li><li>原子类型提供的一些操作符都是 memory_order_seq_cst 的封装，所以他们都是顺序一致性的。</li></ul><p>最后说明一下，在除非必要的情况下，不用使用 std::memory_order，std::atmoic 默认用的是最强限制。</p><h1 id="线程局部存储">线程局部存储</h1><p>线程局部存储（TLS， thread local storage）是一个已有的概念。简单地说，所谓线程局部存储变量，就是拥有线程生命期及线程可见性的变量。线程局部存储实际上是由单线程程序中的全局/静态变量被应用到多线程程序中被线程共享而来。我们可以简单地回顾一下所谓的线程模型。通常情况下，线程会拥有自己的栈空间，但是堆空间、静态数据区则是共享的。这样一来，全局、静态变量在这种多线程模型下就总是在线程间共享的。 C++11 声明一个 TLS 变量的语法很简单，即通过 thread_local 修饰符声明变量即可：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">thread_local</span> errcode;</span><br></pre></td></tr></tbody></table></figure><p>一旦声明一个变量为 thread_local，其值将在线程开始时被初始化，而在线程结束时，该值也将不再有效。对于 thread_local 变量地址取值（&amp;），也只可以获得当前线程中的 TLS 变量的地址值。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dpemFyZHRvSC9hcnRpY2xlL2RldGFpbHMvODExMTE1NDk=">https://blog.csdn.net/WizardtoH/article/details/81111549<i class="fa fa-external-link-alt"></i></span><br>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（四）智能指针</title>
      <link href="/next/2022/Program/CPP11Part4/"/>
      <url>/next/2022/Program/CPP11Part4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP11ImproveTypeSafety.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyZjM0NjU2NTNiYjA3NGIyMmU3Njg=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="shared_ptr">shared_ptr</h1><h2 id="实现原理">实现原理</h2><p>一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。shared_ptr 需要维护的信息有两部分：</p><ul><li>指向共享资源的指针</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针</li></ul><p>所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。当我们创建一个 shared_ptr 时，其实现一般如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">sptr1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer1.jpg"></p><p>复制一个 shared_ptr ：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; sptr2 = sptr1;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer2.jpg"></p><p>为什么控制信息和每个 shared_ptr 对象都需要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？</p><p>答案是：不能。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</p><p>来看一个例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fruit</span> {</span><br><span class="line">    <span class="type">int</span> juice;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vegetable</span> {</span><br><span class="line">    <span class="type">int</span> fiber;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tomato</span> : <span class="keyword">public</span> Fruit, Vegetable {</span><br><span class="line">    <span class="type">int</span> sauce;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span></span><br><span class="line">std::shared_ptr&lt;Tomato&gt; tomato = std::<span class="built_in">make_shared</span>&lt;Tomato&gt;();</span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = tomato;</span><br><span class="line">std::shared_ptr&lt;Vegetable&gt; vegetable = tomato;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer3.jpg"></p><p>另外，std::shared_ptr 支持 aliasing constructor。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( <span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r, element_type* ptr )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>Aliasing constructor，简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> elts = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">    std::shared_ptr&lt;Vec&gt; pvec = std::<span class="built_in">make_shared</span>&lt;Vec&gt;(elts);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(pvec, &amp;(*pvec)[<span class="number">2</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = <span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sptr.<span class="built_in">get</span>()[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer4.jpg"></p><p>看上面的例子，使用 std::shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 std::make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer5.jpg"></p><p>这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer6.jpg"></p><h2 id="析构">析构</h2><p>shared_ptr 默认调用 delete 释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个 shared_ptr 的策略。下面的例子是一个由于采用默认析构策略导致的问题：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {...};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>] )</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在此场景下，shared_ptr 指向一组对象，但是当离开作用域时，默认的析构函数调用 delete 释放资源。实际上，我们应该调用 delete[] 来销毁这个数组。用户可以通过调用一个函数，例如一个 lamda 表达式，来指定一个通用的释放步骤。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">        [ ](Test* p) { <span class="keyword">delete</span>[ ] p; } )</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过指定 delete[] 来析构，上面的代码可以完美运行。</p><h2 id="issues">Issues</h2><p>所有的 shared_ptrs 拥有相同的引用计数，属于相同的组。上述代码工作良好，让我们看另外一组例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr1</span><span class="params">( p)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr2</span><span class="params">( p )</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码会产生一个错误，因为两个来自不同组的 shared_ptr 指向同一个资源。下表给你关于错误原因的图景：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/sp1.jpg"></p><p>避免这个问题，尽量不要从一个裸指针 (naked pointer) 创建 shared_ptr。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">m_sptrB</span>(<span class="literal">nullptr</span>) { };</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">     cout&lt;&lt;<span class="string">" A is destroyed"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    shared_ptr&lt;B&gt; m_sptrB;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">m_sptrA</span>(<span class="literal">nullptr</span>) { };</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    {</span><br><span class="line">     cout&lt;&lt;<span class="string">" B is destroyed"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    shared_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码产生了一个循环引用，A 对 B 有一个 shared_ptr, B 对 A 也有一个 shared_ptr ，与 sptrA 和 sptrB 关联的资源都没有被释放，参考下表：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/sp2.jpg"></p><p>当 sptrA 和 sptrB 离开作用域时，它们的引用计数都只减少到 1，所以它们指向的资源并没有释放！！！！！</p><ul><li>如果几个 shared_ptrs 指向的内存块属于不同组，将产生错误。</li><li>如果从一个普通指针创建一个 shared_ptr 还会引发另外一个问题。在上面的代码中，考虑到只有一个 shared_ptr 是由 p 创建的，代码可以好好工作。万一程序员在智能指针作用域结束之前删除了普通指针 p。天啦噜！！！又是一个 crash。</li><li>循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放。</li></ul><p>为了解决循环引用，C++提供了另外一种智能指针：weak_ptr</p><h1 id="weak_ptr">Weak_Ptr</h1><h2 id="原理">原理</h2><p>std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p><ul><li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; wptr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sptr = wptr.<span class="built_in">lock</span>()) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"value: "</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"wptr lock fail"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wptr;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">111</span>);</span><br><span class="line">    wptr = sptr;</span><br><span class="line">    <span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer7.jpg"></p><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer8.jpg"></p><h2 id="enable_shared_from_this">enable_shared_from_this</h2><p>一个类的成员函数如何获得指向自身（this）的 shared_ptr？ 看看下面这个例子有没有问题？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Foo&gt;(<span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Foo&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr2.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面的代码其实会生成两个独立的 shared_ptr，他们的控制块是独立的，最终导致一个 Foo 对象会被 delete 两次。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer9.jpg"></p><p>成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Bar&gt; {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;Bar&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Bar&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr2.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><p>一般情况下，继承了 std::enable_shared_from_this 的子类，成员变量中增加了一个指向 this 的 weak_ptr。这个 weak_ptr 在第一次创建 shared_ptr 的时候会被初始化，指向 this。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/smart_pointer10.jpg"></p><p>似乎继承了 std::enable_shared_from_this 的类都被强制必须通过 shared_ptr 进行管理。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = <span class="keyword">new</span> Bar;</span><br><span class="line"><span class="keyword">auto</span> sptr = b-&gt;<span class="built_in">shared_from_this</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="使用">使用</h2><p>现在让我们见识一下 weak_ptr 如何解决循环引用问题：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(  ) : <span class="built_in">m_a</span>(<span class="number">5</span>)  { };</span><br><span class="line">    ~<span class="built_in">A</span>( )</span><br><span class="line">    {</span><br><span class="line">     cout&lt;&lt;<span class="string">" A is destroyed"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintSpB</span><span class="params">( )</span></span>;</span><br><span class="line">    weak_ptr&lt;B&gt; m_sptrB;</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(  ) : <span class="built_in">m_b</span>(<span class="number">10</span>) { };</span><br><span class="line">    ~<span class="built_in">B</span>( )</span><br><span class="line">    {</span><br><span class="line">     cout&lt;&lt;<span class="string">" B is destroyed"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    weak_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::PrintSpB</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>( !m_sptrB.<span class="built_in">expired</span>() )</span><br><span class="line">    {</span><br><span class="line">     cout&lt;&lt; m_sptrB.<span class="built_in">lock</span>( )-&gt;m_b&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">    sptrA-&gt;<span class="built_in">PrintSpB</span>( );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/sp3.jpg"></p><h1 id="unique_ptr">unique_ptr</h1><p>unique_ptr 遵循着独占语义。在任何时间点，资源只能唯一地被一个 unique_ptr 占有。当 unique_ptr 离开作用域，所包含的资源被释放。如果资源被其它资源重写了，之前拥有的资源将被释放。所以它保证了他所关联的资源总是能被释放。</p><p><strong>创建</strong> </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">uptr</span><span class="params">( <span class="keyword">new</span> <span class="type">int</span> )</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>当创建 unique_ptr 时，这一组对象被视作模板参数的部分。这样，程序员就不需要再提供一个指定的析构方法，如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[ ]&gt; <span class="title">uptr</span><span class="params">( <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>] )</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>当把 unique_ptr 赋给另外一个对象时，资源的所有权就会被转移。记住 unique_ptr 不提供复制语义（拷贝赋值和拷贝构造都不可以），只支持移动语义 (move semantics)。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lNDkxOWYxYzNhMjg=">https://www.jianshu.com/p/e4919f1c3a28<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNTA1NTUxNjU=">https://zhuanlan.zhihu.com/p/150555165<i class="fa fa-external-link-alt"></i></span><br>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（三）auto、decltype 与 for</title>
      <link href="/next/2022/Program/CPP11Part3/"/>
      <url>/next/2022/Program/CPP11Part3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP11EasyToLearn.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyZWZmYTYzNzY4OTA4MmYwMzA4Nzk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="右尖括号的改进">右尖括号&gt;的改进</h1><p>在 C++98 中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i&gt; <span class="keyword">class</span> <span class="title class_">X</span>{};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Y</span>{};</span><br><span class="line"></span><br><span class="line">Y&lt;X&lt;<span class="number">1</span>&gt; &gt; x1;   <span class="comment">//编译成功</span></span><br><span class="line">Y&lt;X&lt;<span class="number">2</span>&gt;&gt; x2;   <span class="comment">//编译失败</span></span><br></pre></td></tr></tbody></table></figure><p>在 x2 的定义中，编译器会把&gt;&gt;优先解析为右移符号。</p><p>C++98 同样会将&gt;&gt;优先解析为右移。C++11 中，这种限制被取消了。事实上，C++11 标准要求编译器智能地去判断在哪些情况下&gt;&gt;不是右移符号。使用 C++11 标准，上述所示代码则会成功地通过编译。</p><h1 id="auto-关键字">auto 关键字</h1><h2 id="auto-的限制">auto 的限制</h2><p>使用 auto 的时候必须对变量进行初始化，这是 auto 的限制之一。那么，除此以外，auto 还有哪些其它的限制呢？</p><ul><li>auto 不能在函数的参数中使用 这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的</li><li>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</li><li>auto 关键字不能定义数组</li><li>auto 不能作用于模板参数</li></ul><h2 id="auto-的应用">auto 的应用</h2><ul><li>使用 auto 定义迭代器</li><li>auto 用于泛型编程</li></ul><h1 id="decltype-关键字">decltype 关键字</h1><h2 id="decltype-与-auto-的区别">decltype 与 auto 的区别</h2><p>既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p><p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br></pre></td></tr></tbody></table></figure><p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p><p>auto 根据=右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系。</p><p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式： decltype(exp) varname;</p><blockquote><p>原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p></blockquote><h2 id="decltype-推导规则">decltype 推导规则</h2><ul><li>如果 exp 是一个不被括号 ( ) 包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li><li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li><li>如果 exp 是一个左值，或者被括号 ( ) 包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li></ul><h2 id="decltype-的实际应用">decltype 的实际应用</h2><p>auto 的语法格式比 decltype 简单，所以在一般的类型推导中，使用 auto 比使用 decltype 更加方便，本节仅演示只能使用 decltype 的情形。</p><p>我们知道，auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>{</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，T::iterator 并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p><p>要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>{</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="基于范围的-for-循环">基于范围的 for 循环</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p= arr; p &lt; arr +<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); ++p){</span><br><span class="line">        *p *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(p =arr; p &lt; arr +<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); ++p){</span><br><span class="line">        cout &lt; *p &lt; <span class="string">"\t"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上述代码中，我们使用了指针 p 来遍历数组 arr 中的内容，两个循环分别完成了每个元素自乘以 2 和打印工作。而 C++的标准模板库中，我们还可以找到形如 for_each 的模板函数。如果我们使用 for_each 来完成上述代码中的工作，代码看起来会是这个样子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">action1</span><span class="params">(<span class="type">int</span> &amp; e)</span> </span>{e*=<span class="number">2</span>;};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">action2</span><span class="params">(<span class="type">int</span> &amp;e)</span> </span>{cout &lt;&lt; e &lt;&lt; <span class="string">'\t'</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}</span><br><span class="line">    for_each(arr, arr + <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), action1);</span><br><span class="line">    for_each(arr, arr + <span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]), action2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for_each 使用了迭代器的概念，其迭代器就是指针，迭代器内含了自增操作。</p><p>我们可以看一下基于范围的 for 循环改写的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;e: arr)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;e: arr)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码就是一个基于范围的 for 循环的实例。for 循环后的括号由冒号“：”分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示将被迭代的范围。这样一来，遍历数组和 STL 容器就非常容易了。</p><p>值得指出的是，是否能够使用基于范围的 for 循环，必须依赖于一些条件。首先，就是 for 循环迭代的范围是可确定的。对于类来说，如果该类有 begin 和 end 函数，那么 begin 和 end 之间就是 for 循环迭代的范围。对于数组而言，就是数组的第一个和最后一个元素间的范围。其次，基于范围的 for 循环还要求迭代的对象实现++和=等操作符。对于标准库中的容器，如 string、aray、 vector、 deque、it、 queue、map、set 等，不会有问题，因为标准库总是保证其容器定义了相关的操作。普通的已知长度的数组也不会有问题。而用户自己写的类，则需要自行提供相关操作。相反，如果我们数组大小不能确定的话，是不能够使用基于范围的 for 循环的。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzY5ODQuaHRtbA==">http://c.biancheng.net/view/6984.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzcxNTEuaHRtbA==">http://c.biancheng.net/view/7151.html<i class="fa fa-external-link-alt"></i></span><br>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（二）右值引用与 POD</title>
      <link href="/next/2022/Program/CPP11Part2/"/>
      <url>/next/2022/Program/CPP11Part2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP11GeneralPurposeAndSpecialPurposeAtTheEnd.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyZTBlYTdkOWMwODA3NmQxMDkzMGE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="继承构造函数">继承构造函数</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i){};</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> d, <span class="type">int</span> i) {};</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> f, <span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>* c){};</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i){};</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">double</span> d, <span class="type">int</span> i): <span class="built_in">A</span>(d, i){};</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">float</span> f, <span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>*c): <span class="built_in">A</span>(f, i, c)(){};</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Extrainterface</span><span class="params">()</span></span>{};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>继承于 A 的派生类 B 实际上只是添加了一个接口 Extralnterface，那么如果我们在构造 B 的时候想要拥有 A 这样多的构造方法的话，就必须一“透传”各个接口。这无疑是相当不方便的。事实上，在 C++中已经有了一个好用的规则，子类可以通过使用 using 声明来声明继承基类的构造函数。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i){};</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span> d, <span class="type">int</span> i) {};</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> f, <span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>* c){};</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Extrainterface</span><span class="params">()</span></span>{};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>而有的时候，我们还会遇到继承构造函数“冲突”的情况。这通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有的时候，我们也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {<span class="built_in">A</span>(<span class="type">int</span>){}};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {<span class="built_in">B</span>(<span class="type">int</span>){}};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: A, B {</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A 和 B 的构造函数会导致 C 中重复定义相同类型的继承构造函数。这种情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐式生成相应的继承构造函数来解决冲突。比如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: A, B {</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>){};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中的构造函数 C(int) 就很好地解决了继承构造函数的冲突问题。</p><h1 id="委派构造函数">委派构造函数</h1><p>与继承构造函数类似的，委派构造函数也是 C++11 中对 C++的构造函数的一项改进其目的也是为了减少程序员书写构造函数的时间。通过委派其他构造函数，多构造函数的类编写将更加容易。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>(): <span class="built_in">type</span>(<span class="number">1</span>), <span class="built_in">name</span>(a){<span class="built_in">Initrest</span>()};</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i): <span class="built_in">type</span>(i), <span class="built_in">name</span>(a){<span class="built_in">Initrest</span>()};</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e): <span class="built_in">type</span>(<span class="number">1</span>), <span class="built_in">name</span>(e){<span class="built_in">Initrest</span>()};</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> Initrest（）{<span class="comment">/*其他初始化*/</span> }</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在上述代码中，我们声明了一个 Info 的自定义类型。该类型拥有 2 个成员变量以及 3 个构造函数。这里的 3 个构造函数都声明了初始化列表来初始化成员 type 和 name，并且都调用了相同的函数 Initrest。可以看到，除了初始化列表有的不同，而其他的部分，3 个构造函数基本上是相似的，因此其代码存在着很多重复。</p><p>在 C++11 中，我们可以使用委派构造函数来达到期望的效果。更具体的，C++11 中的委派构造函数是在构造函数的初始化列表位置进行构造的、委派的。我们可以看看</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>(){<span class="built_in">Initrest</span>();};</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i): <span class="built_in">Info</span>(){type =i;};</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e): <span class="built_in">Info</span>(){name = e;};</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Initrest</span><span class="params">()</span></span>{<span class="comment">/*其他初始化*/</span>};</span><br><span class="line">    <span class="type">int</span> type{<span class="number">1</span>};</span><br><span class="line">    <span class="type">char</span> name{<span class="string">'a'</span>};</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，在上述代码中，我们在 Info（int）和 Info（char）的初始化列表的位置，调用了“基准版本”的构造函数 Info。这里我们为了区分被调用者和调用者，称在初始化列表中调用“基准版本”的构造函数为委派构造函数（ delegating constructor），而被调用的基准版本”则为目标构造函数（ target constructor）。在 C++11 中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。</p><h1 id="右值引用移动语义和完美转发">右值引用：移动语义和完美转发</h1><h2 id="c11-的左值和右值的概念">C++11 的左值和右值的概念</h2><p>在 c++中，一个值要么是右值，要么是左值，左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lvalue = <span class="number">1</span>; <span class="comment">// lvalue 为左值， 1 为右值</span></span><br></pre></td></tr></tbody></table></figure><h2 id="左值引用和右值引用">左值引用和右值引用</h2><ul><li>左值引用：引用一个对象</li><li>右值引用：就是必须绑定到右值的引用，C++11 中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。右值引用，可以延长右值的生命期，比如：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; i = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; j = std::<span class="built_in">move</span>(i);</span><br><span class="line"><span class="type">int</span>&amp;&amp; k = i;        <span class="comment">//编译不过，这里 i 是一个左值，右值引用只能引用右值</span></span><br></pre></td></tr></tbody></table></figure><p>可以通过下面的代码，更深入的体会左值引用和右值引用的区别：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; j = i++; <span class="comment">// 右值 i 先赋值，然后做+1 运算，运算结果存在栈中</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; k = ++i; <span class="comment">// 左值 先做+1 运算，+1 的结果赋值到 i 变量中，i 是一个左值</span></span><br><span class="line"><span class="type">int</span>&amp; m = i++;</span><br><span class="line"><span class="type">int</span>&amp; l = ++i;</span><br><span class="line"></span><br><span class="line">move.cpp: In function ‘<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>’:</span></span><br><span class="line"><span class="function">move.cpp:<span class="number">72</span>:<span class="number">14</span>: error: cannot bind ‘int’ lvalue to ‘int&amp;&amp;’</span></span><br><span class="line"><span class="function">  int&amp;&amp; k =</span> ++i;</span><br><span class="line">              ^</span><br><span class="line">move.cpp:<span class="number">73</span>:<span class="number">15</span>: error: invalid initialization of non-<span class="type">const</span> reference of type ‘<span class="type">int</span>&amp;’ from an rvalue of type ‘<span class="type">int</span>’</span><br><span class="line">     <span class="type">int</span>&amp; m = i++;</span><br></pre></td></tr></tbody></table></figure><h2 id="为什么需要右值引用">为什么需要右值引用</h2><p>C++引入右值引用之后，可以通过右值引用，充分使用临时变量，或者即将不使用的变量即右值的资源，减少不必要的拷贝，提高效率。如下代码，均会产生临时变量：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RValue</span> {</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">RValue <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RValue</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(RValue)</span></span>{}</span><br></pre></td></tr></tbody></table></figure><p>为了充分利用右值的资源，减少不必要的拷贝，C++11 引入了右值引用 (&amp;&amp;)，移动构造函数，移动复制运算符以及 std::move。</p><h2 id="stdmove">std::move</h2><h3 id="右值引用-移动构造函数移动复制运算符以及-stdmove">右值引用 (&amp;&amp;)，移动构造函数，移动复制运算符以及 std::move</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RValue</span> {</span><br><span class="line"><span class="built_in">RValue</span>():<span class="built_in">sources</span>(<span class="string">"hello!!!"</span>){}</span><br><span class="line"><span class="built_in">RValue</span>(RValue&amp;&amp; a) {</span><br><span class="line">sources = std::<span class="built_in">move</span>(a.sources);</span><br><span class="line">cout&lt;&lt;<span class="string">"&amp;&amp; RValue"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">RValue</span>(<span class="type">const</span> RValue&amp; a) {</span><br><span class="line">sources = a.sources;</span><br><span class="line">cout&lt;&lt;<span class="string">"&amp; RValue"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> RValue&amp;&amp; a) {</span><br><span class="line">sources = std::<span class="built_in">move</span>(a.sources);</span><br><span class="line">cout&lt;&lt;<span class="string">"&amp;&amp; =="</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> RValue&amp; a) {</span><br><span class="line">sources = a.sources;</span><br><span class="line">cout&lt;&lt;<span class="string">"&amp; =="</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">string sources;;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">RValue <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    RValue a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(RValue)</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">RValue a = <span class="built_in">get</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">"---------------"</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">put</span>(<span class="built_in">RValue</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不过，当运行的时候却发现没有任何输出</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line">./move</span><br><span class="line">---------------</span><br></pre></td></tr></tbody></table></figure><p>这是因为，编译器做了优化，编译的时候加上-fno-elide-constructors，去掉优化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ move.cpp -std=c++11 -fno-elide-constructors -o move</span><br><span class="line"> ./move</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line">&amp;&amp; RValue</span><br></pre></td></tr></tbody></table></figure><p>通过上面的代码，可以看出，在没有加-fno-elide-constructors 选项时，编译器做了优化，没有临时变量的生成。在加了-fno-elide-constructors 选项时，get 产生了两次临时变量，put 生成了一次临时变量。</p><p>将 get 函数稍微修改一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RValue <span class="function"><span class="title">get</span></span>() {</span><br><span class="line">RValue a;</span><br><span class="line"><span class="built_in">return</span> std::move(RValue());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">//加编译选项</span><br><span class="line">g++ move.cpp -std=c++11 -fno-elide-constructors -o move</span><br><span class="line"> ./move</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">---------------</span><br><span class="line">&amp;&amp; RValue</span><br></pre></td></tr></tbody></table></figure><p>只是简单的修改了一下，std::move(a)，在编译器做了优化的情况下，用了 std::move，反而多做了一次拷贝。</p><p>其实，RValue 如果在没有定义移动构造函数，重复上面的操作，生成临时变量的次数还是一样的，只不过，调用的时拷贝构造函数了而已。</p><p>通过 get 函数可以知道，乱用 std::move 在编译器开启构造函数优化的场景下反而增加了不必要的拷贝。那么，std::move 应该在什么场景下使用？</p><h3 id="stdmove-使用场景">std::move 使用场景</h3><h4 id="移动构造函数的原理">移动构造函数的原理</h4><p>通过移动构造，b 指向 a 的资源，a 不再拥有资源，这里的资源，可以是动态申请的内存，网络链接，打开的文件，也可以是本例中的 string。这时候访问 a 的行为时未定义的，比如，如果资源是动态内存，a 被移动之后，再次访问 a 的资源，根据移动构造函数的定义，可能是空指针，如果是资源上文的 string，移动之后，a 的资源为空字符串（string 被移动之后，为空字符串）。 可以通过下面代码验证，修改 main 函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">RValue a, b;</span><br><span class="line">RValue a1 = std::<span class="built_in">move</span>(a);</span><br><span class="line">cout&lt;&lt;<span class="string">"a.sources:"</span>&lt;&lt;a.sources&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">"a1.sources:"</span>&lt;&lt;a1.sources&lt;&lt;endl;</span><br><span class="line"><span class="function">RValue <span class="title">b1</span><span class="params">(b)</span></span>;</span><br><span class="line">cout&lt;&lt;<span class="string">"b.sources:"</span>&lt;&lt;b.sources&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">"b1.sources:"</span>&lt;&lt;a1.sources&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++<span class="number">11</span> -o move</span><br><span class="line"> ./move</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">a.sources:</span><br><span class="line">a1.sources:hello!!!</span><br><span class="line">&amp; RValue</span><br><span class="line">b.sources:hello!!!</span><br><span class="line">b1.sources:hello!!!</span><br></pre></td></tr></tbody></table></figure><p>通过移动构造函数之后，a 的资源为空，b 指向了 a 的资源。通过拷贝构造函数，b 复制了 a 的资源。</p><h4 id="stdmove-的原理">std::move 的原理</h4><p>std::move 的定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>{ <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里，T&amp;&amp;是通用引用，需要注意和右值引用（比如 int&amp;&amp;）区分。通过 move 定义可以看出，move 并没有”移动“什么内容，只是将传入的值转换为右值，此外没有其他动作。std::move+移动构造函数或者移动赋值运算符，才能充分起到减少不必要拷贝的意义。</p><h4 id="stdmove-的使用场景">std::move 的使用场景</h4><p>在之前的项目中看到有的同事到处使用 std::move，好像觉得使用了 std::move 就能移动资源，提升性能一样，在我看来，std::move 主要使用在以下场景：</p><ul><li>使用前提：<ul><li><ol type="1"><li>定义的类使用了资源并定义了移动构造函数和移动赋值运算符</li></ol></li><li><ol start="2" type="1"><li>该变量即将不再使用</li></ol></li></ul></li><li>使用场景</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RValue a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 a,b 做一系列操作之后，不再使用 a,b，但需要保存到智能指针或者容器之中</span></span><br><span class="line"><span class="function">unique_ptr&lt;RValue&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> RValue(std::move(a)))</span></span>;</span><br><span class="line">vector&lt;RValue*&gt; vr;</span><br><span class="line">vr.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">RValue</span>(std::<span class="built_in">move</span>(b)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时容器中保存的大量的元素需要复制到目标容器之中</span></span><br><span class="line">vector&lt;RValue&gt; vrs_temp;</span><br><span class="line">vrs_temp.<span class="built_in">push_back</span>(<span class="built_in">RValue</span>());</span><br><span class="line"><span class="function">vector&lt;RValue&gt; <span class="title">vrs</span><span class="params">(std::move(vrs_temp))</span></span>;</span><br><span class="line"></span><br><span class="line">RValue c;</span><br><span class="line"><span class="built_in">put</span>(std::<span class="built_in">move</span>(c));</span><br></pre></td></tr></tbody></table></figure><ul><li>在没有右值引用之前，为了使用临时变量，通常定义 const 的左值引用，比如 const string&amp;，在有了右值引用之后，为了使用右值语义，不要把参数定义为常量左值引用，否则，传递右值时调用的是拷贝构造函数。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void put(const RValue&amp; c){</span><br><span class="line">cout&lt;&lt;<span class="string">"----------"</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">unique_ptr&lt;RValue&gt; up(new RValue(std::move(c)));</span></span><br><span class="line"><span class="string">cout&lt;&lt;"----------"&lt;&lt;endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">RValue c;</span><br><span class="line">put(std::move(c));</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move</span><br><span class="line">----------</span><br><span class="line">&amp; RValue</span><br><span class="line">----------</span><br></pre></td></tr></tbody></table></figure><p>不使用左值常量引用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void put(RValue c){</span><br><span class="line">cout&lt;&lt;<span class="string">"----------"</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">unique_ptr&lt;RValue&gt; up(new RValue(std::move(c)));</span></span><br><span class="line"><span class="string">cout&lt;&lt;"----------"&lt;&lt;endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">RValue c;</span><br><span class="line">put(std::move(c));</span><br><span class="line"></span><br><span class="line">g++ move.cpp -std=c++11 -o move</span><br><span class="line"> ./move</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">----------</span><br><span class="line">&amp;&amp; RValue</span><br><span class="line">----------</span><br></pre></td></tr></tbody></table></figure><p>这是因为，根据通用引用的定义，std::move(c) 过程中，模板参数被推倒为 const RValue&amp;，因此，调用拷贝构造函数。</p><h4 id="总结">总结</h4><p>通过简绍右值和右值引用以及 std::move 和移动构造函数，总结右值引用，移动构造函数和移动赋值运算符和 std::move 的用法和注意事项。</p><h2 id="stdforward">std::forward</h2><h3 id="forward-的作用">forward 的作用</h3><p>std::forward 被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经 std::forward 处理后该值还是左值；如果原来的值是右值，经 std::forward 处理后它还是右值。</p><p>看看下面的例子，你应该就清楚上面这句话的含义了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"左值"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"右值"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>{</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"======================"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testFoward</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o forward test_forward.cpp</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码执行结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">左值</span><br><span class="line">右值</span><br><span class="line">=========================</span><br><span class="line">左值</span><br><span class="line">右值</span><br></pre></td></tr></tbody></table></figure><p>从上面第一组的结果我们可以看到，传入的 1 虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了 std::forward 函数，所以不会改变它的右值属性，因此会调用参数为右值引用的 print 模板函数；第三行，因为 std::move 会将传入的参数强制转成右值，所以结果一定是右值。</p><p>再来看看第二组结果。因为 x 变量是左值，所以第一行一定是左值；第二行使用 forward 处理，它依然会让其保持左值，所以第二也是左值；最后一行使用 move 函数，因此一定是右值。</p><p>通过上面的例子我想你应该已经清楚 forward 的作用是什么了吧？</p><h3 id="forward-实现原理">forward 实现原理</h3><p>要分析 forward 实现原理，我们首先来看一下 forward 代码实现。由于我们之前已经有了分析 std::move 的基础，所以再来看 forward 代码应该不会太困难。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>forward 实现了两个模板函数，一个接收左值，另一个接收右值。</p><h1 id="pod">POD</h1><p>POD 是英文中 Plain Old Data 的缩写。POD 在 C++中是非常重要的一个概念，通常用于说明一个类型的属性，尤其是用户自定义类型的属性。具体地，C++11 将 POD 划分为两个基本概念的合集，即：平凡的（trivial）和标准布局的（standard layout）。</p><h2 id="trivial">trivial</h2><p>我们先来看一下平凡的定义。通常情况下，一个平凡的类或结构体应该符合以下定义：</p><ul><li>拥有平凡的默认构造函数（trivial constructor）和析构函数（trivial destructor）。平凡的默认构造函数就是说构造函数“什么都不干”。使用=default 关键字来显式地声明缺省版本的构造函数，使得类型恢复“平凡化”。</li><li>拥有平凡的拷贝构造函数（trivial copy constructor）和移动构造函数（trivialmove constructor）。平凡的拷贝构造函数基本上等同于使用 memcpy 进行类型的构造。同平凡的默认构造函数一样，不声明拷贝构造函数的。话，编译器会帮程序员自动地生成。同样地，可以显式地使用=default 声明默认拷贝构造函数。</li><li>拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）。这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。</li><li>不能包含虚函数以及虚基类</li></ul><h2 id="standard-layout">standard layout</h2><p>标准布局的类或结构体应该符合以下定义：</p><ul><li>所有非静态成员有相同的访问权限（public, private, protected）</li><li>在类或者结构体继承时，满足以下两种情况之一：<ul><li>派生类中有非静态成员，且只有一个仅包含静态成员的基类</li><li>基类有非静态成员，而派生类没有非静态成员</li></ul></li><li>类中第一个非静态成员的类型与其基类不同</li><li>没有虚函数和虚基类</li><li>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局。这是一个递归的定义，没有什么好特别解释的</li></ul><h2 id="pod-1">POD</h2><p>对于 POD 而言，在 C++11 中的定义就是平凡的和标准布局的两个方面。同样地，要判定某一类型是否是 POD，标准库中的<type_traits>头文件也为程序员提供了如下模板类：</type_traits></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// is_pod</span></span><br><span class="line"><span class="comment">// Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pod</span></span><br><span class="line">: <span class="keyword">public</span> integral_constant&lt;<span class="type">bool</span>, __is_pod(_Tp)&gt;</span><br><span class="line">  { };</span><br></pre></td></tr></tbody></table></figure><p>使用 POD 我们看得到的大概有如下 3 点：</p><ul><li>字节赋值，代码中我们可以安全地使用 memset 和 memcpy 对 POD 类型进行初始化和拷贝等操作。</li><li>提供对 C 内存布局兼容。C++程序可以与 C 函数进行相互操作，因为 POD 类型的数据在 C 与 C++间的操作总是安全的。</li><li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而 POD 类型的对象初始化往往更加简单（比如放入目标文件的。bss 段，在初始化中直接被赋 0）。</li></ul><h1 id="用户定义字面量">用户定义字面量</h1><h2 id="c中的字面量">C++中的字面量</h2><p>C++ 自带 4 种字面量：</p><ul><li>整形 123</li><li>浮点型 12.3</li><li>字符 '1'</li><li>字符串 "123"</li></ul><p>字面量又可添加后缀来表明具体类型：</p><ul><li>无符号整形 (unsigned int): 123u</li><li>长整形 (long): 123l</li></ul><p>在 C++03 中，我们可以定义一个浮点数 height</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> height = <span class="number">3.4</span>;</span><br></pre></td></tr></tbody></table></figure><p>那么，痛点来了，此处的 height 的单位是什么呢？米？厘米？又或是英尺？在面对此类问题时，如果我们能编写如下代码，事情就会简单许多：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">3</span>cm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ratio = (3 * 10) / 2</span></span><br><span class="line">ratio = <span class="number">3</span>cm / <span class="number">2</span>mm;</span><br></pre></td></tr></tbody></table></figure><h2 id="用户自定义字面量">用户自定义字面量</h2><p>C++11 允许用户自定义字面量后缀</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="keyword">operator</span><span class="string">""</span> _cm(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="keyword">operator</span><span class="string">""</span> _m(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">1000</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="keyword">operator</span><span class="string">""</span> _mm(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// height = 30.0</span></span><br><span class="line"><span class="keyword">auto</span> height = <span class="number">3.0</span>_cm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// length = 1230.0</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="number">1.23</span>_m;</span><br></pre></td></tr></tbody></table></figure><p>如果使用这种写法，_cm, _m, _mm 等函数将在运行时被调用，如果希望在编译时就调用字面量后缀函数，则需要把函数定义为 constexpr，例如</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="keyword">operator</span><span class="string">""</span> _cm(<span class="type">long</span> <span class="type">double</span> x) {</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更进一步，我们甚至可以</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，如果这里要定义函数为 constexpr</span></span><br><span class="line"><span class="comment">// 编译时需要使用 c++14 标准 (-std=c++14)</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span><span class="string">""</span> _bin(</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* s,</span><br><span class="line">  <span class="type">size_t</span> l</span><br><span class="line">) {</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++){</span><br><span class="line">    ret = (ret &lt;&lt; <span class="number">1</span>) | (s[i] - <span class="string">'0'</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="string">"110"</span>_bin; <span class="comment">// num = 6</span></span><br></pre></td></tr></tbody></table></figure><h2 id="自定义字面量的限制">自定义字面量的限制</h2><p>C++11 只允许字面量后缀函数的参数为以下类型，即整数，浮点以及字符串：</p><ul><li>unsigned long long</li><li>long double</li><li>char const*</li><li>char const*, std::size_t</li><li>wchar_t const*, std::size_t</li><li>char16_t const*, std::size_t</li><li>char32_t const*, std::size_t</li></ul><p>返回值则无类型限制</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NDU4ODIwNA==">https://zhuanlan.zhihu.com/p/94588204<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85N2ZkZDg1Mjk3NGY=">https://www.jianshu.com/p/97fdd852974f<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMTEzNjk2OTM=">https://zhuanlan.zhihu.com/p/111369693<i class="fa fa-external-link-alt"></i></span><br>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11（一）assert 与 noexcept</title>
      <link href="/next/2022/Program/CPP11Part1/"/>
      <url>/next/2022/Program/CPP11Part1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPP11EnsureStabilityAndCompatibility.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyZDc3NTFlMDg1MzA3YTI0YjdiMDI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="静态断言-static_assert">静态断言 static_assert</h1><p>断言 assert 宏只有在程序运行时才能起作用，而#error 只在编译器预处理时才能起作用。有的时候，我们希望在编译时能做一些断言。读者也可以尝试一下 Boost 库内置的 BOOST_STATIC_ASSERT，其缺陷都是很明显的：诊断信息不够充分，从而难以准确定位错误的根源。</p><p>在 C++11 标准中，引人了 static_assert 断言来解决这个问题。 static_assert 使用起来非常简单，它接收两个参数，一个是断言表达式，这个表达式通常需要返回一个 bool 值；一个则是警告信息，它通常也就是一段字符串，在出错时会输出该字符信息，这样出错位置就是非常明确的。</p><h1 id="noexcept">noexcept</h1><p>noexcept 形如其名，表示其修饰的函数不会抛出异常。在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate 函数来终止程序的运行，这比基于异常机制的 throw 在效率上会高一些。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（ unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。</p><p>当然， noexcept 更大的作用是保证应用程序的安全。比如一个类析构函数不应该抛出异常，那么对于常被析构函数调用的 delete 函数来说，C++默认将 delete 函数设置成 noexcept，就可以提高应用程序的安全性。而同样出于安全考虑，C++11 标准中让类的析构函数默认也是 noexcept(true) 的。当然，如果程序员显式地为析构函数指定了 noexcept，或者类的基类或成员有 noexcept(false) 的析构函数，析构函数就不会再保持默认值。</p><h1 id="非静态成员的-sizeof">非静态成员的 sizeof</h1><p>从 C 语言被发明开始， sizeof 就是一个运算符，也是 C 语言中除了加减乘除以外为数不多的特殊运算符之一。而在 C++引入类（ class）类型之后， sizeof 的定义也随之进行了拓展。不过在 C++98 标准中，对非静态成员变量使用 sizeof 是不能够通过编译的。我们可以看看下面的例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hand;</span><br><span class="line">    <span class="type">static</span> People * all;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    People p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p.hand) &lt;&lt; endl;         <span class="comment">//C++98 中通过，C++11 中通过</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(People::all）&lt;&lt;endl；    <span class="comment">//c++98 中通过，C+11 中通过</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(People::hand）&lt;&lt; end1;   <span class="comment">//C++98 中错误，C++11 中通过</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意最后一个 sizeof 操作。在 C++11 中，对非静态成员变量使用 sizeof 操作是合法的。而在 C++98 中，只有静态成员，或者对象的实例才能对其成员进行 sizeof 操作。因此如果读者只有一个支持 C++98 标准的编译器，在没有定义类实例的时候，要获得类成员的大小，我们通常会采用以下的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (((People*)<span class="number">0</span>)-&gt;hand)</span><br></pre></td></tr></tbody></table></figure><p>这里我们强制转换 0 为一个 People 类的指针，继而通过指针的解引用获得其成员变量并用 sizeof 求得该成员变量的大小。而在 C++11 中，我们无需这样的技巧，因为 sizeof 可以作用的表达式包括了类成员表达式。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(People::hand);</span><br></pre></td></tr></tbody></table></figure><p>可以看到，无论从代码的可读性还是编写的便利性，C++11 的规则都比强制指针转换的方案更胜一筹。</p><h1 id="扩展的-friend-语法">扩展的 friend 语法</h1><p>friend 关键字用于声明类的友元，友元可以无视类中成员的属性。无论成员是 public、 protected 或是 private 的，友元类或友元函数都可以访问，这就完全破坏了面向对象编程中封装性的概念。因此，使用 friend 关键字充满了争议性。在通常情况下，面向对象程序开发的专家会建议程序员使用 Get/Set 接口来访问类的成员，但有的时候， friend 关键字确实会让程序员少写很多代码。因此即使存在争论， friend 还是在很多程序中被使用到。而 C++11 对 friend 关键字进行了一些改进，以保证其更加好用，我们可以看看下面的例子。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Poly</span>;</span><br><span class="line"><span class="keyword">typedef</span> Poly P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lilei</span> {</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Poly</span>;  <span class="comment">//C++98 通过，C++11 通过</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jim</span> {</span><br><span class="line">    <span class="keyword">friend</span> Poly;        <span class="comment">//C++98 失败，C++11 通过</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanmeimei</span> {</span><br><span class="line">    <span class="keyword">friend</span> p;           <span class="comment">//C++98 失败，C++11 通过</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>虽然在 C++11 中这是一个小的改进，却会带来一点应用的变化一程序员可以为类模板声明友元了。这在 C++98 中是无法做到的。比如下面这个例子，如代码清单 2-20 所示。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>{</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">People&lt;P&gt; PP;   <span class="comment">//类型 P 在这里是 People 类型的友元</span></span><br><span class="line">People&lt;<span class="type">int</span>&gt; P;  <span class="comment">//对于 int 类型模板参数，友元声明被忽略</span></span><br></pre></td></tr></tbody></table></figure><p>从代码中我们看到，对于 People 这个模板类，在使用类 P 为模板参数时，P 是 People&lt; P &gt; 的一个 friend 类。而在使用内置类型 int 作为模板参数的时候， People&lt; int &gt;会被实例化为一个普通的没有友元定义的类型。这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。这是一个非常有趣的小特性，在编写一些测试用例的时候，使用该特性是很有好处的。</p><h1 id="finaloverride-控制">final/override 控制</h1><p>final 关键字的作用是使派生类不可覆盖它所修饰的虚函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">object</span>{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>: <span class="keyword">public</span> object {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">final</span></span>;       <span class="comment">//声明为 fina1</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;             <span class="comment">//无法通过编译</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>派生于 Object 的 Base 类重载了 Object 的 fun 接口，并将本类中的 fun 函数声明为 final 的。那么派生于 Base 的 Derived 类对接口 fun 的重载则会导致编译时的错误。</p><p>在 C++11 中为了帮助程序员写继承结构复杂的类型，引入了虚函数描述符 override，如果派生类在虚函数声明时使用了 override 描述符，那么该函数必须重载其基类中的同名函数否则代码将无法通过编译。</p><h1 id="外部模板">外部模板</h1><h2 id="为什么需要外部模板">为什么需要外部模板</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><p>在第一个 test1.pp 文件中，我们定义了以下代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> test. h<span class="string">"</span></span></span><br><span class="line"><span class="string"><span class="meta">void test1() {fun(3)};</span></span></span><br></pre></td></tr></tbody></table></figure><p>而在另一个 test2.cpp 文件中，我们定义了以下代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>{<span class="built_in">fun</span>(<span class="number">4</span>)};</span><br></pre></td></tr></tbody></table></figure><p>由于两个源代码使用的模板函数的参数类型一致，所以在编译 test1.cpp 的时候，编译器实例化出了函数 fun<int>(int)，而当编译 test2.cpp 的时候，编译器又再一次实例化出了函数 fun<int>(int)。那么可以想象，在 test1.o 目标文件和 test2.o 目标文件中，会有两份一模一样的函数 fun<int>(int) 代码。而代码重复，为了节省空间，保留其中之一就可以了。事实上，大部分链接器也是这样做的，在链接的时候，链接器通过一些编译器辅助的手段将重复的模板函数代码 fun<int>(int) 删除掉，只保留了单个副本。我们可以看看下图中的模板函数的编译与链接的过程示意。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/c++11_1.png"></int></int></int></int></p><p>不过读者也注意到了，对于源代码中出现的每一处模板实例化，编译器都需要去做实例化的工作；而在链接时，链接器还需要移除重复的实例化代码。会极大地增加编译器的编译时间和链接时间。解决这个问题的方法就是使用“外部的”模板。</p><h2 id="显式的实例化与外部模板的声明">显式的实例化与外部模板的声明</h2><p>外部模板的使用实际依赖于 C++98 中一个已有的特性，即显式实例化。显式实例化的语法很简单，比如对于以下模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span></span>{}</span><br></pre></td></tr></tbody></table></figure><p>我们只需要声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);</span><br></pre></td></tr></tbody></table></figure><p>这就可以使编译器在本编译单元中实例化出一个 fun<int>(int) 版本的函数（这种做法也被称为强制实例化）。而在 C++11 标准中，又加入了外部模板（ Extern Template）的声明。语法上，外部模板的声明跟显式的实例化差不多，只是多了一个关键字 extern。对于上面的例子，我们可以通过：</int></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>)</span><br></pre></td></tr></tbody></table></figure><p>首先，在 test1.cpp 做显式地实例化：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test.h"</span></span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);    <span class="comment">//显示地实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>{<span class="built_in">fun</span>(<span class="number">3</span>)};</span><br></pre></td></tr></tbody></table></figure><p>接下来，在 test2.cpp 中做外部模板的声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude <span class="string">"test.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> fun&lt;<span class="type">int</span>&gt;（<span class="type">int</span>）;   <span class="comment">//外部模板的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>{<span class="built_in">fun</span>(<span class="number">3</span>)};</span><br></pre></td></tr></tbody></table></figure><p>这样一来，在 test2.o 中不会再生成 fun<int>(int) 的实例代码。整个模板的实例化流程如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/c++11_2.png"></int></p><p>可以看到，由于 test2.o 不再包含 fun<int>(int) 的实例，因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让 test1.cpp 和 test2.cpp 共享一份代码位置即可。而同时，编译器也不用每次都产生一份 fun<int>(int) 的代码，所以可以减少编译时间。这里也可以把外部模板声明放在头文件中，这样所有包含 test.h 的头文件就可以共享这个外部模板声明了，这一点跟使用外部变量声明是完全一致的。</int></int></p><h1 id="参考文献">参考文献</h1><p>《深入理解 C++11：C++11 新特性解析与应用》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构（三）构筑测试体系</title>
      <link href="/next/2022/Program/RefactorPart3/"/>
      <url>/next/2022/Program/RefactorPart3/</url>
      
        <content type="html"><![CDATA[<h1 id="自测试代码的价值">自测试代码的价值</h1><p>一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需的时间。</p><p>事实上，撰写测试代码的最好时机是在开始动手编码之前。当我需要添加特性时，我会先编写相应的测试代码。听起来离经叛道，其实不然。编写测试代码其实就是在问自己：为了添加这个功能，我需要实现些什么？编写测试代码还能帮我把注意力集中于接口而非实现（这永远是一件好事）。预先写好的测试代码也为我的工作安上一个明确的结束标志：一旦测试代码正常运行，工作就可以结束了。</p><p>Kent Beck 将这种先写测试的习惯提炼成一门技艺，叫测试驱动开发（Test-Driven Development，TDD）[mf-tdd]。测试驱动开发的编程方式依赖于下面这个短循环：先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁。这个“测试、编码、重构”的循环应该在每个小时内都完成很多次。这种良好的节奏感可使编程工作以更加高效、有条不紊的方式开展。</p><span id="more"></span><h1 id="第一组重构">第一组重构</h1><h2 id="提炼函数extract-function">提炼函数（Extract Function）</h2><p>我会浏览一段代码，理解其作用，然后将其提炼到一个独立的函数中，并以这段代码的用途为这个函数命名。如果你需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。以后再读到这段代码时，你一眼就能看到函数的用途，大多数时候根本不需要关心函数如何达成其用途（这是函数体内干的事）。</p><h2 id="提炼变量extract-variable">提炼变量（Extract Variable）</h2><p>如果我考虑使用提炼变量，就意味着我要给代码中的一个表达式命名。一旦决定要这样做，我就得考虑这个名字所处的上下文。如果这个名字只在当前的函数中有意义，那么提炼变量是个不错的选择；但如果这个变量名在更宽的上下文中也有意义，我就会考虑将其暴露出来，通常以函数的形式。如果在更宽的范围可以访问到这个名字，就意味着其他代码也可以用到这个表达式，而不用把它重写一遍，这样能减少重复，并且能更好地表达我的意图。</p><h2 id="改变函数声明change-function-declaration">改变函数声明（Change Function Declaration）</h2><p>如果我看到一个函数的名字不对，一旦发现了更好的名字，就得尽快给函数改名。这样，下一次再看到这段代码时，我就不用再费力搞懂其中到底在干什么。有一个改进函数名字的好办法：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字。） 修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合。如何选择正确的参数，没有简单的规则可循。我可能有一个简单的函数，用于判断支付是否逾期——如果超期 30 天未付款，那么这笔支付就逾期了。这个函数的参数应该是“支付”（payment）对象，还是支付的到期日呢？如果使用支付对象，会使这个函数与支付对象的接口耦合，但好处是可以很容易地访问后者的其他属性，当“逾期”的逻辑发生变化时就不用修改所有调用该函数的代码——换句话说，提高了该函数的封装度。</p><h2 id="封装变量encapsulate-variable">封装变量（Encapsulate Variable）</h2><p>如果我把数据搬走，就必须同时修改所有引用该数据的代码，否则程序就不能运行。如果数据的可访问范围很小，比如一个小函数内部的临时变量，那还不成问题。但如果可访问范围变大，重构的难度就会随之增大，这也是说全局数据是大麻烦的原因。所以，如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。这样，我就能把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务。</p><p>封装数据的价值还不止于此。封装能提供一个清晰的观测点，可以由此监控数据的变化和使用情况；我还可以轻松地添加数据被修改时的验证或后续逻辑。我的习惯是：对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。</p><h2 id="引入参数对象introduce-parameter-object">引入参数对象（Introduce Parameter Object）</h2><p>我常会看见，一组数据项总是结伴同行，出没于一个又一个函数。这样一组数据就是所谓的数据泥团，我喜欢代之以一个数据结构。</p><p>这项重构真正的意义在于，它会催生代码中更深层次的改变。一旦识别出新的数据结构，我就可以重组程序的行为来使用这些结构。我会创建出函数来捕捉围绕这些数据的共用行为——可能只是一组共用的函数，也可能用一个类把数据结构与使用数据的函数组合起来。这个过程会改变代码的概念图景，将这些数据结构提升为新的抽象概念，可以帮助我更好地理解问题域。</p><h2 id="函数组合成类combine-functions-into-class">函数组合成类（Combine Functions into Class）</h2><p>如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），我就认为，是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分。</p><h2 id="拆分阶段split-phase">拆分阶段（Split Phase）</h2><p>每当看见一段代码在同时处理两件不同的事，我就想把它拆分成各自独立的模块，因为这样到了需要修改的时候，我就可以单独处理每个主题，而不必同时在脑子里考虑两个不同的主题。如果运气够好的话，我可能只需要修改其中一个模块，完全不用回忆起另一个模块的诸般细节。</p><p>最简洁的拆分方法之一，就是把一大段行为分成顺序执行的两个阶段。如果一块代码中出现了上下几段，各自使用不同的一组数据和函数，这就是最明显的线索。将这些代码片段拆分成各自独立的模块，能更明确地标示出它们之间的差异。</p><h1 id="封装">封装</h1><h2 id="封装记录encapsulate-record">封装记录（Encapsulate Record）</h2><p>记录型结构是多数编程语言提供的一种常见特性。它们能直观地组织起存在关联的数据，让我可以将数据作为有意义的单元传递，而不仅是一堆数据的拼凑。但简单的记录型结构也有缺陷，最恼人的一点是，它强迫我清晰地区分“记录中存储的数据”和“通过计算得到的数据”。假使我要描述一个整数闭区间，我可以用{start: 1, end: 5}描述，或者用{start: 1, length: 5}（甚至还能用{end: 5, length: 5}，如果我想露两手华丽的编程技巧的话）。但不论如何存储，这 3 个值都是我想知道的，即区间的起点（start）和终点（end），以及区间的长度（length）。</p><p>这就是对于可变数据，我总是更偏爱使用类对象而非记录的原因。对象可以隐藏结构的细节，仅为这 3 个值提供对应的方法。该对象的用户不必追究存储的细节和计算的过程。同时，这种封装还有助于字段的改名：我可以重新命名字段，但同时提供新老字段名的访问方法，这样我就可以渐进地修改调用方，直到替换全部完成。</p><h2 id="封装集合encapsulate-collection">封装集合（Encapsulate Collection）</h2><p>封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。 一种避免直接修改集合的方法是，永远不直接返回集合的值。还有一种方法是，以某种形式限制集合的访问权，只允许对集合进行读操作。</p><h2 id="以查询取代临时变量replace-temp-with-query">以查询取代临时变量（Replace Temp with Query）</h2><p>这项重构手法在类中施展效果最好，因为类为待提炼函数提供了一个共同的上下文。如果不是在类中，我很可能会在顶层函数中拥有过多参数，这将冲淡提炼函数所能带来的诸多好处。 以查询取代临时变量手法只适用于处理某些类型的临时变量：那些只被计算一次且之后不再被修改的变量。</p><h2 id="隐藏委托关系hide-delegate">隐藏委托关系（Hide Delegate）</h2><p>如果某些客户端先通过服务对象的字段得到另一个对象（受托类），然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一受托类修改了接口，变化会波及通过服务对象使用它的所有客户端。我可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。这么一来，即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。</p><h2 id="移除中间人remove-middle-man">移除中间人（Remove Middle Man）</h2><p>在隐藏委托关系的“动机”一节中，我谈到了“封装受托对象”的好处。但是这层封装也是有代价的。每当客户端要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性（功能）越来越多，更多的转发函数就会使人烦躁。服务类完全变成了一个中间人，此时就应该让客户直接调用受托类。</p><p>很难说什么程度的隐藏才是合适的。还好，有了隐藏委托关系（189）和删除中间人，我大可不必操心这个问题，因为我可以在系统运行过程中不断进行调整。随着代码的变化，“合适的隐藏程度”这个尺度也相应改变。</p><h1 id="简化条件逻辑">简化条件逻辑</h1><h2 id="分解条件表达式decompose-conditional">分解条件表达式（Decompose Conditional）</h2><p>在带有复杂条件逻辑的函数中，代码会告诉我发生的事，但常常让我弄不清楚为什么会发生这样的事，这就说明代码的可读性的确大大降低了。和任何大块头代码一样，我可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!aDate.isBefore(plan.summerStart) &amp;amp;&amp;amp; !aDate.isAfter(plan.summerEnd))</span><br><span class="line"> charge = quantity * plan.summerRate;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> charge = quantity * plan.regularRate + plan.regularServiceCharge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (summer())</span><br><span class="line"> charge = summerCharge();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> charge = regularCharge();</span><br></pre></td></tr></tbody></table></figure><h2 id="以卫语句取代嵌套条件表达式replace-nested-conditional-with-guard-clauses">以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）</h2><p>根据我的经验，条件表达式通常有两种风格。第一种风格是：两个条件分支都属于正常行为。第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况。</p><p>这两类条件表达式有不同的用途，这一点应该通过代码表现出来。如果两条分支都是正常行为，就应该使用形如 if...else... 的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”（guard clauses）。</p><p>以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。如果使用 if-then-else 结构，你对 if 分支和 else 分支的重视是同等的。这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。卫语句就不同了，它告诉阅读者：“这种情况不是本函数的核心逻辑所关心的，如果它真发生了，请做一些必要的整理工作，然后退出。”</p><h2 id="以多态取代条件表达式replace-conditional-with-polymorphism">以多态取代条件表达式（Replace Conditional with Polymorphism）</h2><p>复杂的条件逻辑是编程中最难理解的东西之一，因此我一直在寻求给条件逻辑添加结构。很多时候，我发现可以将条件逻辑拆分到不同的场景（或者叫高阶用例），从而拆解复杂的条件逻辑。这种拆分有时用条件逻辑本身的结构就足以表达，但使用类和多态能把逻辑的拆分表述得更清晰。</p><p>多态是面向对象编程的关键特性之一。跟其他一切有用的特性一样，它也很容易被滥用。我曾经遇到有人争论说所有条件逻辑都应该用多态取代。我不赞同这种观点。我的大部分条件逻辑只用到了基本的条件语句——if/else 和 switch/case，并不需要劳师动众地引入多态。但如果发现如前所述的复杂条件逻辑，多态是改善这种情况的有力工具。</p><h2 id="引入断言introduce-assertion">引入断言（Introduce Assertion）</h2><p>断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。断言的失败不应该被系统任何地方捕捉。整个程序的行为在有没有断言出现的时候都应该完全一样。实际上，有些编程语言中的断言可以在编译期用一个开关完全禁用掉。</p><h1 id="处理继承关系">处理继承关系</h1><h2 id="以子类取代类型码replace-type-code-with-subclasses">以子类取代类型码（Replace Type Code with Subclasses）</h2><p>软件系统经常需要表现“相似但又不同的东西”，比如员工可以按职位分类（工程师、经理、销售），订单可以按优先级分类（加急、常规）。表现分类关系的第一种工具是类型码字段——根据具体的编程语言，可能实现为枚举、符号、字符串或者数字。类型码的取值经常来自给系统提供数据的外部服务。</p><p>大多数时候，有这样的类型码就够了。但也有些时候，我可以再多往前一步，引入子类。继承有两个诱人之处。首先，你可以用多态来处理条件逻辑。另外，有些字段或函数只对特定的类型码取值才有意义，例如“销售目标”只对“销售”这类员工才有意义。此时我可以创建子类，然后用字段下移把这样的字段放到合适的子类中去。当然，我也可以加入验证逻辑，确保只有当类型码取值正确时才使用该字段，不过子类的形式能更明确地表达数据与类型之间的关系。</p><h2 id="以委托取代子类replace-subclass-with-delegate">以委托取代子类（Replace Subclass with Delegate</h2><p>继承也有其短板。最明显的是，继承这张牌只能打一次。导致行为不同的原因可能有多种，但继承只能用于处理一个方向上的变化。比如说，我可能希望“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”，也可以是“富人”和“穷人”，但不能同时采用两种继承方式。更大的问题在于，继承给类之间引入了非常紧密的关系。在超类上做任何修改，都很可能破坏子类，所以我必须非常小心，并且充分理解子类如何从超类派生。</p><p>这两个问题用委托都能解决。对于不同的变化原因，我可以委托给不同的类。委托是对象之间常规的关系。与继承关系相比，使用委托关系时接口更清晰、耦合更少。因此，继承关系遇到问题时运用以委托取代子类是常见的情况。有一条流行的原则：“对象组合优于类继承”（“组合”跟“委托”是同一回事）。</p><h2 id="以委托取代超类replace-superclass-with-delegate">以委托取代超类（Replace Superclass with Delegate）</h2><p>如果超类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。除了“子类用得上超类的所有函数”之外，合理的继承关系还有一个重要特征：子类的所有实例都应该是超类的实例，通过超类的接口来使用子类的实例应该完全不出问题。</p><h1 id="参考文献">参考文献</h1><p>《重构 改善既有代码的设计》<br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLXJlZmFjdG9yaW5nMi5pZm1pY3JvLmNvbS9kb2NzL2NoMy5odG1s">https://book-refactoring2.ifmicro.com/docs/ch3.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Refactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构（二）代码的坏味道</title>
      <link href="/next/2022/Program/RefactorPart2/"/>
      <url>/next/2022/Program/RefactorPart2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/BadCodeSmell.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyYjg4NTBlM2U3NDA3ZGE1MWRmYjE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="神秘命名mysterious-name">神秘命名（Mysterious Name）</h1><p>整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。 然而，很遗憾，命名是编程中最难的两件事之一。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（用于给函数改名）、变量改名、字段改名等。很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。</p><p>改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。</p><h1 id="重复代码duplicated-code">重复代码（Duplicated Code）</h1><p>如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。</p><p>最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用提炼函数提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试用移动语句重组代码顺序，把相似的部分放在一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移来避免在两个子类之间互相调用。</p><h1 id="过长函数long-function">过长函数（Long Function）</h1><p>我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</p><p>如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数，最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量来消除这些临时元素。引入参数对象和保持对象完整则可以将过长的参数列表变得更简洁一些。</p><p>如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏——以命令取代函数。</p><p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。</p><p>条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式处理条件表达式。对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数变成独立的函数调用。如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式。</p><p>至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环将其拆分成各自独立的任务。</p><h1 id="过长参数列表long-parameter-list">过长参数列表（Long Parameter List）</h1><p>刚开始学习编程的时候，老师教我们：把函数所需的所有东西都以参数的形式传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据很快就会变成邪恶的东西。但过长的参数列表本身也经常令人迷惑。</p><p>如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数去掉这第二个参数。如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象将其合并成一个对象。如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数。</p><p>使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类，将这些共同的参数变成这个类的字段。如果戴上函数式编程的帽子，我们会说，这个重构过程创造了一组部分应用函数（partially applied function）。</p><h1 id="全局数据global-data">全局数据（Global Data）</h1><p>全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的 bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。</p><p>首要的防御手段是封装变量，每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。</p><p>全局数据印证了帕拉塞尔斯的格言：良药与毒药的区别在于剂量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。即便只是少量的数据，我们也愿意将它封装起来，这是在软件演进过程中应对变化的关键所在。</p><h1 id="可变数据mutable-data">可变数据（Mutable Data）</h1><p>对数据的修改经常导致出乎意料的结果和难以发现的 bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。因此，有一整个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。 不过这样的编程语言仍然相对小众，大多数程序员使用的编程语言还是允许修改变量值的。即便如此，我们也不应该忽视不可变性带来的优势——仍然有很多办法可以用于约束对数据的更新，降低其风险。 可以用封装变量来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量将其拆分为各自不同用途的变量，从而避免危险的更新操作。 如果可变数据的值能在其他地方计算出来，这就是一个特别刺鼻的坏味道。它不仅会造成困扰、bug 和加班，而且毫无必要。消除这种坏味道的办法很简单，使用以查询取代派生变量即可。 如果变量作用域只有几行代码，即使其中的数据可变，也不是什么大问题；但随着变量作用域的扩展，风险也随之增大。可以用函数组合成类或者函数组合成变换来限制需要对变量进行修改的代码量。如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象令其直接替换整个数据结构。</p><h1 id="发散式变化divergent-change">发散式变化（Divergent Change）</h1><p>如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这 3 个函数，”这就是发散式变化的征兆。 如果发生变化的两个方向自然地形成了先后次序，就可以用拆分阶段将两者分开，两者之间通过一个清晰的数据结构进行沟通。如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数把处理逻辑分开。如果函数内部混合了两类处理逻辑，应该先用提炼函数将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以用提炼类来做拆分。</p><h1 id="霰弹式修改shotgun-surgery">霰弹式修改（Shotgun Surgery）</h1><p>霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。</p><p>这种情况下，你应该使用搬移函数和搬移字段把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段。</p><p>面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数或是内联类——把本不该分散的逻辑拽回一处。完成内联之后，你可能会闻到过长函数或者过大的类的味道，不过你总可以用与提炼相关的重构手法将其拆解成更合理的小块。即便如此钟爱小型的函数和类，我们也并不担心在重构的过程中暂时创建一些较大的程序单元。</p><h1 id="依恋情结feature-envy">依恋情结（Feature Envy）</h1><p>所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：这个函数想跟这些数据待在一起，那就使用搬移函数把它移过去。有时候，函数中只有一部分受这种依恋之苦，这时候应该使用提炼函数把这一部分提炼到独立的函数中，再使用搬移函数带它去它的梦想家园。</p><p>当然，并非所有情况都这么简单。一个函数往往会用到几个模块的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起。如果先以提炼函数将这个函数分解为数个较小的函数并分别置放于不同地点，上述步骤也就比较容易完成了。</p><p>有几个复杂精巧的模式破坏了这条规则。说起这个话题，GoF[gof] 的策略（Strategy）模式和访问者（Visitor）模式立刻跳入我的脑海，Kent Beck 的 Self Delegation 模式、[Beck SBPP] 也在此列。使用这些模式是为了对抗发散式变化这一坏味道。最根本的原则是：将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。策略模式和和访问者模式使你得以轻松修改函数的行为，因为它们将少量需被覆写的行为隔离开来——当然也付出了“多一层间接性”的代价。</p><h1 id="数据泥团data-clumps">数据泥团（Data Clumps）</h1><p>数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用提炼类将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象或保持对象完整为它瘦身。这么做的直接好处是可以将很多参数列表缩短，简化函数调用。是的，不必在意数据泥团只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。</p><p>一个好的评判办法是：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。</p><p>我们在这里提倡新建一个类，而不是简单的记录结构，因为一旦拥有新的类，你就有机会让程序散发出一种芳香。得到新的类以后，你就可以着手寻找“依恋情结”，这可以帮你指出能够移至新类中的种种行为。这是一种强大的动力：有用的类被创建出来，大量的重复被消除，后续开发得以加速，原来的数据泥团终于在它们的小社会中充分发挥价值。</p><h1 id="基本类型偏执primitive-obsession">基本类型偏执（Primitive Obsession）</h1><p>大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。一些库会引入一些小对象，如日期。但我们发现一个很有趣的现象：很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。于是，我们看到了把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似 if (a &lt; upper &amp;&amp; a &gt; lower) 这样的代码。</p><p>字符串是这种坏味道的最佳培养皿，比如，电话号码不只是一串字符。一个体面的类型，至少能包含一致的显示逻辑，在用户界面上需要显示时可以使用。“用字符串来代表类似这样的数据”是如此常见的臭味，以至于人们给这类变量专门起了一个名字，叫它们“类字符串类型”（stringly typed）变量。</p><p>你可以运用以对象取代基本类型将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码加上以多态取代条件表达式的组合将它换掉。</p><p>如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类和引入参数对象来处理。</p><h1 id="重复的-switch-repeated-switches">重复的 switch （Repeated Switches）</h1><p>如果你跟真正的面向对象布道者交谈，他们很快就会谈到 switch 语句的邪恶。在他们看来，任何 switch 语句都应该用以多态取代条件表达式消除掉。我们甚至还听过这样的观点：所有条件逻辑都应该用多态取代，绝大多数 if 语句都应该被扫进历史的垃圾桶。</p><p>重复的 switch 的问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库。</p><h1 id="过长的消息链message-chains">过长的消息链（Message Chains）</h1><p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。在实际代码中你看到的可能是一长串取值函数或一长串临时变量。采取这种方式，意味客户端代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p><p>这时候应该使用隐藏委托关系。你可以在消息链的不同位置采用这种重构手法。理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。</p><p>有些人把任何函数链都视为坏东西，我们不这样想。我们的冷静镇定是出了名的，起码在这件事上是这样的。</p><h1 id="中间人middle-man">中间人（Middle Man）</h1><p>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。比如，你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。</p><p>但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用内联函数把它们放进调用端。如果这些中间人还有其他行为，可以运用以委托取代超类或者以委托取代子类把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p><h1 id="参考文献">参考文献</h1><p>《重构 改善既有代码的设计》<br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLXJlZmFjdG9yaW5nMi5pZm1pY3JvLmNvbS9kb2NzL2NoMy5odG1s">https://book-refactoring2.ifmicro.com/docs/ch3.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Refactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构（一）重构的原则</title>
      <link href="/next/2022/Program/RefactorPart1/"/>
      <url>/next/2022/Program/RefactorPart1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/refactor_principle.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMyYTA5ZTA3OTEyOTA3YzI4YWM4MDM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="何谓重构">何谓重构</h1><p>“重构”这个词既可以用作名词也可以用作动词。</p><ul><li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li><li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li></ul><p>重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。每个单独的重构要么很小，要么由若干小步骤组合而成。因此，在重构的过程中，我的代码很少进入不可工作的状态，即便重构没有完成，我也可以在任何时刻停下来。</p><blockquote><p><strong>Tip</strong> 如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</p></blockquote><p>在上述定义中，我用了“可观察行为”的说法。它的意思是，整体而言，经过重构之后的代码所做的事应该与重构之前大致一样。这个说法并非完全严格，并且我是故意保留这点儿空间的：重构之后的代码不一定与重构前行为完全一致。比如说，提炼函数会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明和搬移函数等重构经常会改变模块的接口。不过就用户应该关心的行为而言，不应该有任何改变。如果我在重构过程中发现了任何 bug，重构完成后同样的 bug 应该仍然存在。</p><h1 id="两顶帽子">两顶帽子</h1><p>Kent Beck 提出了“两顶帽子”的比喻。使用重构技术开发软件时，我把自己的时间分配给两种截然不同的行为：添加新功能和重构。添加新功能时，我不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，我可以衡量自己的工作进度。重构时我就不能再添加功能，只管调整代码的结构。此时我不应该添加任何测试，只在绝对必要（用以处理接口变化）时才修改测试。 软件开发过程中，我可能会发现自己经常变换帽子。首先我会尝试添加新功能，然后会意识到：如果把程序结构改一下，功能的添加会容易得多。于是我换一顶帽子，做一会儿重构工作。程序结构调整好后，我又换上原先的帽子，继续添加新功能。新功能正常工作后，我又发现自己的编码造成程序难以理解，于是又换上重构帽子……整个过程或许只花 10 分钟，但无论何时我都清楚自己戴的是哪一顶帽子，并且明白不同的帽子对编程状态提出的不同要求。</p><h1 id="为何重构">为何重构</h1><h2 id="重构改进软件的设计">重构改进软件的设计</h2><p>如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。经常性的重构有助于代码维持自己该有的形态。</p><p>消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</p><h2 id="重构使软件更容易理解">重构使软件更容易理解</h2><p>用于协作</p><h2 id="重构帮助找到-bug">重构帮助找到 bug</h2><p>对代码的理解，可以帮我找到 bug。我承认我不太擅长找 bug。有些人只要盯着一大段代码就可以找出里面的 bug，我不行。但我发现，如果对代码进行重构，我就可以深入理解代码的所作所为，并立即把新的理解反映在代码当中。搞清楚程序结构的同时，我也验证了自己所做的一些假设，于是想不把 bug 揪出来都难。</p><h2 id="重构提高编程速度">重构提高编程速度</h2><p>最后，前面的一切都归结到了这一点：重构帮我更快速地开发程序。</p><p>有的团队： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/cg1.jpeg"></p><p>但有些团队的境遇则截然不同。他们添加新功能的速度越来越快，因为他们能利用已有的功能，基于已有的功能快速构建新功能。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/cg2.jpeg"></p><p>两种团队的区别就在于软件的内部质量。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，我引入 bug 的可能性就会变小，即使引入了 bug，调试也会容易得多。理想情况下，我的代码库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。 20 年前，行业的陈规：良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。</p><h1 id="何时重构">何时重构</h1><h2 id="预备性重构让添加新功能更容易">预备性重构：让添加新功能更容易</h2><p>重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。 修复 bug 时的情况也是一样。在寻找问题根因时，我可能会发现：如果把 3 段一模一样且都会导致错误的代码合并到一处，问题修复起来会容易得多。或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样 bug 的概率也会降低。</p><h2 id="帮助理解的重构使代码更易懂">帮助理解的重构：使代码更易懂</h2><p>我需要先理解代码在做什么，然后才能着手修改，这些都是重构的机会。 看代码时，我会在脑海里形成一些理解，但我的记性不好，记不住那么多细节。正如 Ward Cunningham 所说，通过重构，我就把脑子里的理解转移到了代码本身。随后我运行这个软件，看它是否正常工作，来检查这些理解是否正确。如果把对代码的理解植入代码中，这份知识会保存得更久，并且我的同事也能看到。</p><h2 id="捡垃圾式重构">捡垃圾式重构</h2><p>帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。</p><h2 id="有计划的重构和见机行事的重构">有计划的重构和见机行事的重构</h2><p>上面的例子——预备性重构、帮助理解的重构、捡垃圾式重构——都是见机行事的：我并不专门安排一段时间来重构，而是在添加功能或修复 bug 的同时顺便重构，这是我自然的编程流的一部分。</p><blockquote><p><strong>Tip</strong> 还有一种常见的误解认为，重构就是人们弥补过去的错误或者清理肮脏的代码。当然，如果遇上了肮脏的代码，你必须重构，但漂亮的代码也需要很多重构。</p></blockquote><p>如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更容易添加新功能。在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。</p><h2 id="何时不应该重构">何时不应该重构</h2><p>如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个 API 之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。 另一种情况是，如果重写比重构还容易，就别重构了。</p><h1 id="重构架构和-yagni">重构、架构和 YAGNI</h1><p>与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，我更愿意只根据当前的需求来构造软件，同时把软件的设计质量做得很高。随着对用户需求的理解加深，我会对架构进行重构，使其能够应对新的需要。如果一种灵活性机制不会增加复杂度，我可以很开心地引入它；但如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入。如果不同的调用者不会传入不同的参数值，那么就不要添加这个参数。当真的需要添加这个参数时，运用函数参数化也很容易。要判断是否应该为未来的变化添加灵活性，我会评估“如果以后再重构有多困难”，只有当未来重构会很困难时，我才考虑现在就添加灵活性机制。我发现这是一个很有用的决策方法。</p><p>这种设计方法有很多名字：简单设计、增量式设计或者 YAGNI——“你不会需要它”（you arenʼt going to need it）的缩写。YAGNI 并不是“不做架构性思考”的意思，不过确实有人以这种欠考虑的方式做事。我把 YAGNI 视为将架构、设计与开发过程融合的一种工作方式，这种工作方式必须有重构作为基础才可靠。</p><h1 id="重构与软件开发过程">重构与软件开发过程</h1><p>重构的第一块基石是自测试代码。我应该有一套自动化的测试，我可以频繁地运行它们，并且我有信心：如果我在编程过程中犯了任何错误，会有测试失败。 如果一支团队想要重构，那么每个团队成员都需要掌握重构技能，能在需要时开展重构，而不会干扰其他人的工作。这也是我鼓励持续集成的原因：有了 CI，每个成员的重构都能快速分享给其他同事，不会发生这边在调用一个接口那边却已把这个接口删掉的情况；如果一次重构会影响别人的工作，我们很快就会知道。自测试的代码也是持续集成的关键环节，所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应。 有这三大实践在手，我们就能运用前一节介绍的 YAGNI 设计方法。重构和 YAGNI 交相呼应、彼此增效，重构（及其前置实践）是 YAGNI 的基础，YAGNI 又让重构更易于开展：比起一个塞满了想当然的灵活性的系统，当然是修改一个简单的系统要容易得多。在这些实践之间找到合适的平衡点，你就能进入良性循环，你的代码既牢固可靠又能快速响应变化的需求。 有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分。持续交付确保软件始终处于可发布的状态，很多互联网团队能做到一天多次发布，靠的正是持续交付的威力。即便我们不需要如此频繁的发布，持续集成也能帮我们降低风险，并使我们做到根据业务需要随时安排发布，而不受技术的局限。有了可靠的技术根基，我们能够极大地压缩“从好点子到生产代码”的周期时间，从而更好地服务客户。这些技术实践也会增加软件的可靠性，减少耗费在 bug 上的时间。</p><h1 id="参考文献">参考文献</h1><p>《重构 改善既有代码的设计》<br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLXJlZmFjdG9yaW5nMi5pZm1pY3JvLmNvbS9kb2NzL2NoMi5odG1s">https://book-refactoring2.ifmicro.com/docs/ch2.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Refactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++（四） Effective-C++（下）</title>
      <link href="/next/2022/Program/CPPEffectivePart3/"/>
      <url>/next/2022/Program/CPPEffectivePart3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/Effective-C++3.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxZDg4YWU0MDFmZDA3MjZiZWIyMDI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="模板与泛型编程">模板与泛型编程</h1><h2 id="条款-41了解隐式接口和编译期多态">条款 41：了解隐式接口和编译期多态</h2><p>面向对象编程世界总是以显式接口（ explicit interfaces）和运行期多态（ runtime polymorphism）解决问题。Templates 及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口（ implicit interfaces）和编译期多态（ compile-time polymorphism）移到前头了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doprocessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != somenastywidget) {</span><br><span class="line">        <span class="function">T <span class="title">temp</span> <span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span> ();</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>w 必须支持哪一种接口，系由 template 中执行于 w 身上的操作来决定。本例看来 w 的类型好像必须支持 size， normalize 和 swap 成员函数、copy 构造函数（用以建立 temp）、不等比较（ inequality comparison，用来比较 somenasty-Widget）。我们很快会看到这并非完全正确，但对目前而言足够真实。重要的是，这一组表达式（对此 template 而言必须有效编译）便是必须支持的一组隐式接口 (implicit interface)。</li><li>凡涉及 w 的任何函数调用，例如 operator&gt;和 operator!=，有可能造成 template 具现化（ instantiated），使这些调用得以成功。这样的具现行为发生在编译期。“以不同的 template 参数具现化 function templates”会导致调用不同的函数，这便是所谓的编译期多态（ compile-time polymorphism）。</li></ul><p><strong>请记住</strong></p><ul><li>classes 和 templates 都支持接口（ interfaces）和多态（ polymorphism）对 classes 而言接口是显式的（ explicit），以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li><li>对 template 参数而言，接口是隐式的（ implicit），奠基于有效表达式。多态则是通过 template 具现化和函数重载解析（ function overloading resolution）发生于编译期。</li></ul><h2 id="条款-42了解-typename-的双重意义">条款 42：了解 typename 的双重意义</h2><ul><li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li><li>请使用关键字 typename 标识嵌套从属类型名称；但不得在 base class lists（基类列）或 member initialization list（成员初值列）内以它作为 base class 修饰符。</li></ul><h2 id="条款-43学习处理模板化基类内的名称">条款 43：学习处理模板化基类内的名称</h2><p>假设我们需要撰写一个程序，它能够传送信息到若干不同的公司去。信息要不译成密码，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于 template 的解法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Class CompanyA</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendcleartext</span><span class="params">(<span class="type">const</span> std: string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendencrypted</span><span class="params">(<span class="type">const</span> std: string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line">Class CompanyB</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendcleartext</span><span class="params">(<span class="type">const</span> std: string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendencrypted</span><span class="params">(<span class="type">const</span> std: :string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">...                         <span class="comment">//针对其他公司设计的 classes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Msginfo</span> {...};        <span class="comment">//这个 class 用来保存信息，以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...                     <span class="comment">//构造函数、析构函数等等。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendclear</span><span class="params">(<span class="type">const</span> Msginfo&amp; info)</span></span>{</span><br><span class="line">        std::string msg;</span><br><span class="line">        <span class="comment">//在这儿，根据 info 产生信息；</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendcleartext</span>(msg);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> Msginfoinfo)</span>  <span class="comment">//类似 sendclear，唯一不同是</span></span></span><br><span class="line"><span class="function">    </span>{...}                               <span class="comment">//这里调用 c.sendencrypted</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个做法行得通。但假设我们有时候想要在每次送出信息时志记（log）某些信息。 derived class 可轻易加上这样的生产力，那似乎是个合情合理的解法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loggingmsgsender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...                                 <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendclearmsg</span><span class="params">(<span class="type">const</span> Msginfo&amp; info)</span></span>{</span><br><span class="line">        <span class="comment">//将“传送前”的信息写至 log</span></span><br><span class="line">        <span class="built_in">sendclear</span>(info);    <span class="comment">//调用 base class 函数；这段码无法通过编译。编译器会抱怨 sendclear 不存在</span></span><br><span class="line">        <span class="comment">//将“传送后”的信息写至 log；</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>问题在于，当编译器遭遇 class template Loggingmsgsender 定义式时，并不知道它继承什么样的 class 当然它继承的是 MsgSender<company>，但其中的 Company 是个 template 参数，不到后来（当 Loggingmsg Sender 被具现化）无法确切知道它是什么。而如果不知道 Company 是什么，就无法知道 class MsgSender<company>看起来像什么一更明确地说是没办法知道它是否有个 sendclear 函数。</company></company></p><p>有三个办法，第一是在 base class 函数调用动作之前加上 "this-&gt;":</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loggingmsgsender</span>: <span class="keyword">public</span> Msgsender&lt;Company&gt;</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendclearmsg</span><span class="params">(<span class="type">const</span> Msginfo&amp; info)</span></span>{</span><br><span class="line">        <span class="comment">//将“传送前”的信息写至 log</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendclear</span>(info);   <span class="comment">//成立假设 sendClean 被继承</span></span><br><span class="line">        <span class="comment">//将“传送后”的信息写至 log；</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第二是使用 using 声明式。如果你已读过条款 33，这个解法应该会令你感到熟悉。条款 33 描述 using 声明式如何将“被掩盖的 base class 2 名称”带入个 derived class 作用域内。我们可以这样写下 sendclearmsg:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loggingmsgsender</span>: <span class="keyword">public</span> Msgsender&lt;Company&gt;</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Msgsender&lt;Company&gt;::sendclear；<span class="comment">//告诉编译器，请它假设</span></span><br><span class="line">    ...                                 <span class="comment">// sendclear 位于 base class 内。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendclearmsg</span><span class="params">(<span class="type">const</span> Msginfo&amp; info)</span></span>{</span><br><span class="line">        <span class="comment">//将“传送前”的信息写至 log</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendclear</span>(info);   <span class="comment">//OK，假设 sendclear 将被继承下来。</span></span><br><span class="line">        <span class="comment">//将“传送后”的信息写至 log；</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第三个做法是，明白指出被调用的函数位于 base class 内：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loggingmsgsender</span>: <span class="keyword">public</span> Msgsender&lt;Company&gt;</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendclearmsg</span><span class="params">(<span class="type">const</span> Msginfo&amp; info)</span></span>{</span><br><span class="line">        <span class="comment">//将“传送前”的信息写至 log</span></span><br><span class="line">        Msgsender&lt;Company&gt;::<span class="built_in">sendclear</span>(info);  <span class="comment">//OK, sendclear</span></span><br><span class="line">        <span class="comment">//将“传送后”的信息写至 log；</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但这往往是最不让人满意的一个解法，因为如果被调用的是 virtual 函数，上述的明确资格修饰（ explicit qualification）会关闭“ virtual 绑定行为”。</p><p><strong>请记住</strong></p><p>可在 derived class templates 内通过" this-&gt;"指涉 base class templates 内的成员名称，或藉由一个明白写出的“base class 资格修佈符”完成。</p><h2 id="条款-44将与参数无关的代码抽离-templates">条款 44：将与参数无关的代码抽离 templates</h2><ul><li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li><li>因非类型模板参数（non 一 type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。</li><li>因类型参数（ type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（ binary representations）的具现类型（ instantiation types）共享实现码。</li></ul><h2 id="条款-45运用成员函数模板接受所有兼容类型">条款 45：运用成员函数模板接受所有兼容类型</h2><ul><li>请使用 member function templates（成员函数模板）生成“可接受所有兼容类型的函数。</li><li>如果你声明 member templates 用于“泛化 copy 构造”或“泛化 assignment 操作”，你还是需要声明正常的 copy 构造函数和 copy assignment 操作符。</li></ul><h2 id="条款-46需要类型转换时请为模板定义非成员函数">条款 46：需要类型转换时请为模板定义非成员函数</h2><p>模板类中的模板函数不支持隐式类型转换，如果你在调用时传了一个其他类型的变量，编译器无法帮你做类型转换，从而报错。 解决方案是将该模板函数定义为模板类内的友元模板函数，从而支持了参数的隐式转换。</p><h2 id="条款-47请使用-traits-classes-表现类型信息">条款 47：请使用 traits classes 表现类型信息</h2><p>对于模板函数，可能对于接收参数的不同类型，有不同的实现。此时，可以提供一个 traits class，其中包含了某一系列类型的类型信息（通常以枚举区分具体类型），然后，在该类中实现接收多种 traits 参数的重载工具函数，用来根据标识的不同类进行不同的具体函数操作。这使得该行为能在编译期就被区分。</p><h2 id="条款-48认识模板元编程tmp">条款 48：认识模板元编程（TMP）</h2><p>所谓 template metaprogram（模板元程序）是以 C++写成、执行于 C++编译器内的程序。一旦 TMP 程序结束执行，其输出，也就是从 templates 具现出来的若干 C++源码，便会一如往常地被编译。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="keyword">enum</span> { value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value };</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="keyword">enum</span> { value = <span class="number">1</span> };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了这个 template metaprogram（其实只是个单一的 template metafuncti acterial），只要你指涉 Factoria<n>： value 就可以得到阶乘值。</n></p><p>循环发生在 template 具现体 Factorial<n>内部指涉另一个 template 具现体 Factorial<n-1>之时。和所有良好递归一样，我们需要一个特殊情况造成递归结束。这里的特殊情况是 template 特化体 Factorial&lt;0&gt;。</n-1></n></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std: cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;    <span class="comment">//印出 120</span></span><br><span class="line">    std: cout &lt;&lt; Factorial&lt;<span class="number">10</span>&gt;::value;   <span class="comment">//印出 3628800</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>请记住</strong></p><ul><li>Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期因而得以实现早期错误侦测和更高的执行效率</li><li>TMP 可被用来生成“基于政策选择组合”（ based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</li></ul><h1 id="定制-new-和-delete">定制 new 和 delete</h1><h2 id="条款-49了解-new-handler-的行为">条款 49：了解 new-handler 的行为</h2><ul><li>set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</li></ul><h2 id="条款-50了解-new-和-delete-的合理替換时机">条款 50：了解 new 和 delete 的合理替換时机</h2><p>让我们暂时回到根本原理。首先，怎么会有人想要替换编译器提供的 operatornew 或 operator deletel 呢？下面是三个最常见的理由：</p><ul><li><p>用来检测运用上的错误。如果将“new 所得内存” delete 掉却不幸失败，会导致内存泄漏（ memory leaks）。如果在“new 所得内存”身上多次 delete 则会导致不确定行为。如果 operator new 持有一串动态分配所得地址，而 operator delete 将地址从中移走，倒是很容易检测出上述错误用法。此外各式各样的编程错误可能导致数据" over runs"（写入点在分配区块尾端之后）或" under runs"（写入点在分配区块起点之前）。如果我们自行定义个 operator news，便可超额分配内存，以额外空间（位于客户所得区块之前或后）放置特定的 byte pattems（即签名， signatures）。 operator deletes 便得以检查上述签名是否原封不动，若否就表示在分配区的某个生命时间点发生了 over run 或 under run，这时候 operator delete 可以志记（log）那个事实以及那个惹是生非的指针。</p></li><li><p>为了强化效能。编译器所带的 operator new 和 operator delete 主要用于一般目的。它们必须处理一系列需求，包括大块内存、小块内存、大小混合型内存。它们必须接纳各种分配形态，范围从程序存活期间的少量区块动态分配，到大数量短命对象的持续分配和归还。它们必须考虑破碎问题（ fragmentation），这最终会导致程序无法满足大区块内存要求即使彼时有总量足够但分散为许多小区块的自由内存。</p></li><li><p>为了收集使用上的统计数据。在一头栽进定制型 news 和定制型 deletes 之前，理当先收集你的软件如何使用其动态内存。分配区块的大小分布如何？寿命分布如何？它们倾向于以 FIFO（先进先出）次序或 LIFO（后进先出）次序或随机次序来分配和归还？它们的运用型态是否随时间改变，也就是说你的软件在不同的执行阶段有不同的分配归还形态吗？任何时刻所使用的最大动态分配量（高水位）是多少？自行定义 operator new 和 operator delete 使我们得以轻松收集到这些信息。</p></li></ul><h1 id="参考文献">参考文献</h1><p>《Effective C++》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++（三） Effective C++（中）</title>
      <link href="/next/2021/Program/CPPEffectivePart2/"/>
      <url>/next/2021/Program/CPPEffectivePart2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/Effective-C++2.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxY2E5ODBlM2U3NDA3ZGE1MDFhNDM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="设计与声明">设计与声明</h1><h2 id="条款-19设计-class-犹如设计-type">条款 19：设计 class 犹如设计 type</h2><p>C++就像在其他 OOP（面向对象编程）语言一样，当你定义一个新 class，也就定义了一个新 type。这意味你并不只是 class 设计者，还是 type 设计者。重载（ overloading）函数和操作符、控制内存的分配和归还、定义对象的初始化和终结全都在你手上。因此你应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研讨 class 的设计。</p><h2 id="条款-20宁以传递-const-引用替换传递值">条款 20：宁以传递 const 引用替换传递值</h2><p>缺省情况下 C++以 by value 方式传递对象至（或来自）函数。除非你另外指定，否则函数参数都是以实际实参的复件（副本）为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件（副本）系由对象的 capy 构造函数产出，这可能使得 pass-by-value 成为费时的操作。</p><p>如果有什么方法可以回避所有那些构造和析构动作就太好了。有的，就是 pass by reference-to-const：这种传递方式的效率高得多：没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。修订后的这个参数声明中的 const 是重要的。</p><p>以 by reference 方式传递参数也可以避免 slicing（对象切割）问题。当一个 derived class 对象以 by value 方式传递并被视为一个 base class 对象， base class 的 copy 构造函数会被调用，而“造成此对象的行为像个 derived class 对象”的那些特化性质全被切割掉了，仅仅留下一个 base class 对象。这实在不怎么让人惊讶，因为正是 base class 构造函数建立了它，但这几乎绝不会是你想要的。</p><p><strong>请记住</strong></p><ul><li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（ slicing problem）</li><li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言 pass-by-value 往往比较适当</li></ul><h2 id="条款-21必须返回对象时别妄想返回其引用">条款 21：必须返回对象时，别妄想返回其引用</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs</span><br><span class="line">                            <span class="type">const</span> Rational&amp;rhs)</span><br><span class="line">{                               <span class="comment">//警告，又一堆烂代码</span></span><br><span class="line">    <span class="type">static</span> Rational result;     <span class="comment">// static 对象，此函数将返回其 reference</span></span><br><span class="line">    result = ...                <span class="comment">//将 lhs 乘以 rhs，并将结果置于 result 内</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>就像所有用上 static 对象的设计一样，这一个也立刻造成我们对多线程安全性的疑虑。不过那还只是它显而易见的弱点。如果想看看更深层的瑕疵，考虑以下面这些完全合理的客户代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs     <span class="comment">//ー个针对 Rationals</span></span><br><span class="line">                <span class="type">const</span> Rational&amp; rhs）； <span class="comment">//而写的 operator：==</span></span><br><span class="line">Rational a, b, c, d;</span><br><span class="line"><span class="keyword">if</span>（（a*b） == (c*d) {</span><br><span class="line">    ...     <span class="comment">//当乘积相等时，做适当的相应动作</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    ...     <span class="comment">//当乘积不等时，做适当的相应动作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>猜想怎么着？表达式（a * b）==（c * d））总是被核算为 true，不论 a，b，c 和 d 的值是什么！ 一旦将代码重新写为等价的函数形式，很容易就可以了解出了什么意外：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d)))</span><br></pre></td></tr></tbody></table></figure><p>注意，在 operator==被调用前，已有两个 operator* 调用式起作用，每一个都返回 reference 指向 operator 的内部定义的 static Rational 对象。因此 operator=被要求将“ operator* 内的 static Rational 对象值”拿来和“ operator* 内的 static Rational 对象值”比较，如果比较结果不相等，那オ奇怪呢。（译注：这里我补充说明：两次 operator *调用的确各自改变了 static Rational 对象值，但由于它们返回的都是 reference，因此调用端看到的永远是 static Rational 对象的“现值”。）</p><p><strong>请记住</strong></p><p>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向个 heap allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。</p><h2 id="条款-22将成员变量声明为-private">条款 22：将成员变量声明为 private</h2><p>对于 private 变量，如果你通过函数访问成员变量，日后可改以某个计算替换这个成员变量，而 class 客户一点也不会知道 class 的内部实现已经起了变化，完全具备封装性。</p><p>假设我们有一个 public 成员变量，而我们最终取消了它，多少代码可能会被破坏呢？唔，所有使用它的客户码都会被破坏，而那是一个不可知的大量，因此 public 成员变量完全没有封装性。</p><p>假设我们有一个 protected 成员变量，而我们最终取消了它，有多少代码被破坏？唔，所有使用它的 derived classes 都会被破坏，那往往也是个不可知的大量。因此， protected 成员变量完全没有封装性。</p><h2 id="条款-23宁以-non-membernon-friend-替换-member-函数">条款 23：宁以 non-member、non-friend 替换 member 函数</h2><p>让我们从封装开始讨论。如果某些东西被封装，它就不再可见。愈多东西被封装，愈少人可以看到它，我们就有愈大的弹性去变化它。因此，愈多东西被封装，我们改变那些东西的能力也就愈大。</p><p>现在考虑对象内的数据。愈少代码可以看到数据，愈多的数据可被封装，而我们也就愈能自由地改变对象数据，愈多函数可访问它，数据的封装性就愈低。</p><p>条款 22 曾说过，成员变量应该是 private，能够访问 private 成员变量的函数只有 class 的 member 函数加上 friend 函数而已。如果要你在一个 member 函数和一个 non-member，non-friend 函数之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是 non-member non-friend 函数，因为它并不增加“能够访问 class 内之 private，成分”的函数数量。</p><p>将所有便利函数放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组便利函数。他们需要做的就是添加更多 non-member non-friend 函数到此命名空间内。</p><h2 id="条款-24若所有参数皆需类型转换请为此采用-non-member-函数">条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数</h2><p>假设你这样开始你的 Rational class：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator =<span class="number">0</span>,  <span class="comment">//构造函数刻意不为 explicit</span></span><br><span class="line">            <span class="type">int</span> denominator=<span class="number">1</span>）；<span class="comment">//允许 int-to-Rational 隐式转换。</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">numerator</span>() <span class="type">const</span>;      <span class="comment">//分子（ numerator）和分母（ denominator）</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">denominator</span>() <span class="type">const</span>;    <span class="comment">//的访问函数（ accessors）</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你想支持算术运算诸如加法、乘法等等，但你不确定是否该由 member 函数、non-member 函数，或可能的话由 non-member friend 函数来实现它们，先研究一下将 operator *写成 Rational 成员函数的写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs) <span class="type">const</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个设计使你能够将两个有理数以最轻松自在的方式相乘：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result= oneHalf * oneEighth;   <span class="comment">//很好</span></span><br><span class="line">result = result * oneEighth;            <span class="comment">//很好</span></span><br></pre></td></tr></tbody></table></figure><p>但你还不满足。你希望支持混合式运算，也就是拿 Rationals 和……嗯例如 int 相乘。毕竟很少有什么东西会比两个数值相乘更自然的了一即使是两个不同类型的数值。然而当你尝试混合式算术，你发现只有一半行得通：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">//很好</span></span><br><span class="line">result =<span class="number">2</span> * oneHalf     <span class="comment">//错误！</span></span><br></pre></td></tr></tbody></table></figure><p>这不是好兆头。乘法应该满足交换律，不是吗？当你以对应的函数形式重写上述两个式子，问题所在便一目了然了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result= oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);   <span class="comment">//很好</span></span><br><span class="line">result =<span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);   <span class="comment">//错误！</span></span><br></pre></td></tr></tbody></table></figure><p>是的， oneHalf 是一个内涵 operator* 函数的 class 的对象，所以编译器调用该函数。然而整数 2 并没有相应的 class，也就没有 operator* 成员函数。</p><p>结论是，只有当参数被列于参数列（ parameter list）内，这个参数才是隐式类型转换的合格参与者。这就是为什么上述第一次调用可通过编译，第二次调用则否，因为第一次调用伴随一个放在参数列内的参数，第二次调用则否。 然而你一定也会想要支持混合式算术运算。可行之道终于拨云见日：让 operator 成为一个 non-member 函数，俾允许编译器在每一个实参身上执行隐式类型转换：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">{</span><br><span class="line">    ... <span class="comment">//不包括 operator</span></span><br><span class="line">}</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,       <span class="comment">//现在成了一个</span></span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs);   <span class="comment">//non- member 函数</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span> (lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                     lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">onefourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = onefourth * <span class="number">2</span>; <span class="comment">//没问题</span></span><br><span class="line">result =<span class="number">2</span> * onefourth;  <span class="comment">//万岁，通过编译了！</span></span><br></pre></td></tr></tbody></table></figure><h1 id="实现">实现</h1><h2 id="条款-26尽可能延后变量定义式的出现时间">条款 26：尽可能延后变量定义式的出现时间</h2><p>尽可能延后变量定义式的出现，既包括延后构造它，保证只有真正使用才构造；也包括只有到赋值时才构造它，避免默认构造函数无谓调用。 对于循环操作，在循环前还是中进行构造，取决于赋值操作与构造+析构操作的成本对比。</p><ul><li>循环前：1 个构造函数+1 个析构函数+n 个赋值操作。</li><li>循环后：n 个构造函数+n 个析构函数。</li></ul><h2 id="条款-30透彻了解-inline-的里里外外">条款 30：透彻了解 inline 的里里外外</h2><p>在一台内存有限的机器上，过度热衷 inline 会造成程序体积太大。即使拥有虚拟内存， inline 造成的代码膨胀亦会导致额外的换页行为（ paging），降低指令高速缓存装置的击中率（ instruction cache hit rate），以及伴随这些而来的效率损失。</p><p>换个角度说，如果 inline 函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小。果真如此，将函数 inline 确实可能导致较小的目标码（ object code）和较高的指令高速缓存装置击中率！</p><p>程序库设计者必须评估“将函数声明为 inline”的冲击： inline 函数无法随着程序库的升级而升级。换句话说如果 f 是程序库内的一个 inline 函数，客户将“f 函数本体”编进其程序中，一旦程序库设计者决定改变 f，所有用到 f 的客户端程序都必须重新编译。这往往是大家不愿意见到的。</p><p>记住， inline 只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。隐喻方式是将函数定义于 class 定义式内。</p><h2 id="条款-31将文件间的编译依存关系降至最低">条款 31：将文件间的编译依存关系降至最低</h2><p>针对 Person 我们可以这样做：把 Person 分割为两个 classes，一个只提供接口，另一个负责实现该接口。如果负责实现的那个所谓 implementation class 取名为 PersonImpl， Person 将定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">//标准程序库组件不该被前置声明。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>    <span class="comment">//此乃为了 tr1： shared ptr 而含入；详后</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;   <span class="comment">// Person 实现类的前置声明。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;         <span class="comment">// Person 接口用到的 classes 的前置声明。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std: string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">            <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthdate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pimpl；<span class="comment">//指针，指向实现物</span></span><br><span class="line">                                            <span class="comment">//std::tr1::shared_ptr 见条款 13.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就不必 include Date、Address 等头文件而只是声明该 class（定义式改声明式）。</p><h3 id="pimp-方式">pimp 方式</h3><p>在这里， class Person 只内含一个指针成员，指向其实现类（ PersonImpl）。这般设计常被称为 pimpl idiom(pimp 是" pointer to implementation"的缩写）。</p><p>这样的设计之下， Person 的客户就完全与 Dates， Addresses 以及 Persons 的实现细目分离了。那些 classes 的任何实现修改都不需要 Person 客户端重新编译。此外由于客户无法看到 Person 的实现细目，也就不可能写出什么“取决于那些细目”的代码。这真正是“接口与实现分离。</p><p>这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略。</p><ul><li>如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects。你可以只靠一个类型声明式就定义出指向该类型的 references 和 pointers；但如果定义某类型的 objects，就需要用到该类型的定义式。</li><li>如果能够，尽量以 class 声明式替换 class 定义式。</li></ul><h3 id="abstract-baseclass-方式">abstract baseclass 方式</h3><p>另一个制作 Handle class 的办法是，令 Person 成为一种特殊的 abstract baseclass（抽象基类），称为 Interface class。这种 class 的目的是详细一描述 derived classes 的接口，因此它通常不带成员变量，也没有构造函数，只有个 virtual 析构函数以及一组 pure virtual 函数，用来叙述整个接口。</p><h1 id="继承与面向对象设计">继承与面向对象设计</h1><h2 id="条款-32确定你的-public-继承是-is-a-关系">条款 32：确定你的 public 继承是 is-a 关系</h2><p>“ public 继承”意味 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p><h3 id="条款-33避免遮掩继承而来的名称">条款 33：避免遮掩继承而来的名称</h3><ul><li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有人希望如此。</li><li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数（ forwarding functions)。</li></ul><h2 id="条款-34区分接口继承和实现继承">条款 34：区分接口继承和实现继承</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std: string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectid</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape {...};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape {...};</span><br></pre></td></tr></tbody></table></figure><p>shape class 声明了三个函数。draw 是个 pure virtual 函数； error 是个简朴的（非纯） impure virtual 函数； objectid 是个 non-virtual 函数。这些不同的声明带来什么样的暗示呢？</p><ul><li>声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。</li><li>声明简朴的（非纯） impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。</li><li>声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。</li></ul><h2 id="条款-35考虑虚函数以外的其他选择">条款 35：考虑虚函数以外的其他选择</h2><p>假设你正在写一个视频游戏软件，你打算为游戏内的人物设计一个继承体系。你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况并不罕见。你因此决定提供一个成员函数 healthvalue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将 healthvalue 声明为 virtual 似乎是再明白不过的做法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">heal_thvalue</span><span class="params">()</span> <span class="type">const</span>； <span class="comment">//返回人物的健康指数</span></span></span><br><span class="line"><span class="function">    ...                               <span class="comment">// derived classes 可重新定义它。</span></span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure><p>healthvalue 并未被声明为 pure virtual，这暗示我们将会有个计算健康指数的缺省算法。这的确是再明白不过的设计，但是从某个角度说却反而成了它的弱点。由于这个设计如此明显，你可能因此没有认真考虑其他替代方案。为了帮助你跳脱面向对象设计路上的常轨，让我们考虑其他一些解法。</p><h3 id="藉由-non-virtual-interface-手法实现-template-method-模式">藉由 Non-Virtual Interface 手法实现 Template Method 模式</h3><p>我们将从一个有趣的思想流派开始，这个流派主张 virtual 函数应该几乎总是 private。这个流派的拥护者建议，较好的设计是保留 healthvalue 为 public 成员函数，但让它成为 non-virtual，并调用一个 private virtual 函数（例如 dohealthvalue）进行实际工作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// derived classes 不重新定义它，</span></span><br><span class="line">    {                               <span class="comment">//见条款 36</span></span><br><span class="line">        ...                         <span class="comment">//做一些事前工作，详下</span></span><br><span class="line">        <span class="type">int</span> retval=<span class="built_in">dohealthvalue</span>(); <span class="comment">//做真正的工作。</span></span><br><span class="line">        ...                         <span class="comment">//做一些事后工作，详下。</span></span><br><span class="line">        <span class="keyword">return</span> retval</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">int</span> <span class="built_in">dohealthvalue</span>() <span class="type">const</span>;  <span class="comment">// derived classes 可重新定义它。</span></span><br><span class="line">    {</span><br><span class="line">        ...                             <span class="comment">//缺省算法，计算健康指数。</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，称为 mom-virtual interface（NVI）手法。它是所谓 Template Method 设计模式（与 C++ templates 并无关联）的一个独特表现形式。</p><p>NVI 手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后工作”之中。那些注释用来告诉你当时的代码保证在“ virtual 函数进行真正工作之前和之后”被调用。</p><h3 id="藉由-function-pointers-实现-strategy-模式">藉由 Function Pointers 实现 Strategy 模式</h3><p>另一个更戏剧性的设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gamecharacter</span>;         <span class="comment">//前置声明（ forward declaration）</span></span><br><span class="line"><span class="comment">//以下函数是计算健康指数的缺省算法。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaulthealthcalc</span><span class="params">(<span class="type">const</span> Gamecharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamecharacter</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Healthcalcfunc)</span><span class="params">(<span class="type">const</span> Gamecharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(Healthcalcfunc hcf= defaulthealthcalc)</span> :healtheunc(hcf)</span></span><br><span class="line"><span class="function">    {</span>}</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">healthfunc</span> (*<span class="keyword">this</span>); };</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Healthcalcfunc healtheunc;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个做法是常见的 Strategy 设计模式的简单应用。拿它和“植基于 GameCharacter 继承体系内之 virtual 函数”的做法比较，它提供了某些有趣弹性：</p><ul><li>同一人物类型之不同实体可以有不同的健康计算函数。</li><li>某已知人物之健康指数计算函数可在运行期变更。</li></ul><h3 id="藉由-tr1-function-完成-strategy-模式">藉由 tr1： function 完成 Strategy 模式</h3><p>一旦习惯了 templates 以及它们对隐式接口的使用，基于函数指针的做法看起来便过分苛刻而死板了。为什么要求“健康指数之计算”必须是个函数，而不能是某种“像函数的东西”（例如函数对象）呢？如果一定得是函数，为什么不能够是个成员函数？为什么一定得返回 int 而不是任何可被转换为 int 的类型呢？</p><p>如果我们不再使用函数指针（如前例的 healtheunc），而是改用一个类型为 tr1::function 的对象，这些约束就全都挥发不见了。就像条款 54 所说，这样的对象可持有（保存）任何可调用物（ callable entity，也就是函数指针、函数对象、或成员函数指针），只要其签名式兼容于需求端。以下将刚才的设计改为使用：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tr1::function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> <span class="comment">//如前</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaulthealthcalc</span><span class="params">(<span class="type">const</span> Gamecharacter&amp; gc)</span></span>;  <span class="comment">//如前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamecharacter</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Hea1 thcalcfunc 可以是任何“可调用物”（ callable entity），可被调用并接受</span></span><br><span class="line">    <span class="comment">//任何兼容于 Gamecharacter 之物，返回任何兼容于 int 的东西。详下。</span></span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span>(<span class="type">const</span> Gamecharacter&amp;)&gt; Healthcalcfunc;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Gamecharacter</span><span class="params">(Healthcalcfunc hcf = defaulthealthcalc)</span></span></span><br><span class="line"><span class="function">        :healtheunc(hcf)</span></span><br><span class="line"><span class="function">    int healthvalue() const</span></span><br><span class="line"><span class="function">     {</span><span class="keyword">return</span> <span class="built_in">healthfunc</span> (*<span class="keyword">this</span>);}</span><br><span class="line">     ..</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcfunc healtheunc;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在我们靠近一点瞧瞧 HealthCalceunc 是个什么样的 typedef std::tr1::function&lt;int (const Gamecharacter&amp;)&gt; 这里我把 tr1::function 具现体（ instantiation）的目标签名式（ target signature），那个签名代表的函数是“接受一个 reference 指向 const Gamecharacter，并返回 int”。</p><p>和前一个设计（其 GameCharacter 持有的是函数指针）比较，这个设计几乎相同。唯一不同的是如今 Gamecharacter 持有一个 tr1::function 对象，相当于个指向函数的泛化指针。这个改变如此细小，我总说它没有什么外显影响，除非客户在“指定健康计算函数”这件事上需要更惊人的弹性：</p><p>本条款的根本忠告是，当你为解决问题而寻找某个设计方法时，不妨考虑 virtual 函数的替代方案：</p><ul><li>使用 non-virtual interface（NVI）手法，那是 Template Method 设计模式的一种特殊形式。它以 public non-virtual 成员函数包裹较低访问性（ private 或 protected）的 virtual 函数。</li><li>将 virtual 函数替换为“函数指针成员变量”，这是 Strategy 设计模式的一种分解表现形式。</li><li>以 tr1::function 成员变量替换 virtual 函数，因而允许使用任何可调用物（ callable entity）搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。</li><li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 Strategy 设计模式的传统实现手法。</li></ul><h2 id="条款-36绝不重新定义继承而来的非虚函数">条款 36：绝不重新定义继承而来的非虚函数</h2><p>non-virtual 函数是静态绑定。这意思是，由于 pb 被声明为一个 pointer-to-B，通过 pb 调用的 non-virtual 函数永远是 B 所定义的版本，即使 pb 指向一个类型为“B 派生之 class”的对象。</p><p>但另一方面， virtual 函数却是动态绑定。如果 mf 是个 virtual 函数，不论是通过 pB（指向 D）或 pD（指向 D）调用 mf，都会导致调用 D::mf，因为 pB 和 pD 真正指的都是一个类型为 D 的对象。</p><h2 id="条款-37绝不重新定义继承而来的缺省参数值缺省参数值都是静态绑定而">条款 37：绝不重新定义继承而来的缺省参数值（缺省参数值都是静态绑定而）</h2><p>这种情况下，本条款成立的理由就非常直接而明确了： virtual 函数系动态绑定（ dynamically bound），而缺省参数值却是静态绑定（ statically bound）。静态绑定又叫前期绑定，earbinding：动态绑定又名后期绑定， late binding。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ー个用以描述几何形状的 cass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Shapecolor</span> { Red, Green, Blue };<span class="comment">//所有形状都必须提供一个函数，用来绘出自己</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(Shapecolor color=Red)</span><span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:   <span class="comment">//注意，赋予不同的缺省参数值，这真糟糕，可能是 Red</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( Shapecolor color=Green )</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">( Shapecolor color)</span> <span class="type">const</span></span>; <span class="comment">//译注：请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。</span></span><br><span class="line">                                                <span class="comment">//因为静态绑定下这个函数并不从其 base 继承缺省参数值。</span></span><br><span class="line">                                                <span class="comment">//但若以指针（或 reference）调用此函数，可以不指定参数值</span></span><br><span class="line">                                                <span class="comment">//因为动态绑定下这个函数会从其 base 继承缺省参数值。</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个继承体系图示如下 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/effectionc++4.png"></p><p>现在考虑这些指针：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape* pr =<span class="keyword">new</span> Rectangle;   <span class="comment">//静态类型为 Shape*</span></span><br><span class="line">pr ー&gt;<span class="built_in">draw</span>();                <span class="comment">//调用 Rectangle：draw（ Shape：Red）！</span></span><br></pre></td></tr></tbody></table></figure><p>此例之中，pr 的动态类型是 Rectangle<em>，所以调用的是 Rectangle 的 virtual 函数，一如你所预期。 Rectangle::draw 函数的缺省参数值应该是 GREN，但由于 pr 的静态类型是 Shape</em>，所以此一调用的缺省参数值来自 shape class 而非 Rectangle class！结局是这个函数调用有着奇怪并且几乎绝对没人预料得到的组合，由 Shape class 和 Rectangle class 的 draw 声明式各出一半力。</p><p><strong>请记住</strong></p><p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定而 virtual 函数一你唯一应该覆写的东西一却是动态绑定</p><h2 id="条款-38通过复合表示-has-a-或者根据某物实现出的关系">条款 38：通过复合表示 has-a 或者“根据某物实现出”的关系</h2><p>复合（ composition）的意义和 public 继承完全不同。 在应用域（ application domain），复合意味 has a（有一个）。在实现域（ implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）。</p><h2 id="条款-39明智而审慎地使用-private-继承">条款 39：明智而审慎地使用 private 继承</h2><p>其中 class Student 以 public 形式继承 class Person，于是编译器在必要时刻（为了让函数调用成功）将 Students 暗自转换为 Persons。现在我以 private 继承替换 public 继承：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {...};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person;  <span class="comment">//这次改用 pnvate 继承</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;      <span class="comment">//任何人都会吃</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;   <span class="comment">//只有学生才在校学习</span></span><br><span class="line">Person p;                       <span class="comment">//p 是人</span></span><br><span class="line">Student s;                      <span class="comment">//s 是学生</span></span><br><span class="line"><span class="built_in">eat</span> (p);                        <span class="comment">//没问题，p 是人，会吃。</span></span><br><span class="line"><span class="built_in">eat</span>(s);                         <span class="comment">//错误！吓，难道学生不是人？！</span></span><br></pre></td></tr></tbody></table></figure><p>如果 classes 之间的继承关系是 private，编译器不会自动将一个 derived class 对象（例如 Student）转换为一个 base class 对象（例如 Person）。这和 public 继承的情况不同。这也就是为什么通过 s 调用 eat 会失败的原因。第二条规则是，由 private base class 继承而来的所有成员，在 derived class 中都会变成 private 属性，纵使它们在 base class 中原本是 protected 或 public 属性。</p><p>Private 继承意味 implemented-in-terms-of（根据某物实现出）， private 继承意味只有实现部分被继承，接口部分应略去。</p><p><strong>请记住</strong></p><ul><li>Private 继承意味 is-implemented-in-terms of（根据某物实现出）。它通常比复合（ composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li><li>和复合（ composition）不同， private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ul><h2 id="条款-40明智而审慎地使用多重继承">条款 40：明智而审慎地使用多重继承</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/effectionc++5.png"></p><p>使用 virtual 继承的那些 classes 所产生的对象往往比使用 non-virtual 继承的兄弟们体积大，访问 virtual base classes 的成员变量时，也比访问 non-virtual base classes 的成员变量速度慢。</p><p>virtual 继承的成本还包括其他方面。支配“ virtual base classes 初始化”的规则比起 non-virtual bases 的情况远为复杂且不直观。 virtual base 的初始化责任是由继承体系中的最低层（ most derived） class 负责，这暗示：</p><ul><li>classes 若派生自 virtual bases 而需要初始化，必须认知其 virtual bases 一不论那些 bases 距离多远。</li><li>当一个新的 derived class 加入继承体系中，它必须承担其 virtual bases（不论直接或间接）的初始化责任。</li></ul><p>我对 virtual base classes（亦相当于对 virtual 继承）的忠告很简单。第一，非必要不使用ⅵrtual bases。平常请使用 non-virtual 继承。第二，如果你必须使用 virtual base classes，尽可能避免在其中放置数据。这么一来你就不需担心这些 classes 身上的初始化（和赋值）所带来的诡异事情了。</p><h1 id="参考文献">参考文献</h1><p>《Effective C++》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++（二） Effective C++（上）</title>
      <link href="/next/2021/Program/CPPEffectivePart1/"/>
      <url>/next/2021/Program/CPPEffectivePart1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/Effective-C++1.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxYmQ0NjFlZmFkNDA3ZTk5OTI3ZWI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="让自己习惯-c">让自己习惯 C++</h1><h2 id="条款-03尽可能使用-const">条款 03：尽可能使用 const</h2><p>如果关键字 const 出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting; <span class="comment">//non-const pointer,non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p greeting; <span class="comment">//non-const pointer,const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;   <span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting; <span class="comment">//const pointer,const data</span></span><br></pre></td></tr></tbody></table></figure><h2 id="条款-04确定对象被使用前已先被初始化">条款 04：确定对象被使用前已先被初始化</h2><ul><li>为内置型对象进行手工初始化，因为 C++不保证初始化它们。</li><li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。</li></ul><blockquote><p>成员初始化列表和构造函数的函数体都可以为我们的类数据成员指定一些初值，但是两者在给成员指定初值的方式上是不同的。成员初始化列表使用初始化的方式来为数据成员指定初值，而构造函数的函数体是通过赋值的方式来给数据成员指定初值。也就是说，成员初始化列表是在数据成员定义的同时赋初值，但是构造函的函数体是采用先定义后赋值的方式来做。这样的区别就造成了，在有些场景下，是必须要使用成员初始化列表。</p></blockquote><h1 id="构造析构赋值运算">构造/析构/赋值运算</h1><h2 id="条款-05了解-c默默编写并调用哪些函数">条款 05：了解 C++默默编写并调用哪些函数</h2><p>举个例子，假设 Namedobject 定义如下，其中 namevalue 是个 reference to string，objectValue 是个 const T：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Namedobject</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Namedobject</span> (std:string&amp; name,<span class="type">const</span> T&amp;value);</span><br><span class="line">                <span class="comment">//如前，假设并未声明 operator=</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string&amp; namevalue；<span class="comment">// referenceconst T objectvalue;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>现在考虑下面会发生什么事：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std:<span class="function">string <span class="title">newDog</span><span class="params">(<span class="string">"Persephone"</span>)</span></span>;</span><br><span class="line">std:<span class="function">string <span class="title">oldDog</span> <span class="params">(<span class="string">"Satch"</span>)</span></span>;</span><br><span class="line"><span class="function">Namedobject&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(newDog,<span class="number">2</span>)</span></span>;   <span class="comment">//当初撰写至此，我们的狗 Persephone</span></span><br><span class="line">                                <span class="comment">//即将度过其第二个生日。</span></span><br><span class="line"><span class="function">Namedobject&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(oldDog，<span class="number">36</span>)</span></span>; <span class="comment">//我小时候养的狗 Satch 则是 36 岁，</span></span><br><span class="line"></span><br><span class="line">p = s;                          <span class="comment">//现在 p 的成员变量该发生什么事？</span></span><br></pre></td></tr></tbody></table></figure><p>因为 C++并不允许“让 reference 改指向不同对象”。面对这个难题，C++的响应是拒绝编译那一行赋值动作。如果你打算在一个“内含 reference 成员”的 class 内支持赋值操作（assignment），你必须自己定义 copy assignment 操作符。</p><p>面对“内含 const 成员”的 classes，编译器的反应也一样。更改 const 成员是不合法的，所以编译器不知道如何在它自已生成的赋值函数内面对它们。</p><p>最后还有一种情况：如果某个 base classes 将 copy assignment 操作符声明为 private，编译器将拒绝为其 derived classes 生成一个 copy assignment 操作符。</p><h2 id="条款-06若不想使用编译器自动生成的函数就该明确拒绝">条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>所有编译器产出的函数都是 public。为阻止这些函数被创建出来，你得自行声明它们，但这里并没有什么需求使你必须将它们声明为 public。因此你可以将 copy 构造函数或 copy assignment 操作符声明为 private。藉由明确声明一个成员函数，你阻止了编译器暗自创建其专属版本；而令这些函数为 private，使你得以成功阻止人们调用它。</p><p><strong>请记住</strong></p><ul><li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 private 并且不予实现。</li></ul><h2 id="条款-07为多态基类声明虚析构函数">条款 07：为多态基类声明虚析构函数</h2><ul><li>polymorphic（带多态性质的）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数，因为 C++明白指出，当 derived class 对象经由一个 base class 指针被删除，而该 base class 带着一个 non-virtual 析构函数，其结果未有定义一实际执行时通常发生的是对象的 derived 成分没被销毁。</li><li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性（polymorphically），就不该声明 virtual 析构函数。当 class 不企图被当作 base class，令其析构函数为 virtual 往往是个馊主意。额外的虚表指针和虚函数表生成，导致占空间增加以及不兼容性。</li></ul><h2 id="条款-08别让异常逃离析构函数">条款 08：别让异常逃离析构函数</h2><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><h2 id="条款-09绝不在构造和析构过程中调用虚函数">条款 09：绝不在构造和析构过程中调用虚函数</h2><p><strong>在 base class 构造期间，virtual 函数不是 virtual 函数。</strong> 由于 base class 构造函数的执行更早于 derived class 构造函数，当 base class 构造函数执行时 derived class 的成员变量尚未初始化。如果此期间调用的 virtual 函数下降至 derived classes 阶层，要知道 derived class 的函数几乎必然取用 local 成员变量，而那些成员变量尚未初始化。所以 C++不让你走这条路。</p><p>其实还有比上述理由更根本的原因：在 derived class 对象的 base class 构造期间，对象的类型是 base class 而不是 derived class。不只 virtual 函数会被编译器解析至（resolve to）base class：，若使用运行期类型信息（runtime type information，例如 dynamic_cast 和 typeid），也会把对象视为 base class 类型。</p><p>相同道理也适用于析构函数。一旦 derived class 析构函数开始执行，对象内的 derived class 成员变量便呈现未定义值，所以 C++视它们仿佛不再存在。进入 baseclass 析构函数后对象就成为一个 base class 对象，而 C++的任何部分包括 virtual 函数、dynamic_casts 等等也就那么看待它。</p><h2 id="条款-10令-operator-返回一个-this-引用">条款 10：令 operator= 返回一个* this 引用</h2><p>关于赋值，有趣的是你可以把它们写成连锁形式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">//赋值连锁形式</span></span><br></pre></td></tr></tbody></table></figure><p>同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (y = (z = <span class="number">15</span>));</span><br></pre></td></tr></tbody></table></figure><p>这里 15 先被赋值给 z，然后其结果（更新后的 z）再被赋值给 y，然后其结果（更新后的 y）再被赋值给 x。为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符的左侧实参。这是你为 classes 实现赋值操作符时应该遵循的协议：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)    <span class="comment">//返回类型是个 reference，</span></span><br><span class="line">    {                                       <span class="comment">//指向当前对象。</span></span><br><span class="line">        <span class="keyword">return</span>* <span class="keyword">this</span>;                       <span class="comment">//返回左侧对象</span></span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="条款-12复制对象时勿忘其每一个成分">条款 12：复制对象时勿忘其每一个成分</h2><p>当你编写一个 copying 函数，请确保：</p><ul><li>复制所有 local 成员变量。</li><li>调用所有 base classes 内的适当的 copying 函数。</li></ul><p>令 copy assignment 操作符调用 copy 构造函数是不合理的，因为这就像试图构造个已经存在的对象。这件事如此荒谬，乃至于根本没有相关语法。是有一些看似如你所愿的语法，但其实不是；也的确有些语法背后真正做了它，但它们在某些情况下会造成你的对象败坏，所以我不打算将那些语法呈现给你看。单纯地接受这个叙述吧：你不该令 copy assignment 操作符调用 copy 构造函数。</p><p>反方向一令 copy 构造函数调用 copy assignment 操作符一同样无意义。构造函数用来初始化新对象，而 assignment 操作符只施行于已初始化对象身上。对一个尚未构造好的对象赋值，就像在一个尚未初始化的对象身上做“只对已初始化对象才有意义”的事一样。无聊嘛！别尝试。</p><p>如果你发现你的 copy 构造函数和 copy assignment 操作符有相近的代码，消除重复代码的做法是，建立一个新的成员函数给两者调用。这样的函数往往是 private 而且常被命名为 init。这个策略可以安全消除 copy 构造函数和 copy assignment 操作符之间的代码重复。</p><h1 id="参考文献">参考文献</h1><p>《Effective C++》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++（一）对象模型</title>
      <link href="/next/2021/Program/CPPobjectModel/"/>
      <url>/next/2021/Program/CPPobjectModel/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPPObjectModle.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxODNiYzBlM2U3NDA3ZGE0ZWE3ZGU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="对象模式">对象模式</h1><p>在 C++中，有两种 class data members：static 和 nonstatic，以及三种 class member functions：static、nonstatic 和 virtual。已知下面这个 class Point 声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp;</span></span><br><span class="line"><span class="function">      <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个 class Point 在机器中将会被怎么样表现呢？也就是说，我们如何模塑（modeling）出各种 data members 和 function members 呢？</p><h2 id="c对象模型the-c-object-model">C++对象模型（The C++ Object Model）</h2><p>Stroustrup 当初设计的 C++对象模型是从简单对象模型派生而来的，并对内存空间和存取时间做了优化。在此模型中：</p><ul><li>Nonstatic datamembers 被配置于每一个 class object 之内。</li><li>static data members 则被存放在所有的 class object 之外（data 段或 bss 段）。</li><li>Static 和 nonstatic function members 也被放在所有的 class object 之外（代码段）。</li><li>Virtual functions 则以两个步骤支持之：<ul><li>每一个 class 产生出一堆指向 virtual functions 的指针，放在表格之中。这个表格被称为 virtual table（vtbl）</li><li>每一个 class object 被添加了一个指针，指向相关的 virtual table。通常这个指针被称为 vptr。vptr 的设定（setting）和重置（resetting）都由每一个 class 的 constructor、destructor 和 copy assignment 运算符自动完成。每一个 class 所关联的 type_info object（用以支持：runtime type identifcation，RTTI）也经由 virtual table 被指出来，通常是放在表格的第一个 slot 处 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo3.png"></li></ul></li></ul><h2 id="加上继承adding-inheritance">加上继承（Adding Inheritance）</h2><p>单一继承：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Library_materials</span> {...}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Library_materials {..}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rental_book</span> : <span class="keyword">public</span> Book {..}</span><br></pre></td></tr></tbody></table></figure><p>多重继承：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原本的（更早于标准版的）iostream 实现方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span>:</span><br><span class="line">    <span class="keyword">public</span> istream,</span><br><span class="line">    <span class="keyword">public</span> ostream {..}</span><br></pre></td></tr></tbody></table></figure><p>甚至，继承关系也可以指定为虚拟（virtual，也就是共享的意思）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios {...}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios {...}</span><br></pre></td></tr></tbody></table></figure><p>在虚拟继承的情况下，base class 不管在继承串链中被派生（derived）多少次，永远只会存在一个实体（称为 subobject）。例如 iostream 之中就只有 virtual ios base class 的一个实体。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo4.png"></p><p>base class table 被产生出来时，表格中的每一个 slot 内含一个相关的 base class 地址，这很像 virtual table 内含每一个 virtual function 的地址一样。每一个 class object 内含一个 bptr，它会被初始化，指向其 base class table。</p><ul><li>缺点：主要缺点是由于间接性而导致的空间和存取时间上的额外负担，</li><li>优点：<ul><li>在每一个 class object 中对于继承都有一致的表现方式：每一个 class object 都应该在某个固定位置上安放一个 base table 指针，与 base classes 的大小或数目无关</li><li>不需要改变 class objects 本身，就可以放大、缩小、或更改 base class table <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo5.png"></li></ul></li></ul><p>需要多少内存才能够表现一个 class object？一般而言要有：</p><ul><li>其 nonstatic data members 的总和大小。</li><li>加上任何由于 alignment 的需求而填补（padding）上去的空间。</li><li>加上为了支持 virtual 而由内部产生的任何额外负担（overhead）。</li></ul><h1 id="构造函数语义学">构造函数语义学</h1><h2 id="default-constructor-的建构操作">Default Constructor 的建构操作</h2><p>C++ Standard【ISO-C++95】的 Section12.1 这么说： 对于 class X，如果没有任何 user-declared constructor，那么会有一个 default constructor 被暗中（implicitly）声明出来。一个被暗中声明出来的 default constructor 将是一个 trivial（浅薄而无能，没啥用的）constructor。</p><p>C++ Standard 然后开始叙述在什么样的情况下这个 implicit default constructor 会被视为 trivial。一个 nontrivial default constructor 在 ARM 的术语中就是编译器所需要的那种，必要的话会由编译器合成出来。下面分别讨论 nontrivial default constructor 的四种情况。</p><h3 id="带有-default-constructor-的-member-class-object">带有 Default Constructor 的 Member Class Object</h3><p>如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是“nontrivial'”，编译器需要为此 class 合成出一个 default constructor。</p><ul><li>在 C++各个不同的编译模块中，编译器如何避免合成出多个 default constructor 呢？解决方法是把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 方式完成。一个 inline 函数有静态链接（static linkage），不会被档案以外者看到。如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实体</li><li>“如果 class A 内含一个或一个以上的 member class objects，那么 class A 的每一个 constructor 必须调用每一个 member classes 的 default constructor”。编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 在被执行之前，先调用必要的 default constructors</li><li>如果有多个 class member objects 都要求 constructor 初始化操作，将如何呢？C++语言要求以“member objects 在 class 中的声明次序”来调用各个 constructors</li></ul><h3 id="带有-default-constructor-的-base-class">带有 Default Constructor 的 Base Class</h3><p>类似的道理，如果一个没有任何 constructors 的 class 派生自一个“带有 default constructor'”的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的 default constructor（根据它们的声明次序）。</p><p>如果设计者提供多个 constructors，但其中都没有 default constructor 呢？编译器会扩张现有的每一个 constructors，将“用以调用所有必要之 default constructors”的程序代码加进去。它不会合成一个新的 default constructor，这是因为其它“由 user 所提供的 constructors”存在的缘故。</p><p>如果同时亦存在着“带有 default constructors”的 member class objects，那些 default constructor 也会被调用-—在所有 base class constructor 都被调用之后。</p><h3 id="带有一个-virtual-function-的-class">带有一个 Virtual Function 的 Class</h3><ul><li>class 声明（或继承）一个 virtual function</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes</li></ul><p>不管哪一种情况，由于缺乏由 user 声明的 constructors，编译器会详细记录合成一个 default constructor 的必要信息。</p><ul><li>一个 virtual function table（在 cfront 中被称为 vtbl）会被编译器产生出来，内放 class 的 virtual functions 地址</li><li>在每一个 class object 中，一个额外的 pointer member（也就是 vptr）会被编译器合成出来，内含相关的 class vtbl 的地址</li></ul><h3 id="带有一个-virtual-base-class-的-class">带有一个 Virtual Base Class 的 Class</h3><p>Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共通点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。例如下面这段程序代码中：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> {<span class="keyword">public</span>:<span class="type">int</span> i;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X {<span class="keyword">public</span>:<span class="type">int</span> j;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X {<span class="keyword">public</span>:<span class="type">double</span> d;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B {<span class="keyword">public</span>:<span class="type">int</span> k;};</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A *pa)</span> </span>{ pa-&gt;i = <span class="number">1024</span>;};</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原先 cfront 的做法是靠“在 derived class object 的每一个 virtual base classes 中安插一个指针”完成。所有“经由 reference 或 pointer 来存取一个 virtual base class”的操作都可以通过相关指针完成。foo() 可以被改写如下，以符合这样的实现策略：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能的编译器转变操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A*pa)</span> </span>{pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;}</span><br></pre></td></tr></tbody></table></figure><p>其中__vbcX 表示编译器所产生的指针，指向 virtual base class X。正如你所臆测的那样，__vbcX（或编译器所做出的某个什么东西）是在 class object 建构期间被完成的。对于 class 所定义的每一个 constructor，编译器会安插那些“允许每一个 virtual base class 的执行期存取操作”的码。如果 class 没有声明任何 constructors，编译器必须为它合成一个 default constructor。</p><h2 id="copy-constructor-的建构操作">Copy Constructor 的建构操作</h2><p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值。最明显的一种情况当然就是对一个 object 做明确的初始化操作，另两种情况是当 object 被当作参数交给某个函数以及当函数传回一个 class object 时。</p><h3 id="default-memberwise-initialization">Default Memberwise Initialization</h3><p>如果 class 没有提供一个 explicit copy constructor 又当如何？当 class object 以“相同 class 的另一个 object”作为初值时，其内部是以所谓的 default memberwise initializatior 手法完成的，也就是把每一个内建的或派生的 datamember（例如一个指针或数目组）的值，从某个 object 拷贝一份到另一个 object 身上。不过它并不会拷贝其中的 member class object，而是以递归的方式施行 memberwise initializaon。</p><p>如果一个 String object 被声明为另一个 class 的 member，像这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//……没有 explicit copy constructorprivate:</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    string _word；<span class="comment">//译注：String object 成为 class Word 的一个 member!</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>那么一个 Word object 的 default memberwise initialization 会拷贝其内建的 member _occurs，然后再于 String member object_word 身上递归实施 memberwise initialization</p><p>就像 default constructor 一样，C++ Standard 上说，如果 class 没有声明一个 copy constructor，就会有隐含的声明（implicitly declared）或隐含的定义（implicitlydefined）出现。和以前一样，C++Standard 把 copy constructor 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实体才会被合成于程序之中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copysemantics'”。</p><h3 id="bitwise-copy-semantics位逐次拷贝">Bitwise Copy Semantics（位逐次拷贝）</h3><p>在下面的程序片段中：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Word.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Word <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Word verb = noun;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很明显 verb 是根据 noun 来初始化。但是在尚未看过 class Word 的声明之前，我们不可能预测这个初始化操作的程序行为。如果 class Word 的设计者定义了一个 copy constructor，verb 的初始化操作会调用它。但如果该 class 没有定义 explicit copy constructor，那么是否会有一个编译器合成的实体被调用呢？这就得视该 class 是否展现"bitwise copy semantics'”而定。举个例子，已知下面的 class Word 声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下声明展现了 bitwise copy semantic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="type">const</span> <span class="type">char</span>*)</span><br><span class="line">    ~<span class="built_in">Word</span>() {<span class="keyword">delete</span>[] str;}</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这种情况下并不需要合成出一个 default copy constructor，因为上述声明展现了“default copy semantics”，而 verb 的初始化操作也就不需要以一个函数调用收场。</p><p>一般来说，如果你的 class 仅包含了 POD（Plain Object Data) 这样的，是展现出了 Bitwise Copy Semantics，即编译器在内部可以一个字节一个字节的拷贝（如 memcpy）也不会出现问题。</p><p>然而，如果 class Word 是这样声明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下声明并未展现出 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="type">const</span> String&amp;)</span><br><span class="line">    ~<span class="built_in">Word</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其中 String 声明了一个 explicit copy constructor：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* );</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在这个情况下，编译器必须合成出一个 copy constructor 以便调用 member class String object 的 copy constructor：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个被合成出来的 copy constructor</span></span><br><span class="line"><span class="comment">//C++伪码</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Word::Word</span><span class="params">(<span class="type">const</span> Word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有一点很值得注意：在这被合成出来的 copy constructor 中，如整数、指针、数组等等的 nonclass members 也都会被复制，正如我们所期待的一样。</p><h3 id="不要-bitwise-copy-semantics">不要 Bitwise Copy Semantics！</h3><p>什么时候一个 class 不展现出“bitwise copy semantics”呢？有四种情况：</p><ul><li>当 class 内含一个 member object 而后者的 class 声明有一个 copy constructor 时（不论是被 class 设计者明确地声明，就像前面的 String 那样；或是被编译器合成，像 class Word 那样）。</li><li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（再次强调，不论是被明确声明或是被合成而得）。</li><li>当 class 声明了一个或多个 virtual functions 时。</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</li></ul><p>前两种情况中，编译器必须将 member 或 base class 的“copy constructors 调用操作”安插到被合成的 copy constructor 中。前一节 class Word 的“合成而得的 copy constructor”正足以说明情况 1,2。情况 3 和 4 有点复杂，是我接下来要讨论的题目。</p><p><strong>重新设定 Virtual Table 的指针</strong><br>回忆编译期间的两个程序扩张操作（只要有一个 class 声明了一个或多个 virtual functions 就会如此）：</p><ul><li>增加一个 virtual function table（vtbl），内含每一个有作用的 virtual function 的地址。</li><li>将一个指向 virtual function table 的指针（vptr），安插在每一个 class object 内。</li></ul><p>很显然，如果编译器对于每一个新产生的 class object 的 vptr 不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个 vptr 到 class 之中时，该 class 就不再展现 bitwise semantics 了。现在，编译器需要合成出一个 copy constructor，以求将 vptr 适当地初始化。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo6.png"></p><p>yogi 会被 default Bear constructor 初始化。而在 constructor 中，yogi 的 vptr 被设定指向 Bear class 的 virtual table（靠编译器安插的码完成）。因此，把 yogi 的 vptr 值拷贝给 winnie 的 vptr 是安全的。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo7.png"> 合成出来的 ZooAnimal copy constructor 会明确设定 object 的 vptr 指向 ZooAnimal class 的 virtual table，而不是直接从右手边的 class object 中将其 vptr 现值拷贝过来。</p><h1 id="data-语意学">Data 语意学</h1><h2 id="类对象大小受三个因素影响">类对象大小受三个因素影响</h2><ul><li>virtual base 和 virtual function 带来的 vptr 影响</li><li>EBO（Empty Base class Optimize）空基类优化处理，EBC（Empty Base Class）占用一个字节，其他含有数据成员的从 EBC 派生的派生类，只会算自己数据成员的大小，不受 EBC 一字节的影响</li><li>alignment 字节对齐</li></ul><h2 id="nonstatic-data-members">Nonstatic data members</h2><ul><li>Nonstatic data members 在 class object 中的排列顺序将和其被声明顺序一样，任何中间介入的 static data members 都不会被放进布局之中</li><li>每一个 nonstatic data member 的偏移量在编译时即可获知，不管其有多么复杂的派生，都是一样的。通过对象存取一个 nonstatic data member，其效率和存取一个 C struct member 是一样的</li><li>从对象存取 obj.x 和指针存取 pt-&gt;x 有和差异？ 当继承链中有虚基类时，查找虚基类的成员变量时延迟到了执行期，根据 virtual class offset 查找到虚基类的部分，效率稍低</li></ul><h2 id="静态成员变量-static-data-members">静态成员变量 static data members</h2><ul><li>存放在程序的 data segment 之中</li><li>通过指针和对象来存取 member，完全一样，不管继承或者是虚拟继承得来，全局也只存在唯一一个实例</li><li>静态常量成员可以在类定义时直接初始化，而普通静态常量成员只能在。o 编译单元的全局范围内初始化</li></ul><h2 id="迷承与-data-member">“迷承”与 Data Member</h2><h4 id="只要继承不要多态inheritance-without-polymorphism">只要继承不要多态（Inheritance without Polymorphism）</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">char</span> c3;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo8.png"></p><p>在一部 32 位机器中，每一个 Concrete class object 的大小都是 8 bytes，细分如下：</p><ul><li>val 占用 4 bytes</li><li>c1、c2 和 c3 各占用 1 bytes</li><li>alignment（调整到 word 边界）需要 1 bytes</li></ul><p>现在假设，经过某些分析之后，我们决定了一个更逻辑的表达方式，把 Concrete 分裂为三层结构：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete1</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//.…</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> bit1;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete2</span> : <span class="keyword">public</span> Concrete1</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> bit2;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete3</span> : <span class="keyword">public</span> Concrete2</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> bit3;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Concrete1 内含两个 members：val 和 bit1，加起来是 5 bytes。而一个 Concrete.object 实际用掉 8 bytes，包括填补用的 3 bytes，以使 object 能够符合一部机器的 word 边界。不论是 C 或 C++都是这样。一般而言，边界调整（alignment）是由处理器（processor）来决定的。</p><p>Concrete2 的 bit2 实际上被放在填补空间所用的 3 bytes 之后。于是其大小变成 12 bytes，不是 8 bytes。其中有 6 bytes 浪费在填补空间上。相同的道理使得 Concrete3 object 的大小是 16 bytes，其中 9 bytes 用于填补空间。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo9.png"></p><h4 id="多重继承multiple-inheritance">多重继承（Multiple Inheritance）</h4><p>多重继承既不像单一继承，也不容易模塑出其模型。例如，考虑下面这个多重继承所获得的 class Vertex3d：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _x,_y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span> : <span class="keyword">public</span> Point3d ，<span class="keyword">public</span> vertex</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> mumble;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其继承关系如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo10.png"></p><p>内存布局如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo11.png"></p><h4 id="虚拟继承-vitual-inheritance">虚拟继承 (Vitual Inheritance)</h4><p>一般的实现方法如下所述。Class 如果内含一个或多个 virtual base class subobjects，将被分割为两部分：一个不变局部和一个共享局部。不变局部中的数据，不管后继如何衍化，总是拥有固定的 offset（从 object 的开头算起），所以这一部分数据可以被直接存取。至于共享局部，所表现的就是 virtual base class subobject。这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。各家编译器实现技术之间的差异就在于间接存取的方法不同。下面是 Vertex3d 虚拟继承的层次结构：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _x,_y;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> vitrual Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _z;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span> : <span class="keyword">public</span> vitrual Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//，·.（译注：拥有 virtual 接口。所以 Vertex 对象之中会有 vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span>:: <span class="keyword">public</span> Point3d ，<span class="keyword">public</span> vertex</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> mumble;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其继承关系如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo12.png"></p><p>内存布局如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo13.png"></p><h1 id="function-语意学">Function 语意学</h1><h2 id="c的设计准则之一nostatic-member-function-至少必须和一般的-nonmember-function-有相同的效率">C++的设计准则之一：nostatic member function 至少必须和一般的 nonmember function 有相同的效率</h2><ul><li>改写函数原型，在参数中增加 this 指针。</li><li>对每一个"nonstatic data member 的存取操作"改为由 this 指针来存取。</li><li>将 member function 重写为一个外部函数，经过"mangling"处理。</li></ul><h2 id="覆盖override重写overload隐藏hide的区别">覆盖（override）、重写（overload）、隐藏（hide）的区别</h2><ul><li>重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li><li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。</li><li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li></ul><h2 id="virtual-member-functions虚拟成员函数">Virtual Member Functions（虚拟成员函数）</h2><p>我们已经看过了 virtual function 的一般实现模型：每一个 class 有一个 virtual table，内含该 class 之中有作用的 virtual function 的地址，然后每个 object 有一个 vptr，指向 virtual table 的所在。在这一节中，我要走访一组可能的设计，然后根据单一继承、多重继承和虚拟继承等各种情况，从细部上探究这个模型、为了支持 virtual function 机制，必须首先能够对于多态对象有某种形式的“执行期类型判断法（runtime type resolution）”。也就是说，以下的调用操作将需要 ptr 在执行期的某些相关信息，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></tbody></table></figure><p>如此一来才能够找到并调用 z() 的适当实体。或许最直接了当但是成本最高的解决方法就是把必要的信息加在 ptr 身上。在这样的策略之下，一个指针（或是一个 reference）含有两项信息：</p><ul><li>它所参考到的对象的地址。</li><li>对象类型的某种编码，或是某个结构的地址。</li></ul><p>这个方法带来两个问题</p><ul><li>第一，它明显增加了空间负担，即使程序并不使用多态（polymorphism）。</li><li>第二，它打断了与 C 程序间的链接兼容性。如果这份额外信息不能够和指针放在一起，下一个可以考虑的地方就是把它放在对象本身。</li></ul><p>欲鉴定哪些 classes 展现多态特性，我们需要额外的执行期信息。一如我所说，关键词 class 和 struct 并不能够帮助我们。由于没有导入如 polymorphic 之类的新关键词，因此识别一个 class 是否支持多态，唯一适当的方法就是看看它是否有任何 virtual function。只要 class 拥有一个 virtual function，它就需要这份额外的执行期信息。</p><p>下一个明显的问题是，什么样的额外信息是我们需要存储起来的？也就是说，如果我有这样的调用：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></tbody></table></figure><p>其中 z() 是一个 virtual function，那么什么信息才能让我们在执行期调用正确的 z() 实体？我需要知道：</p><ul><li>ptr 所指对象的真实类型。这可使我们选择正确的 z() 实体。</li><li>z() 实体位置，以便我能够调用它。</li></ul><p>那么，我如何有足够的知识在编译时期设定 virtual function 的调用呢？</p><ul><li>一般而言，我并不知道 ptr 所指对象的真正类型，然而我知道，经由 ptr 可以存取到该对象的 virtual table。虽然我不知道哪一个 z() 函数实体会被调用，但我知道每一个 z() 函数地址都被放在 slot4。这些信息使得编译器可以将该调用转化为：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ptr-&gt;vptr[<span class="number">4</span>]) (ptr );</span><br></pre></td></tr></tbody></table></figure><p>在这个转化中，ptr 表示编译器所安的指针，指向 virtual table；4 表示 z() 被赋值的 slot 编号（关联到 Point 体系的 virtual table）唯一个在执行期才能知道的东西是：slot4 所指的到底是哪一个 z() 函数实体？</p><p>在一个单一继承体系中，virtual function 机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，对 virtual functions 的支持就没有那么美好了。</p><h3 id="多重继承下的-virtual-functions">多重继承下的 Virtual Functions</h3><p>在多重继承中支持 virtual functions，其复杂度围绕在第二个及后继的 base classes 身上，以及“必须在执行期调整 this 指针”这一点。以下面的 class 体系为例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class 体系，用来描述多重继承（MI）情况下支持 virtual function 时的复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speakclearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Base1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mumble</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Base2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span> <span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Derived;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo15.png"></p><p>“Derived 支持 virtual functions”的困难度，统统落在 Base2 subobject 身上。有三个问题需要解决，以此例而言分别是</p><ul><li>virtual destructor。</li><li>被继承下来的 Base2：mumble()。</li><li>一组 clone() 函数实体。</li></ul><p>让我依次解决每一个问题</p><p><strong>第一种情况：</strong><br>我把一个从 heap 中配置而得的 Derived 对象的地址，指定给一个 Base2 指针：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br></pre></td></tr></tbody></table></figure><p>新的 Derived 对象的地址必须调整，以指向其 Base2 subobject。编译时期会产生以下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移以支持第二个 base class</span></span><br><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = temp ? temp + <span class="built_in">sizeof</span> ( Base1 ) : <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果没有这样的调整，指针的任何“非多态运用”（像下面那样）都将失败：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使 pbase2 被指定一个 Derived 对象，这也应该没有问题</span></span><br><span class="line">pbase2-&gt;data_Base2;</span><br></pre></td></tr></tbody></table></figure><p>当程序员要删除 pbase2 所指的对象时：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须首先调用正确的 virtual destructor 函数实体</span></span><br><span class="line"><span class="comment">//然后施行 delete 运算符。</span></span><br><span class="line"><span class="comment">//pbase2 可能需要调整，以指出完整对象的起始点</span></span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></tbody></table></figure><p>指针必须被再一次调整，以求再一次指向 Derived 对象的起始处（推测它还指向 Derived 对象）。然而上述的 offset 加法却不能够在编译时期直接设定，因为 pbase2 所指的真正对象只有在执行期才能确定。</p><p>一般规则是，经由指向“第二或后继之 base class”的指针（或 reference）来调用 derived class virtual function。泽注就像本例的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pbase2; <span class="comment">//invoke derived class's destructor (virtual)</span></span><br></pre></td></tr></tbody></table></figure><p>该调用操作所连带的“必要的 this 指针调整”操作，必须在执行期完成。也就是说，offset 的大小，以及把 offset 加到 this 指针上头的那一小段程序代码必须由编译器在某个地方插人。问题是，在哪个地方？</p><p><strong>offset</strong><br>Bjarne 原先实施于 cfront 编译器中的方法是将 virtual table 加大，使它容纳此处所需的 this 指针，调整相关事物。每一个 virtual table slot，不再只是一个指针，而是一个聚合体，内含可能的 offset 以及地址。于是 virtual function 的调用操作由：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pbase2-&gt;vptr [<span class="number">1</span>])(pbase2 )</span><br></pre></td></tr></tbody></table></figure><p>改变为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*pbase2-&gt;vptr[<span class="number">1</span>].faddr)</span><br><span class="line">    pbase2 + pbase2-&gt;vptr[<span class="number">1</span>].offset )</span><br></pre></td></tr></tbody></table></figure><p>其中 faddr 内含 virtual function 地址，offset 内含 this 指针调整值。</p><p>这个做法的缺点是，它相当于连带处罚了所有的 virtual function 调用操作。不管它们是否需要 offset 的调整我所谓的处罚，包括 offset 的额外存取及其加法，以及每一个 virtual table slot 的大小改变。</p><p>比较有效率的解决方法是利用所谓的 thunk。Thunk 技术初次引进到编译器技术中，我相信是为了支持 ALGOL 独一无二的 pass-by-name 语意。所谓 thunk 是一小段 assembly 码，用来以适当的 offset 值调整 this 指针，跳到 virtual function 去。例如，经由一个 Base？指针调用 Derived destructor，其相关的 thunk 可能看起来是这个样子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟 C++码</span></span><br><span class="line">pbase2_dtor_thunk:</span><br><span class="line">    <span class="keyword">this</span> += <span class="built_in">sizeof</span> (base1)</span><br><span class="line">    Derived::~<span class="built_in">Derived</span> (<span class="keyword">this</span> )</span><br></pre></td></tr></tbody></table></figure><p>Bjarne 并不是不知道 thunk 技术，问题是 thunk 只有以 assembly 码完成才有效率可言。由于 cfront 使用 C 作为其程序代码产生语言，所以无法提供一个有效率的 thunk 编译器。 Thunk 技术允许 virtual table slot 继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。Slots 中的地址可以直接指向 virtual function，也可以指向一个相关的 thunk（如果需要调整 this 指针的话）。于是，对于那些不需要调整 this 指针的 virtual function（相信大部分是如此，虽然我手上没有数据）而言，也就不需承载效率上的额外负担。 调整 this 指针的第二个额外负担就是，由于两种不同的可能：</p><ul><li>经由 derived class 调用，经由第二个 base class 调用，同一函数在 virtual table 中可能需要多笔对应的 slots。例如：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base1 *pbase1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pbase1;</span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></tbody></table></figure><p>虽然两个 delete 操作导致相同的 Derived destructor，但它们需要两个不同的 virtual table slots:</p><ul><li>pbase1 不需要调整 this 指针（因为 Base1 是最左端 base class 之故，它已经指向 Derived 对象的起始处）。其 virtual table slot 需放置真正的 destructor 地址。</li><li>pbase2 需要调整 this 指针。其 virtual table slot 需要相关的 thunk 地址。</li></ul><p>在多重继承之下，一个 derived class 内含 n-1 个额外的 virtual tables，n 表示其上一层 base classes 的数目（因此，单一继承将不会有额外的 virtual tables）。对于本例之 Derived 而言，会有两个 virtual tables 被编译器产生出来：</p><ul><li>一个主要实体，与 Basel（最左端 base class）共享。</li><li>一个次要实体，与 Base2（第二个 base class）有关。</li></ul><p>针对每一个 virtual tables，Derived 对象中有对应的 vptr。图 4.2 说明了这一点。vptrs 将在 constructor（s）中被设立初值（经由编译器所产生出来的码） <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo16.png"></p><p>用以支持“一个 class 拥有多个 virtual tables'”的传统方法是，将每一个 tables 以外部对象的形式产生出来，并给予独一无二的名称。例如，Derived 所关联的两个 tables 可能有这样的名称：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vtbl Derived;  <span class="comment">//主要表格</span></span><br><span class="line">vtbl Base2_Derived;  <span class="comment">//次要表格</span></span><br></pre></td></tr></tbody></table></figure><p>于是当你将一个 Derived 对象地址指定给一个 Base1 指针或 Derived 指针时，被处理的 virtual table 是主要表格 vtbl Derived。而当你将一个 Derived 对象地址指定给一个 Base2 指针时，被处理的 virtual table 是次要表格 vtbl Base2 Derived。</p><p>由于执行期链接器（runtime linkers）的降临，符号名称的链接可能变得非常缓慢。为了调节执行期链接器的效率，Sun 编译器将多个 virtual tables 连锁为一个；指向次要表格的指针，可由主要表格名称加上一个 offset 获得。在这样的策略下，每一个 class 只有一个具名的 virtual table。“对于许多 Sun 项目程序代码而言，速度的提升十分明显。</p><p>稍早我曾写道，有三种情况，第二或后继的 base class 会影响对 virtual functions 的支持。第一种情况是，通过一个“指向第二个 base class”的指针，调用 derived class virtual function。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Derived：~Derived</span></span><br><span class="line"><span class="comment">//ptr 必须被向后调整 sizeof（Basel）个 bytes</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></tbody></table></figure><p>从图 4.2 之中，你可以看到这个调用操作的重点：ptr 指向 Derived 对象中的 Base2 subobject；为了能够正确执行，ptr 必须调整指向 Derived 对象的起始处。</p><p><strong>第二种情况：</strong><br>是第一种情况的变化，通过一个“指向 derived class”的指针，调用第二个 base class 中一个继承而来的 virtual function。在此情况下，derived class 指针必须再次调整，以指向第二个 base subobject。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Base2：mumble()</span></span><br><span class="line"><span class="comment">//per 必须被向前调整 sizeof（zaael）个 bytes</span></span><br><span class="line">pder-&gt;<span class="built_in">munble</span>();</span><br></pre></td></tr></tbody></table></figure><p><strong>第三种情况：</strong><br>发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化，可能是 base type，也可能是 publicly derived type。这一点可以通过 Derivea：clone() 函数实体来说明。clone 函数的 Derived 版本传回一个 Derived class 指针，默默地改写了它的两个 base class 函数实体。当我们通过“指向第二个 base class'”的指针来调用 clone() 时，this 指针的 offset 问题于是诞生：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Derived*Derived：clone()</span></span><br><span class="line"><span class="comment">//返回值必须被调整，以指向 Base2 subobject</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></tbody></table></figure><p>当进行 pb1-&gt;clone() 时，pb1 会被调整指向 Derived 对象的起始地址，于是 clone() 的 Derived 版会被调用：它会传回一个指针，指向一个新的 Derived 对象；该对象的地址在被指定给 pb2 之前，必须先经过调整，以指向 Base2 subobject。</p><p>当函数被认为“足够小”的时候，Sun 编译器会提供一个所谓的“splitfunctions”技术：以相同算法产生出两个函数，其中第二个在返回之前，为指针加上必要的 offset。于是不论通过 Base1 指针或 Derived 指针调用函数，都不需要调整返回值；而通过 Base2 指针所调用的，是另一个函数。</p><p>如果函数并不小，“split function”策略会给予此函数中的多个进入点（entrypoints）中的一个。每一个进人点需要三个指令，然而 OO 程序员都会尽量使用小规模的 virtual function 将操作“局部化”。通常，virtual function 的平均大小是 8 行。</p><p>函数如果支持多重进入点，就可以不必有许多“thunks'”。如 IBM 就是把 thunk 搂抱在真正被调用的 virtual function 中。函数一开始先调整 this 指针，然后才执行程序员所写的函数码：至于不需调整的函数调用操作，就直接进人的部分。</p><h3 id="虚拟继承下的-virtual-functions">虚拟继承下的 Virtual Functions</h3><p>两者之间的转换也就需要调整 this 指针。至于在虚拟继承的情况下要消除 thunks，一般而言已经被证明是一项高难度技术。</p><p>当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual functions 和 nonstatic data members 时，编译器对于 virtual base class 的支持简直就像进了迷宫一样。我的建议是：</p><blockquote><p>不要在一个 virtual base class 中声明 nonstatic data members</p></blockquote><h2 id="静态成员函数-static-member-functions">静态成员函数 static member functions</h2><ul><li>不能访问非静态成员。</li><li>不能声明为 const、volatile 或 virtual。</li><li>参数没有 this。</li><li>可以不用对象访问，直接 类名：: 静态成员函数访问。</li></ul><h2 id="vtable-虚函数表一定是在编译期间获知的其函数的个数位置和地址是固定不变的完全由编译器掌控执行期间不允许任何修改">vtable 虚函数表一定是在编译期间获知的，其函数的个数、位置和地址是固定不变的，完全由编译器掌控，执行期间不允许任何修改</h2><p>vtable 的内容：</p><ul><li>virtual class offset（有虚基类才有）。</li><li>topoffset。</li><li>typeinfo。</li><li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数。</li><li>新的虚函数（或者是纯虚函数占位）。</li></ul><h2 id="执行期虚函数调用步骤">执行期虚函数调用步骤</h2><ul><li>通过 vptr 找到 vtbl。</li><li>通过 thunk 技术以及 topoffset 调整 this 指针（因为成员函数里面可能调用了成员变量）。</li><li>通过 virtual class offset 找到虚基类共享部分的成员。</li><li>执行 vtbl 中对应 slot 的函数。</li><li>多重继承中，一个派生类会有 n-1 个额外的 vtbl（也可能有 n 或者 n 以上个 vtbl，看是否有虚基类），它与第一父类共享 vtbl，会修改其他父类的 vtbl。</li></ul><blockquote><p>最后：Inline 对编译器只是请求，并非命令。inline 中的局部变量+有表达式参数--&gt;大量临时变量--&gt;程序规模暴涨</p></blockquote><h1 id="执行期语意学">执行期语意学</h1><ul><li>尽量推迟变量定义，避免不必要的构造和析构（虽然 C++编译器会尽量保证在调用变量的时候才进行构造，推迟变量定义会使得代码好阅读）.</li><li>全局类变量在编译期间被放置于 data 段中并被置为 0.<ul><li>GOOGLE C++编程规范：禁止使用 class 类型的静态或全局变量，只允许使用 POD 型静态变量 (Plain Old Data) 和原生数据类型。因为它们会导致很难发现的 bug 和不确定的构造和析构函数调用顺序</li><li>解决：改成在 static 函数中，产生局部 static 对象</li></ul></li><li>如果有表达式产生了临时对象，那么应该对完整表达式求值结束之后才摧毁这些创建的临时对象。有两个例外：<ul><li>该临时对象被 refer 为另外一个对象的引用；</li><li>该对象作为另一对象的一部分被使用，而另一对象还没有被释放。</li></ul></li></ul><h1 id="站在对象模型的尖端">站在对象模型的尖端</h1><ul><li>对于 RTTI 的支持，在 vtbl 中增加一个 type_info 的 slot。</li><li>dynamic_cast 比 static_cast 要花费更多的性能（检查 RTTI 释放匹配、指针 offset 等），但是安全性更好。</li><li>对引用施加 dynamic_cast：1）成功；或 2）抛出 bad_cast 异常；对指针施加：1）成功；2）返回 0 指针。</li><li>使用** typeid() **进行判断，合法之后再进行 dynamic_cast，这样就能够避免对引用操作导致的 bad_cast 异常： if(typeid(rt) == typeid(rt2)) …。但是如果 rt 和 rt2 本身就是合法兼容的话，就会损失了一次 typeid 的操作性能。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pmZW5nemhlbi9CbG9nL2Jsb2IvbWFzdGVyL2FydGljbGUvJUUzJTgwJThBJUU2JUI3JUIxJUU1JTg1JUE1JUU2JThFJUEyJUU3JUI0JUEyQyUyQiUyQiVFNSVBRiVCOSVFOCVCMSVBMSVFNiVBOCVBMSVFNSU5RSU4QiVFMyU4MCU4QiVFOCVBRiVCQiVFNCVCOSVBNiVFNyVBQyU5NCVFOCVBRSVCMC5tZA==">https://github.com/zfengzhen/Blog/blob/master/article/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md<i class="fa fa-external-link-alt"></i></span><br>《深入探索 C++对象模型》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接装载与库（五）动态链接</title>
      <link href="/next/2021/Program/LinksAndLibrariesPart5/"/>
      <url>/next/2021/Program/LinksAndLibrariesPart5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/DynamicLinks.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxNDUwMjU2NTNiYjA3NGIxZDU3NjE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="为什么要动态链接">为什么要动态链接</h1><ul><li><p>内存和磁盘空间： /usr/bin 下就有数千个可执行文件，还有其他数以千计的库如果都需要静态链接，那么空间浪费无法想象</p></li><li><p>程序开发和发布： 一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户</p></li><li><p>程序可扩展性和兼容性： 动态链接还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库</p></li><li><p>存在的问题： 当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原有的程序无法运行</p></li></ul><h1 id="简单的动态链接例子">简单的动态链接例子</h1><p>我们分别需要如下几个源文件：“Program1.c”、“Program2.c”、“Lib.c”和“Lib.h”。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">清单 <span class="number">7</span><span class="number">-1</span> SimpleDynamicalLinking</span><br><span class="line"><span class="comment">/*Program1.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    foobar(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Program2.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    foobar(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Lib.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span> <span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Printing from Lib.so d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Lib.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>程序很简单，两个程序的主要模块 Program1.c 和 Program2.c 分别调用了 Lib.c 里面的 foobar() 函数。然后我们使用 GCC 将 Lib.c 编译成一个共享对象文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so Lib.c</span><br></pre></td></tr></tbody></table></figure><p>上面 GCC 命令中的参数“-shared”表示产生共享对象。这时候我们得到了一个 Lib.so 文件，这就是包含了 Lib.c 的 foobar() 函数的共享对象文件。然后我们分别编译链接 Program1.c 和 Program2.c：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o Program1 Program1.c ./Lib.so</span><br><span class="line">gcc -o Program2 Program2.c ./Lib.so</span><br></pre></td></tr></tbody></table></figure><p>这样我们得到了两个程序 Program1 和 Program2，这两个程序都使用了 Lib.so 里面的 foobar() 函数。从 Program1 的角度看，整个编译和链接过程如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/dl3.png"></p><p><strong>关于模块（Module）</strong></p><p>在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件（Program1）和程序所依赖的共享对象（Lib.so），很多时候我们也把这些部分称为模块。</p><p>当链接器将 Program1.o 链接成可执行文件时，这时候链接器必须确定 Program1.o 中所引用的 foobar() 函数的性质。如果 foobar() 是一个静态目标模块中的函数，将 Program1.o 中的 foobar 地址引用重定位：如果 foobar() 是一个定义在某个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行。</p><p>那么这里就有个问题，链接器如何知道 foobar 的引用是一个静态符号还是一个动态符号？这实际上就是我们要用到 Lib.so 的原因。Lib.so 中保存了完整的符号信息，把 Lib.o 也作为链接的输入文件之一，链接器在解析符号时就可以知道：foobar 是一个定义在 Lib.so 的动态符号。这样链接器就可以对 foobar 的引用做特殊的处理，使它成为一个对动态符号的引用。</p><p><strong>动态链接程序运行时地址空间分布</strong></p><p>我们还是以上面的 Program1 为例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Printing from Lib.so &amp;d\n"</span>,i);</span><br><span class="line">    sleep(<span class="number">-1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后就可以查看进程的虚拟地址空间分布： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/dl4.png"></p><p>Lib.so 与 Program1 一样，它们都是被操作系统用同样的方法映射至进程的虚拟地址空间，只是它们占据的虚拟地址和长度不同。Program1 除了使用 Lib.so 以外，它还用到了动态链接形式的 C 语言运行库 libc-2.6.1.so。另外还有一个很值得关注的共享对象就是 ld-2.6.so，它实际上是 Linux 下的动态链接器。动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行 Program1 之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给 Program1。</p><p>我们通过 readelf 工具来查看 Lib.so 的装载属性：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">readelf -1 Lib.so</span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x390</span><br><span class="line">There are 4 program headers,starting at offset 52</span><br><span class="line">Program Headers:</span><br><span class="line">Type        offset  VirtAddr    PhysAddrFilesiz MemSiz  Flg       Align</span><br><span class="line">LOAD        0x000000 0x00000000 0x00000000      0x004e0 0x004e0RE 0×1000</span><br><span class="line">LOAD        0x0004e0 0x000014e0 0x000014e0      0x0010c 0x00110RW 0x1000</span><br><span class="line">DYNAMIC     0x0004f4 0x000014f4 0x000014f4      0x000c8 0x000c8RW 0x4</span><br><span class="line">GNU_STACK   0x000000 0×00000000 0×00000000      0x00000 0x00000RW 0×4</span><br><span class="line"></span><br><span class="line">Section to Segment mapping:</span><br><span class="line">  Segment Sections..</span><br><span class="line">00 .<span class="built_in">hash</span> .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn</span><br><span class="line">   .rel.plt .init .plt .text .fini</span><br><span class="line">01 .ctors .dtors .jcr .dynamic .got .got.plt .data .bss</span><br><span class="line">02 .dynamic</span><br><span class="line">03</span><br></pre></td></tr></tbody></table></figure><p>注意：动态链接模块的装载地址是从地址 0x00000000 开始的。我们知道这是无效地址，并且从上面的进程虚拟空间分布看到，Lib.so 的最终装载地址并不是 0x00000000，从这一点我们可以推断，共享对象的最终装载地址在编译时是不确定的，而是在装载时动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p><h1 id="地址无关代码">地址无关代码</h1><h2 id="固定装载地址的困扰">固定装载地址的困扰</h2><p>如果不同的模块目标装载地址不一样是不行的，我们设想是否可以让共享对象在任意地址加载？</p><h2 id="装载时重定位">装载时重定位</h2><p>在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。我们前面在静态链接时提到过重定位，那时的重定位叫做链接时重定位（Link Time Relocation），而现在这种情况经常被称为装载时重定位（Load Time Relocation）。</p><p>但是动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的。当然，动态连接库中的可修改数据部分对于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。</p><h2 id="地址无关代码-1">地址无关代码</h2><p>其实我们的目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC，Position-independent Code）的技术。</p><p>产生地址无关的代码并不麻烦。主要分如下四种情况：</p><ul><li>第一种是模块内部的函数调用、跳转等都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</li><li>第二种是模块内部的数据访问、比如模块中定义的全局变量、静态变量。现代的体系结构中，数据的相对寻址往往没有相对与当前指令地址（PC）的寻址方式，所以 ELF 用了一个很巧妙的办法来得到当前的 PC 值，然后再加上一个偏移量就可以达到访问相应变量的目的了。</li><li>第三种是模块外部的数据访问、比如其他模块中定义的全局变量。ELF 的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用。</li><li>第四种是模块外部的函数调用、跳转等。GOT 中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过 GOT 中的项进行间接跳转。</li></ul><h2 id="共享模块的全局变量问题">共享模块的全局变量问题</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global:</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    global = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当编译器编译 module.c 时，它无法判断 global 是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中。</p><p>假设 module.c 是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码，它引用这个全局变量的方式跟普通数据访问方式一样，编译器会产生这样的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl $Ox1,XXXXXXXX</span><br></pre></td></tr></tbody></table></figure><p>XXXXXXXX 就是 global 的地址。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个 global 变量的副本。那么问题就很明显了，现在 global 变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。</p><p>于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF 共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过 GOT 来实现变量的访问。</p><h1 id="延迟绑定plt">延迟绑定（PLT）</h1><p>动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。据统计 ELF 程序在静态链接下要比动态库稍微快点，大约为 1%~5%。我们知道动态链接比静态链接慢的主要原因是动态链接下对于全局和静态的数据访问都要进行复杂的 GOT 定位，然后间接寻址；对于模块间的调用也要先定位 GOT，然后再进行间接跳转。另外一个减慢运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作。</p><p><strong>延迟绑定实现</strong></p><p>在动态链接下，如果一开始就把所有函数都链接好实际上是一种浪费。所以 ELF 采用了一种叫做延迟绑定（Lay Binding）的做法，基本的思想就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。</p><p>PLT 在 ELF 文件中以独立的段存放，段名通常叫做“.plt”，因为它本身是一些地址无关的代码，所以可以跟代码段等一起合并成同一个可读可执行的“Segment”被装载入内存。</p><h1 id="动态链接相关段">动态链接相关段</h1><h2 id="interp-段">.interp 段</h2><p>实际上，动态链接器的位置既不是由系统配置指定，也不是由环境参数决定，而是由 ELF 可执行文件决定。在动态链接的 ELF 可执行文件中，有一个专门的段叫做“.interp”段。“.interp”内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objdump -s a.out</span><br><span class="line">a.out:  file format elf32-i386</span><br><span class="line">Contents of section .interp:</span><br><span class="line">    8048114 2f6c6962 2f6c642d 6c696e75 782e736f /lib/ld-1inux.so</span><br><span class="line">    8048124 2e3200</span><br><span class="line">.2.</span><br></pre></td></tr></tbody></table></figure><p>“.interp”的内容很简单，里面保存的就是一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径，在 Linux 下，可执行文件所需要的动态链接器的路径几乎都是“/lib/ld-linux.so.2”。</p><h2 id="dynamic-段">.dynamic 段</h2><p>动态链接 ELF 中最重要的结构应该是“.dynamic”段，这个段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p><h2 id="dynsym-段动态符号表">.dynsym 段（动态符号表）</h2><p>为了表示动态链接这些模块之间的符号导入导出关系，ELF 专门有一个叫做动态符号表（Dynamic Symbol Table）的段用来保存这些信息，这个段的段名通常叫做“.dynsym”（Dynamic Symbol）。与静态链接中的符号表“.symtab”不同的是，“.dynsym”只保存了与动态链接相关的符号。</p><p>与“.symtab”类似，动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表。静态链接时叫做符号字符串表“.strtab”（String Table），在这里就是动态符号字符串表“.dynstr”（Dynamic String Table）；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（“.hash”）。我们可以用 readelf 工具来查看 ELF 文件的动态符号表及它的哈希表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -sD Lib.so</span><br></pre></td></tr></tbody></table></figure><h2 id="动态链接重定位表">动态链接重定位表</h2><p>对于使用 PIC 技术的可执行文件或共享对象来说，虽然它们的代码段不需要重定位（因为地址无关），但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离了出来，变成了 GOT，而 GOT 实际上是数据段的一部分。除了 GOT 以外，数据段还可能包含绝对地址引用。</p><p>在静态链接中，目标文件里面包含有专门用于表示重定位信息的重定位表，比如“.rela.text”表示是代码段的重定位表，“.rela.data”是数据段的重定位表。动态链接的文件中，也有类似的重定位表分别叫做“.rela.dyn”和“.rela.plt'”。“.rela.dyn”实际上是对数据引用的修正，它所修正的位置位于“.got”以及数据段；而“.rela.plt”是对函数引用的修正，它所修正的位置位于“.got.plt”。</p><h1 id="动态链接的步骤和实现">动态链接的步骤和实现</h1><ul><li>首先操作系统会读取可执行文件的头部，检查文件的合法性，然后从头部中的“Program Header”中读取每个“Segment”的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置。</li><li>对于静态链接。 操作系统接着就可以把控制权转交给可执行文件的入口地址，然后程序开始执行，一切看起来非常直观</li><li>对于动态链接。<ul><li>可执行文件里对于很多外部符号的引用还处于无效地址的状态。所以在映射完可执行文件之后，操作系统会先启动一个动态链接器（Dynamic Linker）</li><li>将控制权交给动态链接器的入口地址，执行一系列自身的初始化操作，开始对可执行文件进行动态链接工作</li><li>当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行</li></ul></li></ul><h2 id="动态链接器自举">动态链接器自举</h2><p>我们知道动态链接器本身也是一个共享对象，但是事实上它有一些特殊性。对于普通共享对象文件来说，它的重定位工作由动态链接器来完成。可是对于动态链接器本身来说，它的重定位工作由谁来完成？动态链接器必须有些特殊性。</p><ul><li>首先是，动态链接器本身不可以依赖于其他任何共享对象。</li><li>其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。</li></ul><p>对于第一个条件我们可以人为地控制，在编写动态链接器时保证不使用任何系统库、运行库；对于第二个条件，动态链接器必须在启动时有一段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为自举（Bootstrap）。</p><p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的 GOT。而 GOT 的第一个入口保存的即是“.dynamic”段的偏移地址，由此找到了动态连接器本身的“.dynamic”段。通过“.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用白己的全局变量和静态变量。</p><p>实际上在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。其实我们在前面分析地址无关代码时已经提到过，实际上使用 PIC 模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，即使用 GOT/PLT 的方式，所以在 GOT/PLT 没有被重定位之前，自举代码不可以使用任何全局变量，也不可以调用函数。</p><h2 id="装载共享对象">装载共享对象</h2><p>完成基本自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中，我们可以称它为全局符号表（Global Symbol Table）。然后链接器开始寻找可执行文件所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取一个所需要的共享对象的名字，找到相应的文件后打开该文件，读取相应的 ELF 文件头和“.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个 ELF 共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来为止。</p><p><strong>符号的优先级</strong></p><p>在动态链接器按照各个模块之间的依赖关系，对它们进行装载并且将它们的符号并入到全局符号表时，会不会有这么一种情况发生，那就是有可能两个不同的模块定义了同一个符号？一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象被称为共享对象全局符号介入（Global Symbol Interpose）。</p><p>关于全局符号介入这个问题，实际上 Linux 下的动态链接器是这样处理的：它定义了一个规则，那就是当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。</p><p><strong>全局符号介入与地址无关代码</strong></p><p>前面介绍地址无关代码时，对于第一类模块内部调用或跳转的处理时，我们简单地将其当作是相对地址调用/跳转。但实际上这个问题比想象中要复杂，结合全局符号介入，关于调用方式的分类的解释会更加清楚。还是拿前面“pic.c”的例子来看，由于可能存在全局符号介入的问题，foo() 函数对于 bar() 的调用不能够采用第一类模块内部调用的方法，因为一旦 bar 函数由于全局符号介入被其他模块中的同名函数覆盖，那么 foo 如果采用相对地址调用的话，那个相对地址部分就需要重定位，这又与共享对象的地址无关性矛盾。所以对于 bar() 函数的调用，编译器只能采用第三种，即当作模块外部符号处理，bar() 函数被覆盖，动态链接器只需要重定位“.got.plt”，不影响共享对象的代码段。 为了提高模块内部函数调用的效率，有一个办法是把 bar() 函数变成编译单元私有函数，即使用“static”关键字定义 bar() 函数，这种情况下，编译器要确定 bar() 函数不被其他模块覆盖，就可以使用第一类的方法，即模块内部调用指令，可以加快函数的调用速度。</p><h2 id="重定位和初始化">重定位和初始化</h2><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的 GOT/PLT 中的每个需要重定位的位置进行修正。此时动态链接器已经拥有了进程的全局符号表，这里就不再重复介绍了。</p><p>重定位完成之后，如果某个共享对象有“.init”段，那么动态链接器会执行“.init”段中的代码，用以实现共享对象特有的初始化过程，比如最常见的，共享对象中的 C++的全局/静态对象的构造就需要通过“.init”来初始化。相应地，共享对象中还可能有“.finit”段，当进程退出时会执行“.finit'”段中的代码，可以用来实现类似 C++全局对象析构之类的操作。</p><p>如果进程的可执行文件也有“.init”段，那么动态链接器不会执行它，因为可执行文件中的“.init”段和“.finit'”段由程序初始化部分代码负责执行。</p><p>当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器将进程的控制权转交给程序的入口并且开始执行。</p><h1 id="linux-动态链接器实现">Linux 动态链接器实现</h1><p>关于动态链接器的实现的几个问题还是很值得思考的：</p><ul><li><p>动态链接器本身是动态链接的还是静态链接的？ 动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身是用来帮助其他 ELF 文件解决共享对象依赖问题的，如果它也依赖于其他共享对象，那么谁来帮它解决依赖问题？所以它本身必须不依赖于其他共享对象。这一点可以使用 ldd 来判断： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd /lib/ld-linux.so.2</span><br><span class="line">statically linked</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>动态链接器本身必须是 PIC 的吗？ 是不是 PIC 对于动态链接器来说并不关键，动态链接器可以是 PIC 的也可以不是，但往往使用 PIC 会更加简单一些。一方面，如果不是 PIC 的话，会使得代码段无法共享，浪费内存；另一方面也会使 ld.so 本身初始化更加复杂，因为自举时还需要对代码段进行重定位。实际上的 ld-linux.so.2 是 PIC 的</p></li><li><p>动态链接器可以被当作可执行文件运行，那么他的装载地址应该是多少？ ld.so 的装载地址跟一般的共享对象没区别，即为 0x00000000。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址</p></li></ul><h1 id="显式运行时链接">显式运行时链接</h1><p>显式运行时链接（Explicit Run-time Linking）有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以将其卸载。这种共享对象往往被叫做动态装载库（Dynamic Loading Library），其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。</p><h1 id="参考文献">参考文献</h1><p>《程序员的自我修养》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Links Libraries </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接装载与库（四）可执行文件的装载与进程</title>
      <link href="/next/2021/Program/LinksAndLibrariesPart4/"/>
      <url>/next/2021/Program/LinksAndLibrariesPart4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/LoadingAndProcessingOfExecutableFiles.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMwYTZlNzA3OTEyOTA3YzI4NjNmZmM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="装载的方式">装载的方式</h1><p>程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这就是最简单的静态装入的办法。后来研究发现，程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><h2 id="页映射">页映射</h2><p>将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p><p>为了演示页映射的基本机制，假设我们的 32 位机器有 16KB 的内存，每个页大小为 4096 字节，则共有 4 个页，如下表所示。</p><table><thead><tr class="header"><th>页编号</th><th>地址</th></tr></thead><tbody><tr class="odd"><td>F0</td><td>0x00000000 - 0xFFFFF000</td></tr><tr class="even"><td>F1</td><td>0x00001000 - 0x00001FFF</td></tr><tr class="odd"><td>F2</td><td>0X00002000 - 0X00002FFF</td></tr><tr class="even"><td>F3</td><td>0X00003000 - 0X00003FFF</td></tr></tbody></table><p>假设程序所有的指令和数据总和为 32KB，那么程序总共被分为 8 个页。我们将它们编号为 P0~P7。很明显，16KB 的内存无法同时将 32KB 的程序装入，那么我们将按照动态装入的原理来进行整个装入过程。如果程序刚开始执行时的入口地址在 P0，这时装载管理器发现程序的 P0 不在内存中，于是将内存 F0 分配给 P0，并且将 P0 的内容装入 F0；运行一段时间以后，程序需要用到 P5，于是装载管理器将 P5 装入 F1；就这样，当程序用到 P3 和 P6 的时候，它们分别被装入到了 F2 和 F3，它们的映射关系如图 6-4 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load4.png"></p><p>很明显，如果这时候程序只需要 P0、P3、P5 和 P6 这 4 个页，那么程序就能一直运行下去。但是问题很明显，如果这时候程序需要访问 P4，那么装载管理器必须做出抉择，它必须放弃目前正在使用的 4 个内存页中的其中一个来装载 P4。至于选择哪个页，我们有很多种算法可以选择，比如可以选择 F0，因为它是第一个被分配掉的内存页（这个算法我们可以称之为 FIFO，先进先出算法）：假设装载管理器发现 F2 很少被访问到，那么我们可以选择 F2（这种算法可以称之为 LUR，最少使用算法）。</p><h1 id="从操作系统角度看可执行文件的装载">从操作系统角度看可执行文件的装载</h1><h2 id="进程的建立">进程的建立</h2><p>创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间，建立虚拟空间到物理空间的映射关系。创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</li><li>读取可执行文件头，建立虚拟空间与可执行文件的映射关系，是传统意义上“装载”的过程。</li><li>将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU 运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。还记得 ELF 文件头中保存有入口地址吗？没错，就是这个地址。</li></ul><p>让我们考虑最简单的情况，假设我们的 ELF 可执行文件只有一个代码段“.text“，它的虚拟地址为 0x08048000，它在文件中的大小为 0x000e1，对齐为 0x1000。一旦该可执行文件被装载，可执行文件与执行该可执行文件进程的虚拟空间的映射关系如图 6-5 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load5.png"></p><p>很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux 中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。比如上例中，操作系统创建进程后，会在进程相应的数据结构中设置有一个。text 段的 VMA：它在虚拟空间中的地址为 0x08048000~0x08049000，它对应 ELF 文件中偏移为 0 的。text，它的属性为只读（一般代码段都是只读的）。</p><h2 id="页错误">页错误</h2><p>上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。假设在上面的例子中，程序的入口地址为 0x08048000，即刚好是。text 段的起始地址。当 CPU 开始打算执行这个地址的指令时，发现页面 0x08048000~0x08049000 是个空页面，于是它就认为这是一个页错误（Page Fault）。CPU 将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。这时候我们前面提到的装载过程的第二步建立的数据结构起到了很关键的作用，操作系统将查询这个数据结构，然后找到空页面所在的 VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。</p><p>随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求，如图 6-6 所示。当然有可能进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候应将分配给进程的物理内存暂时收回等，这就涉及了操作系统的虚拟存储管理。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load6.png"></p><h1 id="进程虚存空间分布">进程虚存空间分布</h1><h2 id="elf-文件链接视图和执行视图">ELF 文件链接视图和执行视图</h2><p>当段的数量增多时，就会产生空间浪费的问题。当我们站在操作系统装载可执行文件的角度看问题时，可以发现它实际上并不关心可执行文件各个段所包含的实际内容，只关心一些跟装载相关的问题，最主要的是段的权限（可读、可写、可执行）。基本上是三种：</p><ul><li>以代码段为代表的权限为可读可执行的段。</li><li>以数据段和 BSS 段为代表的权限为可读可写的段。</li><li>以只读数据段为代表的权限为只读的段。</li></ul><p>那么我们可以找到一个很简单的方案就是：对于相同权限的段，把它们合并到一起当作一个段进行映射。比如有两个段分别叫“.text”和“.init”，它们包含的分别是程序的可执行代码和初始化代码，并且它们的权限相同，都是可读并且可执行的。假设。text 为 4097 字节，.init 为 512 字节，这两个段分别映射的话就要占用三个页面，但是，如果将它们合并成一起映射的话只须占用两个页面，如图 6-7 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load7.png"></p><p>ELF 可执行文件引入了一个概念叫做“Segment”，一个“Segment”包含一个或多个属性类似的“Section”。正如我们上面的例子中看到的，如果将“.text”段和“.init”段合并在一起看作是一个“Segment'”，那么装载的时候就可以将它们看作一个整体一起映射，也就是说映射以后在进程虚存空间中只有一个相对应的 VMA，而不是两个，这样做的好处是可以很明显地减少页面内部碎片，从而节省了内存空间。</p><blockquote><p>从链接的角度看，ELF 文件是按“Section”存储的，事实也的确如此；从装载的角度看，ELF 文件又可以按照“Segment”划分。</p></blockquote><p>“Segment'”的概念实际上是从装载的角度重新划分了 ELF 的各个段。而系统正是按照、“Segment”而不是“Section”来映射可执行文件的。下面的例子是一个很小的程序，程序本身是不停地循环执行“sleep”操作，除非用户发信号给它，否则就一直运行。它的源代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们使用静态连接的方式将其编译连接成可执行文件，然后得到的可执行文件“SectionMapping.elf”是一个 Linux 下很典型的可执行文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gcc</span> -static SectionMapping.c -o SectionMapping.elf</span><br></pre></td></tr></tbody></table></figure><p>使用 readelf 可以看到，这个可执行文件中总共有 32 个段（Section）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -S SectionMapping.elf</span><br><span class="line">There are 32 section headers, starting at offset 0xd4588:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.propert NOTE             0000000000400270  00000270</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 2] .note.gnu.build-i NOTE             0000000000400290  00000290</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.ABI-tag     NOTE             00000000004002b4  000002b4</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .rela.plt         RELA             00000000004002d8  000002d8</span><br><span class="line">       0000000000000240  0000000000000018  AI       0    20     8</span><br><span class="line">  [ 5] .init             PROGBITS         0000000000401000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 6] .plt              PROGBITS         0000000000401020  00001020</span><br><span class="line">       0000000000000180  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 7] .text             PROGBITS         00000000004011a0  000011a0</span><br><span class="line">       00000000000919a0  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 8] __libc_freeres_fn PROGBITS         0000000000492b40  00092b40</span><br><span class="line">       0000000000001ca0  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 9] .fini             PROGBITS         00000000004947e0  000947e0</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [10] .rodata           PROGBITS         0000000000495000  00095000</span><br><span class="line">       000000000001bfcc  0000000000000000   A       0     0     32</span><br><span class="line">  [11] .stapsdt.base     PROGBITS         00000000004b0fcc  000b0fcc</span><br><span class="line">       0000000000000001  0000000000000000   A       0     0     1</span><br><span class="line">  [12] .eh_frame         PROGBITS         00000000004b0fd0  000b0fd0</span><br><span class="line">       000000000000a5d4  0000000000000000   A       0     0     8</span><br><span class="line">  [13] .gcc_except_table PROGBITS         00000000004bb5a4  000bb5a4</span><br><span class="line">       00000000000000b1  0000000000000000   A       0     0     1</span><br><span class="line">  [14] .tdata            PROGBITS         00000000004bd0c0  000bc0c0</span><br><span class="line">       0000000000000020  0000000000000000 WAT       0     0     8</span><br><span class="line">  [15] .tbss             NOBITS           00000000004bd0e0  000bc0e0</span><br><span class="line">       0000000000000040  0000000000000000 WAT       0     0     8</span><br><span class="line">  [16] .init_array       INIT_ARRAY       00000000004bd0e0  000bc0e0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY       00000000004bd0f0  000bc0f0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .data.rel.ro      PROGBITS         00000000004bd100  000bc100</span><br><span class="line">       0000000000002df4  0000000000000000  WA       0     0     32</span><br><span class="line">  [19] .got              PROGBITS         00000000004bfef8  000beef8</span><br><span class="line">       00000000000000f0  0000000000000000  WA       0     0     8</span><br><span class="line">  [20] .got.plt          PROGBITS         00000000004c0000  000bf000</span><br><span class="line">       00000000000000d8  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .data             PROGBITS         00000000004c00e0  000bf0e0</span><br><span class="line">       0000000000001a50  0000000000000000  WA       0     0     32</span><br><span class="line">  [22] __libc_subfreeres PROGBITS         00000000004c1b30  000c0b30</span><br><span class="line">       0000000000000048  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] __libc_IO_vtables PROGBITS         00000000004c1b80  000c0b80</span><br><span class="line">       00000000000006a8  0000000000000000  WA       0     0     32</span><br><span class="line">  [24] __libc_atexit     PROGBITS         00000000004c2228  000c1228</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [25] .bss              NOBITS           00000000004c2240  000c1230</span><br><span class="line">       0000000000001718  0000000000000000  WA       0     0     32</span><br><span class="line">  [26] __libc_freeres_pt NOBITS           00000000004c3958  000c1230</span><br><span class="line">       0000000000000028  0000000000000000  WA       0     0     8</span><br><span class="line">  [27] .comment          PROGBITS         0000000000000000  000c1230</span><br><span class="line">       000000000000002a  0000000000000001  MS       0     0     1</span><br><span class="line">  [28] .note.stapsdt     NOTE             0000000000000000  000c125c</span><br><span class="line">       00000000000013e8  0000000000000000           0     0     4</span><br><span class="line">  [29] .symtab           SYMTAB           0000000000000000  000c2648</span><br><span class="line">       000000000000af68  0000000000000018          30   734     8</span><br><span class="line">  [30] .strtab           STRTAB           0000000000000000  000cd5b0</span><br><span class="line">       0000000000006e81  0000000000000000           0     0     1</span><br><span class="line">  [31] .shstrtab         STRTAB           0000000000000000  000d4431</span><br><span class="line">       0000000000000157  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure><p>我们可以使用 readelf 命令来查看 ELF 的“Segment”。正如描述“Section”属性的结构叫做段表，描述“Segment'”的结构叫程序头（Program Header），它描述了 ELF 文件该如何被操作系统映射到进程的虚拟空间：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -l SectionMapping.elf</span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is EXEC (Executable file)</span><br><span class="line">Entry point 0x401bc0</span><br><span class="line">There are 10 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000518 0x0000000000000518  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000</span><br><span class="line">                 0x00000000000937ed 0x00000000000937ed  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000</span><br><span class="line">                 0x0000000000026655 0x0000000000026655  R      0x1000</span><br><span class="line">  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000005170 0x00000000000068c0  RW     0x1000</span><br><span class="line">  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000000020 0x0000000000000060  R      0x8</span><br><span class="line">  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0</span><br><span class="line">                 0x0000000000002f40 0x0000000000002f40  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt</span><br><span class="line">   01     .init .plt .text __libc_freeres_fn .fini</span><br><span class="line">   02     .rodata .stapsdt.base .eh_frame .gcc_except_table</span><br><span class="line">   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs</span><br><span class="line">   04     .note.gnu.property</span><br><span class="line">   05     .note.gnu.build-id .note.ABI-tag</span><br><span class="line">   06     .tdata .tbss</span><br><span class="line">   07     .note.gnu.property</span><br><span class="line">   08</span><br><span class="line">   09     .tdata .init_array .fini_array .data.rel.ro .got</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到，这个可执行文件中共有 10 个 Segment。从装载的角度看，我们目前只关心两个“LOAD”类型的 Segment，因为只有它是需要被映射的，其他的诸如“NOTE”、“TLS”、“GNU_STACK”都是在装载时起辅助作用的，我们在这里不详细展开。可以用图 6-8 来表示“SectionMapping.elf”可执行文件的段与进程虚拟空间的映射关系。</p><p>“SectionMapping.elf”被重新划分成了三个部分，有一些段被归入可读可执行的，它们被统一映射到一个 VMA0；另外一部分段是可读可写的，它们被映射到了 VMA1；还有一部分段在程序装载时没有被映射的，它们是一些包含调试信息和字符串表等段，这些段在程序执行时没有用，所以不需要被映射。很明显，所有相同属性的“Section”被归类到一个“Segment”，并且映射到同一个 VMA。</p><p>所以总的来说，“Segment”和“Section”是从不同的角度来划分同一个 ELF 文件。这个在 ELF 中被称为不同的视图（View），从“Section”的角度来看 ELF 文件就是链接视图（Linking View），从“Segment”的角度来看就是执行视图（Execution View）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load8.png"></p><h2 id="堆和栈">堆和栈</h2><p>在操作系统里面，VMA 除了被用来映射可执行文件中的各个“Segment'”以外，它还可以有其他的作用，操作系统通过使用 VMA 来对进程的地址空间进行管理。我们知道进程在执行的时候它还需要用到栈（Stack）、堆（Heap）等空间，事实上它们在进程的虚拟空间中的表现也是以 VMA 的形式存在的，很多情况下，一个进程中的栈和堆分别都有一个对应的 VMA。在 Linux 下，我们可以通过查看“/proc”来查看进程的虚拟空间分布：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./SectionMapping.elf &amp;</span><br><span class="line">[1]21963</span><br><span class="line">$ <span class="built_in">cat</span> /proc/21963/maps</span><br><span class="line">08048000-080b9000   r-xp    00000000    08:01   2801887 ./SectionMapping.elf</span><br><span class="line">080b9000-080bb000   rwxp    00070000    08:01   2801887 ./SectionMapping.elf</span><br><span class="line">080bb000-080de000   rwxp    080bb000    00:00   0       [heap]</span><br><span class="line">bf7ec000-bf802000   rw-p    bf7ec0000   00:00   0       [stack]</span><br><span class="line">ffffe000-fffff000   r-xp0   000000000:0 00:00   0       [vdso]</span><br></pre></td></tr></tbody></table></figure><p>上面的输出结果中：</p><ul><li>第一列是 VMA 的地址范围。</li><li>第二列是 VMA 的权限，“r”表示可读，“w”表示可写，“x”表示可执行，“p”表示私有（COW，Copy on Write），“s"表示共享。</li><li>第三列是偏移，表示 VMA 对应的 Segment 在映像文件中的偏移。</li><li>第四列表示映像文件所在设备的主设备号和次设备号。</li><li>第五列表示映像文件的节点号。</li><li>最后一列是映像文件的路径。</li></ul><blockquote><p>我们可以看到进程中有 5 个 VMA，只有前两个是映射到可执行文件中的两个 Segment。另外三个段的文件所在设备主设备号和次设备号及文件节点号都是 0，则表示它们没有映射到文件中，这种 VMA 叫做匿名虚拟内存区域（Anonymous Virtual Memory Area）。</p></blockquote><p>另外有一个很特殊的 VMA 叫做“vdso”，它的地址己经位于内核空间了（即大于 0xC0000000 的地址），事实上它是一个内核的模块，进程可以通过访问这个 VMA 来跟内核进行一些通信。</p><p>通过上面的例子，让我们小结关于进程虚拟地址空间的概念：操作系统通过给进程空间划分出一个个 VMA 来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个 VMA；一个进程基本上可以分为如下几种 VMA 区域：</p><ul><li>代码 VMA，权限只读、可执行；有映像文件。</li><li>数据 VMA，权限可读写、可执行；有映像文件。</li><li>堆 VMA，权限可读写、可执行：无映像文件，匿名，可向上扩展。</li><li>栈 VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。</li></ul><p>当我们在讨论进程虚拟空间的“Segment”的时候，基本上就是指上面的几种 VMA。现在再让我们来看一个常见进程的虚拟空间是怎么样的，如图 6-9 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/load9.png"></p><h2 id="段地址对齐">段地址对齐</h2><p>如果有很多段的大小很小，按照 page 对齐映射会造成空间的浪费，为了解决这种问题，有些 UNIX 系统采用了一个很取巧的办法，就是让那些各个段接壤部分共享一个物理页面，然后将该物理页面分别映射多次。</p><h1 id="linux-内核装载-elf-过程简介">Linux 内核装载 ELF 过程简介</h1><p>当我们在 Linux 系统的 bash 下输入一个命令执行某个 ELF 程序时，Linux 系统是怎样装载这个 ELF 文件并且执行它的呢？ 首先在用户层面，bash 进程会调用 fork() 系统调用创建一个新的进程，然后新的进程调用 execve() 系统调用执行指定的 ELF 文件，原先的 bash 进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"minibashs"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"s"</span>,buf);</span><br><span class="line">        pid <span class="title function_">fork</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(pid =<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span>(execlp(buf,<span class="number">0</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"exec error\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt;<span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fork error &amp;d\n"</span>,pid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在进入 execve() 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，execve() 系统调用相应的入口是 sys_execve()，进行一些参数的检查复制之后，调用 do_execve()。do_execve() 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。(Linux 支持的可执行文件不止 ELF 一种，还有 a.out、Java 程序和以“#！”开始的脚本程序）。</p><p>当 do_execve() 读取了这 128 个字节的文件头部之后，然后调用 search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程。Linux 中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handle() 会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如 ELF 可执行文件的装载处理过程叫做 load_elf_binary()；a.out 可执行文件的装载处理过程叫做 load_aout_binary()；而装载可执行脚本程序的处理过程叫做 load_script()。这里我们只关心 ELF 可执行文件的装载，load_elf_binary()，这个函数的代码比较长，它的主要步骤是：</p><ul><li>检查 ELF 可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li><li>寻找动态链接的“.interp”段，设置动态链接器路径。</li><li>根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射，比如代码、数据、只读数据。</li><li>初始化 ELF 进程环境，比如进程启动时 EDX 寄存器的地址应该是 DT FINI 的地址。</li><li>将系统调用的返回地址修改成 ELF 可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的 ELF 可执行文件，这个程序入口就是 ELF 文件的文件头中 e_entry 所指的地址；对于动态链接的 ELF 可执行文件，程序入口点是动态链接器。</li></ul><p>当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时，上面的第 5 步中已经把系统调用的返回地址改成了被装载的 ELF 程序的入口地址了。所以当 sys_execve() 系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了 ELF 程序的入口地址，于是新的程序开始执行，ELF 可执行文件装载完成。</p><h1 id="参考文献">参考文献</h1><p>《程序员的自我修养》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Links Libraries </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接装载与库（三）静态链接</title>
      <link href="/next/2021/Program/LinksAndLibrariesPart3/"/>
      <url>/next/2021/Program/LinksAndLibrariesPart3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/Staticlinks.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMwODIzYWU0MDFmZDA3MjZiYTVjMzY=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>在这一节里，我们将使用下面这两个源代码文件“a.c”和“b.c”作为例子展开分析： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld1.png"></p><p>假设我们的程序只有这两个模块“a.c”和“b.c”。首先我们使用 gcc 将“a.c”和“b.c”分别编译成目标文件“a.o”和“b.o”：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c b.c</span><br></pre></td></tr></tbody></table></figure><p>从代码中可以看到，“b.c”总共定义了两个全局符号，一个是变量“shared”，另外一个是函数“swap”；“a.c”里面定义了一个全局符号就是“main”。模块“a.c”里面引用到了“b.c”里面的“swap”和“shared”。我们接下来要做的就是把“a.o”和“b.o”这两个目标文件链接在一起并最终形成一个可执行文件“ab”。</p><h1 id="空间与地址分配">空间与地址分配</h1><p>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？</p><h2 id="按序叠加">按序叠加</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld2.png"> 如图 4-1 所示，就是直接将各个目标文件依次合并，但是在有很多输入文件的情况下，输出文件将会有很多零散的段，这种做法非常浪费空间，因为每个段都须要有一定的地址和空间对齐要求。</p><h2 id="相似段合并">相似段合并</h2><p>一个更实际的方法是将相同性质的段合并到一起，比如将所有输入文件的“.text”合并到输出文件的“.text”段，接着是“.data”段、“.bss”段等，如图 4-2 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld3.png"></p><blockquote><p>对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p></blockquote><p>使用这种方法的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法，也就是说整个链接过程分两步。</p><ul><li>第一步空间与地址分配扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。</li><li>第二步符号解析与重定位使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等（核心）。</li></ul><p>我们使用 ld 链接器将“a.o”和“b.o”链接起来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ld</span> a.o b.o -e main -o ab</span><br></pre></td></tr></tbody></table></figure><ul><li>-e main 表示将 main 函数作为程序入口，ld 链接器默认的程序入口为_start。</li><li>-o ab 表示链接输出文件名为 ab，默认为 a.out。</li></ul><p>让我们使用 objdump 来查看链接前后地址的分配情况，代码如清单 4-1 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld4.png"></p><blockquote><p>VMA 表示 Virtual Memory Address，即虚拟地址，LMA 表示 Load Memory Address，即加载地址。</p></blockquote><p>在链接之前，目标文件中的所有段的 VMA 都是 O，因为虚拟空间还没有被分配，等到链接之后，可执行文件“b”中的各个段都被分配到了相应的虚拟地址。这里的输出程序“ab”中，“.text”段被分配到了地址 0x08048094，大小为 0x72 字节；“.data”段从地址 0x08049108 开始，大小为 4 字节。如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld5.png"></p><p>为什么链接器要将可执行文件“ab”的“.text”分配到 0x08048094、将“.data”分配 0x08049108？而不是从虚拟空间的 0 地址开始分配呢？这涉及操作系统的进程虚拟地址空间的分配规则，在 Linux 下，ELF 可执行文件默认从地址 0x08048000 开始分配。</p><h2 id="符号地址的确定">符号地址的确定</h2><p>因为各个符号在段内的相对位置是固定的，所以这时候其实“main”、“shared”和“swap”的地址也已经是确定的了，只不过链接器须要给每个符号加上一个偏移量，使它们能够调整到正确的虚拟地址。比如我们假设“a.o”中的“main”函数相对于“a.o”的“.text”段的偏移是 X，但是经过链接合并以后，“a.o”的“.text”段位于虚拟地址 0x08048094，那么“main”的地址应该是 0x08048094+X。</p><h1 id="符号解析与重定位">符号解析与重定位</h1><h2 id="重定位">重定位</h2><p>使用 objdump 的“-d”参数可以看到“a.o”的代码段反汇编结果： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld6.png"></p><p>我们知道在程序的代码里面使用的都是虚拟地址，在这里也可以看到“main”的起始地址为 0×00000000，这是因为在未进行前面提到过的空间分配之前，目标文件代码段中的起始地址以 0x00000000 开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。</p><p>我们可以很清楚地看到“a.o”的反汇编结果中，“a.o”共定义了一个函数 main。最左边那列是每条指令的偏移量，每一行代表一条指令，我们已经用粗体标出了两个引用“shared”和“swap”的位置，对于“shared”的引用是一条“mov”指令，这条指令总共 8 个字节，它的作用是将“shared”的地址赋值到 ESP 寄存器+4 的偏移地址中去，前面 4 个字节是指令码，后面 4 个字节是“shared”的地址，我们只关心后面的 4 个字节部分，如图 4-4 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld7.png"></p><p>当源代码“a.c”在被编译成目标文件时，编译器并不知道“shared”和“swap”的地址。所以编译器就暂时把地址 O 看作是“shared”的地址，我们可以看到这条“mov”指令中，关于“shared”的地址部分为“0x00000000”。</p><p>另外一个是偏移为 0x26 的指令的一条调用指令，它其实就表示对 swap 函数的调用，如图 4-5 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld8.png"></p><p>这条指令共 5 个字节，前面的 0xE8 是操作码（Operation Code），这条指令是一条近址相对位移调用指令，后面 4 个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。在没有重定位之前，相对偏移被置为 0xFFFFFFFC（小端），它是常量“-4”的补码形式。</p><p>编译器把这两条指令的地址部分暂时用地址“0x00000000”和“0xFFFFFFFC”代替着，把真正的地址计算工作留给了链接器。我们用 objdump 来反汇编输出程序“ab”的代码段，可以看到 main 函数的两个重定位入口都已经被修正到止确的位置： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld9.png"></p><p>经过修正以后，“shared”和“swap”的地址分别为 0x08049108 和 0x00000009（小端字节序）。关于“shared”很好理解，因为“shared”变量的地址的确是 0x08049108。对于“swap”来说稍显晦涩。“call”指令的下一条指令是“add”，它的地址是 0x080480bf，所以“相对于 add 指令偏移量为 0x00000009”的地址为 0x080480bf+9=0x080480c8，即刚好是“swap”函数的地址。</p><blockquote><p>绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。</p></blockquote><h2 id="重定位表">重定位表</h2><p>那么链接器是怎么知道哪些指令是要被调整的呢？怎么调整？事实上在 ELF 文件中，有一个叫重定位表的结构专门用来保存这些与重定位相关的信息，它在 ELF 文件中往往是一个或多个段。</p><p>我们可以使用 objdump 来查看目标文件的重定位表： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld10.png"></p><p>每个要被重定位的地方叫一个重定位入口（Relocation Entry），我们可以看到“a.o”里面有两个重定位入口。重定位入口的偏移（Offset）表示该入口在要被重定位的段中的位置，“RELOCATION RECORDS FOR[.text]”表示这个重定位表是代码段的重定位表，所以偏移表示代码段中须要被调整的位置。</p><h2 id="符号解析">符号解析</h2><p>其实重定位过程也伴随着符号的解析过程。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器须要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。比如我们查看“a.o”的符号表： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld11.png"></p><p>“GLOBAL”类型的符号，除了“main”函数是定义在代码段之外，其他两个“shared”和“swap”都是“UND”，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p><h1 id="common-块">COMMON 块</h1><p>目前的链接器本身并不支持符号的类型，即变量类型对于链接器来说是透明的，它只知道一个符号的名字，并不知道类型是否一致。那么当我们定义的多个符号定义类型不一致时，链接器该如何处理呢？主要分三种情况：</p><ul><li>两个或两个以上强符号类型不一致，链接器会报符号多重定义错误。</li><li>有一个强符号，其他都是弱符号，出现类型不一致，最终输出结果中的符号所占空间与强符号相同。</li><li>两个或两个以上弱符号类型不一致，以占空间大的为准。</li></ul><p>事实上，现在的编译器和链接器都支持一种叫 COMMON 块（Common Block）的机制，当不同的目标文件需要的 COMMON 块空间大小不一致时，以最大的那块为准。</p><p>现在我们再回头总结性地思考关于未初始化的全局变量的问题：在目标文件中，编译器为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理，为它在 BSS 段分配空间，而是将其标记为一个 COMMON 类型的变量？</p><p>当编译器将一个编译单元编译成目标文件的时候，如果该编译单元包含了弱符号（未初始化的全局变量就是典型的弱符号），那么该弱符号最终所占空间的大小在此时是未知的，因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的空间要大。所以编译器此时无法为该弱符号在 BSS 段分配空间，因为所须要空间的大小未知。但是链接器在链接过程中可以确定弱符号的大小，所以它可以在最终输出文件的 BSS 段为其分配空间。所以总体来看，未初始化全局变量最终还是被放在 BSS 段的。</p><h1 id="c相关问题">C++相关问题</h1><p>C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作。最主要的有两个方面，一个是 C++的重复代码消除，还有一个就是全局构造与析构。</p><h2 id="重复代码消除">重复代码消除</h2><p>C++编译器在很多时候会产生重复的代码，比如模板（Templates）、外部内联函数（Extern Inline Function）和虚函数表（Virtual Function Table）都有可能在不同的编译单元里生成相同的代码。</p><p>一个比较有效的做法就是将每个模板的实例代码都单独地存放在一个段里，每个段只包含一个模板实例。比如有个模板函数是“add<t>()”，某个编译单元以 int 类型和 float 类型实例化了该模板函数，那么该编译单元的目标文件中就包含了两个该模板实例的段。我们假设这两个段的名字分别叫“.temp.add<int> ”和“.temp.add<float> ”。这样，当别的编译单元也以 int 或 float 类型实例化该模板函数后，也会生成同样的名字，这样链接器在最终链接的时候可以区分这些相同的模板实例段，然后将它们合并入最后的代码段。</float></int></t></p><p><strong>函数级别链接</strong> VISUAL C++编译器提供了一个编译选项叫函数级别链接（Functional-Level Linking），这个选项的作用就是让所有的函数都像前面模板函数一样，单独保存到一个段里面。当链接器须要用到某个函数时，它就将它合并到输出文件中，对于那些没有用的函数则将它们抛弃。这种做法可以很大程度上减小输出文件的长度，减少空间浪费。但是会增加编译时间。</p><p>GCC 编译器也提供了类似的机制，它有两个选择分别是“-ffunction-sections”和“-fdata-sections”，这两个选项的作用就是将每个函数或变量分别保持到独立的段中。</p><h2 id="全局构造与析构">全局构造与析构</h2><p>Linux 系统下一般程序的入口是“_start'”，这个函数是 Linux 系统库（Glibc）的一部分。当我们的程序与 Glibc 库链接在一起形成最终可执行文件以后，这个函数就是程序的初始化部分的入口，程序初始化部分完成一系列初始化过程之后，会调用 main 函数来执行程序的主体。在 main 函数执行完成以后，返回到初始化部分，它进行一些清理工作，然后结束进程。对于有些场合，程序的一些特定的操作必须在 main 函数之前被执行，还有一些操作必须在 main 函数之后被执行，其中很具有代表性的就是 C++的全局对象的构造和析构函数，因此 ELF 文件还定义了两种特殊的段。</p><ul><li>.init 该段里面保存的是可执行指令，它构成了进程的初始化代码。因此，当一个程序开始运行时，在 main 函数被调用之前，Glibc 的初始化部分安排执行这个段的中的代码。</li><li>.fini 该段保存着进程终止代码指令。因此，当-个程序的 main 函数正常退出时，Glibc 会安排执行这个段中的代码。</li></ul><p>利用这两个特性，C++的全局构造和析构函数就由此实现。</p><h1 id="静态库链接">静态库链接</h1><p>其实一个静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。通常人们使用“ar”压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了 libc.a 这个静态库文件。我们也可以使用“ar”工具来查看这个文件包含了哪些目标文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ar -t libc.a</span><br><span class="line">init-first.o</span><br><span class="line">libc-start.o</span><br><span class="line">sysdep.o</span><br><span class="line">version.o</span><br><span class="line">check_fds.o</span><br><span class="line">libc-tls.o</span><br><span class="line">elf-init.o</span><br><span class="line">dso_handle.o</span><br><span class="line">errno.o</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>使用“objdump”或“readelf'”加上文本查找工具如“grep”，使用“objdump”查看 libc.a 的符号可以发现如下结果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -t libc.a</span><br><span class="line">aio.o:     file format elf64-little</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">...</span><br><span class="line">printf.o:     file format elf64-little</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*0000000000000000 printf.c</span><br><span class="line">0000000000000000 l    d  .text.printf0000000000000000 .text.printf</span><br><span class="line">0000000000000000 l       .text.printf0000000000000000 <span class="variable">$x</span></span><br><span class="line">0000000000000000 g     F .text.printf0000000000000084 <span class="built_in">printf</span></span><br><span class="line">0000000000000000         *UND*0000000000000000 vfprintf</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>可以看到“printf”函数被定义在了“printf.o”这个目标文件中。这里我们似乎找到了最终的机制，那就是“Hello World”程序编译出来的目标文件只要和 libc.a 里面的“printf.o。链接在一起，最后就可以形成一个可用的可执行文件了，printf.o 会依赖其他。o 文件例如 vfprintf.o、stdio.o 等，继续链接其他文件，最终得到如图 4-6 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ld13.png"></p><p>现在 Linux 系统上的库比我们想象的要复杂。当我们编译和链接一个普通 C 程序的时候，不仅要用到 C 语言库 libc.a，而且还有其他一些辅助性质的目标文件和库。我们可以使用下面的 GCC 命令编译“hello.c”，“-verbose”表示将整个编译链接过程的中间步骤打印出来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ gcc -static --verbose -fno-builtin Simplesection.c</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none:hsa</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">'Ubuntu 9.3.0-17ubuntu1~20.04'</span> --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=<span class="built_in">yes</span> --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">'-static'</span> <span class="string">'-v'</span> <span class="string">'-fno-builtin'</span> <span class="string">'-mtune=generic'</span> <span class="string">'-march=x86-64'</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -quiet -v -imultiarch x86_64-linux-gnu Simplesection.c -quiet -dumpbase Simplesection.c -mtune=generic -march=x86-64 -auxbase Simplesection -version -fno-builtin -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccobRCAH.s</span><br><span class="line">GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu)</span><br><span class="line">compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">ignoring nonexistent directory <span class="string">"/usr/local/include/x86_64-linux-gnu"</span></span><br><span class="line">ignoring nonexistent directory <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed"</span></span><br><span class="line">ignoring nonexistent directory <span class="string">"/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/include"</span></span><br><span class="line"><span class="comment">#include "..." search starts here:</span></span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/9/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br><span class="line">GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu)</span><br><span class="line">compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: bbf13931d8de1abe14040c9909cb6969</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">'-static'</span> <span class="string">'-v'</span> <span class="string">'-fno-builtin'</span> <span class="string">'-mtune=generic'</span> <span class="string">'-march=x86-64'</span></span><br><span class="line"> as -v --64 -o /tmp/ccQ6DrhG.o /tmp/ccobRCAH.s</span><br><span class="line">GNU assembler version 2.34 (x86_64-linux-gnu) using BFD version (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.34</span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">'-static'</span> <span class="string">'-v'</span> <span class="string">'-fno-builtin'</span> <span class="string">'-mtune=generic'</span> <span class="string">'-march=x86-64'</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/9/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper -plugin-opt=-fresolution=/tmp/cctIiGBE.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/ccQ6DrhG.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/9/crtend.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">'-static'</span> <span class="string">'-v'</span> <span class="string">'-fno-builtin'</span> <span class="string">'-mtune=generic'</span> <span class="string">'-march=x86-64'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>第一步是调用 cc1 程序，这个程序实际上就是 GCC 的 C 语言编译器，它将“hello.c”编译成一个临时的汇编文件“/tmp/ccUhtGSB.s”。</li><li>然后调用 as 程序，as 程序是 GNU 的汇编器，它将“/tmp/ccUhtGSB.s”汇编成临时目标文件“/tmp/cCQZRPL5.o”，这个“/tmp/cCQZRPL5.o”实际上就是前面的“hello.o”。</li><li>接着最关键的步骤是最后一步，GCC 调用 collect2 程序来完成最后的链接。</li></ul><p>实际上 collect2 可以看作是 ld 链接器的一个包装，它会调用 ld 链接器来完成对目标文件的链接，然后再对链接结果进行一些处理，主要是收集所有与程序初始化相关的信息并且构造初始化的结构。可以看到最后一步中，至少有下列几个库和目标文件被链接入了最终可执行文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">crt1.o</span><br><span class="line">crti.o</span><br><span class="line">crtbeginT.o</span><br><span class="line">libgcc.a</span><br><span class="line">libgcc_eh.a</span><br><span class="line">libc.a</span><br><span class="line">crtend.o</span><br><span class="line">crtn.o</span><br></pre></td></tr></tbody></table></figure><h1 id="链接过程控制">链接过程控制</h1><p>链接器一般都提供多种控制整个链接过程的方法，以用来产生用户所须要的文件。一般链接器有如下三种方法。</p><ul><li>使用命令行来给链接器指定参数，我们前面所使用的 ld 的-o、-e 参数就属于这类。</li><li>将链接指令存放在目标文件里面，编译器经常会通过这种方法向链接器传递指令。比如 VISUAL C++编译器会把链接参数放在 PE 目标文件的。drectve 段以用来传递参数。</li><li>使用链接控制脚本，是最为灵活、最为强大的链接控制方法。</li></ul><p>前面我们在使用 ld 链接器的时候，没有指定链接脚本，其实 ld 在用户没有指定链接脚本的时候会使用默认链接脚本。我们可以使用下面的命令行来查看 ld 默认的链接脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld --verbose</span><br></pre></td></tr></tbody></table></figure><p>默认的 ld 链接脚本存放在/usr/lib/ldscripts/下，不同的机器平台、输出文件格式都有相应的链接脚本。我们可以自己写一个脚本，然后指定该脚本为链接控制脚本。比如可以使用-T 参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -T link.script</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《程序员的自我修养》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Links Libraries </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接装载与库（二）目标文件</title>
      <link href="/next/2021/Program/LinksAndLibrariesPart2/"/>
      <url>/next/2021/Program/LinksAndLibrariesPart2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ObjectFile.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMwNzVlODdkOWMwODA3NmQwOWM4MDI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p><h1 id="目标文件的格式">目标文件的格式</h1><p>现在 PC 平台流行的可执行文件格式主要是 Windows 下的 PE（Portable Executable）和 Linux 的 ELF（Executable Linkable Format），它们都是 COFF（Common fileformat）格式的变种。</p><p>ELF 文件标准里面把系统中采用 ELF 格式的文件归为如下表所列举的 4 类。</p><table><colgroup><col style="width: 18%"><col style="width: 52%"><col style="width: 29%"></colgroup><thead><tr class="header"><th>ELF 文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr class="odd"><td>可重定位文件 <bar> Relocatable File</bar></td><td>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td>Linux 的。o <bar> Windows 的。obj</bar></td></tr><tr class="even"><td>可执行文件 <bar> Executable File</bar></td><td>这类文件包含了可以直接执行的程序，它的代表就是 ELF 可执行文件，它们一般都没有扩展名</td><td>比如/bin/bash 文件 <bar> Windows 的。exe</bar></td></tr><tr class="odd"><td>共享目标文件 <bar> Shared Object File</bar></td><td>这种文件包含了代码和数据，可以在以下两种情况下使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td>Linux 的。so，lib/glibc-2.5.so <bar> Windows 的 DLL</bar></td></tr><tr class="even"><td>核心转储文件 <bar> Core Dump File</bar></td><td>当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td><td>Linux 下的 core dump</td></tr></tbody></table><p>我们可以在 Linux 下使用 file 命令来查看相应的文件格式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file foobar.o</span><br><span class="line">foobar.o:ELF 32-bit LSB relocatable,Intel 80386,version 1 (SYSV),notstripped</span><br><span class="line">file /bin/bash</span><br><span class="line">/bin/bash:ELF 32-bit LSB executable,Intel 80386,version 1 (SYSV),forGNU/Linux 2.6.8,dynamically linked (uses shared libs),stripped</span><br><span class="line"><span class="variable">$fi1e</span>/1ib/1d-2.6.1.8o</span><br><span class="line">/lib/libc-2.6.1.so:ELF 32-bit LSB shared object,Intel 80386,version 1(SYSV),<span class="keyword">for</span> GNU/Linux 2.6.8,stripped</span><br></pre></td></tr></tbody></table></figure><h1 id="目标文件是什么样的">目标文件是什么样的</h1><p>目标文件中的内容至少有编译后的机器指令代码、数据。除了这些内容以外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“段”（Segment）的形式存储。</p><p>让我们来看一个简单的程序被编译成目标文件后的结构，如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf1.png"></p><p>假设图 3-1 的可执行文件（目标文件）的格式是 ELF，从图中可以看到，ELF 文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，文件头还包括一个段表（Section Table），段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等。</p><blockquote><p>一般 C 语言的编译后执行语句都编译成机器代码，保存在。text 段；已初始化的全局变量和局部静态变量都保存在。data 段；未初始化的全局变量和局部静态变量一般放在一个叫“.bss”的段里。.bss 段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间。</p></blockquote><p>数据和指令分段的好处有很多，主要有如下几个方面：</p><ul><li>一方面是当程序被装载后，数据和指令分别被映射到两个虚存区域。这两个虚存区域的权限可以被分别设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</li><li>另外一方面是对于现代的 CPU 来说，它们有着极为强大的缓存（Cache）体系。指令区和数据区的分离有利于提高程序的局部性，所以程序的指令和数据被分开存放对 CPU 的缓存命中率提高有好处。</li><li>第三个原因，其实也是最重要的原因，就是当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只须要保存一份该程序的指令部分。</li></ul><h1 id="挖掘-simplesection.o">挖掘 SimpleSection.o</h1><p>我们就以 SimpleSection.c 编译出来的目标文件作为分析对象，这个程序是经过精心挑选的，具有一定的代表性而又不至于过于繁琐和复杂。图 3-1 中的程序代码如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">simpleSection.c</span></span><br><span class="line"><span class="comment">Linux:</span></span><br><span class="line"><span class="comment">gcc -c Simplesection.c</span></span><br><span class="line"><span class="comment">Windows:</span></span><br><span class="line"><span class="comment">cl Simplesection.c /c /Za</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*format,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b );</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们使用 GCC 来编译这个文件（参数-c 表示只编译不链接）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c Simplesection.c</span><br></pre></td></tr></tbody></table></figure><p>我们得到了一个 2.1k 字节的 SimpleSection.o 目标文件。我们可以使用 binutils 的工具 objdump 来查看 object 内部的结构，它可以用来查看各种目标文件的结构和内容。运行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ objdump -h Simplesection.o</span><br><span class="line"></span><br><span class="line">Simplesection.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000ac  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d7  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></tbody></table></figure><p>Linux 还有一个很不错的工其叫 readelf，它是专门针对 ELF 文件格式的解析器，很多时候它对 ELF 文件的分析可以跟 objdump 相互对照，所以我们下面会经常用到这个工具。参数“-h”就是把 ELF 文件的各个段的基本信息打印出来。我们也可以使用“objdump -x”把更多的信息打印出来，但是“-x”输出的这些信息又多又复杂，对于不熟悉 ELF 和 objdump 的读者来说可能会很陌生。</p><p>从上面的结果来看，SimpleSection.o 的段的数量比我们想象中的要多，除了最基本的代码段、数据段和 BSS 段以外，还有 3 个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GNU-stack），每个段的第 2 行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在文件中存在。我们可以看到 BSS 段没有“CONTENTS”，表示它实际上在 ELF 文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但它的长度为 0，这是个很古怪的段，我们暂且忽略它，认为它在 ELF 文件中也不存在。那么 ELF 文件中实际存在的也就是“.text”、“.data”、“.rodata”和“.comment'”这 4 个段了。它们在 ELF 中的结构如图 3-3 所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf2.png"></p><p>了解了这几个段在 SimpleSection.o 的基本分布，接着将逐个来看这几个段，看看它们包含了什么内容。有一个专门的命令叫做“size”，它可以用来查看 ELF 文件的代码段、数据段和 BSS 段的长度：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ size Simplesection.o</span><br><span class="line">   text   data    bss    dec    hexfilename</span><br><span class="line">    219      8      4    231     e7Simplesection.o</span><br></pre></td></tr></tbody></table></figure><h2 id="代码段">代码段</h2><p>objdump 的“-s”参数可以将所有段的内容以十六进制的方式打印出来，“-d”参数可以将所有包含指令的段反汇编。我们将 objdump 输出中关于代码段的内容提取出来，分析一下关于代码段的内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ objdump -x -s -d Simplesection.o</span><br><span class="line"></span><br><span class="line">Simplesection.o:     file format elf64-x86-64</span><br><span class="line">Simplesection.o</span><br><span class="line">architecture: i386:x86-64, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x0000000000000000</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000ac  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d7  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000d8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .eh_frame     00000058  0000000000000000  0000000000000000  000000f8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*0000000000000000 Simplesection.c</span><br><span class="line">0000000000000000 l    d  .text0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data0000000000000004 static_var.2324</span><br><span class="line">0000000000000000 l     O .bss0000000000000004 static_var2.2325</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .note.gnu.property0000000000000000 .note.gnu.property</span><br><span class="line">0000000000000000 l    d  .eh_frame0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data0000000000000004 global_init_var</span><br><span class="line">0000000000000004       O *COM*0000000000000004 global_uninit_var</span><br><span class="line">0000000000000000 g     F .text0000000000000028 func1</span><br><span class="line">0000000000000000         *UND*0000000000000000 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000000         *UND*0000000000000000 <span class="built_in">printf</span></span><br><span class="line">0000000000000028 g     F .text0000000000000037 main</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....}..</span><br><span class="line"> 0010 45fc89c6 488d3d00 000000b8 00000000  E...H.=.........</span><br><span class="line"> 0020 e8000000 0090c9c3 f30f1efa 554889e5  ............UH..</span><br><span class="line"> 0030 4883ec10 c745f801 0000008b 15000000  H....E..........</span><br><span class="line"> 0040 008b0500 00000001 c28b45f8 01c28b45  ..........E....E</span><br><span class="line"> 0050 fc01d089 c7e80000 00008b45 f8c9c3    ...........E...</span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span><br><span class="line"> 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20</span><br><span class="line"> 0020 2e303429 20392e33 2e3000             .04) 9.3.0.</span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span><br><span class="line"> 0010 020000c0 04000000 03000000 00000000  ................</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 28000000 00450e10 8602430d  ....(....E....C.</span><br><span class="line"> 0030 065f0c07 08000000 1c000000 3c000000  ._..........&lt;...</span><br><span class="line"> 0040 00000000 37000000 00450e10 8602430d  ....7....E....C.</span><br><span class="line"> 0050 066e0c07 08000000                    .n......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func1&gt;:</span><br><span class="line">   0:f3 0f 1e fa          endbr64</span><br><span class="line">   4:55                   push   %rbp</span><br><span class="line">   5:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   8:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   c:89 7d <span class="built_in">fc</span>             mov    %edi,-0x4(%rbp)</span><br><span class="line">   f:8b 45 <span class="built_in">fc</span>             mov    -0x4(%rbp),%eax</span><br><span class="line">  12:89 c6                mov    %eax,%esi</span><br><span class="line">  14:48 8d 3d 00 00 00 00 lea    0x0(%rip),%rdi        <span class="comment">#  1b &lt;func1+0x1b&gt;</span></span><br><span class="line">17: R_X86_64_PC32.rodata-0x4</span><br><span class="line">  1b:b8 00 00 00 00       mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  20:e8 00 00 00 00       callq  25 &lt;func1+0x25&gt;</span><br><span class="line">21: R_X86_64_PLT32printf-0x4</span><br><span class="line">  25:90                   nop</span><br><span class="line">  26:c9                   leaveq</span><br><span class="line">  27:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000000028 &lt;main&gt;:</span><br><span class="line">  28:f3 0f 1e fa          endbr64</span><br><span class="line">  2c:55                   push   %rbp</span><br><span class="line">  2d:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  30:48 83 ec 10          sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  34:c7 45 f8 01 00 00 00 movl   <span class="variable">$0x1</span>,-0x8(%rbp)</span><br><span class="line">  3b:8b 15 00 00 00 00    mov    0x0(%rip),%edx        <span class="comment">#  41 &lt;main+0x19&gt;</span></span><br><span class="line">3d: R_X86_64_PC32.data</span><br><span class="line">  41:8b 05 00 00 00 00    mov    0x0(%rip),%eax        <span class="comment">#  47 &lt;main+0x1f&gt;</span></span><br><span class="line">43: R_X86_64_PC32.bss-0x4</span><br><span class="line">  47:01 c2                add    %eax,%edx</span><br><span class="line">  49:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">  4c:01 c2                add    %eax,%edx</span><br><span class="line">  4e:8b 45 <span class="built_in">fc</span>             mov    -0x4(%rbp),%eax</span><br><span class="line">  51:01 d0                add    %edx,%eax</span><br><span class="line">  53:89 c7                mov    %eax,%edi</span><br><span class="line">  55:e8 00 00 00 00       callq  5a &lt;main+0x32&gt;</span><br><span class="line">56: R_X86_64_PLT32func1-0x4</span><br><span class="line">  5a:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">  5d:c9                   leaveq</span><br><span class="line">  5e:c3                   retq</span><br></pre></td></tr></tbody></table></figure><p>“Contents of section.text”就是。text 的数据以十六进制方式打印出来的内容，最左面一列是偏移量，中间 4 列是十六进制内容，最右面一列是。text 段的 ASCII 码形式。对照下面的反汇编结果，可以很明显地看到，.text 段里所包含的正是 SimpleSection.c 里两个函数 func1() 和 main() 的指令。.text 段的第一个字节“55”就是“func1()”函数的第一条“push %rbp”指令，而最后一个字节 0xc3 正是 main 函数的最后一条指令“retq”。</p><h2 id="数据段和只读数据段">数据段和只读数据段</h2><p>.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面的 SimpleSection.c 代码里面一共有两个这样的变量，分别是 global_init_varabal 与 static_var。这两个变量每个 4 字节，一共刚好 8 个字节，所以“.data”这个段的大小为 8 个字节。 SimpleSection.c 里面我们在调用“printf”的时候，用到了一个字符串常量“%d”，它是一种只读数据，所以它被放到了“.rodata”段，我们可以从输出结果看到“.rodata”这个段的 4 个字节刚好是这个字符串常量的 ASCII 字节序，最后以、0 结尾。 单独设立“.rodata”段有很多好处，不光是在语义上支持了 C++的 const 关键字，而且操作系统在加载的时候可以将“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。 另外值得一提的是，有时候编译器会把字符串常量放到“.data”段，而不会单独放在“.rodata”段。</p><h2 id="bss-段">BSS 段</h2><p>.bss 段存放的是未初始化的全局变量和局部静态变量，如上述代码中 global_uninit_var 和 static_var2 就是被存放在。bss 段，其实更准确的说法是。bss 段为它们预留了空间。但是我们可以看到该段的大小只有 4 个字节，这与 global_uninit_var 和 static_var2 的大小的 8 个字节不符。 其实我们可以通过符号表（Symbol Table）看到，只有 static_var2 被存放在了。bss 段，而 global_uninit_var 却没有被存放在任何段，只是一个未定义的“COMMON 符号”。这其实是跟不同的语言与不同的编译器实现有关，有些编译器会将全局的未初始化变量存放在目标文件。bss 段，有些则不存放，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在。bss 段分配空间。</p><h2 id="其他段">其他段</h2><p>除了。text、.data、.bss 这 3 个最常用的段之外，ELF 文件也有可能包含其他的段，用来保存与程序相关的其他信息。下表中列举了 ELF 的一些常见的段：</p><table><thead><tr class="header"><th>常用的段名</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>.rodatal</td><td>Read only Data，这种段里存放的是只读数据，比如字符串常量、全局 const 变量。跟“.rodata”一样</td></tr><tr class="even"><td>.comment</td><td>存放的是编译器版本信息，比如字符串：”GCC：（GNU）4.2.0</td></tr><tr class="odd"><td>.debug</td><td>调试信息</td></tr><tr class="even"><td>.dynamic</td><td>动态链接信息</td></tr><tr class="odd"><td>.hash</td><td>符号哈希表</td></tr><tr class="even"><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr class="odd"><td>.note</td><td>额外的编译器信息。比如程序的公司名、发布版本号等</td></tr><tr class="even"><td>.strtab</td><td>String Table. 字符串表，用于存储 ELF 文件中用到的各种字符串</td></tr><tr class="odd"><td>.symtab</td><td>Symbol Table. 符号表</td></tr><tr class="even"><td>.shstrtab</td><td>Section String Table. 段名表</td></tr><tr class="odd"><td>.plt <bar> .got</bar></td><td>动态链接的跳转表和全局入口表</td></tr><tr class="even"><td>.init <bar> .fini</bar></td><td>程序初始化与终结代码段</td></tr></tbody></table><p>这些段的名字都是由“.”作为前缀，表示这些表的名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名。比如我们可以在 ELF 文件中插入一个“music”的段，里面存放了一首 MP3 音乐，当 ELF 文件运行起来以后可以读取这个段播放这首 MP3。但是应用程序自定义的段名不能使用“.”作为前缀，否则容易跟系统保留段名冲突。</p><p>Q：如果我们要将一个二进制文件，比如图片、MP3 音乐、词典一类的东西作为目标文件中的一个段，该怎么做？ A：可以使用 objcopy 工具，比如我们有一个图片文件“image.jpg”，大小为 0x82100 字节：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objcopy -I binary -o elf32-1386 -B i386 image.jpg image.o</span><br><span class="line">objdump -ht image.o</span><br></pre></td></tr></tbody></table></figure><h1 id="elf-文件结构描述">ELF 文件结构描述</h1><p>下图描述的是 ELF 目标文件的总体结构，我们省去了 ELF-些繁琐的结构，把最重要的结构提取出来： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf3.png"></p><h2 id="文件头">文件头</h2><p>我们可以用 readelf 命令来详细查看 ELF 文件，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -h Simplesection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">'s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1184 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         14</span></span><br><span class="line"><span class="string">  Section header string table index: 13</span></span><br></pre></td></tr></tbody></table></figure><p>从上面输出的结果可以看到，ELF 的文件头中定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。这些数值中有关描述 ELF 目标平台的部分，与我们常见的 32 位 Intel 的硬件平台基本上一样。</p><h2 id="段表">段表</h2><p>前文中我们使用了“objudump -h”来查看 ELF 文件中包含的段，结果是 SimpleSection 里面看到了总共有 6 个段，分别是“.code”、“.data”、“.bss”、“.rodata”、“.comment'”和“.note.GNU-stack”。实际上的情况却有所不同，“objdump -h”命令只是把 ELF 文件中关键的段显示了出来，而省略了其他的辅助性的段，比如：符号表、字符串表、段名字符串表、重定位表等。我们可以使用 readelf 工具来查看 ELF 文件的段，它显示出来的结果才是真正的段表结构：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -S Simplesection.o</span><br><span class="line">There are 14 section headers, starting at offset 0x4a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000380</span><br><span class="line">       0000000000000078  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000ac</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d7</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .note.gnu.propert NOTE             0000000000000000  000000d8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .eh_frame         PROGBITS         0000000000000000  000000f8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .rela.eh_frame    RELA             0000000000000000  000003f8</span><br><span class="line">       0000000000000030  0000000000000018   I      11     9     8</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  00000150</span><br><span class="line">       00000000000001b0  0000000000000018          12    12     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  00000300</span><br><span class="line">       000000000000007c  0000000000000000           0     0     1</span><br><span class="line">  [13] .shstrtab         STRTAB           0000000000000000  00000428</span><br><span class="line">       0000000000000074  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure><p>对于 SimpleSection.o 来说，段表就是有 11 个元素的数组。ELF 段表的这个数组的第一个元素是无效的段描述符，它的类型为“NULL”，除此之外每个段描述符都对应一个段。也就是说 SimpleSection.o 共有 13 个有效的段。</p><h2 id="重定位表">重定位表</h2><p>我们注意到，SimpleSection.o 中有一个叫做“.rela.text”的段，它的类型（sh_type）为“RELA”，也就是说它是一个重定位表（Relocation Table）。正如我们最开始所说的，链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。</p><p>比如 SimpleSection.o 中的“.rela.text”就是针对“.text”段的重定位表，因为“.text”段中至少有一个绝对地址的引用，那就是对“printf”函数的调用；而“.data”段则没有对绝对地址的引用，它只包含了几个常量，所以 SimpleSection.o 中没有针对“.data”段的重定位表“.rela.data”。</p><h2 id="字符串表">字符串表</h2><p>ELF 文件中用到了很多字符串，比如段名、变量名等，比如下表这个字符串表。</p><table><thead><tr class="header"><th>偏移</th><th>+0</th><th>+1</th><th>+2</th><th>+3</th><th>+4</th><th>+5</th><th>+6</th><th>+7</th><th>+8</th><th>+9</th></tr></thead><tbody><tr class="odd"><td>+0</td><td>\0</td><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>w</td><td>o</td><td>r</td><td>l</td></tr><tr class="even"><td>+10</td><td>d</td><td>\0</td><td>M</td><td>y</td><td>v</td><td>a</td><td>r</td><td>i</td><td>a</td><td>b</td></tr><tr class="odd"><td>+20</td><td>l</td><td>e</td><td>\0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>常见的段名为“.strtab”或“.shstrtab”。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。</p><h1 id="符号">符号</h1><p>在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号，我们将符号表中所有的符号进行分类，它们有可能是下面这些类型中的一种：</p><ul><li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如 SimpleSection.o 里面的“func1”、“main”和“global_init_var”。</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们前面所讲的符号引用。比如 SimpleSection.o 里面的“printf”。</li><li>段名，这种符号往往由编译器产生，它的值就是该段的起始地址。比如 SimpleSection.o 里面的“.text”、“.data”等。</li><li>局部符号，这类符号只在编译单元内部可见。比如 SimpleSection.o 里面的“static_var”和“static_var2”。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li><li>行号信息，即目标文件指令与源代码中代码行的对应关系，它也是可选的。</li></ul><p>对于我们来说，最值得关注的就是全局符号，即上面分类中的第一类和第二类。因为链接过程只关心全局符号的相互“粘合”，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的。我们可以使用很多工具来查看 ELF 文件的符号表，比如 readelf、objdump、nm 等，比如使用“nm”来查看“SimpleSection.o”的符号结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ nm Simplesection.o</span><br><span class="line">                 U _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000000 T func1</span><br><span class="line">0000000000000000 D global_init_var</span><br><span class="line">0000000000000004 C global_uninit_var</span><br><span class="line">0000000000000028 T main</span><br><span class="line">                 U <span class="built_in">printf</span></span><br><span class="line">0000000000000004 d static_var.2324</span><br><span class="line">0000000000000000 b static_var2.2325</span><br></pre></td></tr></tbody></table></figure><h2 id="特殊符号">特殊符号</h2><p>当我们使用 ld 作为链接器来链接生产可执行文件时，它会为我们定义很多特殊的符号，这些符号并没有在你的程序中定义，但是你可以直接声明并且引用它，我们称之为特殊符号。其实这些符号是被定义在 ld 链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，注意，只有使用 ld 链接生产最终可执行文件的时候这些符号才会存在。</p><ul><li>_executable_start，该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。</li><li>etext 或_etext 或 etext，该符号为代码段结束地址，即代码段最末尾的地址。</li><li>_edata 或 edata，该符号为数据段结束地址，即数据段最末尾的地址。</li><li>_end 或 end，该符号为程序结束地址。</li><li>以上地址都为程序被装载时的虚拟地址。</li></ul><p>我们可以在程序中直接使用这些符号。</p><h2 id="符号修饰与函数签名">符号修饰与函数签名</h2><p><strong>C++符号修饰</strong><br>C++允许多个不同参数类型的函数拥有一样的名字，就是所谓的函数重载；另外 C++还在语言级别支持名称空间，即允许在不同的名称空间有多个同样名字的符号。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">func</span><span class="params">(<span class="type">float</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span> {</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line">namespace N {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们引入一个术语叫做函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息，函数签名用于识别不同的函数。C++编译器和链接器都使用符号来识别和处理函数和变量，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。上面的 6 个函数签名在 GCC 编译器下，相对应的修饰后名称如下表所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf6.png"></p><p>GCC 的基本 C++名称修饰方法如下：所有的符号都以“_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾。比如 N::C::func 经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，它的参数列表紧跟在“E”后面，对于 int 类型来说，就是字母“i”。所以整个 N::C::func（int）函数签名经过修饰为_ZN1N1C4funcEi。binutils 里面提供了一个叫“c++filt”的工具可以用来解析被修饰过的名称，比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++filt _ZN1N1C4funcEi</span><br><span class="line">N:C:func(int)</span><br></pre></td></tr></tbody></table></figure><p>签名和名称修饰机制不光被使用到函数上，C++中的全局变量和静态变量也有同样的机制。对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制。</p><p>由于不同的编译器采用不同的名字修饰方法，必然会导致由不同编译器编译产生的目标文件无法正常相互链接，这是导致不同编译器之间不能互操作的主要原因之一。</p><h2 id="extern-c">extern “C"</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *<span class="type">int</span>, <span class="type">size_t</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p>在 C++语言中，编译器会认为这个 memset 函数是一个 C++函数，将 memset 的符号修饰成_ZmemsetPvii，这样链接器就无法与 C 语言库中的 memset 符号进行链接。所以对于 C++来说，必须使用 extern“C"来声明 memset 这个函数。但是 C 语言又不支持 extern“C”语法。幸好我们有一种很好的方法可以解决上述问题，就是使用 C++的宏“_cplusplus”，C++编译器会在编译 C++的程序时默认定义这个宏，具体代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *<span class="type">int</span>,<span class="type">size_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码中的技巧几乎在所有的系统头文件里面都被用到。</p><h2 id="弱符号与强符号">弱符号与强符号</h2><p>对于 C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。我们也可以通过 GCC 的“<strong>attribute</strong>（weak）”来定义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用。比如我们有下面这段程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>:</span><br><span class="line">__attribute__((weak) weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面这段程序中，“weak”和“weak2”是弱符号，“strong”和“main”是强符号，而“ext”既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链接器就会按如下规则处理与选择被多次定义的全局符号：</p><ul><li>规则 1：不允许强符号被多次定义。</li><li>规则 2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>规则 3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><p>弱引用和强引用：</p><ul><li>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。</li><li>与之相对应还有一种弱引用（Weak Reference），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。</li></ul><p>在 GCC 中，我们可以通过使用“<strong>attribute</strong>（weakref）”这个扩展关键字来声明对一个外部函数的引用为弱引用，比如下面这段代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((weakref))<span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    foo():</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以将它编译成一个可执行文件，GCC 并不会报链接错误。但是当我们运行这个可执行文件时，会发生运行错误。因为当 main 函数试图调用 foo 函数时，foo 函数的地址为 0，于是发生了非法地址访问的错误。一个改进的例子是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((weakref) <span class="type">void</span> foo();</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(foo)</span><br><span class="line">        foo();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数。</p><h1 id="调试信息">调试信息</h1><p>如果我们在 GCC 编译时加上“-g”参数，编译器就会在产生的目标文件里面加上调试信息，我们通过 readelf 等工具可以看到，目标文件里多了很多“debug”相关的段：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ gcc -c -g Simplesection.c</span><br><span class="line">vooxle@liushuai:~$ <span class="built_in">ls</span></span><br><span class="line">Document  Simplesection.c  Simplesection.o  nfs_rootfs  workspace</span><br><span class="line">vooxle@liushuai:~$ readelf -S Simplesection.o</span><br><span class="line">There are 22 section headers, starting at offset 0x1570:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000d40</span><br><span class="line">       0000000000000078  0000000000000018   I      19     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .debug_info       PROGBITS         0000000000000000  000000ac</span><br><span class="line">       00000000000003a0  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .rela.debug_info  RELA             0000000000000000  00000db8</span><br><span class="line">       0000000000000678  0000000000000018   I      19     6     8</span><br><span class="line">  [ 8] .debug_abbrev     PROGBITS         0000000000000000  0000044c</span><br><span class="line">       0000000000000130  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .debug_aranges    PROGBITS         0000000000000000  0000057c</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [10] .rela.debug_arang RELA             0000000000000000  00001430</span><br><span class="line">       0000000000000030  0000000000000018   I      19     9     8</span><br><span class="line">  [11] .debug_line       PROGBITS         0000000000000000  000005ac</span><br><span class="line">       000000000000012e  0000000000000000           0     0     1</span><br><span class="line">  [12] .rela.debug_line  RELA             0000000000000000  00001460</span><br><span class="line">       0000000000000018  0000000000000018   I      19    11     8</span><br><span class="line">  [13] .debug_str        PROGBITS         0000000000000000  000006da</span><br><span class="line">       0000000000000314  0000000000000001  MS       0     0     1</span><br><span class="line">  [14] .comment          PROGBITS         0000000000000000  000009ee</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [15] .note.GNU-stack   PROGBITS         0000000000000000  00000a19</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [16] .note.gnu.propert NOTE             0000000000000000  00000a20</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000000000  00000a40</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .rela.eh_frame    RELA             0000000000000000  00001478</span><br><span class="line">       0000000000000030  0000000000000018   I      19    17     8</span><br><span class="line">  [19] .symtab           SYMTAB           0000000000000000  00000a98</span><br><span class="line">       0000000000000228  0000000000000018          20    17     8</span><br><span class="line">  [20] .strtab           STRTAB           0000000000000000  00000cc0</span><br><span class="line">       000000000000007c  0000000000000000           0     0     1</span><br><span class="line">  [21] .shstrtab         STRTAB           0000000000000000  000014a8</span><br><span class="line">       00000000000000c3  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure><p>这些段中保存的就是调试信息。现在的 ELF 文件采用一个叫 DWARF（Debug With Arbitrary Record Format）的标准的调试信息格式，现在该标准已经发展到了第三个版本，即 DWARF3，由 DWARF 标准委员会由 2006 年颁布。在 Linux 下，我们可以使用“strip”命令来去掉 ELF 文件中的调试信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strip foo</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《程序员的自我修养》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Links Libraries </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接装载与库（一）编译和链接</title>
      <link href="/next/2021/Program/LinksAndLibrariesPart1/"/>
      <url>/next/2021/Program/LinksAndLibrariesPart1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/CompileAndLink.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMwNmM0OWYzNDZmYjA3ZjkyZGFiOGI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="被隐藏了的过程">被隐藏了的过程</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Linux 下，当我们使用 GCC 来编译 Hello World 程序时，只须使用最简单的命令（假设源代码文件名为 hello.c）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br><span class="line">Hello world</span><br></pre></td></tr></tbody></table></figure><p>事实上，上述过程可以分解为 4 个步骤，分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/program1.png"></p><h2 id="预编译">预编译</h2><p>第一步预编译的过程相当于如下命令（-E 表示只进行预编译）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp hello.c hello.i</span><br></pre></td></tr></tbody></table></figure><p>预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“#include”、“#define”等，预编译成一个。i 文件，主要处理规则如下：</p><ul><li>将所有的“#define”删除，并且展开所有的宏定义</li><li>处理所有条件预编译指令，比如“#if”、“#ifdef'”、“#elif”、“#else”、“#endif”</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。删除所有的注释“//”和“/**/”</li><li>添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号</li><li>保留所有的#pragma 编译器指令，因为编译器须要使用它们</li></ul><p>经过预编译后的。i 文件不包含任何宏定义，并且包含的文件也已经被插入到。i 文件中。</p><h2 id="编译">编译</h2><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。上面的编译过程相当于如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -s hello.i -o hello.s</span><br></pre></td></tr></tbody></table></figure><p>现在版本的 GCC 把预编译和编译两个步骤合并成一个步骤，使用一个叫做 cc1 的程序来完成这两个步骤。这个程序位于“/usr/lib/gcc/i486-linux-gnu/4.1/”，我们也可以直接调用 cc1 来完成它：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c</span><br></pre></td></tr></tbody></table></figure><p>或者使用如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -s hello.c -o hello.s</span><br></pre></td></tr></tbody></table></figure><h2 id="汇编">汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，只是根据汇编指令和机器指令的对照表一翻译就可以了。上面的汇编过程我们可以调用汇编器 as 来完成：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></tbody></table></figure><p>或者使用 gcc 命令从 C 源代码文件开始，经过预编译、编译和汇编直接输出目标文件（Object File):</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></tbody></table></figure><h2 id="链接">链接</h2><p>下面让我们来看看怎么样调用 ld 才可以产生一个能够正常运行的 HelloWorld 程序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ld -static /usr/lib/crt1.o /usr/lib/crti.o</span><br><span class="line">/usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o</span><br><span class="line">-L/usr/lib/gcc/i486-linux-gnu/4.1.3 -L/usr/lib -L/lib hello.o --start-group</span><br><span class="line">-lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o/usr/lib/crtn.o</span><br></pre></td></tr></tbody></table></figure><p>如果把所有的路径都省略掉，那么上面的命令就是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们需要将一大堆文件链接起来才可以得到“a.out”，即最终的可执行文件。</p><h1 id="编译器做了什么">编译器做了什么</h1><p>从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。</p><p>编译过程一般可以分为步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。整个过程如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/compile.png"></p><p>我们将结合上图来简单描述从源代码（Source Code）到最终目标代码（Final Target Code）的过程。以一段很简单的 C 语言的代码为例子来讲述这个过程。比如我们有一行 C 语言的源代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index +<span class="number">4</span>)*(<span class="number">2</span> +<span class="number">6</span>)</span><br><span class="line">CompilerExpression.c</span><br></pre></td></tr></tbody></table></figure><h2 id="词法分析">词法分析</h2><p>首先源代码程序被输入到扫描器（Scanner），扫描器的任务很简单，它只是简单地进行词法分析，运用一种类似于有限状态机（Finite State Machine）的算法可以很轻松地将源代码的字符序列分割成一系列的记号（Token）。比如上面的那行程序，总共包含了 28 个非空字符，经过扫描以后，产生了 16 个记号，如下所示。</p><table><thead><tr class="header"><th>记号</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>array</td><td>标识符</td></tr><tr class="even"><td>[</td><td>左方括号</td></tr><tr class="odd"><td>index</td><td>标识符</td></tr><tr class="even"><td>]</td><td>右方括号</td></tr><tr class="odd"><td>=</td><td>赋值</td></tr><tr class="even"><td>(</td><td>左圆括号</td></tr><tr class="odd"><td>index</td><td>标识符</td></tr><tr class="even"><td>+</td><td>加号</td></tr><tr class="odd"><td>4</td><td>数字</td></tr><tr class="even"><td>)</td><td>右圆括号</td></tr><tr class="odd"><td>*</td><td>乘号</td></tr><tr class="even"><td>(</td><td>左圆括号</td></tr><tr class="odd"><td>2</td><td>数字</td></tr><tr class="even"><td>+</td><td>加号</td></tr><tr class="odd"><td>6</td><td>数字</td></tr><tr class="even"><td>)</td><td>右圆括号</td></tr></tbody></table><p>词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p><h2 id="语法分析">语法分析</h2><p>语法分析器生成的语法树就是以表达式（Expression）为节点的树。上面例子中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/sytex.png"></p><p>从上图中我们可以看到，整个语句被看作是一个赋值表达式；赋值表达式的左边是一个数组表达式，它的右边是一个乘法表达式；数组表达式又由两个符号表达式组成，等等。在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如果出现了表达式不合法，编译器就会报告语法分析阶段的错误。</p><h2 id="语义分析">语义分析</h2><p>语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。比如语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的。编译器所能分析的语义是静态语义（Static Semantic），所谓静态语义是指在编译期可以确定的语义，与之对应的动态语义（Dynamic Semantic）就是只有在运行期才能确定的语义。</p><p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，语义分析过程中需要完成这个步骤。</p><p>经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。上面描述的语法树在经过语义分析阶段以后成为如图 2-4 所示的形式。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/sytex2.png"></p><p>可以看到，每个表达式（包括符号和数字）都被标识了类型。我们的例子中几乎所有的表达式都是整型的，所以无须做转换，整个分析过程很顺利。语义分析器还对符号表里的符号类型也做了更新。</p><h2 id="中间语言生成前端">中间语言生成（前端）</h2><p>现代的编译器有着很多层次的优化，往往在源代码级别会有一个优化过程。源代码级优化器会在源代码级别进行优化，在上例中，细心的读者可能己经发现，（2+6）这个表达式可以被优化掉，因为它的值在编译期就可以被确定。经过优化的语法树如图 2-5 所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/sytex3.png"></p><p>我们看到（2+6）这个表达式被优化成 8。其实直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），它是语法树的顺序表示，其实它已经非常接近目标代码了。 中间代码使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码，这样可以跨平台。</p><h2 id="目标代码生成与优化后端">目标代码生成与优化（后端）</h2><p>属于编译器后端，编译器后端主要包括代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）。代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p><p>最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p><p>经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器忙活了这么多个步骤以后，源代码终于被编译成了目标代码，但是这个目标代码中有一个问题是变量和函数的地址还没有确定。</p><h1 id="链接器">链接器</h1><p>假设有一种计算机，它的每条指令是 1 个字节，也就是 8 位。我们假设有一种跳转指令，它的高 4 位是 0001，表示这是一条跳转指令： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/sytex4.png"></p><p>低 4 位存放的是跳转目的地的绝对地址。我们可以从上图中看到，这个程序的第一条指令就是一条跳转指令，它的目的地址是第 5 条指令（注意，第 5 条指令的绝对地址是 4）。</p><p>现在问题来了，程序并不是一写好就永远不变化的，它可能会经常被修改。比如我们在第 1 条指令之后、第 5 条指令之前插入了一条或多条指令，那么第 5 条指令及后面的指令的位置将会相应地往后移动，原先第一条指令的低位的数字将需要相应地调整。这种重新计算各个目标的地址过程被叫做重定位（Relocation）。</p><p>先驱者发明了汇编语言，这相比机器语言来说是个很大的进步。汇编语言可以使用符号来标记位置，比如一个符号“divide”表示一个除法子程序的起始地址，比记住从某个位置开始的第几条指令是除法子程序方便得多。最重要的是，这种符号的方法使得人们从具体的指令地址中逐步解放出来。比如前面纸带程序中，我们把刚开始第 5 条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp foo</span><br></pre></td></tr></tbody></table></figure><p>符号（Symbol）这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序的起始地址，也可以是一个变量的起始地址。</p><p>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题，那就是模块间符号的引用。这个模块的拼接过程就是链接（Linking）。</p><h1 id="静态链接">静态链接</h1><p>链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。链接器所要做的工作其实跟前面所描述的“程序员人工调整地址”本质上没什么两样，链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。</p><p>使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的 func.c 模块查找 foo 的地址，然后将 main.c 模块中所有引用到 foo 的指令重新修正，让它们的目标地址为真正的 foo 函数的地址。这就是静态链接的最基本的过程和作用。</p><p>让我们结合具体的 CPU 指令来了解这个过程。假设我们有个全局变量叫做 var，它在目标文件 A 里面。我们在目标文件 B 里面要访问这个全局变量，比如我们在目标文件里面有这么一条指令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl %Ox2a,var</span><br></pre></td></tr></tbody></table></figure><p>这条指令就是给这个 var 变量赋值 0x2a，相当于 C 语言里面的语句 var=42。然后我们编译目标文件 B，得到这条指令机器码，如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/sytex7.png"></p><p>由于在编译目标文件 B 的时候，编译器并不知道变量 var 的目标地址，将这条 mov 指令的目标地址置为 O，等待链接器在将目标文件 A 和 B 链接起来的时候再将其修正。我们假设 A 和 B 链接后，变量 var 的地址确定下来为 0x1000，那么链接器将会把这个指令的目标地址部分修改成 0x10000。这个地址修正的过程也被叫做重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p><h1 id="参考文献">参考文献</h1><p>《程序员的自我修养》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Links Libraries </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于反作用轮的 3D 倒立摆的非线性分析与控制</title>
      <link href="/next/2021/Science/NonlinearAnalysisAndControlOf3DInvertedPendulumBasedOnCounterwheelAction/"/>
      <url>/next/2021/Science/NonlinearAnalysisAndControlOf3DInvertedPendulumBasedOnCounterwheelAction/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>本文介绍了基于反作用轮的 3D 倒立摆 Cubli 的非线性分析和控制设计。 使用广义动量的概念，将基于反作用轮的 3D 倒立摆的关键特性与 1D 情况的特性进行比较，以提出相对简单和直观的非线性控制器。 最后，在 Cubli 上实现了所提出的控制器，并给出了实验结果</p><h1 id="introduction">INTRODUCTION</h1><p>本文介绍了图 1 所示 Cubli 的非线性分析和控制。Cubli 是一个边长为 150 mm 的立方体，三个反作用轮相互垂直安装。 与其他 3D 倒立摆试验台 [1] 和 [2] 相比，Cubli 具有两个独特的功能。 一是其占地面积相对较小（因此得名 Cubli，源自瑞士德语中“立方体”的缩略词）。 另一个特点是它能够在没有任何外部支撑的情况下从静止位置跳起来，通过突然制动以高角速度旋转的反作用轮。 在 [3] 中介绍了跳跃的概念，在 [4] 中介绍了线性控制器，本文重点分析非线性模型和非线性控制策略。</p><p>与 [5] 和 [6] 中提出的工作相反，本文从纯机械的角度来处理控制器设计。 Cubli 的基本机械特性被利用来提出具有物理洞察力的简单直观的推导（[5]：1D，反作用轮，反馈线性化；[6]：3D，检测质量，线性控制器，局部稳定性）。 由此产生的平滑、渐近稳定的控制律提供了基于四个直观参数的相对简单的调整策略，从而使控制律适用于实际实现</p><p>本文的其余部分结构如下：第 II 节首先介绍了反作用轮基于一维倒立摆的简要非线性分析和控制。 接下来，非线性系统动力学是从第 III 节中的第一原理推导出来的，然后分别在第 IV 节和第 V 节中进行详细的分析和控制设计。 最后，实验结果在第六节中给出，结论在第七节中得出。</p><h1 id="analysis-and-control-of-a-1d-inverted-pendulum">ANALYSIS AND CONTROL OF A 1D INVERTED PENDULUM</h1><p>本节介绍了基于 1D 反作用轮倒立摆的分析和非线性控制策略。 由于 1D 和 3D 情况下某些关键属性的相似性，分析 3D 倒立摆在后面的部分。</p><h2 id="modelling">Modelling</h2><p>让 $$ 和 $$ 描述如图 2 所示的一维倒立摆的位置。接下来，让 $_w $ 表示反作用轮的转动惯量，<span class="math inline">\(\Phi_o\)</span> 表示系统围绕身体固定坐标系中枢轴点的总转动惯量，以及 <span class="math inline">\(m_{tot}\)</span> 和 <span class="math inline">\(l\)</span> 代表总质量和枢轴点到整个系统重心的距离。</p><p>系统的拉格朗日 [7] 由下式给出：</p><p><span class="math display">\[\iota = \frac{1}{2} \hat{\Theta_o}\dot{\varphi^2} + \frac{1}{2} \Theta_w(\dot{\varphi } + \dot{\psi } )^2 - mg\cos \varphi \tag1\]</span></p><p>其中 <span class="math inline">\(\hat{\Theta_o} = \Theta_o − \Theta_w &gt; 0，m = m_{tot}l\)</span>，g 是恒定的重力加速度。 广义动量定义为：</p><p><span class="math display">\[p_{\varphi } :=\frac{\partial \iota }{\partial {\varphi }' }  = \Theta_o{\varphi }' + \Theta_w\dot{\psi }  \tag2\]</span></p><p><span class="math display">\[p_{\psi } :=\frac{\partial \iota }{\partial {\psi }' }  = \Theta_w({\varphi }' + \dot{\psi })  \tag3\]</span></p><p>让 T 表示电机施加到反作用轮上的扭矩。 现在，可以使用欧拉-拉格朗日方程将扭矩 T 作为非势能推导出运动方程。 这产生：</p><p><span class="math display">\[\dot{p}_{\varphi } = \frac{\partial \iota }{\partial \varphi }  = mg\sin \varphi  \tag4\]</span></p><p><span class="math display">\[\dot{p}_{\psi } = \frac{\partial \iota }{\partial \psi }  +T = T \tag5\]</span></p><p>请注意，（2）和（3）中广义动量的引入导致系统的简化表示，其中（4）类似于由（5）中的积分器增强的倒立摆。</p><p>由于反作用轮的实际位置并不重要，我们引入 <span class="math inline">\(x := (\varphi; p_{\varphi}; p_{\psi} )\)</span> 来表示简化的状态集并描述机械系统的动力学如下：</p><p><span class="math display">\[\dot{x} = \begin{pmatrix}\dot{\varphi }  \\\dot{p}_{\varphi }  \\\dot{p}_{\psi }\end{pmatrix} = f(x,T) = \begin{pmatrix}\hat{\Theta_o}^{-1}(p_{\varphi } - p_{\psi })  \\mg\sin \varphi  \\T\end{pmatrix} \tag6\]</span></p><h2 id="analysis">Analysis</h2><p>（1）状态空间：对于后续分析，状态空间定义为：<span class="math inline">\(\chi = {x | \varphi \in (-\pi, \pi ], p_{\varphi }\in \mathcal{R}, p_{\psi }\in \mathcal{R} }\)</span> （2）均衡：系统的均衡由下式给出：<span class="math inline">\(\varepsilon = {(x,T)\in \chi \times \mathcal{R} | f(x,T) = 0 }\)</span> 评估<span class="math inline">\(\dot{p_{\varphi }} = \dot{p_{\psi }} = \dot{\varphi } = 0\)</span>给出以下平衡：</p><p><span class="math display">\[\varepsilon_1 =  \left \{ {(x,T)\in \chi \times \mathcal{R} | \varphi =0 , p_{\varphi } = p_{\psi }, T = 0} \right \}  \tag7\]</span></p><p><span class="math display">\[\varepsilon_2 =  \left \{ {(x,T)\in \chi \times \mathcal{R} | \varphi =\pi  , p_{\varphi } = p_{\psi }, T = 0} \right \}  \tag8\]</span></p><p>每个均衡都是一个封闭的不变量集，其常数 $p_{} $可能不为零。 从机械上讲，这意味着摆锤可以在直立位置静止，而其反作用轮以恒定角速度旋转。 进一步的线性分析表明，在李雅普诺夫的意义上，直立平衡点 <span class="math inline">\(\varepsilon_1\)</span> 是不稳定的，而悬挂平衡点 <span class="math inline">\(\varepsilon_2\)</span> 是稳定的</p><h2 id="control-design">Control Design</h2><p>控制器的目标是将倒立摆驱动到直立位置 $ = 0$ 并使反作用轮的角速度 <span class="math inline">\(\dot{\psi } = 0\)</span> 为零，具体来说：</p><p><span class="math display">\[\lim_{t \to \infty} x = 0 \tag9\]</span></p><p>现在，考虑以下反馈控制律：</p><p><span class="math display">\[u(\varphi ,p_{\varphi }, p_{\psi }) = k_1 mg \sin \varphi + k_2p_{\varphi } - k_3p_{\psi } \tag{10}\]</span></p><p>其中：</p><p><span class="math display">\[k_1 = 1+\alpha \hat{\Theta_0 } + \frac{\beta \gamma }{mg} + \delta   \\k_2 = \frac{\beta }{\hat{\Theta_0 }} \cos \varphi  + \gamma (1 + \alpha \hat{\Theta_0 }) \\k_3 =  \frac{\beta }{\hat{\Theta_0 }} \cos \varphi  + \gamma \\\alpha ,\beta, \gamma ,\delta &gt; 0\]</span></p><p>定理 2.1：（10）中给出的控制律 <span class="math inline">\(T = u(\varphi,p_{\varphi},p_{\psi})\)</span>使得平衡点 <span class="math inline">\(x = 0\)</span>在域$^- = &nbsp;{ = ,p_{= 0,p_{} = 0} } $ 上稳定且渐近稳定</p><p>证明：考虑下面的李雅普诺夫候选函数 $V: x $</p><p><span class="math display">\[V(x) = \frac{1}{2} \alpha p^2_{\varphi } + mg(1 - \cos \varphi ) _ \frac{1}{2 \delta \hat{\Theta_0} }z^2  \tag{11}\]</span></p><p>where <span class="math inline">\(z = z(x) = p_{\varphi } (1 + \alpha \hat{\Theta_0} ) + \beta \sin \varphi - p_{\psi }\)</span>存在类<span class="math inline">\(\kappa_{\propto }^1\)</span>函数$ a(x) :=x^2$ with $&lt; min{  , ,  } $ such that <span class="math inline">\(V（x） \ge a(\left \| p_{\varphi }, \varphi, z \right \| )_2 , \forall x\in \chi\)</span> and <span class="math inline">\(V(0) = 0\)</span> 这里<span class="math inline">\(V(x)\)</span> 是正定和有效的李雅普诺夫候选。 上述李雅普诺夫候选函数沿闭环轨迹的时间导数为：</p><p><span class="math display">\[\begin{aligned}\dot{V}(x) &amp;=\frac{m g}{\hat{\Theta}_{0}}(z-\beta \sin \varphi) \sin \varphi+\frac{1}{\delta \hat{\Theta}_{0}} z \dot{z} \\&amp;=-\frac{m g}{\hat{\Theta}_{0}} \beta \sin ^{2} \varphi-\frac{\gamma}{\delta \hat{\Theta}_{0}} z^{2} \leq 0, \quad \forall x \in \mathcal{X} .\end{aligned}\]</span></p><p>由于$（x） 0, x $ 我们从李雅普诺夫稳定性定理得出结论，点 <span class="math inline">\(x = 0\)</span> 是稳定的。 现在，为了证明 <span class="math inline">\(x = 0\)</span> 在 <span class="math inline">\(\chi^−\)</span> 中的渐近稳定性，让我们定义集合：</p><p><span class="math display">\[\mathcal{R}=\left\{x \in \mathcal{X}^{-} \mid \dot{V}(x)=0\right\}\]</span></p><p>考虑 <span class="math inline">\(\mathcal{R}\)</span> 的不变集内的轨迹 <span class="math inline">\(x(t)\)</span>。显然，它们必须满足 $ = 0, z = 0$ 和系统动力学 (6)。 这意味着 <span class="math inline">\(x(t) ≡ 0\)</span>，因此 <span class="math inline">\(\mathcal{R}\)</span> 中最大的不变量集是 <span class="math inline">\(x = 0\)</span>。 现在，根据 Krasovskii-LaSalle 原理 [9](定理 4.4），对于任何轨迹 <span class="math inline">\(x(t)\)</span>，</p><p><span class="math display">\[\lim _{t \rightarrow \infty} x(t)=0, \quad x(0) \in \mathcal{X}^{-}\]</span></p><p>有关基于一维反作用轮的倒立摆的类似控制设计和稳定性证明，请参见 [10]。</p><h2 id="remarks">Remarks</h2><p>（1）、Lyapunov 函数 (11) 的解释：Lyapunov 函数 (11) 可以通过标准的反推方法 [9]、[10] 找到。 如果忽略反作用轮动力学并且假设 p 是控制输入，则函数<span class="math inline">\(\tilde{V}\left(\varphi, p_{\varphi}\right)=\frac{1}{2} \alpha p_{\varphi}^{2}+m g(1-\cos \varphi)\)</span> 是有效的李雅普诺夫函数候选。 沿轨迹要求<span class="math inline">\(\dot{\tilde{V} } \le 0\)</span>将意味着<span class="math inline">\(p_{\psi}=p_{\varphi}\left(1+\alpha \hat{\Theta}_{0}\right)+\beta \sin \varphi\)</span>，即 <span class="math inline">\(z = 0\)</span>。这导致解释 z 惩罚与控制律的偏差，该偏差将应用于 忽略车轮动力学时的系统。 因此，降低调整参数 δ 会导致更积极的控制器，该控制器将倾斜置于车轮速度之上。 （2）、控制器 (10) 的扩展：Lyapunov 函数 (11) 可以通过额外的积分器状态进行扩充：</p><p><span class="math display">\[\hat{V}(x)=V(x)+\frac{\nu}{2 \delta \hat{\Theta}_{0}} z_{i n t}^{2}\]</span> where <span class="math inline">\(z_{i n t}(t)=z_{0}+\int_{0}^{t} z(\tau) d \tau\)</span> 因此，控制器 (10) 必须扩展 <span class="math inline">\(z_{i n t}, \hat{u}=u+\nu z_{i n t}\)</span> 以提供直立平衡的稳定性。 这对于实际实施也可能很重要，因为它考虑了建模错误。</p><p>控制律（10）的解释：（10）中给出的控制律可以改写为 :</p><p><span class="math display">\[u=\frac{\beta}{m g} \ddot{p}_{\varphi}+k_{1} \dot{p}_{\varphi}+\gamma\left(1+\alpha \hat{\Theta}_{0}\right) p_{\varphi}-\gamma p_{\psi}\]</span></p><p>where ：</p><p><span class="math display">\[p_{\psi}=u_{0}+\int_{0}^{t} u(\tau) d \tau\]</span></p><p>这只不过是由比例、（双）微分和积分部分组成的线性控制器。 此外 $$可以解释为积分器权重。</p><h2 id="system-dynamics-of-the-reaction-wheel-based-3d-inverted-pendulum">SYSTEM DYNAMICS OF THE REACTION WHEEL-BASED 3D INVERTED PENDULUM</h2><p>让 <span class="math inline">\(\Theta_0\)</span> 表示整个 Cubli 围绕枢轴点 O 的总转动惯量（见图 3），<span class="math inline">\(\Theta_{wi};i = 1, 2, 3\)</span> 表示每个反作用轮的转动惯量（在相应旋转轴的方向上）并定义 <span class="math inline">\(\Theta_w := diag(\Theta_{w1}, \Theta_{w2}, \Theta_{w3}), \Theta^0 := \Theta_0 - \Theta_w\)</span>。接下来，让$ $ 表示从枢轴点到重心的位置向量乘以总质量，$ $ 表示重力向量。张量在特定坐标系上的投影由前面的上标表示，即<span class="math inline">\(B \Theta_{0} \in \mathbb{R}^{3 \times 3}, \quad B(\vec{m})=B m \in \mathbb{R}^{3}\)</span>。箭头符号用于强调向量（和张量）应该先验地被认为是赋范向量空间中的线性对象，与其相对于特定坐标系的坐标表示分离。由于身体固定坐标系 ${ B } $ 是最常用的投影坐标系，为了简单起见，我们通常将其前面的上标去掉。进一步注意，<span class="math inline">\({ }^{B} \hat{\Theta}_{0}=\hat{\Theta}_{0} \in \mathbb{R}^{3 \times 3}\)</span>是正定的。</p><p>系统的拉格朗日由下式给出：</p><p><span class="math display">\[\begin{gathered}\mathcal{L}\left(\omega_{h}, g, \omega_{w}, \phi\right)=\frac{1}{2} \omega_{h}{ }^{\mathrm{T}} \hat{\Theta}_{0} \omega_{h}+\frac{1}{2}\left(\omega_{h}+\omega_{w}\right)^{\mathrm{T}} \\\Theta_{w}\left(\omega_{h}+\omega_{w}\right)+m^{\mathrm{T}} g\end{gathered} \tag{12}\]</span></p><p>其中<span class="math inline">\(B\left(\vec{\omega}_{h}\right)=\omega_{h} \in \mathbb{R}^{3}\)</span> 表示主体角速度<span class="math inline">\({ }^{B}\left(\vec{\omega}_{w}\right)=\omega_{w} \in \mathbb{R}^{3}\)</span>表示反作用轮角速度。 <span class="math inline">\(T \in \mathbb{R}^{3}\)</span> 的组件包含施加到反作用轮上的扭矩。 在身体固定坐标系中，向量 m 是常数，而 g 的时间导数由 <span class="math inline">\({ }^{B}(\dot{\vec{g}})=0=\dot{g}+\omega_{h} \times g=\dot{g}+\tilde{\omega}_{h} g\)</span> 给出。 应用于向量 <span class="math inline">\(v \in \mathbb{R}^{3}\)</span> 的波浪号运算符，即 <span class="math inline">\(\tilde{v}\)</span>表示<span class="math inline">\(\tilde{v} a=v \times a \text { holds } \forall a \in \mathbb{R}^{3} \text {. }\)</span> 的偏斜对称矩阵。 介绍广义动量。</p><p><span class="math display">\[\begin{aligned}p_{\omega_{h}}= \frac{\partial \mathcal{L}^{\mathrm{T}}}{\partial \omega_{h}}=\Theta_{0} \omega_{h}+\Theta_{w} \omega_{w}, \tag{13}\end{aligned}\]</span> p_{<em>{w}}= ^{}=</em>{w}(<em>{h}+</em>{w})  $$</p><p>导致运动方程由下式给出：</p><p><span class="math display">\[\begin{aligned}\dot{g} &amp;=-\tilde{\omega}_{h} g, \tag{15}\end{aligned}\]</span></p><p><span class="math display">\[\dot{p}_{\omega_{h}} =-\tilde{\omega}_{h} p_{\omega_{h}}+\tilde{m} g, \tag{16}\]</span></p><p><span class="math display">\[\dot{p}_{\omega_{w}} =T . \tag{17}\]</span></p><p>请注意，有多种推导运动方程的方法； 例如，在 [4] 中使用了虚拟功率的概念。 附录 2 显示了使用拉格朗日形式主义的推导，并强调了 1D 和 3D 情况之间的相似之处。 拉格朗日形式主义也激发了广义动量的引入。</p><p>现在，使用<span class="math inline">\(\dot{\vec{v}}=\dot{v}+\omega_{h} \times v\)</span>，旋转坐标系中向量的时间导数，（15）-（17）可以进一步简化为：</p><p><span class="math display">\[\begin{aligned}\dot{\vec{g}} =0, \tag{18}\end{aligned}\]</span></p><p><span class="math display">\[\dot{\vec{p}}_{\omega_{h}} =\vec{m} \times \vec{g}, \tag{19}\]</span></p><p><span class="math display">\[\dot{p}_{\omega_{w}} =T . \tag{20}\]</span></p><p>这特别突出了 1D 和 3D 倒立摆之间的相似性。 由于向量的范数与其在坐标系中的表示无关，因此脉冲变化的 2 范数由<span class="math inline">\(\left\|\dot{\vec{p}}_{\omega_{h}}\right\|_{2}= \|\vec{m}\|_{2}\|\vec{g}\|_{2} \sin \phi\)</span>给出。 在这种情况下，<span class="math inline">\(\phi\)</span> 表示向量 <span class="math inline">\(\vec{m}\)</span> 和 <span class="math inline">\(\vec{g}\)</span> 之间的角度。 此外，在 1D 情况下，<span class="math inline">\(p_{w_w}\)</span> 是所施加扭矩 T 的积分。</p><h1 id="analysis-1">ANALYSIS</h1><h2 id="conservation-of-angular-momentum">Conservation of Angular Momentum</h2><p>从（19）可以看出$ $ 的变化率总是与<span class="math inline">\(\vec{m}\)</span> 和<span class="math inline">\(\vec{g}\)</span> 正交。 由于<span class="math inline">\(\vec{g}\)</span> 是常数，$ $ 在整个轨迹中永远不会改变它在<span class="math inline">\(\vec{g}\)</span>方向上的分量。 用 Cubli 的身体固定坐标系表示，可以写成<span class="math inline">\(\frac{d}{d t}\left(p_{\omega_{h}}^{\mathrm{T}} g\right) \equiv 0\)</span> 这不过是绕轴角动量守恒~</p><h2 id="state-space">State Space</h2><p>由于后续的分析和控制将在固定体坐标系中进行，状态空间定义为集合 $={x=(g, p_{<em>{h}}, p</em>{<em>{w}}) ^{9} |g|</em>{2}= 9.81} <span class="math inline">\(。 注意\)</span><em>{h}=</em>{0}^{-1}(p_{<em>{h}}-p</em>{_{w}})$。</p><h2 id="equilibria">Equilibria</h2><p>该程序与第 II-B.2 小节中介绍的程序相同。 从 (19) 中可以看出，只有当<span class="math inline">\(m \| g \text {, i.e., } g=\pm \frac{m}{\|m\|_{2}}\|g\|_{2}\)</span> 时，才满足条件 <span class="math inline">\(\dot{\vec{p}}_{\omega_{h}}=0\)</span>。 从 (20) 得出 <span class="math inline">\(p_{w_w} = const, T = 0\)</span>。使用 (15) 和 (16) 导致 <span class="math inline">\(\omega_{h}=\hat{\Theta}_{0}^{-1}\left(p_{\omega_{h}}-p_{\omega_{w}}\right) \| g \text { and } p_{\omega_{h}} \| g\)</span>， 这正好对应于<span class="math inline">\(p_{w_h}\)</span> 的守恒部分。 将所有内容结合在一起会导致以下平衡：</p><p><span class="math display">\[\begin{gathered}\mathcal{E}_{1}=\left\{(x, T) \in \mathcal{X} \times \mathbb{R}^{3} \mid g^{\mathrm{T}} m=-\|g\|_{2}\|m\|_{2},\right. \\\left.p_{\omega_{h}}\left\|m, \hat{\Theta}_{0}^{-1}\left(p_{\omega_{h}}-p_{\omega_{w}}\right)\right\| m, T=0\right\}, \\\mathcal{E}_{2}=\left\{(x, T) \in \mathcal{X} \times \mathbb{R}^{3} \mid g^{\mathrm{T}} m=\|g\|_{2}\|m\|_{2},\right. \\\left.p_{\omega_{h}}\left\|m, \hat{\Theta}_{0}^{-1}\left(p_{\omega_{h}}-p_{\omega_{w}}\right)\right\| m, T=0\right\} .\end{gathered}\]</span></p><p>线性化表明，在李雅普诺夫的意义上，直立平衡点 E1 是不稳定的，而悬挂平衡点 E2 是稳定的。</p><h1 id="nonlinear-control-of-the-reaction-wheel-based-3d-inverted-pendulum">NONLINEAR CONTROL OF THE REACTION WHEEL-BASED 3D INVERTED PENDULUM</h1><p>让我们首先定义控制目标。 由于角动量$ $ 在<span class="math inline">\(\vec{g}\)</span> 的方向上是守恒的，控制器只能将$ $ 的与<span class="math inline">\(\vec{g}\)</span> 正交的分量归零。 因此，将向量 $ $ 分成两部分是很方便的：一个在 <span class="math inline">\(\vec{g}\)</span> 的方向上，另一个与它正交，即： <span class="math display">\[\vec{p}_{\omega_{h}}=\vec{p}_{\omega_{h}}^{\perp}+\vec{p}_{\omega_{h}}^{g} \quad \text { and } \quad \vec{p}_{\omega_{h}}^{g}=\left(\vec{p}_{\omega_{h}}^{\mathrm{T}} \vec{g}\right) \frac{\vec{g}}{\|\vec{g}\|_{2}^{2}} .\]</span></p><p>从 (19) 和角动量守恒，可以直接得出：</p><p><span class="math display">\[B\left(\dot{\vec{p}}_{\omega_{h}}^{\perp}\right)=\dot{p}_{\omega_{h}}^{\perp}+\tilde{\omega}_{h} p_{\omega_{h}}^{\perp}=\tilde{m} g \tag{21}\]</span></p><p>控制目标的另一个合理补充是 Cubli 的角速度 !h 渐近收敛到零。 因此，控制目标可以表述为将系统推向闭不变量：</p><p><span class="math display">\[\begin{aligned}&amp; \mathcal{T}=\left\{x \in \mathcal{X} \mid g^{\mathrm{T}} m=-\|g\|_{2}\|m\|_{2}, \omega_{h}=\hat{\Theta}_{0}^{-1}\left(p_{\omega_{h}}-\right.\right. \left.\left.p_{\omega_{w}}\right)=0, p_{\omega_{h}}^{\perp}=0\right\}\end{aligned}\]</span></p><p>为了证明渐近稳定性，必须排除悬挂平衡（稍后将变得清楚）。 这可以通过引入集合 $^− = $来完成，其中 <span class="math inline">\(x^−\)</span> 表示悬垂平衡 <span class="math inline">\(w_h = 0\)</span>：</p><p><span class="math display">\[x^{-}=\left\{x \in X \mid g=\frac{\|g\|_{2}}{\|m\|_{2}} m, p_{\omega_{h}}^{\perp}=0, p_{\omega_{h}}=p_{\omega_{w}}\right\}\]</span></p><p>接下来，考虑控制器：</p><p><span class="math display">\[u=K_{1} \tilde{m} g+K_{2} \omega_{h}+K_{3} p_{\omega_{h}}-K_{4} p_{\omega_{w}} \tag{22}\]</span></p><p>where：</p><p><span class="math display">\[\begin{aligned}&amp;K_{1}=(1+\beta \gamma+\delta) I+\alpha \hat{\Theta}_{0} \\&amp;K_{2}=\alpha \hat{\Theta}_{0} \tilde{p}_{\omega_{h}}^{\perp}+\beta \tilde{m} \tilde{g}+\tilde{p}_{\omega_{h}} \\&amp;K_{3}=\gamma\left(I+\alpha \hat{\Theta}_{0}\left(I-\frac{g g^{\mathrm{T}}}{\|g\|_{2}^{2}}\right)\right) \\&amp;K_{4}=\gamma I, \quad \alpha, \beta, \gamma, \delta&gt;0\end{aligned}\]</span></p><p>and <span class="math inline">\(I \in \mathbb{R}^{3 \times 3}\)</span> is the identity matrix</p><p>定理 5.1：（22）中给出的控制器使由（18）-（20）定义的系统的闭不变集 $$在 $x ^- $ 上稳定和渐近稳定。</p><p>证明：考虑以下李雅普诺夫候选函数$x  $：</p><p><span class="math display">\[V(x)=\frac{1}{2} \alpha p_{\omega_{h}}^{\perp}{^{\mathrm{T}}} p_{\omega_{h}}^{\perp}+m^{\mathrm{T}} g+\|m\|_{2}\|g\|_{2}+\frac{1}{2 \delta} z^{\mathrm{T}} \hat{\Theta}_{0}^{-1} z \tag{23}\]</span></p><p>with：</p><p><span class="math display">\[z=z(x)=\alpha \hat{\Theta}_{0} p_{\omega_{h}}^{\perp}+p_{\omega_{h}}+\beta \tilde{m} g-p_{\omega_{w}}\]</span></p><p>当<span class="math inline">\(\mathcal{K}_{\infty}\)</span>函数<span class="math inline">\(a(x):=\epsilon x^{2}, \text { with } \epsilon&lt; \min \left\{\frac{2}{\pi^{2}}\|m\|_{2}\|g\|_{2}, \frac{1}{2 \delta\left\|\hat{\Theta}_{0}\right\|_{2}}, \frac{\alpha}{2}\right\}\)</span> is such that <span class="math inline">\(V(x) \ge a\left(\left\|\left(p_{\omega_{h}}, p_{\omega_{w}}, z\right)\right\|_{2}\right), \forall x \in \mathcal{X}\)</span> 此外<span class="math inline">\(V(x = x_0) = 0\)</span> 意味着 <span class="math inline">\(x = x_0\)</span>，其中 $x_0 $ 。 因此 V 是一个正定函数和一个有效的 Lyapunov 候选</p><p>接下来，沿着闭环系统的轨迹评估 $ $：</p><p><span class="math display">\[\begin{aligned}\dot{V}(x) &amp;=\alpha p_{\omega_{h}}^{\perp}{p}_{\omega_{h}}^{\perp}+m^{\mathrm{T}} \dot{g}+\frac{1}{\delta} z^{\mathrm{T}} \hat{\Theta}_{0}^{-1} \dot{z} \\&amp;=m^{\mathrm{T}} \tilde{g} \hat{\Theta}_{0}^{-1}(\beta \tilde{g} m+z)+\frac{1}{\delta} z^{\mathrm{T}} \hat{\Theta}_{0}^{-1} \dot{z} \\&amp;=-\beta(\tilde{g} m)^{\mathrm{T}} \hat{\Theta}_{0}^{-1}(\tilde{g} m)+z^{\mathrm{T}} \hat{\Theta}_{0}^{-1}\left(\tilde{m} g+\frac{1}{\delta} \dot{z}\right) \\&amp;=-\beta(\tilde{g} m)^{\mathrm{T}} \hat{\Theta}_{0}^{-1}(\tilde{g} m)-\frac{\gamma}{\delta} z^{\mathrm{T}} \hat{\Theta}_{0}^{-1} z \leq 0, \forall x \in \mathcal{X} .\end{aligned}\]</span></p><p>由于 <span class="math inline">\(\dot{V}(x) \leq 0 , \forall x \in \mathcal{X}\)</span>，我们从李雅普诺夫稳定性定理得出结论，点 $x_0 $是稳定的：</p><p>为了证明集合 <span class="math inline">\(\tau\)</span> 在 <span class="math inline">\(\chi^−\)</span> 中的渐近稳定性，定义集合 <span class="math inline">\(\mathcal{R}:=\{x \in \mathcal{X}-\mid \dot{V}(x)=0\}\)</span>。 条件 <span class="math inline">\(\dot{V}(x) = 0\)</span> 立即导致 <span class="math inline">\(z = 0, m || g\)</span>，使得<span class="math inline">\(\mathcal{R}\)</span> 可以重写为 <span class="math inline">\(\mathcal{R}=\left\{x \in \mathcal{X}^{-} \mid m \| g, p_{\omega_{w}}=\alpha \hat{\Theta}_{0} p_{\omega_{h}}^{\perp}+p_{\omega_{h}}\right\}\)</span>。 现在，让我们考虑包含在 <span class="math inline">\(\mathcal{R}\)</span> 中的不变集内轨迹的系统动力学。这给出：</p><p><span class="math display">\[\begin{aligned}g \| m &amp; \Rightarrow g=-\frac{m}{\|m\|_{2}}\|g\|_{2} \Rightarrow \dot{g}=0 \\&amp; \Rightarrow \omega_{h} \| g \quad \because \dot{g}=-\tilde{\omega}_{h} g \\\end{aligned} \tag{24}\]</span></p><p><span class="math display">\[g \| m, z=0  \Rightarrow \omega_{h}=\alpha p_{\omega_{h}}^{\perp} \\ \Rightarrow \omega_{h} \| p_{\omega_{h}}^{\perp} \tag{25}\]</span></p><p>然而，由于 <span class="math inline">\(p_{w_h}^{\perp} \perp g\)</span> 根据定义，(24) 和 (25) 意味着 <span class="math inline">\(w_h = 0\)</span> 和$ p_{w_h}^{} = 0$。这表明 $$ 是 $ $ 的最大不变子集。现在，根据 Krasovskii-LaSalle 原理 [9](定理 4.4） ，由此可知，对于任何轨迹$ x(t)$：</p><p><span class="math display">\[\lim _{t \rightarrow \infty} x(t)=x_{f}, \quad x(0) \in \mathcal{X}^{-}, \quad x_{f} \in \mathcal{T}\]</span></p><h2 id="remarks-1">Remarks</h2>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件系统（三）VFS</title>
      <link href="/next/2021/LinuxKernel/LinuxFileSystemVFS/"/>
      <url>/next/2021/LinuxKernel/LinuxFileSystemVFS/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/LinuxFSVFS.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjNhYmExNzdkOWMwODA3MGU1YjkwODc=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="通用文件系统接口">通用文件系统接口</h1><p>VFS 使得用户可以直接使用 open()、read() 和 write() 这样的系统调用而无须考虑具体文件系统和实际物理介质，使得这些通用的系统调用可以跨越各种文件系统和不同介质执行。</p><p>Unix 使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点 (mount point)。</p><h1 id="vfs-对象及其数据结构">VFS 对象及其数据结构</h1><p>VFS 其实采用的是面向对象的设计思路，使用一组数据结构来代表通用文件对象，有四个主要的对象类型，它们分别是：</p><ul><li>超级块对象，它代表一个具体的已安装文件系统</li><li>索引节点对象，它代表一个具体文件</li><li>目录项对象，它代表一个目录项，是路径的一个组成部分</li><li>文件对象，它代表由进程打开的文件</li></ul><blockquote><p>注意，因为 VFS 将目录作为一个文件来处理，所以不存在目录对象。</p></blockquote><p>每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：</p><ul><li>super_operations 对象，其中包括内核针对特定文件系统所能调用的方法，比如 write_inode() 和 sync_fs() 等方法</li><li>inode_operations 对象，其中包括内核针对特定文件所能调用的方法，比如 create() 和 link() 等方法</li><li>dentry_operations 对象，其中包括内核针对特定目录所能调用的方法，比如 d_compare() 和 d_delete() 等方法</li><li>file_operations 对象，其中包括进程针对已打开文件所能调用的方法，比如 read() 和 write() 等方法</li></ul><p>操作对象作为一个结构体指针来实现，此结构体中包含指向操作其父对象的函数指针。</p><h2 id="超级块对象">超级块对象</h2><p>各种文件系统都必须实现超级块对象，该对象用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块（所以称为超级块对象）。对于并非基于磁盘的文件系统（如基于内存的文件系统，比如 sysfs），它们会在使用现场创建超级块并将其保存到内存中。超级块对象由 super block 结构体表示，定义在文件《linux/fs.h》中，下面给出它的结构和各个域的描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_list</span>;</span><span class="comment">/* Keep this first */</span></span><br><span class="line"><span class="type">dev_t</span>s_dev;<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>s_blocksize_bits;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_blocksize;</span><br><span class="line"><span class="type">loff_t</span>s_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_iflags;<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_magic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">s_umount</span>;</span></span><br><span class="line"><span class="type">int</span>s_count;</span><br><span class="line"><span class="type">atomic_t</span>s_active;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>                    *s_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_operations</span>*<span class="title">s_cop</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">s_master_keys</span>;</span> <span class="comment">/* master crypto keys in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_operations</span> *<span class="title">s_vop</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UNICODE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unicode_map</span> *<span class="title">s_encoding</span>;</span></span><br><span class="line">__u16 s_encoding_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span><span class="title">s_roots</span>;</span><span class="comment">/* alternate root dentries for NFS */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_mounts</span>;</span><span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">s_instances</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>s_quota_types;<span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quota_info</span><span class="title">s_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sb_writers</span><span class="title">s_writers</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and</span></span><br><span class="line"><span class="comment"> * s_fsnotify_marks together for cache efficiency. They are frequently</span></span><br><span class="line"><span class="comment"> * accessed and rarely modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>*s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Granularity of c/m/atime in ns (cannot be worse than a second) */</span></span><br><span class="line">u32s_time_gran;</span><br><span class="line"><span class="comment">/* Time limits for c/m/atime in seconds */</span></span><br><span class="line"><span class="type">time64_t</span>   s_time_min;</span><br><span class="line"><span class="type">time64_t</span>   s_time_max;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">__u32s_fsnotify_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>*<span class="title">s_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line"><span class="type">uuid_t</span>s_uuid;<span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>s_max_links;</span><br><span class="line"><span class="type">fmode_t</span>s_mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment"> * even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment"> * in /proc/mounts will be "type.subtype"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Saved pool identifier for cleancache (-1 means none)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> cleancache_poolid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span><span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line"><span class="type">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of inode/mount/sb objects that are being watched, note that</span></span><br><span class="line"><span class="comment"> * inodes objects are currently double-accounted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_long_t</span> s_fsnotify_connectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Being remounted read-only */</span></span><br><span class="line"><span class="type">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* per-sb errseq_t for reporting writeback errors via syncfs */</span></span><br><span class="line"><span class="type">errseq_t</span> s_wb_err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">s_dio_done_wq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">s_pins</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Owning user namespace and default context in which to</span></span><br><span class="line"><span class="comment"> * interpret filesystem uids, gids, quotas, device nodes,</span></span><br><span class="line"><span class="comment"> * xattrs and security labels.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">s_user_ns</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The list_lru structure is essentially just a pointer to a table</span></span><br><span class="line"><span class="comment"> * of per-node lru lists, each of which has its own spinlock.</span></span><br><span class="line"><span class="comment"> * There is no need to put them into separate cachelines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span><span class="title">s_dentry_lru</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span><span class="title">s_inode_lru</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span><span class="title">destroy_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">s_sync_lock</span>;</span><span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line"><span class="type">spinlock_t</span>s_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span>s_inode_wblist_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_inodes_wb</span>;</span><span class="comment">/* writeback inodes */</span></span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>创建、管理和撤销超级块对象的代码位于文件 fs/super.c 中。超级块对象通过 alloc_super() 函数创建并初始化。在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。</p><h3 id="超级块操作">超级块操作</h3><p>超级块对象中最重要的一个域是 s_op，它指向超级块的操作函数表。超级块操作函数表由 super_operations 结构体表示，定义在文件《linux/fs.h》中，其形式如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> {</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line"><span class="type">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line"><span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line"><span class="type">int</span> (*drop_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line"><span class="type">void</span> (*evict_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line"><span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="type">int</span> (*sync_fs)(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait);</span><br><span class="line"><span class="type">int</span> (*freeze_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="type">int</span> (*freeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="type">int</span> (*thaw_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="type">int</span> (*unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="type">int</span> (*statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line"><span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line"><span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*show_options)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*show_devname)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*show_path)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*show_stats)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line"><span class="type">ssize_t</span> (*quota_read)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*quota_write)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> **(*<span class="title">get_dquots</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">long</span> (*nr_cached_objects)(<span class="keyword">struct</span> super_block *,</span><br><span class="line">  <span class="keyword">struct</span> shrink_control *);</span><br><span class="line"><span class="type">long</span> (*free_cached_objects)(<span class="keyword">struct</span> super_block *,</span><br><span class="line">    <span class="keyword">struct</span> shrink_control *);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>该结构体中的每一项都是一个指向超级块操作函数的指针，超级块操作函数执行文件系统和索引节点的底层操作。当文件系统需要对其超级块执行操作时，首先要在超级块对象中寻找需要的操作方法。</p><p>下面给出 super_operation 中，超级块操作函数的用法。</p><ul><li>alloc_inode: 在给定的超级块下创建和初始化一个新的索引节点对象</li><li>destroy_inode: 用于释放给定的索引节点</li><li>dirty_inode: VFS 在索引节点脏（被修改）时会调用此函数。日志文件系统（如 ext3 和 ext4）执行该函数进行日志更新</li><li>write_inode: 用于将给定的索引节点写入磁盘。wait 参数指明写操作是否需要同步</li><li>...</li></ul><h3 id="索引节点对象">索引节点对象</h3><p>索引节点对象包含了内核在操作文件或目录时需要的全部信息。对于 Unix 风格的文件系统来说，这些信息可以从磁盘索引节点直接读入。 索引节点对象由 inode 结构体表示，它定义在文件《linux/fs.h》中，下面给出它的结构体和各项的描述。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> * the RCU path lookup and 'stat' data) fields at the beginning</span></span><br><span class="line"><span class="comment"> * of the 'struct inode'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> {</span></span><br><span class="line"><span class="type">umode_t</span>i_mode;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>i_opflags;</span><br><span class="line"><span class="type">kuid_t</span>i_uid;</span><br><span class="line"><span class="type">kgid_t</span>i_gid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>*<span class="title">i_acl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>*<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>*<span class="title">i_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>*<span class="title">i_sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>*<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*i_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_ino;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment"> * following functions for modification:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment"> *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">};</span><br><span class="line"><span class="type">dev_t</span>i_rdev;</span><br><span class="line"><span class="type">loff_t</span>i_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span><span class="title">i_atime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span><span class="title">i_mtime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span><span class="title">i_ctime</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>i_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">u8i_blkbits;</span><br><span class="line">u8i_write_hint;</span><br><span class="line"><span class="type">blkcnt_t</span>i_blocks;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line"><span class="type">seqcount_t</span>i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>i_state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dirtied_time_when;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">i_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>*<span class="title">i_wb</span>;</span><span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line"><span class="type">int</span>i_wb_frn_winner;</span><br><span class="line">u16i_wb_frn_avg_time;</span><br><span class="line">u16i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_sb_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_wb_list</span>;</span><span class="comment">/* backing dev writeback list */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">i_dentry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">i_rcu</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="type">atomic64_t</span>i_version;</span><br><span class="line"><span class="type">atomic64_t</span>i_sequence; <span class="comment">/* see futex */</span></span><br><span class="line"><span class="type">atomic_t</span>i_count;</span><br><span class="line"><span class="type">atomic_t</span>i_dio_count;</span><br><span class="line"><span class="type">atomic_t</span>i_writecount;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line"><span class="type">atomic_t</span>i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line"><span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>*<span class="title">i_flctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span><span class="title">i_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">i_devices</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>*<span class="title">i_pipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>*<span class="title">i_cdev</span>;</span></span><br><span class="line"><span class="type">char</span>*i_link;</span><br><span class="line"><span class="type">unsigned</span>i_dir_seq;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">__u32i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">__u32i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>*<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>*<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span>*<span class="title">i_verity_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>一个索引节点代表文件系统中（但是索引节点仅当文件被访问时，才在内存中创建）的一个文件，它也可以是设备或管道这样的特殊文件。因此索引节点结构体中有一些和特殊文件相关的项，比如 i_pipe 项就指向一个代表有名管道的数据结构，i_bdev 指向块设备结构体，i_cdev 指向字符设备结构体。这三个指针被存放在一个公用体中，因为一个给定的索引节点每次只能表示三者之一（或三者均不）。</p><h3 id="索引节点操作">索引节点操作</h3><p>和超级块操作一样，索引节点对象中的 inode_operations 项也非常重要，因为它描述了 VFS 用以操作索引节点对象的所有方法，这些方法由文件系统实现。与超级块类似，对索引节点的操作调用方式如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i-&gt;i_op-&gt;truncate(i)</span><br></pre></td></tr></tbody></table></figure><p>i 指向给定的索引节点，truncate() 函数是由索引节点 i 所在的文件系统定义的。inode_operations 结构体定义在文件《linux/fs.h》中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * (*get_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> delayed_call *);</span><br><span class="line"><span class="type">int</span> (*permission) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>, <span class="title">bool</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*create) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,</span><br><span class="line">       <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line"><span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*symlink) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"><span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,</span><br><span class="line">      <span class="type">umode_t</span>);</span><br><span class="line"><span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*mknod) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,</span><br><span class="line">      <span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line"><span class="type">int</span> (*rename) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*setattr) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="keyword">struct</span> iattr *);</span><br><span class="line"><span class="type">int</span> (*getattr) (<span class="keyword">struct</span> user_namespace *, <span class="type">const</span> <span class="keyword">struct</span> path *,</span><br><span class="line"><span class="keyword">struct</span> kstat *, u32, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">      u64 len);</span><br><span class="line"><span class="type">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec64 *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*<span class="type">atomic_open</span>)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">   <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">   <span class="type">umode_t</span> create_mode);</span><br><span class="line"><span class="type">int</span> (*tmpfile) (<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,</span><br><span class="line"><span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>);</span><br><span class="line"><span class="type">int</span> (*set_acl)(<span class="keyword">struct</span> user_namespace *, <span class="keyword">struct</span> inode *,</span><br><span class="line">       <span class="keyword">struct</span> posix_acl *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*fileattr_set)(<span class="keyword">struct</span> user_namespace *mnt_userns,</span><br><span class="line">    <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> fileattr *fa);</span><br><span class="line"><span class="type">int</span> (*fileattr_get)(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> fileattr *fa);</span><br><span class="line">} ____cacheline_aligned;</span><br></pre></td></tr></tbody></table></figure><p>下面这些接口由各种函数组成，在给定的节点上，可能由 VF 执行这些函数，也可能由具体的文件系统执行：</p><ul><li>create: VFS 通过系统调用 create() 和 open() 来调用该函数，从而为 dentry 对象创建一个新的索引节点。在创建时使用 mode 指定的初始模式</li><li>lookup: 该函数在特定目录中寻找索引节点，该索引节点要对应于 denrty 中给出的文件名</li><li>link: 该函数被系统调用 link() 调用，用来创建硬连接。硬连接名称由 dentry 参数指定，连接对象是 dir 目录中 old_dentry 目录项所代表的文件</li><li>unlink: 该函数被系统调用 unlinkO() 调用，从目录 dir 中删除由目录项 dentry 指定的索引节点对象</li><li>symlink: 该函数被系统调用 symlik() 调用，创建符号连接。该符号连接名称由 symname 指定，连接对象是 dir 目录中的 dentry 目录项</li><li>mkdir: 该函数被系统调用 mkdir() 调用，创建一个新目录。创建时使用 mode 指定的初始模式</li><li>rmdir: 该函数被系统调用 rmdir() 调用，删除 dir 目录中的 dentry 目录项代表的文件</li><li>...</li></ul><h2 id="目录项对象">目录项对象</h2><p>VFS 把目录当作文件对待，虽然它们可以统一由索引节点表示，但是 VFS 经常需要执行目录相关的操作，比如路径名查找等，为了方便查找操作，VFS 引入了目录项的概念。每个 dentry 代表路径中的一个特定部分。解析一个路径并遍历其分量绝非简单，它是耗时的、常规的字符串比较过程，执行耗时、代码繁琐。目录项对象的引入使得这个过程更加简单。目录项也可包括安装点。VFS 在执行目录操作时会现场创建目录项对象。 目录项对象由 dentry 结构体表示，定义在文件《linux/dcache.h》中。下面给出该结构体和其中各项的描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> {</span></span><br><span class="line"><span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line"><span class="type">seqcount_spinlock_t</span> d_seq;<span class="comment">/* per dentry seqlock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment"> * negative */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN];<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span><span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> d_time;<span class="comment">/* used by d_revalidate */</span></span><br><span class="line"><span class="type">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> *d_wait;<span class="comment">/* in-lookup ones only */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span><span class="comment">/* only for in-lookup ones */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">} d_u;</span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>与前面的两个对象不同，目录项对象没有对应的磁盘数据结构，VFS 根据字符串形式的路径名现场创建它。而且由于目录项对象并非真正保存在磁盘上，所以目录项结构体没有是否被修改的标志（也就是是否为脏、是否需要写回磁盘的标志）。</p><h3 id="目录项状态">目录项状态</h3><p>目录项对象有三种有效状态：被使用、未被使用和负状态。</p><ul><li>一个被使用的目录项对应一个有效的索引节点（即 d_inode 指向相应的索引节点）并且表明该对象存在一个或多个使用者（即 d_count 为正值）</li><li>一个未被使用的目录项对应一个有效的索引节点（d_inode 指向一个索引节点），但是应指明 VFS 当前并未使用它（d_count 为 O）。该目录项对象仍然指向一个有效对象，而且被保留在缓存中以便需要时再使用它</li><li>一个负状态的目录项没有对应的有效索引节点（d_inode 为 NULL），因为索引节点已被删除了，或路径不再正确了，但是目录项仍然保留，以便快速解析以后的路径查询。比如，一个守护进程不断地去试图打开并读取一个不存在的配置文件。open() 系统调用不断地返回 ENOENT，直到内核构建了这个路径、遍历磁盘上的目录结构体并检查这个文件的确不存在为止。即便这个失败的查找很浪费资源，但是将负状态缓存起来还是非常值得的</li></ul><h3 id="目录项缓存">目录项缓存</h3><p>如果 VFS 层遍历路径名中所有的元素并将它们逐个地解析成目录项对象，还要到达最深层目录，将是一件非常费力的工作，会浪费大量的时间。所以内核将目录项对象缓存在目录项缓存（简称 dcache）中。 目录项缓存包括三个主要部分：</p><ul><li>“被使用的”目录项链表。该链表通过索引节点对象中的 i_dentry 项连接相关的索引节点，因为一个给定的索引节点可能有多个链接，所以就可能有多个目录项对象，因此用一个链表来连接它们</li><li>“最近被使用的”双向链表。该链表含有未被使用的和负状态的目录项对象。由于该链总是在头部插入目录项，所以链头节点的数据总比链尾的数据要新</li><li>散列表和相应的散列函数用来快速地将给定路径解析为相关目录项对象</li></ul><p>举例说明，假设你需要在自己目录中编译一个源文件，/home/dracula/src/the_sun _sucks.c，每一次对文件进行访问（比如说，首先要打开它，然后要存储它，还要进行编译等），VFS 都必须沿着嵌套的目录依次解析全部路径：/、home、dracula、src 和最终的 the_sun_sucks.c。为了避免每次访问该路径名都进行这种耗时的操作，VFS 会先在目录项缓存中搜索路径名，如果找到了，就无须花费那么大的力气了。相反，如果该目录项在目录项缓存中并不存在，VFS 就必须自己通过遍历文件系统为每个路径分量解析路径，解析完毕后，再将目录项对象加入 dcache 中，以便以后可以快速查找到它。</p><p>而 dcache 在一定意义上也提供对索引节点的缓存，也就是 icache。和目录项对象相关的索引节点对象不会被释放，因为目录项会让相关索引节点的使用计数为正，这样就可以确保索引节点留在内存中。只要目录项被缓存，其相应的索引节点也就被缓存了。</p><p>因为文件访问呈现空间和时间的局部性，所以对目录项和索引节点进行缓存非常有益。</p><h3 id="目录项操作">目录项操作</h3><p>dentry_operation 结构体指明了 VFS 操作目录项的所有方法。该结构定义在文件《linux/dcache.h》中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> {</span></span><br><span class="line"><span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*d_weak_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*d_hash)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</span><br><span class="line"><span class="type">int</span> (*d_compare)(<span class="type">const</span> <span class="keyword">struct</span> dentry *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> qstr *);</span><br><span class="line"><span class="type">int</span> (*d_delete)(<span class="type">const</span> <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">int</span> (*d_init)(<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">void</span> (*d_prune)(<span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line"><span class="type">char</span> *(*d_dname)(<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *(*<span class="title">d_automount</span>)(<span class="keyword">struct</span> <span class="title">path</span> *);</span></span><br><span class="line"><span class="type">int</span> (*d_manage)(<span class="type">const</span> <span class="keyword">struct</span> path *, <span class="type">bool</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">d_real</span>)(<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line">} ____cacheline_aligned;</span><br></pre></td></tr></tbody></table></figure><p>下面给出函数的具体用法：</p><ul><li>d_revalidate: 该函数判断目录对象是否有效。VFS 准备从 dcache 中使用一个目录项时，会调用该函数。大部分文件系统将该方法置 NULL，因为它们认为 dcache 中的目录项对象总是有效的</li><li>d_hash: 该函数为目录项生成散列值，当目录项需要加入到散列表中时，VF 调用该函数</li><li>d_compare: VFS 调用该函数来比较 namel 和 name2 这两个文件名。多数文件系统使用 VFS 默认的操作，仅仅作字符串比较。对有些文件系统，比如 FAT，简单的字符串比较不能满足其需要。因为 FAT 文件系统不区分大小写，所以需要实现一种不区分大小写的字符串比较函数。注意使用该函数时需要加 dcache_lock 锁</li><li>d_delete: 当目录项对象的 d_count 计数值等于 O 时，VFS 调用该函数。注意使用该函数需要加 dcache_lock 锁和目录项的 d_lock</li><li>d_release: 当目录项对象将要被释放时，VFS 调用该函数，默认情况下，它什么也不做</li><li>d_iput: 当一个目录项对象丢失了其相关的索引节点时（也就是说磁盘索引节点被删除了），VFS 调用该函数。默认情况下 VFS 会调用 iput() 函数释放索引节点。如果文件系统重载了该函数，那么除了执行此文件系统特殊的工作外，还必须调用 iput() 函数</li></ul><h2 id="文件对象">文件对象</h2><p>VFS 的最后一个主要对象是文件对象。文件对象表示进程已打开的文件。文件对象包含我们非常熟悉的信息（如访问模式，当前偏移等），同样道理，文件操作和我们非常熟悉的系统调用 read() 和 write() 等也很类似。文件对象是已打开的文件在内存中的表示。该对象（不是物理文件）由相应的 open() 系统调用创建，由 close() 系统调用撤销，所有这些文件相关的调用实际上都是文件操作表中定义的方法。因为多个进程可以同时打开和操作同一个文件，所以同一个文件也可能存在多个对应的文件对象。文件对象仅仅在进程观点上代表已打开文件，它反过来指向目录项对象（反过来指向索引节点），其实只有目录项对象才表示已打开的实际文件。虽然一个文件对应的文件对象不是唯一的，但对应的索引节点和目录项对象无疑是唯一的。 文件对象由 file 结构体表示，定义在文件《linux/fs.h》中，下面给出该结构体和各项的描述。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span><span class="title">fu_llist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">} f_u;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span><span class="title">f_path</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment"> * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">spinlock_t</span>f_lock;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span><span class="title">f_write_hint</span>;</span></span><br><span class="line"><span class="type">atomic_long_t</span>f_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line"><span class="type">fmode_t</span>f_mode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">f_pos_lock</span>;</span></span><br><span class="line"><span class="type">loff_t</span>f_pos;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span><span class="title">f_owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>*<span class="title">f_cred</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span><span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">u64f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line"><span class="type">void</span>*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line"><span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>*<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="type">errseq_t</span>f_wb_err;</span><br><span class="line"><span class="type">errseq_t</span>f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">} __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></tbody></table></figure><p>类似于目录项对象，文件对象实际上没有对应的磁盘数据。所以在结构体中没有代表其对象是否为脏、是否需要写回磁盘的标志。文件对象通过 f_dentry 指针指向相关的目录项对象。目录项会指向相关的索引节点，索引节点会记录文件是否是脏的。</p><h3 id="文件操作">文件操作</h3><p>和 VFS 的其他对象一样，文件操作表在文件对象中也非常重要。跟 file 结构体相关的操作与系统调用很类似，这些操作是标准 Unix 系统调用的基础。 文件对象的操作由 file_operations 结构体表示，定义在文件&lt;linux/fs.h&gt;中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="type">bool</span> spin);</span><br><span class="line"><span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line"><span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line"><span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>具体的文件系统可以为每一种操作做专门的实现，或者如果存在通用操作，也可以使用通用操作。一般在基于 Unix 的文件系统上，这些通用操作效果都不错。并不要求实际文件系统实现文件操作函数表中的所有方法—一虽然不实现最基础的那些操作显然是很不明智的，对不感兴趣的操作完全可以简单地将该函数指针置为 NULL。 下面给出操作的用法说明：</p><ul><li>lleek: 该函数用于更新偏移量指针，由系统调用 lleek() 调用它</li><li>read: 该函数从给定文件的 offset 偏移处读取 conut 字节的数据到 buf 中，同时更新文件指针。由系统调用 read() 调用它</li><li>aio_read: 该函数从 iocb 描述的文件里，以同步方式读取 count 字节的数据到 buf 中。由系统调用 aio_read() 调用它</li><li>write: 该函数从给定的 buf 中取出 conut 字节的数据，写入给定文件的 offset 偏移处，同时更新文件指针。由系统调用 write() 调用它</li><li>aio_write: 该函数以同步方式从给定的 buf 中取出 conut 字节的数据，写入由 iocb 描述的文件中。由系统调用 aio_write() 调用它</li><li>readdir: 该函数返回目录列表中的下一个目录。由系统调用 readdir() 调用它</li><li>poll: 该函数睡眠等待给定文件活动。由系统调用 poll() 调用它</li><li>ioctl: 该函数用来给设备发送命令参数对。当文件是一个被打开的设备节点时，可以通过它进行设置操作。由系统调用 ioctl() 调用它。调用者必须持有 BKL</li><li>unlocked_ioctl: 其实现与 ioctl() 有类似的功能，只不过不需要调用者持有 BKL。如果用户空间调用 ioctl() 系统调用，VFS 便可以调用 unlocked_ioctl()（凡是 ioctl() 出现的场所）。因此文件系统只需要实现其中的一个，一般优先实现 unlocked_ioctl()</li><li>...</li></ul><h1 id="和文件系统相关的数据结构">和文件系统相关的数据结构</h1><p>除了以上几种 VFS 基础对象外，内核还使用了另外一些标准数据结构来管理文件系统的其他相关数据。第一个对象是 file_system_type，用来描述各种特定文件系统类型，比如 ext3、ext4 或 UDF。第二个结构体是 vfsmount，用来描述一个安装文件系统的实例。</p><p>因为 Linux 支持众多不同的文件系统，所以内核必须由一个特殊的结构来描述每种文件系统的功能和行为。file_system_type 结构体被定义在《linux/fs.h》中，具体实现如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT8<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_DISALLOW_NOTIFY_PERM16<span class="comment">/* Disable fanotify permission events */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ALLOW_IDMAP         32      <span class="comment">/* FS has been updated to handle vfs idmappings. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_THP_SUPPORT8192<span class="comment">/* Remove once all fs converted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE32768<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line"><span class="type">int</span> (*init_fs_context)(<span class="keyword">struct</span> fs_context *);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line"><span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">invalidate_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>每种文件系统，不管有多少个实例安装到系统中，还是根本就没有安装到系统中，都只有一个 file_system_type 结构。 更有趣的事情是，当文件系统被实际安装时，将有一个 vfsmount 结构体在安装点被创建。该结构体用来代表文件系统的实例—一换句话说，代表一个安装点。 vfsmount 结构被定义在《linux/mount.h》中，下面是具体结构：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span><span class="comment">/* root of the mounted tree */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span><span class="comment">/* pointer to superblock */</span></span><br><span class="line"><span class="type">int</span> mnt_flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">mnt_userns</span>;</span></span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><h1 id="和进程相关的数据结构">和进程相关的数据结构</h1><p>系统中的每一个进程都有自己的一组打开的文件，像根文件系统、当前工作目录、安装点等。有三个数据结构将 VFS 层和系统的进程紧密联系在一起，它们分别是：file_struct、fs_struct 结构体。 file_struct 结构体定义在文件《linux/fdtable.h》中。该结构体由进程描述符中的 files 目录项指向。所有与单个进程（per-process）相关的信息、（如打开的文件及文件描述符）都包含在其中，其结构和描述如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> {</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">atomic_t</span> count;</span><br><span class="line"><span class="type">bool</span> resize_in_progress;</span><br><span class="line"><span class="type">wait_queue_head_t</span> resize_wait;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> next_fd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>fd_array 数组指针指向已打开的文件对象。因为 NR_OPEN_DEFAULT 等于 BITS_PER_LONG，在 64 位机器体系结构中这个宏的值为 64，所以该数组可以容纳 64 个文件对象。如果一个进程所打开的文件对象超过 6 个，内核将分配一个新数组，并且将 fdt 指针指向它。所以对适当数量的文件对象的访问会执行得很快，因为它是对静态数组进行的操作；如果一个进程打开的文件数量过多，那么内核就需要建立新数组。所以如果系统中有大量的进程都要打开超过 6 个文件，为了优化性能，管理员可以适当增大 NR_OPEN_DEFAULT 的预定义值。 和进程相关的第二个结构体是 fs_struct. 该结构由进程描述符的 fs 域指向。它包含文件系统和进程相关的信息，定义在文件《linux/fs_struct.h》中，下面是它的具体结构体和各项描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> {</span></span><br><span class="line"><span class="type">int</span> users;</span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="type">seqcount_spinlock_t</span> seq;</span><br><span class="line"><span class="type">int</span> umask;</span><br><span class="line"><span class="type">int</span> in_exec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>该结构包含了当前进程的当前工作目录（pwd）和根目录。</p><h1 id="参考文献">参考文献</h1><p>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> FileSystem </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件系统（一）基本概念</title>
      <link href="/next/2021/LinuxKernel/LinuxFileSystemBasic/"/>
      <url>/next/2021/LinuxKernel/LinuxFileSystemBasic/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/FSBasic.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjNhYjMyOTFlMDg1MzA2ZjhjZDczYTk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><blockquote><p>声明：本文转载自 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDY0NTk0NDU=">文件系统的原理<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAzMjkxNzc=">Linux 中的 VFS 实现 [一]<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>没有文件系统，访问磁盘上的数据就需要直接读写磁盘的 sector（繁琐），而文件系统存在的意义，就是能更有效的组织、管理和使用磁盘上的 raw data。</p><h1 id="文件系统的组成">文件系统的组成</h1><p>因为磁盘上的数据要和内存交互，而内存通常是以 4KB 为单位管理的，所以把磁盘按照 4KB 划分比较方便（称为一个 block）。现在假设由一个文件系统管理 64 个 blocks 的一个磁盘区域： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem1.png"></p><h2 id="文件">文件</h2><p>文件系统的基础要素自然是文件，而文件作为一个数据容器的逻辑概念，本质上是字节构成的集合，这些字节就是文件的 user data（对应下图的"D"）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem2.jpg"></p><p>除了文件本身包含的数据，还有文件的访问权限、大小和创建时间等控制信息，这些信息被称为文件的 meta data。这些 meta data 的数据结构就是 inode（对应下图的"I"，有些文件系统称之为 dnode 或 fnode）。</p><p>假设一个 inode 占据 256 字节，那么一个 4KB 的 block 可以存放 16 个 inodes，使用 5 个 blocks 可以存放 80 个 inodes，也就是最多支持 80 个文件。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem3.jpg"></p><h2 id="bitmap">bitmap</h2><p>需要追踪这些 inodes 和 data blocks 的分配和释放情况，判断哪些是已用的，哪些是空闲的。最简单的办法就是使用 bitmap，包括记录 inode 使用情况的 bitmap（对应下图的"i"），和记录 data block 使用情况的 bitmap（对应下图的"d"）。空闲就标记为 0，正在使用就标记为 1。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem4.jpg"></p><h2 id="superblock">superblock</h2><p>superblock 包含了一个文件系统所有的控制信息，比如文件系统中有多少个 inodes 和 data blocks，inode 的信息起始于哪个 block（这里是第 3 个），可能还有一个区别不同文件系统类型的 magic number。因此，superblock 可理解为是文件系统的 meta data。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem5.jpg"></p><h1 id="文件寻址">文件寻址</h1><h2 id="寻址过程">寻址过程</h2><p>这 5 个 blocks 中的 80 个 inodes 构成了一个 inode table。假设一个 inode 的大小是 256 字节，现在我们要访问第 32 个文件，也就是第 32 个 inode 所在的磁盘位置。它应该在相对 inode table 起始地址的 8KB 处（32*256=8192），而 inode table 的起始地址是 12KB，所以实际位置是 20KB。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem6.jpg"></p><p>磁盘同内存不同，它在物理上不是按字节寻址的，而是按 sector。一个 sector 的大小通常是 512 字节，因此换算一下就是第 40 个 sector（20*1024/512）。找到 inode 后，inode 里就有指针指向保持文件数据的 data block 就查找到了文件。</p><p>对于 ext2/3/4 文件系统，以上介绍的这些 inode bitmap, data block bitmap 和 inode table，都可以通过一个名为"dumpe2fs"的工具来查看其在磁盘上的具体位置： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem7.jpg"></p><p>如果只需要查看 inode 的使用情况，那么直接使用"df -i"命令即可： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem8.png"></p><h2 id="寻址方式">寻址方式</h2><p>两种寻址方式：</p><ul><li>inode 里通过指针指向一个 block，假设一个 inode 最多能包含 12 个指针，那么文件的大小不能超过 48KB。那如果超过了怎么办？可由 inode 先指向一个中间 block，这个 block 再指向分散的 data block，这种方法称为 multi-level index。假设一个指针占据 4 个字节，那么一个中间 block 可存储 1024 个指针，二级 index 的寻址范围就可超过 4MB，三级 index 则可超过 4GB。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem9.jpg"></li></ul><p>这种只使用 block 指针的方式（可被称为"pointer-based"）被 ext2 和 ext3 文件系统所采用，但它存在一个问题，对于占据多个 data block 的文件，需要较多的 meta data。</p><ul><li>另一种实现是使用一个 block 指针加上一个 length 来表示一组物理上连续的 blocks（称为一个 extent，其中 length 以 block 为单位计），一个文件则由若干个 extents 构成。这种"extent-based"的方式被后来的 ext4 文件系统所采用。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent</span> {</span></span><br><span class="line">    __le32  ee_block;   <span class="comment">/* first logical block extent covers */</span></span><br><span class="line">    __le16  ee_len;     <span class="comment">/* number of blocks covered by extent */</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>相比"pointer-based"而言，"extent-based"由于需要磁盘上连续的 free space，灵活性稍差，适用于磁盘空闲空间比较充足的场景。</p><h1 id="目录和路径">目录和路径</h1><p>各级目录构成了访问文件的路径，从抽象的角度，目录也可视作一种文件，只是这种文件比较特殊，它的 user data 存储的是该路径下的普通文件的 inode 编号。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem10.jpg"></p><p>所以，如下图所示的这样一个路径结构，假设要在"/foo"目录下创建一个文件"bar.txt"，那么需要从 inode bitmap 中分配一个空闲的 inode，并在"/foo"这个目录中分配一个 entry，以关联这个 inode 号。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem11.jpg"></p><p>接下来，我们要读取刚才创建的这个"/foo/bar.txt"文件，那么先得找到"/"这个目录文件的 inode 号（这必须是事先知道的，假设是 2）。然后访问这个 inode 指向的 data block，从中找到一个名为"foo"的 entry，得到目录文件"foo"的 inode 号（假设是 44）。重复此过程，按图索骥，直到找到文本文件"bar.txt"的 inode 号。</p><h1 id="用户看到的文件">用户看到的文件</h1><h2 id="访问权限控制">访问权限控制</h2><p>每个文件有三种与之关联的权限，分别是读、写和执行。试图访问文件的用户也划分为三类，分别是文件的所有者（user）、与所有者在同一用户组的用户（group），以及其他用户（others）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem12.jpg"></p><p>可通过"chmod"命令修改文件的权限，通过"chown"命令修改文件的 UID 和 GID。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> {</span></span><br><span class="line">    <span class="type">kuid_t</span>    i_uid;    <span class="comment">/* user id */</span></span><br><span class="line">    <span class="type">kgid_t</span>    i_gid;    <span class="comment">/* group id */</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个文件都有三种 timestamp：文件上次被访问的时间（access time，简称 atime）、文件上次被修改的时间（modification time，简称 mtime）和文件属性上次被修改的时间（change time，简称 ctime）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>   <span class="title">i_atime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>   <span class="title">i_mtime</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>   <span class="title">i_ctime</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>mtime 针对的是文件的内容（即 user data），而 ctime 针对的是 inode 结构自身（即 meta data）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem13.jpg"></p><h2 id="特殊文件">特殊文件</h2><p>上面示例的这个文件是 regular file，此外，设备在 Linux 中也被视作文件，一个设备可以是 block device（即"i_bdev"），也可以是 character device（即"i_cdev"），而且设备还具有主设备号和从设备号（即"i_rdev"）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dev_t</span> i_rdev;</span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>     *<span class="title">i_bdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>             *<span class="title">i_cdev</span>;</span></span><br><span class="line">    <span class="type">char</span>                    *i_link;</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如上文所说，目录（directory）也被视作一种特殊的文件，因而它没有独立的数据结构，且基于文件的大部分操作也可用于 directory。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem14.jpg"></p><h2 id="inode-编号和-superblock">inode 编号和 superblock</h2><p>一个文件必然处于一个文件系统中，因而一个 inode 也必然被一个 superblock 所管理（由"i_sb"指向）。同一 superblock 的所有 inodes 以双向链表的形式连接（即"i_sb_list"），每个 inode 在其所属的 superblock 中有唯一的编号（即"i_ino"，对应上面 stat 命令输出的"Inode"项）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">i_sb_list</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>        i_ino;</span><br></pre></td></tr></tbody></table></figure><h2 id="两种-link">两种 link</h2><p>一个文件可以有两种 link：hard link 和 symbolic/soft link，可分别通过"ln"和"ln -s"命令创建。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem15.png"></p><p>它们的 inode 编号却不相同（通过"ls -i"查看），hard link 与原文件的 inode 号相同，soft link 则有单独的 inode 号。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem17.png"></p><p>再来查看文件的详细信息： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem18.png"></p><p>现在用"rm"命令删除原文件，并通过 strace 工具追踪这期间发生的系统调用。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem19.png"></p><p>可以看到，它调用了"unlink"，为什么不是叫"remove"或者"delete"呢？先来试试删除原文件之后，还能否继续使用 hard link 和 soft link。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem20.png"></p><p>hard link 还可以正常访问原来的内容，而 soft link 的访问则会失败。这一切的原因还得从 hard link 和 soft link 的属性说起。</p><p>当创建一个文件时，我们需要选择一个路径（pathname），并为文件设置一个字符串形式的名称（symbol）。这其实做了两件事，一是生成一个 inode 结构体，用于记录这个文件的所有相关信息，包括大小、在磁盘上占据的 blocks 数目等，二是将生成的 inode 关联（link）了这个路径和名称。</p><p>一个文件的 hard link 增加的是对这个 inode 结构体的关联/指向，并不是一个新的文件。而 soft link 本身就是一个文件，就像 directory 这种特殊文件里存放的是该目录下包含哪些文件，soft link 这种文件里存放的则是指向原 inode 的路径，路径越长，soft link 的大小就越大。这就是为什么 hard link 和原文件的 inode 号相同，而 soft link 不同。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/filesystem21.jpg"></p><p>因此，当我们用"rm"命令“删除”原文件时，删除的只是原文件的路径和 inode 之间的关联，而不是这个 inode 本身，文件的内容依然存在于磁盘中，因而只能算是"unlink"。所以直接关联 inode 的 hard link 不受影响，而关联原文件路径的 soft link 此时相当于是一个 dangling reference。</p><p>一个 inode 被 link 的数目由"i_nlink"表示（这就是前面"ls -l"命令输出中第二列数值的含义）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br></pre></td></tr></tbody></table></figure><p>相比起 soft link，hard link 在使用的时候有个限制，就是必须和原文件位于相同的文件系统，原因还是和 inode 编号有关。因为一个 inode 编号只在文件所属的 superblock 中是唯一的，而 hard link 使用和原文件相同的 inode 编号，如果 hard link 跑到其他文件系统，就可能和这些文件系统中既有的文件 inode 编号冲突。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDY0NTk0NDU=">https://zhuanlan.zhihu.com/p/106459445<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDAzMjkxNzc=">https://zhuanlan.zhihu.com/p/100329177<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> FileSystem </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件系统（二）块 I/O</title>
      <link href="/next/2021/LinuxKernel/LinuxFileSystemblockIO/"/>
      <url>/next/2021/LinuxKernel/LinuxFileSystemblockIO/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/LinuxFSBlockI_O.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjNhZTkxMTA3OTEyOTA2ZjUxNDZjODg=">原图<i class="fa fa-external-link-alt"></i></span></p><p>系统中能够随机访问固定大小数据片的硬件设备称作块设备，这些固定大小的数据片就称作块。另一种基本的设备类型是字符设备，字符设备按照子节流的方式被有序访问，像串口和键盘就属于字符设备。对于这两种类型的设备，它们的区别在于是否可以随机访问数据。</p><span id="more"></span><h1 id="剖析一个块设备">剖析一个块设备</h1><p>块设备中最小的可寻址单元是扇区（sector）。扇区大小一般是 2 的整数倍，而最常见的是 512 字节。扇区的大小是设备的物理属性，扇区是所有块设备的基本单元—-块设备无法对比它还小的单元进行寻址和操作。</p><p>因为各种软件的用途不同，所以它们都会用到自己的最小逻辑可寻址单元--块（block）。块是文件系统的一种抽象，只能基于块来访问文件系统。虽然物理磁盘寻址是按照扇区级进行的，但是内核执行的所有磁盘操作都是按照块进行的。由于扇区是设备的最小可寻址单元，所以块不能比扇区还小，只能数倍于扇区大小。另外，内核（对有扇区的硬件设备）还要求块大小是 2 的整数倍，而且不能超过一个页（page）的长度。所以，对块大小的最终要求是，必须是扇区大小的 2 的整数倍，并且要小于页面大小。所以通常块大小是 512 字节、1KB 或 4KB。</p><blockquote><p>扇区——设备的最小寻址单元；同样的，块——文件系统的最小寻址单元。</p></blockquote><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/io1.png"></p><h1 id="缓冲区和缓冲区头">缓冲区和缓冲区头</h1><blockquote><p>缓冲区头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。这个结构体在内核中只扮演一个描述符的角色，说明从缓冲区到块的映射关系。</p></blockquote><p>当一个块被调入内存时，它要存储在一个缓冲区中，每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示。前面提到过，块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。由于内核在处理数据时需要一些相关的控制信息、（比如块属于哪一个块设备，块对应于哪个缓冲区等），所以每一个缓冲区都有一个对应的描述符。该描述符用 buffer head 结构体表示，称作缓冲区头，在文件《linux/buffer_head.h》中定义，它包含了内核操作缓冲区所需要的全部信息。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> b_state;<span class="comment">/* buffer state bitmap (see above) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* circular list of page's buffers */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span><span class="comment">/* the page this bh is mapped to */</span></span><br><span class="line"></span><br><span class="line"><span class="type">sector_t</span> b_blocknr;<span class="comment">/* start block number */</span></span><br><span class="line"><span class="type">size_t</span> b_size;<span class="comment">/* size of mapping */</span></span><br><span class="line"><span class="type">char</span> *b_data;<span class="comment">/* pointer to data within the page */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span></span><br><span class="line"><span class="type">bh_end_io_t</span> *b_end_io;<span class="comment">/* I/O completion */</span></span><br><span class="line"> <span class="type">void</span> *b_private;<span class="comment">/* reserved for b_end_io */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span> <span class="comment">/* associated with another mapping */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span><span class="comment">/* mapping this buffer is</span></span><br><span class="line"><span class="comment">   associated with */</span></span><br><span class="line"><span class="type">atomic_t</span> b_count;<span class="comment">/* users using this buffer_head */</span></span><br><span class="line"><span class="type">spinlock_t</span> b_uptodate_lock;<span class="comment">/* Used by the first bh in a page, to</span></span><br><span class="line"><span class="comment"> * serialise IO completion of other</span></span><br><span class="line"><span class="comment"> * buffers in the page */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在 2.6 内核以前，缓冲区头的作用比现在还要重要。因为缓冲区头作为内核中的 I/O 操作单元，不仅仅描述了从磁盘块到物理内存的映射，而且还是所有块 I/O 操作的容器。可是，将缓冲区头作为 I/O 操作单元带来了两个弊端。</p><ul><li>首先，缓冲区头是一个很大且不易控制的数据结构体（现在是缩减过了的），而且缓冲区头对数据的操作既不方便也不清晰。</li><li>缓冲区头带来的第二个弊端是：它仅能描述单个缓冲区，当作为所有 I/O 的容器使用时，缓冲区头会促使内核把对大块数据的 I/O 操作（比如写操作）分解为对多个 buffer_head 结构体进行操作，这样做必然会造成不必要的负担和空间浪费。所以 2.5 开发版内核的主要目标就是为块 I/O 操作引入一种新型、灵活并且轻量级的容器，也就是 bio 结构体。</li></ul><h1 id="bio-结构体">bio 结构体</h1><p>目前内核中块 I/O 操作的基本容器由 bio 结构体表示，该结构体代表了正在现场的（活动的）以片断（segment）链表形式组织的块 I/O 操作。一个片段是一小块连续的内存缓冲区。这样的话，就不需要保证单个缓冲区一定要连续。所以通过用片段来描述缓冲区，即使一个缓冲区分散在内存的多个位置上，bio 结构体也能对内核保证 I/O 操作的执行。像这样的向量 I/O 就是所谓的聚散 I/O。bio 结构体定义于《linux/bio.h》中，下面给出 bio 结构体和各个域的描述。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span>*<span class="title">bi_next</span>;</span><span class="comment">/* request queue link */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">bi_bdev</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>bi_opf;<span class="comment">/* bottom bits req flags,</span></span><br><span class="line"><span class="comment"> * top bits REQ_OP. Use</span></span><br><span class="line"><span class="comment"> * accessors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>bi_flags;<span class="comment">/* BIO_* below */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>bi_ioprio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>bi_write_hint;</span><br><span class="line"><span class="type">blk_status_t</span>bi_status;</span><br><span class="line"><span class="type">atomic_t</span>__bi_remaining;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span><span class="title">bi_iter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bio_end_io_t</span>*bi_end_io;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*bi_private;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Represents the association of the css and request_queue for the bio.</span></span><br><span class="line"><span class="comment"> * If a bio goes direct to device, it will not have a blkg as it will</span></span><br><span class="line"><span class="comment"> * not have a request_queue associated with it.  The reference is put</span></span><br><span class="line"><span class="comment"> * on release of the bio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>*<span class="title">bi_blkg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_issue</span><span class="title">bi_issue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP_IOCOST</span></span><br><span class="line">u64bi_iocost_cost;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_INLINE_ENCRYPTION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_crypt_ctx</span>*<span class="title">bi_crypt_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span> <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>bi_vcnt;<span class="comment">/* how many bio_vec's */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Everything starting with bi_max_vecs will be preserved by bio_reset()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>bi_max_vecs;<span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span>__bi_cnt;<span class="comment">/* pin count */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>*<span class="title">bi_io_vec</span>;</span><span class="comment">/* the actual vec list */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span>*<span class="title">bi_pool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment"> * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment"> * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span><span class="title">bi_inline_vecs</span>[];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>使用 bio 结构体的目的主要是代表正在现场执行的 I/O 操作，所以该结构体中的主要域都是用来管理相关信息的，其中最重要的几个域是 bi_io_vecs、bi_vcnt 和 bi_idx。下图显示了 bio 结构体及其他结构体之间的关系。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/io2.png"></p><p>Sector、Block、Segment 之间的关系：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Bio.png"></p><h2 id="io-向量">I/O 向量</h2><p>bi_io_vec 域指向一个 bio_vec 结构体数组，该结构体链表包含了一个特定 I/O 操作所需要使用到的所有片段。每个 bio_vec 结构都是一个形式为&lt;page，offset，len&gt;的向量，它描述的是一个特定的片段：片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度。整个 bio_io_vec 结构体数组表示了一个完整的缓冲区。bio_vec 结构定义在《linux/bio.h》文件中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>*<span class="title">bv_page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>bv_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>bv_offset;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在每个给定的块 I/O 操作中，bi_vcnt 域用来描述 bi_io_vec 所指向的 bio_vec 数组中的向量数目。当块 I/O 操作执行完毕后，bi_idx 域指向数组的当前索引。</p><p>bi_vcnt 域记录 bio 结构体的使用计数，如果该域值减为 O，就应该撤销该 bio 结构体，并释放它占用的内存。通过下面两个函数管理使用计数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">bio_get</span><span class="params">(<span class="keyword">struct</span> bio *bio)</span></span><br><span class="line">{</span><br><span class="line">bio-&gt;bi_flags |= (<span class="number">1</span> &lt;&lt; BIO_REFFED);</span><br><span class="line">smp_mb__before_atomic();</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;bio-&gt;__bi_cnt);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">bio_put</span><span class="params">(<span class="keyword">struct</span> bio *)</span>;</span><br></pre></td></tr></tbody></table></figure><p>前者增加使用计数，后者减少使用计数（如果计数减到 0，则撤销 bio 结构体）。在操作正在活动的 bio 结构体时，一定要首先增加它的使用计数，以免在操作过程中该 bio 结构体被释放；相反，在操作完毕后，要减少使用计数。</p><h2 id="新老方法对比">新老方法对比</h2><p>利用 bio 结构体代替 buffer bead 结构体还有以下好处：</p><ul><li>bio 结构体很容易处理高端内存，因为它处理的是物理页而不是直接指针</li><li>bio 结构体既可以代表普通页 I/O，同时也可以代表直接 I/O（指那些不通过页高速缓存的 I/0 操作）</li><li>bio 结构体便于执行分散一集中（矢量化的）块 I/O 操作，操作中的数据可取自多个物理页面</li><li>bio 结构体相比缓冲区头属于轻量级的结构体。因为它只需要包含块 I/O 操作所需的信息就行了，不用包含与缓冲区本身相关的不必要信息</li></ul><p>但是还是需要缓冲区头这个概念，毕竟它还负责描述磁盘块到页面的映射。bio 结构体不包含任何和缓冲区相关的状态信息一它仅仅是一个矢量数组，描述一个或多个单独块 I/O 操作的数据片段和相关信息。在当前设置中，当 bio 结构体描述当前正在使用的 I/O 操作时，bufferhead 结构体仍然需要包含缓冲区信息。内核通过这两种结构分别保存各自的信息，可以保证每种结构所含的信息量尽可能地少。</p><h1 id="请求队列">请求队列</h1><p>块设备将它们挂起的块 I/O 请求保存在请求队列中，该队列由 reques_queue 结构体表示，定义在文件《linux/blkdev.h》中，包含一个双向请求链表以及相关控制信息。通过内核中像文件系统这样高层的代码将请求加入到队列中。请求队列只要不为空，队列对应的块设备驱动程序就会从队列头获取请求，然后将其送入对应的块设备上去。请求队列表中的每一项都是一个单独的请求，由 reques 结构体表示。 队列中的请求由结构体 request 表示，它定义在文件《linux/blkdev.h》中。因为一个请求可能要操作多个连续的磁盘块，所以每个请求可以由多个 bio 结构体组成。注意，虽然磁盘上的块必须连续，但是在内存中这些块并不一定要连续——每个 bio 结构体都可以描述多个片段，而每个请求也可以包含多个 bio 结构体。</p><h1 id="io-调度程序">I/O 调度程序</h1><p>为了优化寻址操作，内核既不会简单地按请求接收次序，也不会立即将其提交给磁盘。相反，它会在提交前，先执行名为合并与排序的预操作，这种预操作可以极大地提高系统的整体性能。在内核中负责提交 I/O 请求的子系统称为 I/O 调度程序。</p><h2 id="io-调度程序的工作">I/O 调度程序的工作</h2><p>I/O 调度程序通过两种方法减少磁盘寻址时间：合并与排序。</p><ul><li><p>合并指将两个或多个请求结合成一个新请求。请求合并后只需要传递给磁盘一条寻址命令，因此合并请求显然能减少系统开销和磁盘寻址次数。</p></li><li><p>整个请求队列将按扇区增长方向有序排列。使所有请求按硬盘上扇区的排列顺序有序排列（尽可能的）的目的不仅是为了缩短单独一次请求的寻址时间，更重要的优化在于，通过保持磁盘头以直线方向移动，缩短了所有请求的磁盘寻址时间。该排序算法类似于电梯调度，所以 I/O 调度程序称作电梯调度。</p></li></ul><h2 id="linus-电梯">Linus 电梯</h2><p>当一个请求加入到队列中时，有可能发生四种操作，它们依次是：</p><ul><li>如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求</li><li>如果队列中存在一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生</li><li>如果队列中以扇区方向为序存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排列的</li><li>如果队列中不存在合适的请求插入位置，请求将被插入到队列尾部</li></ul><h2 id="最终期限-io-调度程序">最终期限 I/O 调度程序</h2><p>最终期限（deadline）I/O 调度程序是为了解决 Linus 电梯所带来的饥饿问题而提出的。</p><p>普通的请求饥饿还会带来名为写一饥饿一读（writes-starving-reads）这种特殊问题。写操作完全和提交它的应用程序异步执行；读操作则恰恰相反是同步的，所以读操作响应时间对系统的性能非常重要。</p><p>问题还可能更严重，这是因为读请求往往会相互依靠。当读操作阻塞后，后面的读请求操作也会跟着阻塞。因此 2.6 版本内核新引入了最后期限 I/0 调度程序来减少请求饥饿现象，特别是读请求饥饿现象。</p><blockquote><p>在最后期限 I/O 调度程序中，每个请求都有一个超时时间。</p></blockquote><p>默认情况下，读请求的超时时间是 500ms，写请求的超时时间是 5s。最后期限 I/O 调度请求类似于 Linus 电梯，也以磁盘物理位置为次序维护请求队列，这个队列称为排序队列。当一个新请求递交给排序队列时，</p><ul><li>最后期限 I/O 调度程序在执行合并和插入请求时类似于 Linus 电梯执行合并排序到排队序列</li><li>同时也会以请求类型为依据将它们插入到额外队列中。读请求按次序被插入到特定的读 FIFO 队列中</li><li>写请求被插入到特定的写 FIFO 队列中</li></ul><p>虽然普通队列以磁盘扇区为序进行排列，但是这些队列是以 FIFO（很有效，以时间为基准排序）形式组织的，结果新队列总是被加人到队列尾部。对于普通操作来说，最后期限 I/O 调度程序将请求从排序队列的头部取下，再推入到派发队列中，派发队列然后将请求提交给磁盘驱动，从而保证了最小化的请求寻址。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/io3.png"></p><p>注意，最后期限 I/O 调度算法并不能严格保证请求的响应时间，但是通常情况下，可以在请求超时或超时前提交和执行，以防止请求饥饿现象的发生。最后期限 I/O 调度程序的实现在文件 block/deadline-iosched.c 中。</p><h2 id="预测-io-调度程序">预测 I/O 调度程序</h2><p>虽然最后期限 I/O 调度程序为降低读操作响应时间做了许多工作，但是它同时也降低了系统吞吐量。预测（Anticipatory）I/O 调度程序的目标就是在保持良好的读响应的同时也能提供良好的全局吞吐量。 预测 I/O 调度程序最主要的改进是它增加了预测启发（anticipation-heuristic）能力。请求提交后并不直接返回处理其他请求，而是会有意空闲片刻（实际空闲时间可以设置，默认为 6ms）。这几 ms，对应用程序来说是个提交其他读请求的好机会——任何对相邻磁盘位置操作的请求都会立刻得到处理。在等待时间结束后，预测 I/O 调度程序重新返回原来的位置，继续执行以前剩下的请求。</p><p>预测 I/O 调度程序的实现在文件内核源代码树的 block/as-iosched.c 中，它是 Linux 内核中缺省的 I/O 调度程序。</p><h2 id="完全公正的排队-io-调度程序">完全公正的排队 I/O 调度程序</h2><p>完全公正的排队 I/O 调度程序（Complete Fair Queuing，CFQ）是为专有工作负荷设计的，CFQ I/O 调度程序把进入的 I/O 请求放入特定的队列中，这种队列是根据引起 I/O 请求的进程组织的。例如，来自 foo 进程的 I/O 请求进入 foo 队列，而来自 bar 进程的 I/O 请求进入 bar 队列。在每个队列中，刚进入的请求与相邻请求合并在一起，并进行插入分类。队列由此按扇区方式分类，这与其他 I/O 调度程序队列类似。CFQ I/O 调度程序的差异在于每一个提交 I/O 的进程都有自己的队列。</p><p>CFQ I/O 调度程序以时间片轮转调度队列，从每个队列中选取请求数（默认值为，可以进行配置），然后进行下一轮调度。这就在进程级提供了公平，确保每个进程接收公平的磁盘带宽片断。</p><h2 id="空操作的-io-调度程序">空操作的 I/O 调度程序</h2><p>空操作（Noop）I/O 调度程序不进行排序，或者也不进行什么其他形式的预寻址操作。不过，空操作 I/O 调度程序忘不了执行合并。除了这一操作，空操作 I/O 调度程序的确再不做什么，只是维护请求队列以近乎 FIFO 的顺序排列，块设备驱动程序便可以从这种队列中摘取请求。</p><p>空操作 I/O 调度程序位于 block/noop-iosched.c，它是专为随机访问设备而设计的。</p><h1 id="参考文献">参考文献</h1><p>《linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> FileSystem </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核调试（二）内存检测</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelDebugMem/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelDebugMem/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Debugftrace.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5YjAzNWU0MDFmZDA3MGJiYTBlYmE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>一般的内存访问错误如下。</p><ul><li>越界访问（out-of-bounds）</li><li>访问已经被释放的内存（use after free）</li><li>重复释放（double free）</li><li>内存泄漏（memory leak）</li><li>栈溢出（stack overflow）</li></ul><p>本节主要介绍 Linux 内核中常用的内存检测的工具和方法。</p><h1 id="slub_debug">slub_debug</h1><p>在 Linux 内核中，对于小块内存分配，大量使用 slab/slub 分配器。slab/slub 分配器提供了一个内存检测功能，很方便在产品开发阶段进行内存检查。内存访问中比较容易出现错误的地方如下。</p><ul><li>访问己经被释放的内存</li><li>越界访问</li><li>释放己经释放过的内存</li></ul><h2 id="配置和编译内核">配置和编译内核</h2><p>首先，需要重新配置内核选项，打开 CONFIG_SLUB、CONFIG_SLUB_DEBUG_ON 以及 CONFIG_SLUB_STATS 选项。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># CONFIG_SLAB is not <span class="built_in">set</span></span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLUB_DEBUG_ON=y</span><br><span class="line">CONFIG_SLUB_STATS=y</span><br></pre></td></tr></tbody></table></figure><p>修改了上述配置文件之后，需要重新编译内核并更新根文件系统。</p><h2 id="添加-slub_debug-选项">添加 slub_debug 选项</h2><p>在内核 commandline 中添加 slub_debug 字符串来打开该功能。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-append <span class="string">"nointrd root=/dev/vda rootfstype=ext4 rw loglevel=8 slub_debug=UFPZ"</span> \</span><br></pre></td></tr></tbody></table></figure><h2 id="编译-slabinfo-工具">编译 slabinfo 工具</h2><p>在 Linux-5.0 内核的 tools/vm 目录下编译 slabinfo 工具。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc slabinfo.c -o slabinfo</span></span><br></pre></td></tr></tbody></table></figure><h2 id="运行">运行</h2><p>加载驱动或运行程序，启动 slabinfo：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ slabinfo -v</span><br></pre></td></tr></tbody></table></figure><p>之后如果有内存越界访问就会有异常 log 输出。</p><h1 id="kasan-内存检测">KASAN 内存检测</h1><p>KASAN 在 Linux4.0 内核中被合并到官方 Linux 内核，他是一个动态检测内存错误的工具，可以检查内存越界访问和使用已经被释放的内存等问题。Linux 内核早期有一个类似的工具 kmemcheck，KASAN 比 kmemeheck 的检测速度更快。要使用 KASAN，必须打开 CONFIG_KASAN 等选项。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">arch</span>/arm64/configs/debian_defconfig&gt;</span><br><span class="line">CONFIG_HAVE_ARCH_KASAN=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_OUTLINE=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line">CONFIG_TEST_KASAN=m</span><br></pre></td></tr></tbody></table></figure><p>使用起来比较简单，不需要像 slab_debug 一样还有单独运行 slabinfo 程序。KASAN 启动后会动态监测内存访问，如果出错会打印相关 log 信息。</p><p>KASAN 总体效率比 slub_debug 要高得多，并且支持的内存错误访问类型更多。缺点是 KASAN 需要较新的内核（Linx4.4 内核才支持 ARM64 版本的 KASAN）和较新的 GCC 编译 器（GCC-4.9.2 以上）。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核调试（一）ftrace</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelDebugftrace/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelDebugftrace/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Debugftrace.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5YjAzNWU0MDFmZDA3MGJiYTBlYmE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="位置无关码">位置无关码</h1><ul><li>加载地址：存储代码的物理地址。如 ARM64 处理器上电复位后是从 0x0 地址开始第一条指令的，所以通常这个地方存放代码最开始的部分，如异常向量表的处理地址</li><li>运行地址：指程序运行时的地址</li><li>链接地址：在编译链接时指定的地址，编程人员设想将来程序要运行的地址。程序所有标号的地址在链接后便确定了，不管程序在哪里运行都不会改变。aarch64-linux-gnu-obidump (objdump) 工具进行反汇编查看的就接地链接地址</li></ul><p>链接地址和运行地址可以相同，也可以不同。那什么时候运行地址和链接地址不相同，什么时候相同呢？我们以一块 ARM64 开发板为例，芯片内部有 SRAM，起始地址为 0x0，DDR 内存的起始地址为 0x4000 0000。</p><p>通常代码存储在 Nor Flash 存储器或者 Nand Flash 存储器中，芯片内部的 BOOT ROM 会把开始的小部分代码装载到 SRAM 中运行。芯片上电复位之后，从 SRAM 中取指令。由于 Uboot 的镜像太大了，SRAM 放不下，因此必须要放在 DDR 内存中。通常 Uboot 编译时链接地址都设置到 DDR 内存中，也就是 0x4000 0000 地址处。那这时运行地址和链接地址就不一样了。运行地址为 0x0，链接地址变成了 0x4000 0000 那么程序为什么还能运行呢个重要问题，就是位置无关代码和位置有关代码。</p><ul><li>位置无关代码：从字面意思看，该指令的执行是与内存地址无关的；无论运行地址和链接地址相等或者不相等，该指令都能正常运行。在汇编语言中，像 BL、B、MOV 指令属于位置无关指令，不管程序装载在哪个位置，它们都能正确地运行，它们的地址域是基于 PC 值的相对偏移寻址，相当于 [pc+offset]</li><li>位置有关代码：从字面意思看，该指令的执行是与内存地址有关的，和当前 PC 值无关。ARM 汇编里面通过绝对跳转修改 PC 值为当前链接地址的值</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr pc, = on_sdram ; 跳到 SDRAM 中继续执行</span><br></pre></td></tr></tbody></table></figure><p>因此，当通过 LDR 指令跳转到链接地址处执行时，运行地址就等于链接地址了。这个过程叫作“重定位”。在重定位之前，程序只能执行和位置无关的一些汇编代码。为什么要刻意设置加载地址、运行地址以及链接地址不一样呢？ 如果所有代码都在 ROM（或 Nor Flash 存储器）中执行，那么链接地址可以与加载地址相同；而在实际项目应用中，往往想要把程序加载到 DDR 内存中，DDR 内存的访问速度比 ROM 要快很多，而且容量也大。但是碍于加载地址的影响，不可能直接达到这一步，所以思路就是让程序的加载地址等于 ROM 起始地址，而链接地址等于 DDR 内存中某一处的起始地址（暂且称为 ram start）。程序先从 ROM 中启动，最先启动的部分要实现代码复制功能（把整个 ROM 代码复制到 DDR 内存中），并通过 LDR 指令来跳转到 DDR 内存中，也就是在链接地址里运行 B 指令没法实现这个跳转）。上述重定位过程在 U-Boot 中实现，如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/relocation.png"></p><p>当跳转到 Linux 内核中时，U-Boot 需要把 Linux 内核映像内容复制到 DDR 内存中，然后跳转到内核入口地址处（ stext 函数）。当跳转到内核入口地址（ stext 函数）时，程序运行在运行地址，即 DDR 内存的地址。但是我们从 vmlinux 看到的 stext 函数的链接地址是虚拟地址（内核启动汇编代码也需要一个重定位过程。这个重定位过程在__primary_switch() 汇编函数中完成。启动 MMU 之后，通过 ldr 指令把 __primary_switched() 函数的链接地址加载到 x8 寄存器，然后通过 br 指令跳转到 __primary_switched() 函数的链接地址处，从而实现了重定位，如图所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/kernspace.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/kernel/head.S&gt;</span><br><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU enabled.</span><br><span class="line"> *</span><br><span class="line"> *   x0 = __PHYS_OFFSET</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line">adr_lx4, init_task</span><br><span class="line">init_cpu_task x4, x5, x6</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors// load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8// vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpx29, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5// Save FDT pointer</span><br><span class="line"></span><br><span class="line">ldr_lx4, kimage_vaddr// Save the offset between</span><br><span class="line">subx4, x4, x0// the kernel virtual and</span><br><span class="line">str_lx4, kimage_voffset, x5// physical mappings</span><br><span class="line"></span><br><span class="line">// Clear BSS</span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst// Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span><br><span class="line">blkasan_early_init</span><br><span class="line">#endif</span><br><span class="line">movx0, x21// pass FDT address in x0</span><br><span class="line">blearly_fdt_map// Try mapping the FDT early</span><br><span class="line">blinit_feature_override// Parse cpu feature overrides</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - 1)// already running randomized?</span><br><span class="line">b.ne0f</span><br><span class="line">blkaslr_early_init// parse FDT for KASLR options</span><br><span class="line">cbzx0, 0f// KASLR disabled? just proceed</span><br><span class="line">orrx23, x23, x0// record KASLR offset</span><br><span class="line">ldpx29, x30, [sp], #16// we must enable KASLR, return</span><br><span class="line">ret// to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">blswitch_to_vhe// Prefer VHE if possible</span><br><span class="line">ldpx29, x30, [sp], #16</span><br><span class="line">blstart_kernel</span><br><span class="line">ASM_BUG()</span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></tbody></table></figure><h1 id="ftrace">ftrace</h1><p>frace 最早出现在 Linux2.6.27 内核中，其设计目标简单，基于静态代码插桩（stub）技术，不需要用户通过额外的编程来定义 trace 行为。静态代码插桩技术比较可靠，不会因为用户使用不当而导致内核崩溃。 ftrace 的名字源于 function trace 利用 GCC 的 profile 特性在所有函数入口处添加一段插桩代码， ftrace 重载这段代码来实现 trace 功能。GCC 的-pg 选项会在每个函数入口处加入 mcount 的调用代码，原本 mcount 有 libc 实现，而内核不会链接 libc 库，因此 frace 编写了自己的 mcount stub 函数。 在使用 ftrace 之前，需要确保内核编译配置选项。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FTRACE=y</span><br><span class="line">ONIFIG_HAVE_FUNCTION_TRACE=y</span><br><span class="line">CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y</span><br><span class="line">CONFIG_HAVE_DYNAMIC_FTRACE=y</span><br><span class="line">CONFIG_FUNCTIONL_TRACER=y</span><br><span class="line">CONFIG_IRQSOFE_TRACER=Y</span><br><span class="line">CONEIG_SCHED_TRACER=y</span><br><span class="line">CONFIG_ENABLE_DEFAULT_TRACERS=y</span><br><span class="line">CONFIG_FTRACE_SYSCALLS=y</span><br><span class="line">CONFIG_PREEMPT_TRACER=y</span><br></pre></td></tr></tbody></table></figure><p>ftrace 的相关配置选项比较多，针对不同的跟踪器有各自对应的配置选项。 ftrace 通过 debugfs 文件系统向用户空间提供访间接口，因此需要在系统启动时挂载 debugfs，可以修改系统的 /etc/fstab 文件或手动挂载。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs debugfs/sys/kernel/debug</span><br></pre></td></tr></tbody></table></figure><p>在 sys/kernel/debug/trace 目录下提供了各种跟踪器（ tracer）和事件（ event），一些常用的选项如下。</p><ul><li>available_tracers：列出当前系统支持的跟踪器</li><li>available_events：列出当前系统支持的事件</li><li>current_tracer：设置和显示当前正在使用的跟踪器。使用 echo 命令把跟踪器的名字写入该文件，即可切换不同的跟踪器。默认为 nop，即不做任何跟踪操作</li><li>trace: 读取跟踪信息。通过 cat 命令查看 ftrace 记录下来的眼踪信息</li><li>tracing_on：用于开始或暂停跟踪</li><li>trace_options：设置 ftrace 的一些相关选项</li></ul><p>ftrace 当前包含多个跟踪器，方便用户跟踪不同类型的信息，如进程睡眠、唤醒、抢占、延迟的信息。查看 available_tracers 可以知道当前系统支持哪些跟踪器，如果系统支持的跟踪器上没有用户想要的。那就必须在配置内核时打开，然后重新编译内核。常用的 ftrace 跟踪器如下所示：</p><ul><li>nop：不跟踪任何信息。将 nop 写入 current_tracer 文件可以清空之前收集到的跟踪信息</li><li>function：跟踪内核函数执行情况</li><li>function_graph：可以显示类似于 C 语言的函数调用关系图，比较直观</li><li>hwlat：用来跟踪与硬件相关的延时</li><li>blk：跟踪块设备的函数</li><li>mmiotrace：用于跟踪内存映射 I/O 操作</li><li>wakeup：跟踪普通优先级的进程从获得调度到被唤醒的最长延迟时间</li><li>weakup_rt：跟踪 RT 类型的任务从获得调度到被唤醒的最长延迟时间</li><li>irqoff：跟踪关闭中断的信息，并记录关闭的最大时长</li><li>preemptoff：跟踪关闭禁止抢占的信息，并记录关闭的最大时长</li></ul><h1 id="irqs-跟踪器">irqs 跟踪器</h1><p>当中断关闭（俗称关中断）后，CPU 就不能响应其他的事件。如果这时有一个鼠标中断，要在下一次开中断时才能响应这个中断，这段延时称为中断延迟。向 current_tracer 文件写入 irqsoff 字符串即可打开 irqsoff 来跟踪中断延迟。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/kernel/debug/tracing/</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; options/function-trace //关闭 funct-trace 可以减少一些延退</span><br><span class="line"><span class="built_in">echo</span> irqsoff &gt; current_trace</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; tracing_on</span><br><span class="line">[...] //停顿一会儿</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on</span><br><span class="line"><span class="built_in">cat</span> trace</span><br></pre></td></tr></tbody></table></figure><h1 id="function-tracing---no-modification-necessary">Function tracing - no modification necessary</h1><p>Ftrace 最强大的追踪器之一是函数追踪器。它使用 gcc 的-pg 选项让内核中的每个函数调用一个特殊的函数“ mcount() ”。该函数必须在汇编中实现，因为调用不遵循正常的 C ABI。</p><p>当配置 CONFIG_DYNAMIC_FTRACE 时，调用会在启动时转换为 NOP，以保持系统以 100% 的性能运行。在编译过程中，记录了 mcount() 调用站点。该列表在启动时用于将这些站点转换为 NOP。由于 NOP 对跟踪毫无用处，因此当启用函数（或函数图）跟踪器时，保存该列表以将调用站点转换回跟踪调用。</p><p>由于此性能增强，强烈建议启用 CONFIG_DYNAMIC_FTRACE。此外，CONFIG_DYNAMIC_FTRACE 提供了筛选应跟踪哪个函数的能力。请注意，即使 NOP 在基准测试中没有显示任何影响，但已知添加-pg 选项附带的帧指针会导致轻微的开销。</p><p>要找出哪些跟踪器可用，只需在跟踪目录中查找 available_tracers 文件即可 ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat available_tracers</span></span><br><span class="line">function_graph <span class="keyword">function</span> sched_switch nop</span><br></pre></td></tr></tbody></table></figure><p>要启用函数跟踪器，只需将“function” echo 到 current_tracer 文件中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat current_tracer</span></span><br><span class="line"><span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">[tracing]<span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">            bash-16939 [000]  6075.461561: mutex_unlock &lt;-tracing_set_tracer</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461561: _spin_unlock_irqrestore &lt;-hrtimer_get_next_event</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461562: rcu_needs_cpu &lt;-tick_nohz_stop_sched_tick</span><br><span class="line">            bash-16939 [000]  6075.461563: inotify_inode_queue_event &lt;-vfs_write</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461563: mwait_idle &lt;-cpu_idle</span><br><span class="line">            bash-16939 [000]  6075.461563: __fsnotify_parent &lt;-vfs_write</span><br></pre></td></tr></tbody></table></figure><p>标题很好地解释了输出的格式。前两项是跟踪的任务名称和 PID。执行跟踪的 CPU 位于括号内。时间戳是自启动以来的时间，后跟函数名称。在这种情况下，函数是被跟踪的函数，其父函数跟在“ &lt;- ”符号之后。</p><p>这些信息非常强大，并且很好地显示了函数的流程。但这可能有点难以遵循。由 Frederic Weisbecker 创建的函数图跟踪器跟踪函数的进入和退出，这使跟踪器能够了解被调用函数的深度。函数图跟踪器可以使人眼更容易跟踪内核中的执行流程：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | head -20</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 1)   1.015 us    |        _spin_lock_irqsave();</span><br><span class="line"> 1)   0.476 us    |        internal_add_timer();</span><br><span class="line"> 1)   0.423 us    |        wake_up_idle_cpu();</span><br><span class="line"> 1)   0.461 us    |        _spin_unlock_irqrestore();</span><br><span class="line"> 1)   4.770 us    |      }</span><br><span class="line"> 1)   5.725 us    |    }</span><br><span class="line"> 1)   0.450 us    |    mutex_unlock();</span><br><span class="line"> 1) + 24.243 us   |  }</span><br><span class="line"> 1)   0.483 us    |  _spin_lock_irq();</span><br><span class="line"> 1)   0.517 us    |  _spin_unlock_irq();</span><br><span class="line"> 1)               |  <span class="function"><span class="title">prepare_to_wait</span></span>() {</span><br><span class="line"> 1)   0.468 us    |    _spin_lock_irqsave();</span><br><span class="line"> 1)   0.502 us    |    _spin_unlock_irqrestore();</span><br><span class="line"> 1)   2.411 us    |  }</span><br><span class="line"> 1)   0.449 us    |  kthread_should_stop();</span><br><span class="line"> 1)               |  <span class="function"><span class="title">schedule</span></span>() {</span><br></pre></td></tr></tbody></table></figure><p>这给出了一个函数的开始和结束，用类似 C 的注释“ { ”来启动一个函数，“ } ”在末尾。叶函数不调用其他函数，只是以“ ; ”结尾。DURATION 列显示在相应函数中花费的时间。函数图跟踪器记录函数进入和退出的时间，并将差异报告为持续时间。这些数字只出现在叶函数和“ }" 符号。注意，这次还包括嵌套函数内所有函数的开销以及函数图跟踪器本身的开销。函数图跟踪器劫持了函数的返回地址，以便为函数插入跟踪回调函数退出。这会破坏 CPU 的分支预测并导致比函数跟踪器更多的开销。最接近的真实时序仅发生在叶函数中。</p><p>孤独的“ + ”是有一个注释标记。当持续时间大于 10 微秒时，显示“ + ”。如果持续时间大于 100 微秒，将显示“ ！ ”。</p><h1 id="using-trace_printk">Using trace_printk()</h1><p>printk() 是所有调试器之王，但它有一个问题。如果您正在调试诸如定时器中断、调度程序或网络之类的大容量区域，printk() 可能会导致系统陷入困境，甚至可能会创建实时锁。添加一些 printk() 时，看到错误“消失”也很常见。这是由于 printk() 引入的绝对开销。</p><p>Ftrace 引入了一种新形式的 printk() 称为 trace_printk()。它可以像 printk() 一样使用，也可以在任何上下文中使用（中断代码、NMI 代码和调度程序代码）。是什么样的好的 trace_printk() 是，它不会输出到控制台。相反，它写入 Ftrace 环形缓冲区，并且可以通过跟踪文件读取。</p><p>使用 trace_printk() 写入环形缓冲区只需要大约十分之一微秒左右。但是使用 printk()，尤其是在写入串行控制台时，每次写入可能需要几毫秒。trace_printk() 的性能优势 使您可以记录内核中最敏感的区域，而几乎没有影响。</p><p>例如，您可以将这样的内容添加到内核或模块中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace_printk(<span class="string">"read foo %d out of bar %p\n"</span>, bar-&gt;foo, bar);</span><br></pre></td></tr></tbody></table></figure><p>然后通过查看跟踪文件，您可以看到您的输出。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-10690 [003] 17279.332920: : <span class="built_in">read</span> foo 10 out of bar ffff880013a5bef8</span><br></pre></td></tr></tbody></table></figure><p>上面的示例是通过添加一个实际上具有 foo 和 bar 构造的模块来完成的 。</p><p>trace_printk() 输出将出现在任何跟踪器中，甚至是函数和函数图跟踪器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># insmod ~/modules/foo.ko</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 3) + 16.283 us   |      }</span><br><span class="line"> 3) + 17.364 us   |    }</span><br><span class="line"> 3)               |    <span class="function"><span class="title">do_one_initcall</span></span>() {</span><br><span class="line"> 3)               |      /* <span class="built_in">read</span> foo 10 out of bar ffff88001191bef8 */</span><br><span class="line"> 3)   4.221 us    |    }</span><br><span class="line"> 3)               |    <span class="function"><span class="title">__wake_up</span></span>() {</span><br><span class="line"> 3)   0.633 us    |      _spin_lock_irqsave();</span><br><span class="line"> 3)   0.538 us    |      __wake_up_common();</span><br><span class="line"> 3)   0.563 us    |      _spin_unlock_irqrestore();</span><br></pre></td></tr></tbody></table></figure><p>是的，trace_printk() 输出看起来像函数图跟踪器中的注释。</p><h1 id="starting-and-stopping-the-trace">Starting and stopping the trace</h1><p>显然，有时您只想跟踪特定的代码路径。也许您只想跟踪运行特定测试时发生的情况。文件 tracing_on 用于禁止环形缓冲区记录数据：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracking_on</span></span><br></pre></td></tr></tbody></table></figure><p>这将禁用 Ftrace 环形缓冲区的记录。其他所有事情仍然发生在跟踪器上，它们仍然会产生大部分开销。他们确实注意到环形缓冲区没有记录，也不会尝试写入任何数据，但仍会执行跟踪器发出的调用。</p><p>要重新启用环形缓冲区，只需将“1”写入该文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 1 &gt;tracing_on</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，在数字和大于号“ &gt; ”之间有一个空格非常重要。否则，您可能正在将标准输入或输出写入该文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0&gt;tracing_on /* 这行不通！*/</span></span><br></pre></td></tr></tbody></table></figure><p>一个常见的运行可能是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracing_on</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; tracing_on; run_test; echo 0 &gt; tracing_on</span></span><br></pre></td></tr></tbody></table></figure><p>第一行禁止环形缓冲区记录任何数据。接下来启用函数图跟踪器。函数图跟踪器的开销仍然存在，但不会将任何内容记录到跟踪缓冲区中。最后一行启用环形缓冲区，运行测试程序，然后禁用环形缓冲区。这缩小了函数图跟踪器存储的数据范围，以仅包括 run_test 程序积累的数据 。</p><h1 id="trace-markers">Trace Markers</h1><p>查看内核内部发生的事情可以让用户更好地了解他们的系统是如何工作的。但有时需要在用户空间发生的事情和内核内部发生的事情之间进行协调。跟踪中显示的时间戳都与跟踪中发生的事情有关，但它们与墙时间不太对应。</p><p>为了帮助同步用户空间和内核空间中的操作，创建了 trace_marker 文件。它提供了一种从用户空间写入 Ftrace 环形缓冲区的方法。该标记随后将出现在轨迹中，以给出轨迹中特定事件发生的位置。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo hello world &gt; trace_marker</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-3718  [001]  5546.183420: 0: hello world</span><br></pre></td></tr></tbody></table></figure><p>在&lt;...&gt;表示该写的标记任务的名字没有记录。未来的版本可能会解决这个问题。</p><h1 id="starting-stopping-and-recording-in-a-program">Starting, Stopping and Recording in a Program</h1><p>该 tracing_on 和 trace_marker 文件的工作很好地跟踪应用程序的活动，如果应用程序的源可用。如果应用程序中存在问题并且您需要找出应用程序特定位置的内核内部发生了什么，这两个文件就派上用场了。</p><p>在应用程序启动时，您可以打开这些文件以准备好文件描述符：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> trace_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> marker_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">char</span> *debugfs;</span><br><span class="line"> <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line"> [...]</span><br><span class="line"></span><br><span class="line"> debugfs = find_debugfs();</span><br><span class="line"> <span class="keyword">if</span> (debugfs) {</span><br><span class="line">  <span class="built_in">strcpy</span>(path, debugfs);  <span class="comment">/* BEWARE buffer overflow */</span></span><br><span class="line">  <span class="built_in">strcat</span>(path,<span class="string">"/tracing/tracing_on"</span>);</span><br><span class="line">  trace_fd = open(path, O_WRONLY);</span><br><span class="line">  <span class="keyword">if</span> (trace_fd &gt;= <span class="number">0</span>)</span><br><span class="line">   write(trace_fd, <span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(path, debugfs);</span><br><span class="line">  <span class="built_in">strcat</span>(path,<span class="string">"/tracing/trace_marker"</span>);</span><br><span class="line">  marker_fd = open(path, O_WRONLY);</span><br></pre></td></tr></tbody></table></figure><p>然后，在代码中的某个关键位置，可以放置标记以显示应用程序当前所在的位置：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (marker_fd &gt;= <span class="number">0</span>)</span><br><span class="line"> write(marker_fd, <span class="string">"In critical area\n"</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (critical_function() &lt; <span class="number">0</span>) {</span><br><span class="line"> <span class="comment">/* we failed! */</span></span><br><span class="line"> <span class="keyword">if</span> (trace_fd &gt;= <span class="number">0</span>)</span><br><span class="line">  write(trace_fd, <span class="string">"0"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在查看示例时，您首先会看到一个名为“find_debugfs()”的函数。挂载调试文件系统的正确位置是/sys/kernel/debug 但强大的工具不应依赖于挂载在那里的调试文件系统。find_debugfs() 的示例 位于此处。文件描述符被初始化为 -1 以允许此代码在启用和不启用跟踪的内核的情况下工作。</p><p>当检测到问题时，将 ASCII 字符“0”写入 trace_fd 文件描述符将停止跟踪。正如在第 1 部分中讨论的那样，这只会禁用记录到 Ftrace 环形缓冲区中，但跟踪器仍然会产生开销。</p><p>使用上面的初始化代码时，跟踪将在应用程序开始时启用，因为跟踪器以覆盖模式运行。也就是说，当跟踪缓冲区填满时，它将删除旧数据并用新数据替换它。由于在出现问题时只有最近的跟踪信息是相关的，因此在应用程序正常运行期间无需停止和启动跟踪。只有在检测到问题时才需要禁用跟踪器，以便跟踪记录导致错误的历史记录。如果应用程序中需要间隔跟踪，它可以将 ASCII“1”写入 trace_fd 以启用跟踪。</p><p>下面是一个名为 simple_trace.c 的简单程序示例， 它使用上述初始化过程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.tv_sec = <span class="number">0</span>;</span><br><span class="line">req.tv_nsec = <span class="number">1000</span>;</span><br><span class="line">write(marker_fd, <span class="string">"before nano\n"</span>, <span class="number">12</span>);</span><br><span class="line">nanosleep(&amp;req, <span class="literal">NULL</span>);</span><br><span class="line">write(marker_fd, <span class="string">"after nano\n"</span>, <span class="number">11</span>);</span><br><span class="line">write(trace_fd, <span class="string">"0"</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>（由于这是一个仅用于示例目的的简单程序，因此未添加错误检查。） 这是跟踪这个简单程序的过程：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracing_on</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># ~/simple_trace</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br></pre></td></tr></tbody></table></figure><p>第一行禁用跟踪，因为程序将在启动时启用它。接下来选择函数图跟踪器。程序被执行，结果如下。请注意，输出可能有点冗长，其中大部分内容已被删除并替换为 [...]：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">  0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line">  0)   0.528 us    |        get_slab();</span><br><span class="line">  0)   2.271 us    |      }</span><br><span class="line">  0)               |      /* before nano */</span><br><span class="line">  0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line">  0)   0.475 us    |        __phys_addr();</span><br><span class="line">  0)   2.062 us    |      }</span><br><span class="line">  0)   0.608 us    |      inotify_inode_queue_event();</span><br><span class="line">  0)   0.485 us    |      __fsnotify_parent();</span><br><span class="line"> [...]</span><br><span class="line">  1)   0.523 us    |          _spin_unlock();</span><br><span class="line">  0)   0.495 us    |    current_kernel_time();</span><br><span class="line">  1)               |          <span class="function"><span class="title">it_real_fn</span></span>() {</span><br><span class="line">  0)   1.602 us    |  }</span><br><span class="line">  1)   0.728 us    |            __rcu_read_lock();</span><br><span class="line">  0)               |  <span class="function"><span class="title">sys_nanosleep</span></span>() {</span><br><span class="line">  0)               |    <span class="function"><span class="title">hrtimer_nanosleep</span></span>() {</span><br><span class="line">  0)   0.526 us    |      hrtimer_init();</span><br><span class="line">  1)   0.418 us    |            __rcu_read_lock();</span><br><span class="line">  0)               |      <span class="function"><span class="title">do_nanosleep</span></span>() {</span><br><span class="line">  1)   1.114 us    |            _spin_lock_irqsave();</span><br><span class="line"> [...]</span><br><span class="line">  0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line">  1)   2.760 us    |  }</span><br><span class="line">  0)   0.556 us    |        get_slab();</span><br><span class="line">  1)               |  <span class="function"><span class="title">mwait_idle</span></span>() {</span><br><span class="line">  0)   1.851 us    |      }</span><br><span class="line">  0)               |      /* after nano */</span><br><span class="line">  0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line">  0)   0.486 us    |        __phys_addr();</span><br></pre></td></tr></tbody></table></figure><p>请注意，对 trace_marker 的写入在函数图跟踪器中显示为注释。 这里的第一列代表 CPU。当我们像这样交错 CPU 跟踪时，可能很难读取跟踪。工具 grep 可以很容易地过滤它，或者可以使用 per_cpu 跟踪文件。 per_cpu 跟踪文件位于 per_cpu 下的 debugfs 跟踪目录中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># ls per_cpu</span></span><br><span class="line">cpu0  cpu1  cpu2  cpu3  cpu4  cpu5  cpu6  cpu7</span><br></pre></td></tr></tbody></table></figure><p>在这些 CPU 目录中的每一个目录中都存在一个跟踪文件，仅显示该 CPU 的跟踪。 要在不受其他 CPU 干扰的情况下更好地了解函数图跟踪器，只需查看 per_cpu/cpu0/trace。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat per_cpu/cpu0/trace</span></span><br><span class="line"> 0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line"> 0)   0.528 us    |        get_slab();</span><br><span class="line"> 0)   2.271 us    |      }</span><br><span class="line"> 0)               |      /* before nano */</span><br><span class="line"> 0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)   0.475 us    |        __phys_addr();</span><br><span class="line"> 0)   2.062 us    |      }</span><br><span class="line"> 0)   0.608 us    |      inotify_inode_queue_event();</span><br><span class="line"> 0)   0.485 us    |      __fsnotify_parent();</span><br><span class="line"> 0)   0.488 us    |      inotify_dentry_parent_queue_event();</span><br><span class="line"> 0)   1.106 us    |      fsnotify();</span><br><span class="line">[...]</span><br><span class="line"> 0)   0.721 us    |    _spin_unlock_irqrestore();</span><br><span class="line"> 0)   3.380 us    |  }</span><br><span class="line"> 0)               |  <span class="function"><span class="title">audit_syscall_entry</span></span>() {</span><br><span class="line"> 0)   0.495 us    |    current_kernel_time();</span><br><span class="line"> 0)   1.602 us    |  }</span><br><span class="line"> 0)               |  <span class="function"><span class="title">sys_nanosleep</span></span>() {</span><br><span class="line"> 0)               |    <span class="function"><span class="title">hrtimer_nanosleep</span></span>() {</span><br><span class="line"> 0)   0.526 us    |      hrtimer_init();</span><br><span class="line"> 0)               |      <span class="function"><span class="title">do_nanosleep</span></span>() {</span><br><span class="line"> 0)               |        <span class="function"><span class="title">hrtimer_start_range_ns</span></span>() {</span><br><span class="line"> 0)               |          <span class="function"><span class="title">__hrtimer_start_range_ns</span></span>() {</span><br><span class="line"> 0)               |            <span class="function"><span class="title">lock_hrtimer_base</span></span>() {</span><br><span class="line"> 0)   0.866 us    |              _spin_lock_irqsave();</span><br><span class="line">[...]</span><br><span class="line"> 0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line"> 0)               |        <span class="function"><span class="title">get_slab</span></span>() {</span><br><span class="line"> 0)   1.851 us    |      }</span><br><span class="line"> 0)               |      /* after nano */</span><br><span class="line"> 0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)   0.486 us    |        __phys_addr();</span><br></pre></td></tr></tbody></table></figure><h1 id="disabling-the-tracer-within-the-kernel">Disabling the Tracer Within the Kernel</h1><p>在内核驱动程序的开发过程中，可能会存在测试过程中出现的奇怪错误。也许驱动陷入睡眠状态，永远不会醒来。当内核事件发生时，试图从用户空间禁用跟踪器是很困难的，通常会导致缓冲区溢出和相关信息丢失，然后用户才能停止跟踪。</p><p>有两个在内核中运行良好的函数： tracing_on() 和 tracking_off()。这两个行为就像分别将“1”或“0” echo 到 tracing_on 文件中一样。如果内核中存在可以检查的某些条件，则可以通过添加如下内容来停止跟踪器：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test_for_error())</span><br><span class="line"> tracking_off();</span><br></pre></td></tr></tbody></table></figure><p>接下来，添加几个 trace_printk() s（参见第 1 部分），重新编译并引导内核。然后，您可以启用函数或函数图跟踪器，然后等待错误条件发生。检查 tracing_on 文件将让您知道错误条件何时发生。当内核调用 tracking_off() 时，它将从“1”切换到“0” 。</p><p>检查跟踪后，或将其保存在另一个文件中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> trace &gt; ~/trace.sav</span><br></pre></td></tr></tbody></table></figure><p>您可以继续跟踪以检查另一个命中。为此，只需将“1” echo 到 tracing_on 中，跟踪将继续。如果可以合法触发触发 tracing_off() 调用的条件，这也很有用 。如果条件是由正常操作触发的，只需通过在 tracing_on 中 echo “1”来重新启动跟踪，希望下次遇到条件时将是因为异常。</p><h1 id="ftrace_dump_on_oops">ftrace_dump_on_oops</h1><p>有时内核会崩溃，检查内存和崩溃状态更像是一门 CSI 科学，而不是程序调试科学。将 kdump / kexec 与 crash 实用程序一起使用是检查崩溃点系统状态的一种有价值的方法，但它不会让您看到在导致崩溃的事件之前发生了什么。</p><p>在内核引导参数中配置 Ftrace 并启用 ftrace_dump_on_oops，或者通过在/proc/sys/kernel/ftrace_dump_on_oops 中 echo “1” ，将使 Ftrace 能够在 oops 或 panic 时以 ASCII 格式将整个跟踪缓冲区转储到控制台。将控制台输出到串行日志使调试崩溃更容易。您现在可以追溯导致崩溃的事件。</p><p>转储到控制台可能需要很长时间，因为默认的 Ftrace 环形缓冲区每个 CPU 超过 1 兆字节。要缩小环形缓冲区的大小，请将希望环形缓冲区的千字节数写入 buffer_size_kb。请注意，该值是每个 CPU，而不是环形缓冲区的总大小。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 50 &gt; buffer_size_kb</span></span><br></pre></td></tr></tbody></table></figure><p>以上将把 Ftrace 环形缓冲区缩小到每个 CPU 50 KB。 您还可以使用 sysrq-z 将 Ftrace 缓冲区的转储触发到控制台 。</p><p>要为内核转储选择特定位置，内核可以直接调用 ftrace_dump()。请注意，这可能会永久禁用 Ftrace，可能需要重新启动才能再次启用它。这是因为 ftrace_dump() 读取缓冲区。缓冲区被写入所有上下文（中断、NMI、调度），但缓冲区的读取需要锁定。为了能够执行 ftrace_dump() 锁定被禁用并且缓冲区可能最终在输出后被破坏。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following code will lock up the box, so we dump out the</span></span><br><span class="line"><span class="comment"> * trace before we hit that location.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ftrace_dump();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* code that locks up */</span></span><br></pre></td></tr></tbody></table></figure><h1 id="stack-tracing">Stack Tracing</h1><p>最后要讨论的主题是检查内核堆栈大小以及每个函数使用多少堆栈空间的能力。启用堆栈跟踪器 ( CONFIG_STACK_TRACER ) 将显示堆栈的最大使用发生在哪里。</p><p>堆栈跟踪器是从函数跟踪器基础结构构建的。它不使用 Ftrace 环形缓冲区，但确实使用函数跟踪器来挂钩每个函数调用。因为它使用函数跟踪器基础结构，所以在未启用时不会增加开销。要启用堆栈跟踪器，请将 1 echo 到 /proc/sys/kernel/stack_tracer_enabled 中。要查看启动期间的最大堆栈大小，请将“ stacktrace ”添加到内核​​启动参数。</p><p>堆栈跟踪器在每次函数调用时检查堆栈的大小。如果它大于最后记录的最大值，它会记录堆栈跟踪并使用新大小更新最大值。要查看当前最大值，请查看 stack_max_size 文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat stack_max_size</span></span><br><span class="line">2928</span><br><span class="line">[tracing]<span class="comment"># cat stack_trace</span></span><br><span class="line">        Depth    Size   Location    (34 entries)</span><br><span class="line">        -----    ----   --------</span><br><span class="line">  0)     2952      16   mempool_alloc_slab+0x15/0x17</span><br><span class="line">  1)     2936     144   mempool_alloc+0x52/0x104</span><br><span class="line">  2)     2792      16   scsi_sg_alloc+0x4a/0x4c [scsi_mod]</span><br><span class="line">  3)     2776     112   __sg_alloc_table+0x62/0x103</span><br><span class="line">[...]</span><br><span class="line"> 13)     2072      48   __elv_add_request+0x98/0x9f</span><br><span class="line"> 14)     2024     112   __make_request+0x43e/0x4bb</span><br><span class="line"> 15)     1912     224   generic_make_request+0x424/0x471</span><br><span class="line"> 16)     1688      80   submit_bio+0x108/0x115</span><br><span class="line"> 17)     1608      48   submit_bh+0xfc/0x11e</span><br><span class="line"> 18)     1560     112   __block_write_full_page+0x1ee/0x2e8</span><br><span class="line"> 19)     1448      80   block_write_full_page_endio+0xff/0x10e</span><br><span class="line"> 20)     1368      16   block_write_full_page+0x15/0x17</span><br><span class="line"> 21)     1352      16   blkdev_writepage+0x18/0x1a</span><br><span class="line"> 22)     1336      32   __writepage+0x1a/0x40</span><br><span class="line"> 23)     1304     304   write_cache_pages+0x241/0x3c1</span><br><span class="line"> 24)     1000      16   generic_writepages+0x27/0x29</span><br><span class="line">[...]</span><br><span class="line"> 30)      424      64   bdi_writeback_task+0x3f/0xb0</span><br><span class="line"> 31)      360      48   bdi_start_fn+0x76/0xd7</span><br><span class="line"> 32)      312     128   kthread+0x7f/0x87</span><br><span class="line"> 33)      184     184   child_rip+0xa/0x20</span><br></pre></td></tr></tbody></table></figure><p>这不仅为您提供了找到的最大堆栈的大小，还显示了每个函数使用的堆栈大小的细分。请注意， write_cache_pages 的堆栈最大，使用了 304 个字节，其次是 generic_make_request，使用了 224 个字节的堆栈。</p><p>要重置最大值，请将“0”回显到 stack_max_size 文件中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; stack_max_size</span></span><br></pre></td></tr></tbody></table></figure><p>保持运行一段时间将显示内核使用过多堆栈的位置。但请记住，堆栈跟踪器只有在未启用时才没有开销。当它运行时，您可能会注意到性能有所下降。</p><p>请注意，当内核使用单独的堆栈时，堆栈跟踪器不会跟踪最大堆栈大小。因为中断有自己的堆栈，它不会跟踪那里的堆栈使用情况。原因是当堆栈不是当前任务的堆栈时，目前没有简单的方法可以快速查看堆栈的顶部是什么。使用拆分堆栈时，进程堆栈可能是两页，而中断堆栈可能只有一页。这可能会在未来修复，但在使用堆栈跟踪器时请记住这一点。</p><h1 id="function-filtering">Function filtering</h1><p>运行函数跟踪器可能会让人不知所措。数据量可能很大，人脑很难掌握。Ftrace 提供了一种方法来限制您看到的功能。存在两个文件，可让您限制跟踪的功能：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_ftrace_filter</span><br><span class="line">set_ftrace_notrace</span><br></pre></td></tr></tbody></table></figure><p>这些过滤功能取决于 CONFIG_DYNAMIC_FTRACE 选项。如前几篇文章所述，当启用此配置时，所有 mcount 调用者位置都将被存储，并在启动时转换为 NOP。这些位置被保存并用于在功能跟踪器被激活时启用跟踪。但这也有一个很好的副作用：并非所有功能都必须启用。上述文件将确定哪些功能被启用，哪些不启用。</p><p>当 set_ftrace_filter 中列出任何函数时，只会跟踪那些函数。当跟踪处于活动状态时，这将有助于系统的性能。跟踪每个函数会产生很大的开销，但是在使用 set_ftrace_filter 时，只有该文件中列出的那些函数才会更改 NOP 以调用跟踪器。根据正在跟踪的功能，仅启用几百个功能几乎不会引起注意。</p><p>该 set_ftrace_notrace 文件是相反 set_ftrace_filter。不是将跟踪限制为一组函数，而是不会跟踪 set_ftrace_notrace 中列出的函数。某些函数经常出现，跟踪这些函数不仅会减慢系统速度，还会填满跟踪缓冲区，并使分析您关心的函数变得更加困难。rcu_read_lock() 和 spin_lock() 等函数 属于这一类。</p><p>向这些文件添加函数的过程通常使用 bash 重定向。使用符号“&gt;”将删除文件中的所有现有函数并将正在回显的内容添加到文件中。使用“&gt;&gt;”附加到文件将保留现有功能并添加新功能。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo sys_read &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo sys_write &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_write</span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo sys_open &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_open</span><br></pre></td></tr></tbody></table></figure><p>要删除所有功能，只需在过滤器文件中回显一个空行即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo sys_read sys_open sys_write &gt; set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_notrace</span></span><br><span class="line">sys_open</span><br><span class="line">sys_write</span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>这些文件中列出的函数也可以在内核命令行上设置。选项 ftrace_notrace 和 ftrace_filter 将通过列出逗号分隔的函数集来预设这些文件。</p><pre><code>ftrace_notrace=rcu_read_lock,rcu_read_unlock,spin_lock,spin_unlockftrace_filter=kfree,kmalloc,schedule,vmalloc_fault,spurious_fault</code></pre><p>内核命令行添加的函数设置了相应过滤器文件中的内容。这些选项仅预加载文件，仍然可以使用如上所述的 bash 重定向来删除或添加功能。 set_ftrace_notrace 中列出的函数优先。也就是说，如果一个函数同时列在 set_ftrace_notrace 和 set_ftrace_filter 中，则不会跟踪该函数。</p><h1 id="wildcard-filters">Wildcard filters</h1><p>可以添加到过滤器文件的函数列表显示在 available_filter_functions 文件中。这个函数列表源自前面提到的存储的 mcount 调用者列表。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat available_filter_functions | head -8</span></span><br><span class="line">_stext</span><br><span class="line">do_one_initcall</span><br><span class="line">run_init_process</span><br><span class="line">init_post</span><br><span class="line">name_to_dev_t</span><br><span class="line">create_dev</span><br><span class="line">T.627</span><br><span class="line">set_personality_64bit</span><br></pre></td></tr></tbody></table></figure><p>您可以 grep 此文件并将结果重定向到过滤器文件之一： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># grep sched available_filter_functions &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter | head -8</span></span><br><span class="line">save_stack_address_nosched</span><br><span class="line">mce_schedule_work</span><br><span class="line">smp_reschedule_interrupt</span><br><span class="line">native_smp_send_reschedule</span><br><span class="line">sys32_sched_rr_get_interval</span><br><span class="line">sched_avg_update</span><br><span class="line">proc_sched_set_task</span><br><span class="line">sys_sched_get_priority_max</span><br></pre></td></tr></tbody></table></figure><p></p><p>不幸的是，向过滤文件添加大量函数很慢，您会注意到上面的 grep 需要几秒钟才能执行。这是因为写入过滤器文件的每个函数名称将被单独处理。上面的 grep 产生了 300 多个函数名。这 300 个名称中的每一个都将与内核中的每个函数名称进行比较（使用 strcmp()），这相当多。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># wc -l  available_filter_functions</span></span><br><span class="line">24331 available_filter_functions</span><br></pre></td></tr></tbody></table></figure><p>所以上面的 grep 导致 set_ftrace_filter 生成超过 300 * 24331 (7,299,300) 次比较！</p><p>幸运的是，这些文件也使用通配符；以下 glob 表达式是有效的：</p><p>value* - 选择所有以 value 开头的函数。 *value* - 选择所有包含文本 value 的函数。 *value - 选择所有以 value 结尾的函数。</p><p>内核包含一个相当简单的解析器，不会以预期的方式处理 value*value。它将忽略第二个 值并选择所有以 value 开头的函数，而不管它以什么结尾。传递给过滤器文件的通配符直接针对每个可用函数进行处理，这比在列表中传递单个函数要快得多。</p><p>因为 bash 也使用星号 (*)，所以最好用引号将输入括起来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo set* &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">[tracing]<span class="comment"># echo 'set*' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter | head -5</span></span><br><span class="line">set_personality_64bit</span><br><span class="line">set_intr_gate_ist</span><br><span class="line">set_intr_gate</span><br><span class="line">set_tsc_mode</span><br></pre></td></tr></tbody></table></figure><p>过滤器还可以通过在过滤器文件的输入中使用“mod”命令来仅选择属于特定模块的那些函数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo ':mod:tg3' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter |head -8</span></span><br><span class="line">tg3_write32</span><br><span class="line">tg3_read32</span><br><span class="line">tg3_write_flush_reg32</span><br><span class="line">tw32_mailbox_flush</span><br><span class="line">tg3_write32_tx_mbox</span><br><span class="line">tg3_read32_mbox_5906</span><br><span class="line">tg3_write32_mbox_5906</span><br><span class="line">tg3_disable_ints</span><br></pre></td></tr></tbody></table></figure><p>如果您正在调试单个模块，并且只想在跟踪中查看属于该模块的函数，这将非常有用。</p><p>在之前的文章中，启用和禁用记录到环形缓冲区是使用 tracing_on 文件以及 tracing_on() 和 tracing_off() 内核函数完成的。但是，如果您不想重新编译内核，并且想在特定函数处停止跟踪，则 set_ftrace_filter 有一个方法可以这样做。 使功能跟踪启用或禁用环形缓冲区的命令格式如下：</p><pre><code>function:command[:count]</code></pre><p>这将在函数开始 时执行命令。该命令是 traceon 或 traceoff，并且可以添加一个可选的计数以使命令只执行给定的次数。如果计数被保留（包括前导冒号），则每次调用该函数时都会执行该命令。</p><p>不久前，我正在调试对内核所做的更改，该更改导致某些程序出现分段错误。我很难捕捉到跟踪，因为当我看到分段错误后能够停止跟踪时，数据已经被覆盖了。但是控制台上的回溯显示正在调用函数__bad_area_nosemaphore。然后我可以使用以下命令停止跟踪器：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo '__bad_area_nosemaphore:traceoff' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">__bad_area_nosemaphore:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，带有命令的函数不会影响一般过滤器。即使已将命令添加到 __bad_area_nosemaphore，过滤器仍允许跟踪所有函数。命令和过滤器功能是分开的，互不影响。将上述命令附加到函数 __bad_area_nosemaphore 后，下次发生分段错误时，跟踪停止并包含调试情况所需的数据。</p><h1 id="removing-functions-from-the-filters">Removing functions from the filters</h1><p>如前所述，用“&gt;”回显将清除过滤器文件。但是如果您只想从过滤器中删除一些功能怎么办？</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter &gt; /tmp/filter</span></span><br><span class="line">[tracing]<span class="comment"># grep -v lock /tmp/filter &gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure><p>上述工作，但如前所述，如果 set_ftrace_filter 中已有多个函数，则可能需要一段时间才能完成。以下执行相同的操作，但速度要快得多：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo '!*lock*' &gt;&gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure><p>这 '！'符号将删除过滤器文件中列出的函数。如上所示，“！”与通配符一起使用，但也可以与单个函数一起使用。自从 '！'在 bash 中具有特殊含义，它必须用单引号括起来，否则 bash 将尝试执行其后的内容。另请注意使用了“&gt;&gt;”。如果您错误地使用了“&gt;”，则过滤器文件中将没有任何功能。 因为命令和过滤器不会相互干扰，清除 set_ftrace_filter 不会清除命令。命令必须用“！”清除象征。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 'sched*' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># echo 'schedule:traceoff' &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | tail -5</span></span><br><span class="line">schedule_console_callback</span><br><span class="line">schedule_bh</span><br><span class="line">schedule_iso_resource</span><br><span class="line">schedule_reallocations</span><br><span class="line">schedule:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">schedule:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo '!schedule:traceoff' &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">[tracing]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>这可能看起来很别扭，但是使用“&gt;”和“&gt;&gt;”只影响要跟踪的函数而不影响函数命令，实际上简化了过滤函数和添加和删除命令之间的控制。</p><h1 id="tracing-a-specific-process">Tracing a specific process</h1><p>也许您只需要跟踪一个特定的进程或一组进程。文件 set_ftrace_pid 允许您指定要跟踪的特定进程。要仅跟踪当前线程，您可以执行以下操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo $$ &gt; set_ftrace_pid</span></span><br></pre></td></tr></tbody></table></figure><p>上面将设置函数 tracer 只跟踪执行 echo 命令的 bash shell。如果要跟踪特定进程，可以创建一个 shell 脚本包装程序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat ~/bin/ftrace-me</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">DEBUGFS=`grep debugfs /proc/mounts | awk <span class="string">'{ print $2; }'</span>`</span><br><span class="line"><span class="built_in">echo</span> $$ &gt; <span class="variable">$DEBUGFS</span>/tracing/set_ftrace_pid</span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; <span class="variable">$DEBUGFS</span>/tracing/current_tracer</span><br><span class="line"><span class="built_in">exec</span> $*</span><br><span class="line">[tracing]<span class="comment"># ~/bin/ftrace-me ls -ltr</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，如果要在执行上述操作后返回通用函数跟踪，则必须清除 set_ftrace_pid 文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo -1 &gt; set_ftrace_pid</span></span><br></pre></td></tr></tbody></table></figure><h1 id="what-calls-a-specific-function">What calls a specific function?</h1><p>有时了解什么在调用特定函数很有用。直接前任很有帮助，但整个回溯甚至更好。函数跟踪器包含一个选项，该选项将为跟踪器调用的每个函数在环形缓冲区中创建一个回溯。由于为每个函数创建回溯具有很大的开销，这可能会实时锁定系统，因此在使用此功能时必须小心。想象一下运行在 1000 HZ 的较慢系统上的定时器中断。很可能让定时器中断调用产生回溯的每个函数需要 1 毫秒才能完成。到定时器中断返回时，将在任何其他工作完成之前触发一个新的中断，从而导致活锁。</p><p>要使用函数跟踪器回溯功能，被调用的函数必须受到函数过滤器的限制。启用函数回溯的选项是函数跟踪器独有的，只有在启用函数跟踪器时才能激活它。这意味着您必须先启用函数跟踪器，然后才能访问该选项：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo kfree &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">kfree</span><br><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; options/func_stack_trace</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | tail -8</span></span><br><span class="line"> =&gt; sys32_execve</span><br><span class="line"> =&gt; ia32_ptregs_common</span><br><span class="line">             cat-6829  [000] 1867248.965100: kfree &lt;-free_bprm</span><br><span class="line">             cat-6829  [000] 1867248.965100: &lt;stack trace&gt;</span><br><span class="line"></span><br><span class="line"> =&gt; free_bprm</span><br><span class="line"> =&gt; compat_do_execve</span><br><span class="line"> =&gt; sys32_execve</span><br><span class="line"> =&gt; ia32_ptregs_common</span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/func_stack_trace</span></span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，在启用 func_stack_trace 选项以确保启用过滤器之前，我小心地对 set_ftrace_filter 进行分类。最后，我在禁用过滤器之前禁用了 options/func_stack_trace。还要注意该选项是非易失性的，也就是说，即使您在 current_tracer 中启用了另一个跟踪器插件，如果您重新启用跟踪器功能，该选项仍然会启用。</p><h1 id="the-function_graph-tracer">The function_graph tracer</h1><p>函数跟踪器非常强大，但可能很难理解它产生的线性格式。Frederic Weisbecker 已将函数跟踪器扩展到 function_graph 跟踪器。function_graph 跟踪器搭载了大部分由函数跟踪器创建的代码，但在 mcount 调用中添加了自己的钩子。因为它仍然使用 mcount 调用方法，所以上面解释的大部分函数过滤也适用于 function_graph 跟踪器，但 traceon / traceoff 命令和 set_ftrace_pid 除外（尽管后者将来可能会改变）。 function_graph tracer 在之前的文章中也有说明，但是 set_graph_function 文件没有说明。上一节中使用的 func_stack_trace 可以看到什么可能调用一个函数，但是 set_graph_function 可以用来查看一个函数调用了什么：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo kfree &gt; set_graph_function</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 0)               |  <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)               |    <span class="function"><span class="title">virt_to_cache</span></span>() {</span><br><span class="line"> 0)               |      <span class="function"><span class="title">virt_to_head_page</span></span>() {</span><br><span class="line"> 0)   0.955 us    |        __phys_addr();</span><br><span class="line"> 0)   2.643 us    |      }</span><br><span class="line"> 0)   4.299 us    |    }</span><br><span class="line"> 0)   0.855 us    |    __cache_free();</span><br><span class="line"> 0)   ==========&gt; |</span><br><span class="line"> 0)               |    <span class="function"><span class="title">smp_apic_timer_interrupt</span></span>() {</span><br><span class="line"> 0)               |      <span class="function"><span class="title">apic_write</span></span>() {</span><br><span class="line"> 0)   0.849 us    |        native_apic_mem_write();</span><br><span class="line"> 0)   2.853 us    |      }</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_graph_function</span></span><br></pre></td></tr></tbody></table></figure><p>这将显示仅由 kfree() 执行的调用图。“ ==========&gt; ”表示通话过程中发生了中断。跟踪记录 kfree() 块中的所有函数，甚至是那些在 kfree() 范围内触发的中断调用的函数。</p><p>function_graph 跟踪器显示函数在持续时间字段中花费的时间。在之前的文章中提到，只有叶子函数，即不调用其他函数的叶函数，才有准确的持续时间，因为父函数的持续时间还包括 function_graph 跟踪器调用子函数的开销。通过使用 set_ftrace_filter 文件，您可以强制任何函数成为 function_graph 跟踪器中的叶函数，这将允许您查看该函数的准确持续时间。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo smp_apic_timer_interrupt &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | head</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 16.433 us   |  smp_apic_timer_interrupt();</span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 25.897 us   |  smp_apic_timer_interrupt();</span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 24.764 us   |  smp_apic_timer_interrupt();</span><br></pre></td></tr></tbody></table></figure><p>上面显示定时器中断需要 16 到 26 微秒才能完成。</p><h1 id="function-profiling">Function profiling</h1><p>oprofile 和 perf 是非常强大的分析工具，它们定期对系统进行采样，并可以显示大部分时间都花在了什么地方。使用函数分析器，可以很好地查看实际的函数执行情况，而不仅仅是示例。如果内核中配置了 CONFIG_FUNCTION_GRAPH_TRACER，则函数分析器将使用函数图基础结构来记录函数执行了多长时间。如果只配置了 CONFIG_FUNCTION_TRACER，函数分析器将只计算被调用的函数。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo nop &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function 0 |head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  schedule                             22943    1994458706 us     86931.03 us</span><br><span class="line">  poll_schedule_timeout                 8683    1429165515 us     164593.5 us</span><br><span class="line">  schedule_hrtimeout_range              8638    1429155793 us     165449.8 us</span><br><span class="line">  sys_poll                             12366    875206110 us     70775.19 us</span><br><span class="line">  do_sys_poll                          12367    875136511 us     70763.84 us</span><br><span class="line">  compat_sys_select                     3395    527531945 us     155384.9 us</span><br><span class="line">  compat_core_sys_select                3395    527503300 us     155376.5 us</span><br><span class="line">  do_select                             3395    527477553 us     155368.9 us</span><br></pre></td></tr></tbody></table></figure><p>以上还包括函数被抢占或 schedule() 被调用以及任务被换出的次数。这可能看起来没用，但它确实可以让我们了解哪些函数经常被抢占。 Ftrace 还包括允许您让函数图跟踪器忽略任务计划时间的选项。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/sleep-time</span></span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  default_idle                          2493    6763414 us     2712.962 us</span><br><span class="line">  native_safe_halt                      2492    6760641 us     2712.938 us</span><br><span class="line">  sys_poll                              4723    714243.6 us     151.226 us</span><br><span class="line">  do_sys_poll                           4723    692887.4 us     146.704 us</span><br><span class="line">  sys_read                              9211    460896.3 us     50.037 us</span><br><span class="line">  vfs_read                              9243    434521.2 us     47.010 us</span><br><span class="line">  smp_apic_timer_interrupt              3940    275747.4 us     69.986 us</span><br><span class="line">  sock_poll                            80613    268743.2 us     3.333 us</span><br></pre></td></tr></tbody></table></figure><p>请注意，sleep-time 选项包含“-”，而不是 sleep_time。</p><p>禁用功能分析器然后重新启用它会导致数字重置。该列表按平均时间排序，但使用脚本您可以轻松地按任何数字排序。所述 trace_stat / function0 仅表示存在一个 CPU 0 trace_stat /功能＃为系统上的每个 CPU。所有被追踪和命中的函数都在这个文件中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | wc -l</span></span><br><span class="line">2978</span><br></pre></td></tr></tbody></table></figure><p>未命中的函数未列出。以上显示自我开始分析以来，已命中 2978 个函数。</p><p>影响分析的另一个选项是图形时间（再次使用“-”）。默认情况下它是启用的。启用后，函数的时间包括函数内调用的所有函数的时间。从上面示例的输出中可以看出，列出了几个系统调用的平均值最高。禁用时，次数只包括函数本身的执行次数，不包括从函数调用函数的次数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/graph-time</span></span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  mwait_idle                           10132    246835458 us     24361.96 us</span><br><span class="line">  tg_shares_up                        154467    389883.5 us     2.524 us</span><br><span class="line">  _raw_spin_lock_irqsave              343012    263504.3 us     0.768 us</span><br><span class="line">  _raw_spin_unlock_irqrestore         351269    175205.6 us     0.498 us</span><br><span class="line">  walk_tg_tree                         14087    126078.4 us     8.949 us</span><br><span class="line">  __set_se_shares                     274937    88436.65 us     0.321 us</span><br><span class="line">  _raw_spin_lock                      100715    82692.61 us     0.821 us</span><br><span class="line">  kstat_irqs_cpu                      257500    80124.96 us     0.311 us</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>请注意，睡眠时间和图形时间也会影响 function_graph 跟踪器显示的持续时间。</p><h1 id="总结">总结</h1><p>函数跟踪器非常强大，有很多不同的选项。它已经在主线 Linux 中可用，并且希望在大多数发行版中默认启用。它允许您深入了解内核及其功能库，让您很好地了解事情发生的原因。开始使用函数跟踪器打开我们称之为内核的黑​​匣子。玩得开心！</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM2NTgzNS8=">https://lwn.net/Articles/365835/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM2Njc5Ni8=">https://lwn.net/Articles/366796/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM3MDQyMy8=">https://lwn.net/Articles/370423/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 并发与同步（四）RCU</title>
      <link href="/next/2021/LinuxKernel/LinuxSyncRCU/"/>
      <url>/next/2021/LinuxKernel/LinuxSyncRCU/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/syncRCU.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5YWMzNzBlM2U3NDA3NGNmODlhMDI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="rcu-概述">RCU 概述</h1><p>RCU 的全称 Read-Copy-Update，它是 Linux 内核中一种重要的同步机制。Linux 内核中已有了原子操作、自旋锁、读写自旋锁、读写信号量、互斥锁等锁机制，为什么要单独设计一个比它们复杂得多的新机制呢？回忆自旋锁、读写信号量和互斥锁的实现，它们都使用了原子操作指令，即原子地访问内存，多 CPU 争用共享的变量会让高速缓存一致性变得很糟，使得性能下降。</p><p>以读写信号量为例，除了上述缺点外，读写信号量还有一个致命弱点，它允许多个读者同时存在，但是读者和写者不能同时存在。因此 RCU 机制要实现的目标是，读者线程没有同步开销，或者说同步开销变得很小，甚至可以忽略不计，不需要额外的锁，不需要使用原子操作指令和内存屏障指令，即可畅通无阻地访问；而把需要同步的任务交给写者线程，写者线程等待所有读者线程完成后才会把旧数据销毁。</p><p>在 RCU 中，如果有多个写者同时存在，那么需要额外的保护机制。RCU 机制的原理可以概括为 RCU 记录了所有指向共享数据的指针的使用者，当要修改共享数据时，首先创建一个副本，在副本中修改。所有读者线程离开读者临界区之后，指针指向修改后的副本，并且删除旧数据。</p><p>RCU 的一个重要的应用场景是链表，链表可以有效地提高遍历读取数据的效率。读取链表成员数据时通常只需要 rcu_read_lock() 函数，允许多个线程同时读取该链表，并且允许一个线程同时修改链表。那为什么这个过程能保证链表访问的正确性呢？ 在读者遍历链表时，假设另外一个线程删除了一个节点。删除线程会把这个节点从链表中移出，但不会直接销毁它。RCU 会等到所有读线程读取完成后，才销毁这个节点。 RCU 提供的接口如下。</p><ul><li>rcu_read_lock()/ rcu_read_unlock()：组成一个 RCU 读者临界区</li><li>rcu_dereference()：用于获取被 RCU 保护的指针，读者线程要访问 RCU 保护的共享数据，需要使用该函数创建一个新指针，并且指向被 RCU 保护的指针</li><li>rcu_assign_pointer()：通常用于写者线程。在写者线程完成新数据的修改后，调用该接口可以让被 RCU 保护的指针指向新创建的数据，用 RCU 的术语是发布了更新后的数据</li><li>synchronize_rcu()：同步等待所有现存的读访问完成</li><li>call_rcu()：注册一个回调函数，当所有现存的读访问完成后，调用这个回调函数销毁旧数据</li></ul><h1 id="关于-rcu-的一个简单例子">关于 RCU 的一个简单例子</h1><p>下面通过关于 RCU 的一个简单例子来理解上述接口的含义，该例子来源于内核源代码中的 Documents/RCU/whatisrcu.rst，并且省略了一些异常处理情况。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">《关于 RCU 的一个简单例子》</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/rcupdate.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> a:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">g_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myrcu_reader_thread</span><span class="params">(<span class="type">void</span>* data)</span> <span class="comment">//读者线程</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        msleep(<span class="number">200</span>);</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        p = rcu_dereference(g_ptr);</span><br><span class="line">        <span class="keyword">if</span> (p) {</span><br><span class="line">            printk(<span class="string">"%s: read a = %d\n"</span>, __func__, p-&gt;a);</span><br><span class="line">        }</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myrcu_del</span><span class="params">(<span class="keyword">struct</span> rcu_head *rh)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">p</span> =</span> container_of(rh, <span class="keyword">struct</span> foo, rcu);</span><br><span class="line">    printk(<span class="string">"%s: read a = %d\n"</span>, __func__, p-&gt;a);</span><br><span class="line">    kfree(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myrcu_writer_thread</span><span class="params">(<span class="type">void</span>* p)</span> <span class="comment">//写者线程</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">new</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="type">int</span> value = (<span class="type">unsigned</span> <span class="type">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        msleep(<span class="number">400</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">new_ptr</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo), GFP_KERNEL);</span><br><span class="line">        old = g_ptr;</span><br><span class="line">        printk(<span class="string">"%s: read a = %d\n"</span>, __func__, value);</span><br><span class="line">        *new_ptr = *old;</span><br><span class="line">        new_ptr-&gt;a = value;</span><br><span class="line">        rcu_assign_pointer(g_ptr, new_ptr);</span><br><span class="line">        call_rcu(&amp;old_rcu, myrcu_del);</span><br><span class="line">        value++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">reader_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">writer_thread</span>;</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"BEN: my module init\n"</span>);</span><br><span class="line"></span><br><span class="line">    g_ptr = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    read_thread = kthread_run(myrcu_reader_thread, <span class="literal">NULL</span>, <span class="string">"rcu_reader"</span>);</span><br><span class="line">    writer_thread = kthread_run(myrcu_writer_thread, (<span class="type">void</span>*)(<span class="type">unsigned</span> <span class="type">long</span>)value, <span class="string">"rcu_writer"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    printk(<span class="string">"GoodBye\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_ptr)</span><br><span class="line">        kfree(g_ptr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MODULE_LICENCE(<span class="string">"GPL);</span></span><br><span class="line"><span class="string">module_init(my_test_init);</span></span><br></pre></td></tr></tbody></table></figure><p>该例子的目的是通过 RCU 机制保护 my_test_init() 函数分配的共享数据结构 g_ptr，并创建一个读者线程和一个写者线程来模拟同步场景。对于 myrcu_reader_thread，注意以下几点。</p><ul><li>通过 rcu_read_lock() 函数和 rcu_read_unlock() 函数来构建一个读者临界区</li><li>调用 rcu_dereference() 函数获取被保护数据的副本，即指针 p，这时 p 和 g_ptr 都指向旧的被保护数据</li><li>读者线程每隔 200ms 读取一次被保护数据</li></ul><p>对于 myrcu_writer_thread，注意以下几点。</p><ul><li>分配新的保护数据，并修改相应数据</li><li>rcu_assign_pointer() 函数让 g_ptr 指向新数据</li><li>call_rcu() 函数注册一个回调函数，确保所有对旧数据的引用都执行完成之后，才调用回调函数来删除旧数据</li><li>写者线程每隔 400ms 修改被保护数据</li></ul><p>上述过程如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/RCU.png"></p><p>在所有访问结束之后，内核可以释放旧数据，关于何时释放旧数据，内核提供了两个接口函数--synchronize_rcu() 和 call_rcu()。</p><h1 id="经典-rcu-和-tree-rcu">经典 RCU 和 Tree RCU</h1><p>本节重点介绍经典 RCU 和 Tree RCU 的实现，可睡眠 RCU 和可抢占 RCU 留给读者学习。RCU 里有两个很重要的概念，分别是宽限期（ Grace Period，GP）和静止状态（Quiescent State, QS）。</p><ul><li>宽限期：GP 有生命周期，有开始和结束之分。从 GP 开始算起，如果所有处于读者临界区的 CPU 都离开了临界区，也就是都至少经历了一次 QS，那么认为一个 GP 可以结束了。GP 结束后，RCU 会调用注册的回调函数，如销毁旧数据等。</li><li>静止状态：在 RCU 设计中，如果一个 CPU 处于 RCU 读者临界区中，说明它的状态是活跃的：如果在时钟滴答中检测到该 CPU 处于用户模式或空闲状态，说明该 CPU 已经离开了读者临界区，那么它是 QS。在不支持抢占的 RCU 实现中，只要检测到 CPU 有上下文切换，就可以知道离开了读者临界区。</li></ul><p>RCU 在开发 Linux2.5 内核时已经被添加到 Linux 内核中，但是在 Linux2.6.29 内核之前的 RCU 通常称为经典 RCU（ Classic RCU）。经典 RCU 在大型系统中遇到了性能问题，后来在 Linux2.6.29 内核中 IBM 的内核专家 Paul E. Mckenney 提出了 Tree RCU 的实现， Tree RCU 也称为 Hierarchical RCU。</p><p>经典 RCU 的实现在超级大系统中遇到了问题，特别是有些系统的 CPU 内核超过了 1024 个，甚至达到 4096 个。经典 RCU 在判断是否完成一次 GP 时采用全局的 cpumask 图。如果每位表示一个 CPU，那么在 1024 个 CPU 内核的系统中， cpumask 位图就有 1024 位。每个 CPU 在 GP 开始时要设置位图中对应的位，GP 结束时要清除相应的位。全局的 cpumask 位图会导致很多 CPU 竞争使用，因此需要自旋锁来保护位图。这样导致锁争用变得很激烈，激烈程度随着 CPU 的个数线性递增。以 4 核 CPU 为例，经典 RCU 的实現如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/rcu1.png"></p><p>而 Tree RCU 的实现巧妙地解决了 cpumask 位图竞争锁的问题，以上述 4 核 CPU 为例，假设 Tree RCU 以两个 CPU 为一个 rcu_node, 这样 4 个 CPU 被分配到两个 rcu_node，使用另外一个 rcu_node 来管理这两个 rcu_node。节点 1 管理 pu0 和 cpu1，节点 2 管理 pu2 和 cpu3。而节点 0 是根节点，管理节点 1 和节点 2。每个节点只需要两位的位图就可以管理各自的 CPU 或者节点，每个节点都通过各自的自旋锁来保护相应的位图。</p><p>假设 4 个 CPU 都经历过一个 QS，那么 4 个 CPU 首先在 Leve0 的节点 1 和节点 2 上修改位图。对于节点 1 或者节点 2 来说，只有两个 CPU 竞争锁，这比经典 RCU 上的锁争用要减少一半。当节点 1 和节点 2 上的位图都被清除干浄后，才会清除上一级节点的位图，并且只有最后清除节点的 CPU 才有机会尝试清除上一级节点的位图。因此对于节点 0 来说，还是两个 CPU 争用锁。整个过程中只有两个 CPU 争用一个锁。这类似于足球比赛，进入四强的 4 支球队被分成上下半区，每个半区有两支球队，只有半决赛获胜的球队才能进入决赛。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/rcu2.png"></p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 并发与同步（三）互斥锁</title>
      <link href="/next/2021/LinuxKernel/LinuxSyncMutex/"/>
      <url>/next/2021/LinuxKernel/LinuxSyncMutex/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/SyncMutex.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5YTdkMzA3OTEyOTA2ZjUxMGZiNDA=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>互斥锁类似于 count 值等于 1 的信号量，为什么内核社区要重新开发互斥锁，mutex 有如下优点：</p><ul><li>mutex 数据结构的定义比信号量小</li><li>互斥锁相对于信号量要简单轻便一些，在锁争用激烈的测试场景下，互斥锁比信号量执行速度更快</li><li>可扩展性更好</li></ul><h1 id="mutex-数据结构">mutex 数据结构</h1><p>下面来看 mutex 数据结构的定义。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/mutex.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> {</span></span><br><span class="line"><span class="type">atomic_long_t</span>owner;</span><br><span class="line"><span class="type">raw_spinlock_t</span>wait_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line"><span class="type">void</span>*magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>wait_lock：自旋锁，用于保护 wait_list 睡眠等待队列</li><li>wait_list：用于管理所有在互斥锁上睡眠的进程，没有成功获取锁的进程会在此链表上睡眠</li><li>owner： Linux4.10 内核把原来的 count 成员和 owner 成员合并成一个。原来的 count 是一个原子值，1 表示锁没有被持有，0 表示锁被持有，负数表示锁被持有且有等待者在排队。现在新版本的 owner 中，0 表示锁没有未被持有，非零值则表示锁持有者的 task_struct 指针的值。另外，最低 3 位有特殊的含义</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MUTEX_FLAG_WAITERS0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUTEX_FLAG_HANDOFF0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUTEX_FLAG_PICKUP0x04</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUTEX_FLAGS0x07</span></span><br></pre></td></tr></tbody></table></figure><ul><li>osq：用于实现 MCS 锁机制 MUTEX_FLAG_WAITERS：表示互斥锁的等待队列里有等待者，解锁的时候必须唤醒这些等候的进程。 MUTEX_FLAG_HANDOFF：对互斥锁的等待队列中的第一个等待者会设置这个标志位，锁持有者在解锁的时候把锁直接传递给第一个等待者。 MUTEX_FLAG_PICKUP：表示锁的传递已经完成。</li></ul><p>互斥锁实现了乐观自旋（ optimistic spinnig）等待机制。准确地说，互斥锁比读写信号量更早地实现了自旋等待机制。自旋等待机制的核心原理是当发现锁持有者正在临界区执行并且没有其它优先级高的进程要调度时，当前进程坚信锁持有者会很快离开临界区并释放锁，因此与其睡眠等待不如乐观地自旋等待，以减少陲眠唤醒的开销。在实现自旋等待机制时，内核实现了一套 MCS 锁机制来保证只有一个等待者自旋等待锁持有者释放锁。</p><h1 id="互斥锁的快速通道">互斥锁的快速通道</h1><p>互斥锁的初化有两种方式，一种是静态使用 DEFINE_MUTE 宏，另一种是在内核代码中动态使用 mutex_init() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">{ .owner = ATOMIC_LONG_INIT(0) \</span></span><br><span class="line"><span class="meta">, .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(lockname.wait_lock) \</span></span><br><span class="line"><span class="meta">, .wait_list = LIST_HEAD_INIT(lockname.wait_list) \</span></span><br><span class="line"><span class="meta">__DEBUG_MUTEX_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">__DEP_MAP_MUTEX_INITIALIZER(lockname) }</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_MUTEX(mutexname) \</span></span><br><span class="line"><span class="meta">struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)</span></span><br></pre></td></tr></tbody></table></figure><p>下面来看 mutex_lock() 函数是如何实现的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">mutex_lock</span><span class="params">(<span class="keyword">struct</span> mutex *lock)</span></span><br><span class="line">{</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__mutex_trylock_fast(lock))</span><br><span class="line">__mutex_lock_slowpath(lock);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(mutex_lock);</span><br></pre></td></tr></tbody></table></figure><p>__mutex_trylock_fast() 函数判断是否可以快速获取锁若不能通过快速通道获取锁，那么要进入慢速通道 __mutex_lock_slowpath().</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> __mutex_trylock_fast(<span class="keyword">struct</span> mutex *lock)</span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> curr = (<span class="type">unsigned</span> <span class="type">long</span>)current;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zero = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>__mutex_trylock_fast() 函数实现的重点是 atomic_long_try_cmpxchg_acquire() 函数，如果以 cmpxchg() 函数的语义来理解，会得出错误的结论。比如，当 lock-&gt;owner 和 zero 相等时，说明 lock 这个锁没有被持有，那么可以成功获取锁，把当前进程的 task_struct-&gt;curr 的值赋给 lock-&gt;owner，然后函数返回 lock-&gt;owner 的旧值，也就是 0。这时 if 判断语句应该判断 atomic_long_try_cmpxchg_acquire() 函数是否返回 0 オ对。但是在 Linux5.0 内核的代码里和我们想的完全相反，那是怎么回事呢？ 细心的读者可以通过翻阅 Linux 内核的 git 日志信息找到答案。在 Linux4.18 内核中有个优化的补丁。锁的子系统维护者 Peter Zijlstra 通过比较反汇编代码发现在 x86_64 架构下使用 try_cmpxchg() 代替 cmpxchg() 数可以少执行ー次 test 指令。try_cmpxchg() 函数的核心还是调用 cmpxchg() 函数，但是返回值发生了变化，它返回一个布尔值，表示 cmpxchg() 函数的返回值是否和第二个参数的值相等。 因此，当原子地判断出 lock-&gt;owr 字段为 0 时，说明锁没有被进程持有，那么可以进入快速通道以迅速获取锁，把当前进程的 task_struct 指针的值原子设置到 lock-&gt;owner 字段中。若 lock-&gt;owner 字段不为 0，则说明该锁已经被进程持有，那么要进入慢速通道__mutex_lock_slowpath()。</p><h1 id="互斥锁的慢速通道">互斥锁的慢速通道</h1><p>__mutex_lock_slowpath() 函数调用__mutex_lock()--&gt;__mutex_lock_common() 函数来实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __sched</span><br><span class="line">__mutex_lock_common(<span class="keyword">struct</span> mutex *lock, <span class="type">unsigned</span> <span class="type">int</span> state, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span><br><span class="line">    <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip,</span><br><span class="line">    <span class="keyword">struct</span> ww_acquire_ctx *ww_ctx, <span class="type">const</span> <span class="type">bool</span> use_ww_ctx)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx)</span><br><span class="line">ww_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">MUTEX_WARN_ON(lock-&gt;magic != lock);</span><br><span class="line"></span><br><span class="line">ww = container_of(lock, <span class="keyword">struct</span> ww_mutex, base);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx) {</span><br><span class="line"><span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx-&gt;acquired == <span class="number">0</span>)</span><br><span class="line">ww_ctx-&gt;wounded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">nest_lock = &amp;ww_ctx-&gt;dep_map;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">preempt_disable();</span><br><span class="line">mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock) ||</span><br><span class="line">    mutex_optimistic_spin(lock, ww_ctx, <span class="literal">NULL</span>)) {</span><br><span class="line"><span class="comment">/* got the lock, yay! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_set_context_fastpath(ww, ww_ctx);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">raw_spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After waiting to acquire the wait_lock, try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock)) {</span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> skip_wait;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line">waiter.task = current;</span><br><span class="line"><span class="keyword">if</span> (use_ww_ctx)</span><br><span class="line">waiter.ww_ctx = ww_ctx;</span><br><span class="line"></span><br><span class="line">lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!use_ww_ctx) {</span><br><span class="line"><span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">__mutex_add_waiter(lock, &amp;waiter, &amp;lock-&gt;wait_list);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">ret = __ww_mutex_add_waiter(&amp;waiter, lock, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_early_kill;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="type">bool</span> first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock(lock))</span><br><span class="line"><span class="keyword">goto</span> acquired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current)) {</span><br><span class="line">ret = -EINTR;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) {</span><br><span class="line">ret = __ww_mutex_check_kill(lock, &amp;waiter, ww_ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"></span><br><span class="line">first = __mutex_waiter_is_first(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">if</span> (__mutex_trylock_or_handoff(lock, first) ||</span><br><span class="line">    (first &amp;&amp; mutex_optimistic_spin(lock, ww_ctx, &amp;waiter)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">raw_spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">}</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;wait_lock);</span><br><span class="line">acquired:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx) {</span><br><span class="line"><span class="keyword">if</span> (!ww_ctx-&gt;is_wait_die &amp;&amp;</span><br><span class="line">    !__mutex_waiter_is_first(lock, &amp;waiter))</span><br><span class="line">__ww_mutex_check_waiters(lock, ww_ctx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line"></span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line"><span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ww_ctx)</span><br><span class="line">ww_mutex_lock_acquired(ww, ww_ctx);</span><br><span class="line"></span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">__mutex_remove_waiter(lock, &amp;waiter);</span><br><span class="line">err_early_kill:</span><br><span class="line">raw_spin_unlock(&amp;lock-&gt;wait_lock);</span><br><span class="line">debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">mutex_release(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">preempt_enable();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将其绘制出一张图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mutex.png"></p><h1 id="乐观自旋等待机制">乐观自旋等待机制</h1><p>乐观自旋等待机制是互斥锁的一个新特性。乐观自旋等待机制其实就是判断锁持有者正在临界区执行时，可以断定锁持有者会很快退出临界区并且释放锁，与其进入睡眠队列，不如像自旋锁一样自旋等待，因为睡眠与唤醒的代价可能更高。乐观自旋等待机制的实现在 mutex_optimistic_spin() 函数里。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">mutex_optimistic_spin</span><span class="params">(<span class="keyword">struct</span> mutex *lock, <span class="keyword">struct</span> ww_acquire_ctx *ww_ctx,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> mutex_waiter *waiter)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!waiter) {</span><br><span class="line"><span class="keyword">if</span> (!mutex_can_spin_on_owner(lock))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!osq_lock(&amp;lock-&gt;osq))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to acquire the mutex... */</span></span><br><span class="line">owner = __mutex_trylock_or_owner(lock);</span><br><span class="line"><span class="keyword">if</span> (!owner)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mutex_spin_on_owner(lock, owner, ww_ctx, waiter))</span><br><span class="line"><span class="keyword">goto</span> fail_unlock;</span><br><span class="line"></span><br><span class="line">cpu_relax();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!waiter)</span><br><span class="line">osq_unlock(&amp;lock-&gt;osq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>采用一张图来表示如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/optimistic_lock.png"></p><p>详细内容不做分析。</p><h1 id="读写锁">读写锁</h1><p>上述介绍的信号量有一个明显的缺点--没有区分临界区的读写属性。读写锁通常允许多个线程并发地读访问临界区，但是写访问只限制于一个线程。读写锁能有效地提高并发性，在多处理器系统中允许有多个读者同时访问共享资源，但写者是排他性的，读写锁具有如特性。</p><ul><li>允许多个读者同时进入临界区，但同一时刻写者不能进入</li><li>同一时刻只允许一个写者进入临界区</li><li>读者和写者不能同时进入临界区</li></ul><p>读写锁有两种，分别是读者自旋锁类型和读者信号量。自旋锁类型的读写锁数据结构定义在 include/linux/rwlock_types.h 头文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/rwlock_types.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">arch_rwlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line"><span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} <span class="type">rwlock_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The queue read/write lock data structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qrwlock</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">atomic_t</span> cnts;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LITTLE_ENDIAN</span></span><br><span class="line">u8 wlocked;<span class="comment">/* Locked for write? */</span></span><br><span class="line">u8 __lstate[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">u8 __lstate[<span class="number">3</span>];</span><br><span class="line">u8 wlocked;<span class="comment">/* Locked for write? */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"><span class="type">arch_spinlock_t</span>wait_lock;</span><br><span class="line">} <span class="type">arch_rwlock_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>常用的函数如下：</p><ul><li>rwlock_init()：初始化 rwlock</li><li>write_lock()：申请写者锁</li><li>write_unlock()：释放写者锁</li><li>read_lock()：申请读者锁</li><li>read_unlock()：释放读者锁</li><li>read_lock_irq()：关闭中断并且申请读者锁</li><li>write_lock_irg()：关闭中断并且申请写者锁</li><li>write_unlock_irq()：打开中断并且释放写者锁</li></ul><p>和自旋锁一样，读写锁有关闭中断和下半部的版本。自旋锁类型的读写锁实现比较简单。</p><h1 id="总结">总结</h1><ul><li>互斥锁最先实现自旋等待机制</li><li>互斥锁在睡眠之前尝试获取锁</li><li>互斥锁通过实现 MCS 锁来避免多个 CPU 争用锁而导致 CPU 高速缓存行颠簸现象，正是因为互斥锁的简洁性和高效性，所以互斥锁的使用场景比信号量要更严格</li></ul><p>使用互斥锁需要注意的约束条件如下：</p><ul><li>同ー时刻只有一个线程可以持有互斥锁</li><li>只有锁持有者可以解锁。不能在一个进程中持有互斥锁，而在另外一个进程释放它。因此互斥锁不适合内核与用户空间复杂的同步场景，信号量和读写信号量则比较合适</li><li>不允许递归地加锁和解锁</li><li>当进程持有互斥锁时，进程不可以退出</li><li>互斥锁必须使用官方接口函数来初始化</li><li>互斥锁可以睡眠，所以不允许在中断处理程序或者中断下半部（如 tasklet、定时器）中使用</li></ul><p>在实际项目中，该如何选择自旋锁、信号量和互斥锁呢？ 在中断上下文中可以毫不犹豫地使用自旋锁，如果临界区有睡眠、隐含睡眠的动作及内核接口函数，应避免选择自旋锁。在信号量和互斥锁中该如何选择呢？除非代码场景不符合上述互斥锁的约束中的某一条，否则可以优先使用互斥锁。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 并发与同步（二）信号量</title>
      <link href="/next/2021/LinuxKernel/LinuxSyncSem/"/>
      <url>/next/2021/LinuxKernel/LinuxSyncSem/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/EventSeq.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5OTFiYzYzNzY4OTA3MTA2MTQ3N2M=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="信号量">信号量</h1><p>信号量（ semaphore）是操作系统中最常用的同步原语之一。自旋锁是一种实现忙等待的锁，而信号量则允许进程进入睡眠状态。简单来说，信号量是一个计数器，它支持两个操作原语，即 P 和 V 操作。</p><h1 id="信号量实现">信号量实现</h1><p>semaphore 数据结构的定义如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/semaphore.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> {</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>lock 是自旋锁变量，用于保护 semaphore 数据结构里的 count 和 wait_list 成员</li><li>count 用于表示允许进入临界区的内核执行路径个数</li><li>wait_list 链表用于管理所有在该信号量上睡眠的进程，没有成功获取锁的进程会在这个链表上睡眠</li></ul><p>通常通过 sema_init() 函数进行信号量的初始化，其中 __SEMAPHORE_INITIALIZER() 完成对 semaphore 数椐结构的填充，val 值通常设为 1。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)\</span></span><br><span class="line"><span class="meta">{\</span></span><br><span class="line"><span class="meta">.lock= __RAW_SPIN_LOCK_UNLOCKED((name).lock),\</span></span><br><span class="line"><span class="meta">.count= n,\</span></span><br><span class="line"><span class="meta">.wait_list= LIST_HEAD_INIT((name).wait_list),\</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SEMAPHORE(name)\</span></span><br><span class="line"><span class="meta">struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">"semaphore-&gt;lock"</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面来看 down() 函数。down() 函数有如下一些变体。其中 down() 函数和 down_interruptible() 函数的区别在于， down_interruptible() 函数在争用信号量失败时进入可中断的睡眠状态，而 down() 函数进入不可中断的睡眠状态。若 down_trylock() 函数返回 0，表示成功获取锁：若返回 1 获取锁失败。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check <span class="title function_">down_killable</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check <span class="title function_">down_trylock</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check <span class="title function_">down_timeout</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> jiffies)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span>;</span><br></pre></td></tr></tbody></table></figure><p>接下来看 down_interruptible() 函数的实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * down_interruptible - acquire the semaphore unless interrupted</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Attempts to acquire the semaphore.  If no more tasks are allowed to</span></span><br><span class="line"><span class="comment"> * acquire the semaphore, calling this function will put the task to sleep.</span></span><br><span class="line"><span class="comment"> * If the sleep is interrupted by a signal, this function will return -EINTR.</span></span><br><span class="line"><span class="comment"> * If the semaphore is successfully acquired, this function returns 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">down_interruptible</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">sem-&gt;count--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = __down_interruptible(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(down_interruptible);</span><br></pre></td></tr></tbody></table></figure><p>首先，第 6~9 行代码判断是否进入自旋锁的临界区。注意，后面的操作会临时打开自旋锁，若涉及对信号量中最重要的 cout 的操作，需要自旋锁来保护，并且在某些中断处理函数中也可能会操作该信号量。由于需要关闭本地 CPU 中断，因此这里采用 raw_spin_lock_irqsave() 函数。当成功进入自旋锁的临界区之后，首先判断 sem-&gt;count 是否大于 0。如果大于 0，则表明当前进程可以成功地获得信号量，并将 sem-&gt;count 值减 1，然后退出。如果 sem-&gt;count 小于或等于 0，表明当前进程无法获得该信号量，则调用 __down_interruptible() 函数来执行睡眠操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">int</span> __sched __down_interruptible(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>__down_interruptible() 函数内部调用__down_common() 函数来实现 state 参数为 TASK_INTERRUPTIBLE。 timeout 参数为 MAX_SCHEDULE_TIMEOUT，是一个很大的 LONG_MAX 值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;down_interruptible()-&gt;__down_interruptible()-&gt;down_common()&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this function is inlined, the 'state' parameter will be</span></span><br><span class="line"><span class="comment"> * constant, and thus optimised away by the compiler.  Likewise the</span></span><br><span class="line"><span class="comment"> * 'timeout' parameter for the cases without timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,</span><br><span class="line"><span class="type">long</span> timeout)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = current;</span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line"><span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> timed_out;</span><br><span class="line">__set_current_state(state);</span><br><span class="line">raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">timeout = schedule_timeout(timeout);</span><br><span class="line">raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (waiter.up)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>semaphore_waiter 数据结构用于描述获取信号量失败的进程，每个进程会有一个 semaphore_waiter 数据结构，并且把当前进程放到信号量 sem 的成员变量 wait_list 链表中，接下来的 for 循环将当前进程的 task_struct、状态设置成 TASK_INTERRUPTIBLE，然后调用 schedule_timeout() 函数主动让出 CPU，相当于当前进程睡眠。注意 schedule_timeou() 函数的参数是 MAX_SCHEDULE_TIMEOUT，它并没有实际等待 MAX_SCHEDULE_TIMEOUT 的时间。当进程再次被调度回来执行时， schedule_timeout() 函数返回并判断再次被调度的原因，当 waiter.up 为 true 时，说明睡眠在 wait_list 队列中的进程被该信号量的 UP 操作唤醒，进程可以获得该信号量。如果进程被其它 CPU 发送的信号或者由于超时等而唤醒，则跳转到 timed_out 或 interrupted 标签处并且返回错误代码。</p><p>down_interruptible() 函数中，在调用 __down_interruptible() 函数时加入 sem-&gt;lock 的自旋锁，这是自旋锁的一个临界区。前面提到，自旋锁临界区中绝对不能睡眠，难道这是例外？仔细阅读__down_common() 函数，会发现 for 循环在调用 schedule_timeout() 函数主动让出 CPU 时，先调用 raw_spin_unlock_irq() 函数释放了该锁，即调用 schedule_timeout() 函数时已经没有自旋锁了，可以让进程先睡眠，“醒来时”再补加一个锁，这是内核编程的常用技巧。</p><p>下面来看与 dowm() 函数对应的 up() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * up - release the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release the semaphore.  Unlike mutexes, up() may be called from any</span></span><br><span class="line"><span class="comment"> * context and even by tasks which have never called down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">sem-&gt;count++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__up(sem);</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(up);</span><br></pre></td></tr></tbody></table></figure><p>如果信号量上的等待队列（sem-&gt;wait_list）为空，则说明没有进程在等待该信号量，直接把 sem-&gt;count 加 1 即可，如果不为空，则说明有进程在等待队列里睡民，需要调用__up() 唤醒它们。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">wake_up_process(waiter-&gt;task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先来看 sm-&gt;wait_list 中第一个成员 waiter，这个等待队列是先进先出队列，在 dowm() 函数中通过 list_add_tail() 函数添加到等待队列尾部。把 waiter-&gt;up 设置为 true, 把然后调用 wake_up_process() 函数唤醒 wite-&gt;task 进程。在 down() 函数中， walter-&gt;task 进程醒来后会判断 waiter-&gt;up 变量是否为 true 如果为 true 则直接回 0，表示该过得成功获取信号量。</p><h1 id="读写信号量">读写信号量</h1><h2 id="rw_semaphore-数据结构">rw_semaphore 数据结构</h2><p>rw_semaphore 数据结构定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> {</span></span><br><span class="line"><span class="type">atomic_long_t</span> count;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Write owner or one of the read owners as well flags regarding</span></span><br><span class="line"><span class="comment"> * the current state of the rwsem. Can be used as a speculative</span></span><br><span class="line"><span class="comment"> * check to see if the write owner is running on the cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_long_t</span> owner;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RWSEM_SPIN_ON_OWNER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">raw_spinlock_t</span> wait_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_RWSEMS</span></span><br><span class="line"><span class="type">void</span> *magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>count 用于表示读写信号量的计数。以前读写信号量的实现用 activity 来表示。若 activity 为 0，表示没有读者和写者：若 activity 为ー 1，表示有写者，若 activity 大于 0，表示有读者。现在 count 的计数方法已经发生了变化</li><li>wait_list 链表用于管理所有在该信号量上睡眠的进程，没有成功获取锁的进程会睡眠在这个链表上</li><li>wait_lock 是一个自旋锁变量，用于实现对 rw_semaphore 数据结构中 count 成员的原子操作和保护</li><li>osq：MCS 锁</li><li><p>owner：当写者成功获取锁时， owner 指向锁持有者的 task_struct 数据结构</p></li><li>若 count 初始化为 0，表示没有读者也没有写者</li><li>若 count 为正数，表示有 count 个读者</li><li>当有写者申请锁时，count 值要加上 RWSEM_ACTIVE_WIRTE_BIAS</li><li>当有读者申请锁时，若 count 值要加上 RWSEM_ACTIVE_READ_BIAS，即 count 值加一</li><li>当有多个写者中请时，判断 count 值是否等于 RWSEM_ACTIVE_WIRTE_BIAS（-65535）若不相等，说明已经有写者抢先持有锁，要自旋等待或者睡眠</li><li><p>当读者申请锁时，若 count 值加上 RWSEM_ACTIVE_READ_BIAS（1）后还小于 0，说明已经有个写者已经成功申请锁，只能等待写者释放锁</p></li></ul><p>把 count 值当作十六进制或者十进制数不是开发人员的原本设计意图，其实应该把 count 值分成两个字段：Bit[0:31] 为低字段，表示正在持有锁的读者或者写者的个数；Bit[32:63] 为高字段，通常为负数，表示有一个正在持有或者处于 pending 状态的写者，以及等待队列中有读写者在等待。因此 count 值可以看作一个二元数，含义如下</p><ul><li>RWSEM_ACTIVE_READ_BIAS=0x000 0001 =[0，1]，表示有一个读者</li><li>RWSEM_ACTIVE_WRITE_BIAS=0xFFFF 0000 =[-1，1]，表示当前只有一个活跃的写者</li><li>RWSEM_WAITING_BIAS=0xFFFF 0000=[-1，0]，表示睡眠等待队列中有读写者在睡眠等待</li></ul><p>kernel/locking/rwsem-xadd.c 代码中有如下一段关于 count 值含义的比较全面的介绍。</p><ul><li>0x0000 0000 初始化值，表示没有读者和写者</li><li>0x0000 000X：表示有 X 个活跃的读者或者正在申请的读者，没有写者干扰</li><li>0xFFFF 000X：或者表示可能有 X 个活跃读者，还有写者正在等待；或者表示有二个写者持有锁，还有多个读者正在等待</li><li>0xFFFF 0001：或者表示当前只有一个活跃的写者；或者表示一个活跃或者申请中的读者，还有写者正在睡眠等待</li><li>0xFFFF 0000 表示 WAITING_BIAS，有读者或者写者正在等待，但是它们都还没成功获取锁。</li></ul><h2 id="申请读者类型信号量">申请读者类型信号量</h2><p>下面来看 down_read() 函数的实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span></span><br><span class="line">{</span><br><span class="line">might_sleep();</span><br><span class="line">rwsem_acquire_read(&amp;sem-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line"></span><br><span class="line">LOCK_CONTENDED(sem, __down_read_trylock, __down_read);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rwsem_acquire_read(l, s, t, i)lock_acquire_shared(l, s, t, NULL, i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lock_acquire_shared(l, s, t, n, i)lock_acquire(l, s, t, 1, 1, n, i)</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We are not always called with irqs disabled - do that here,</span></span><br><span class="line"><span class="comment"> * and also avoid lockdep recursion:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">struct</span> lockdep_map *lock, <span class="type">unsigned</span> <span class="type">int</span> subclass,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> trylock, <span class="type">int</span> read, <span class="type">int</span> check,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> lockdep_map *nest_lock, <span class="type">unsigned</span> <span class="type">long</span> ip)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">trace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!debug_locks)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!lockdep_enabled())) {</span><br><span class="line"><span class="comment">/* XXX allow trylock from NMI ?!? */</span></span><br><span class="line"><span class="keyword">if</span> (lockdep_nmi() &amp;&amp; !trylock) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span> <span class="title">hlock</span>;</span></span><br><span class="line"></span><br><span class="line">hlock.acquire_ip = ip;</span><br><span class="line">hlock.instance = lock;</span><br><span class="line">hlock.nest_lock = nest_lock;</span><br><span class="line">hlock.irq_context = <span class="number">2</span>; <span class="comment">// XXX</span></span><br><span class="line">hlock.trylock = trylock;</span><br><span class="line">hlock.read = read;</span><br><span class="line">hlock.check = check;</span><br><span class="line">hlock.hardirqs_off = <span class="literal">true</span>;</span><br><span class="line">hlock.references = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">verify_lock_unused(lock, &amp;hlock, subclass);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">raw_local_irq_save(flags);</span><br><span class="line">check_flags(flags);</span><br><span class="line"></span><br><span class="line">lockdep_recursion_inc();</span><br><span class="line">__lock_acquire(lock, subclass, trylock, read, check,</span><br><span class="line">       irqs_disabled_flags(flags), nest_lock, ip, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">lockdep_recursion_finish();</span><br><span class="line">raw_local_irq_restore(flags);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(lock_acquire);</span><br></pre></td></tr></tbody></table></figure><p>申请读者锁流程如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/read_lock.png"></p><h2 id="释放读者类型信号量">释放读者类型信号量</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">up_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> perf_singlethreaded ? <span class="number">0</span> : pthread_rwlock_unlock(&amp;sem-&gt;lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于写信号量这里不做详细分析了。</p><h2 id="小结">小结</h2><p>读写信号量在内核中应用广泛，特别是在内存管理中，除了前面介绍的 mm-&gt;mmap_sem 还有 RMAP 系统中的的 anon_vma-&gt;rwsem、 address_space 数据结构中的 i_mmap_rwsem 等。 总结读写信号量的重要特性：</p><ul><li>down_read()：如果一个进程持有读者锁，那么允许继续申请多个读者锁，申请的写者锁则要等待</li><li>down_write()：如果一个进程持有写者锁，那么第二个进程申请该写者锁要自旋等待申请读者锁则要等待</li><li>up_write() up_read()：如果等待队列中第一个成员是写者，那么唤醒该写者；否则唤醒排在等待队列中最前面连续的几个读者</li></ul><h1 id="总结">总结</h1><p>信号量有一个有趣的特点，它可以同时允许任意数量的锁持有者。信号量初始化函数为 sema_init(struct semaphore *sem, int val)，其中 val 的值可以大于或等于 1。当 val 大于 1 时，表示允许在同一时刻至多有 val 个锁持有者，这种信号量叫作计数信号量（ counting semaphore）；当 val 等于 1 时，同一时刻仅允许一个 CPU 持有锁，这种信号量叫作互斥信号量或者二进制信号量（ binary semaphore）。在 Linux 内核中，大多使用 val 值为 1 的信号量。相比自旋锁，信号量是一个允许睡眠的锁。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 并发与同步（一）自旋锁</title>
      <link href="/next/2021/LinuxKernel/LinuxSyncSpinLock/"/>
      <url>/next/2021/LinuxKernel/LinuxSyncSpinLock/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/EventSpinLock.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM5ODMzMDFlZmFkNDA3NTI1N2M2ZDA=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="经典自旋锁">经典自旋锁</h1><p>如果临界区中只有一个変量，那么原子变量可以解決问题，但是临界区有一个数据操作的集合，需要通过锁机制来保障，自旋锁（ spinlock）是 Linux 内核中最常见的锁机制。</p><ul><li>忙等待的锁机制。操作系统中锁的机制分为两类，一类是忙等待，另一类是睡眠等待</li><li>同一时刻只能有一个内核代码路径可以获得该锁</li><li>要求自旋锁持有者尽快完成临界区的执行任务，特别是自旋锁临界区里不能睡眠</li><li>自旋锁可以在中断上下文中使用</li></ul><h2 id="自旋锁的实现">自旋锁的实现</h2><p>先看 spinlock 数据结构的定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/spinlock_types.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line">} <span class="type">spinlock_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> {</span></span><br><span class="line"><span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line"><span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} <span class="type">raw_spinlock_t</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">u32 slock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">raw_tickets</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMEB__</span></span><br><span class="line">u16 next;</span><br><span class="line">u16 owner;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">u16 owner;</span><br><span class="line">u16 next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} tickets;</span><br><span class="line">};</span><br><span class="line">} <span class="type">arch_spinlock_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>spinlock 数据结构的定义既考虑到了不同处理器架构的支持和实时性内核的要求，还定义了 raw_spinlock 和 arch_spinlock_t 数据结构，其中 arch_spinlock_t 数据结构和架构有关。在 Linux2.6.25 内核之前， spinlock 数据结构就是一个简单的无符号类型变量。若 slock 值为 1，表示锁未被持有；若为 0，表示锁被持有。这会存在两个严重问题，不公平和效率低下。因此在 Liux2.6.25 内核后，自旋锁实现了“基于排队的 FIFO”算法的自旋锁机制，称为基于排队的自旋锁。</p><p>基于排队的自旋锁仍然使用原来的数据结构，但 slock 域被拆分成两个部分，如下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slock.png"></p><p>owner 表示自旋锁持有者的牌号，next 表示外面排队的队列中末尾者的牌号。当有线程要获取锁时 next++，当持有锁的线程释放锁时 owner++。当 owner 和 next 相等时，该线程将获得自旋锁。</p><p>自旋锁的原型定义在 include/linux/spinlock.h 头文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/spin_lock. h&gt;</span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">{</span><br><span class="line">raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)_raw_spin_lock(lock)</span></span><br><span class="line"><span class="type">void</span> __lockfunc _raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">{</span><br><span class="line">__raw_spin_lock(lock);</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">{</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>spin_locke 函数最终调用 __raw_spin_lock() 函数来实現。首先关闭内核抢占，这是自旋锁实现的关键点之一。那么为什么自旋锁临界区中不允许发生抢占呢？如果自旋锁临界区中允许抢占，假设在临界区内发生中断，中断返回时会检查抢占调度，这里将有两个问题、一是抢占调度会导致持有锁的进程睡眠，这违背了自旋锁不能睡眠和快速执行完成的设计语义；二是抢占调度进程也可能会申请自旋锁，这样会导致发生死锁。</p><h2 id="自旋锁的变体">自旋锁的变体</h2><p>在驱动中很多操作都需要访问和更新链表，如 open、 ioctl 等，因此操作链表的地方就是一个临界区，需要自旋锁来保护。若在临界区中发生了外部硬件中断，系统暂停当前进程的执行转而处理该中断。假设中断处理程序恰巧也要操作该链表，链表的操作是一个临界区，所以在操作之前要调用 spin_lock() 函数来对该链表进行保护。中断处理程序试图获取该自旋锁，但因为它己经被其他 CPU 持有了，于是中断处理程序进入忙等待状态或者 wfe 睡眠状态。在中断上下文中出现忙等待或者睡眠状态是致命的，中断处理程序要求“短”和“快”，自旋锁的持有者因为被中断打断而不能尽快释放锁，而中断处理程序一直在忙等待该锁，从而导致死锁的发生。 Linux 内核的自旋锁的变体 spin_lock_irq() 函数通过在获取自旋锁时关闭本地 CPU 中断，可以解决该问题。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock_irq</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">{</span><br><span class="line">raw_spin_lock_irq(&amp;lock-&gt;rlock);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock_irq(lock)_raw_spin_lock_irq(lock)</span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> __lockfunc _raw_spin_lock_irq(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">{</span><br><span class="line">__raw_spin_lock_irq(lock);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock_irq(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">{</span><br><span class="line">local_irq_disable();</span><br><span class="line">preempt_disable();</span><br><span class="line">spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>spin_lock_irq() 函数的实现比 spin_lock() 函数多了一个 local_irq_disable() 函数。local_irq_disable() 函数用于关闭本地处理器中断，这样在获取自旋锁时可以确保不会发生中断，从而避免发生死锁问题，即 local_irq_disable() 函数主要防止本地中断处理程序和自旋锁持有者之间产生锁的争用。</p><p>可能有的读者会有疑问，既然关闭了本地 CPU 的中断，那么别的 CPU 依然可以响应外部中断，这会不会也可能导致死锁呢？自旋锁持有者在 CPUO 上，CPU1 响应了外部中断且中断处理程序同样试图去获取该锁，因为 CPU0 上的自旋锁持有者也在继续执行，所以它很快会离开临界区并释放锁，这样 CPU1 上的中断处理程序可以很快获得该锁。</p><p>自旋锁还有另外一个常用的变体-- spin_lock_bh() 函数，用于处理进程和延迟处理机制导致的并发访问的互斥问题。</p><h2 id="spin_lock-和-raw_spin_lock-函数">spin_lock() 和 raw_spin_lock() 函数</h2><p>这要从 Linux 内核的实时补丁（ Rt-patch）说起。实时补丁旨在提升 Linux 内核的实时性它允许在自旋锁的临界区内抢占锁，且在临界区内允许进程睡眠。这样会导致自旋锁语义被修改。当时内核中大约有 10000 处使用了自旋锁，直接修改自旋锁的工作量巨大，但是可以修改那些真正不允许抢占和睡眠的地方，大概有 100 处，因此改为使用 raw_spin_lock()。</p><p>spin_lock() 和 raw_spin_lock() 函数的区别如下：</p><ul><li>在绝对不允许抢占和睡眠的临界区，应该使用 raw_spin_lock() 函数，否则使用 spin_lock()。</li><li>对于没有更新实时补丁的 Linux 内核来说，spin_lock() 函数可以直接调用 raw_spin_lock()，对于更新实时补丁的 Linux 内核来说， spin_lock() 会变成可抢占和睡眠的锁，这需要特别注意。</li></ul><h2 id="效率">效率</h2><p>根据硬件维护的 cache 一致性协议，如果 spinlock 的值没有更改，那么在 busy wait 时，试图获取 spinlock 的 CPU，只需要不断地读取自己包含这个 spinlock 变量的 cache line 上的值就可以了，不需要从 spinlock 变量所在的内存位置读取。</p><p>但是，当 spinlock 的值被更改时，所有试图获取 spinlock 的 CPU 对应的 cache line 都会被 invalidate，因为这些 CPU 会不停地读取这个 spinlock 的值，所以"invalidate"状态意味着此时，它们必须重新从内存读取新的 spinlock 的值到自己的 cache line 中。</p><p>而事实上，其中只会有一个 CPU，也就是队列中最先达到的那个 CPU，接下来可以获得 spinlock，也只有它的 cache line 被 invalidate 才是有意义的，对于其他的 CPU 来说，这就是做无用功。内存比 cache 慢那么多，开销可不小。</p><h1 id="mcs-锁">MCS 锁</h1><p>假设在一个锁争用激烈的系统中，所有等待自旋锁的线程都在同一个共享变量上自旋，申请和释放锁都在同一个变量上修改，高速内存一致性原理（如 MESI 协议）导致参与自旋的 CPU 中的高速缓存行变得无效。在锁争用的激烈过程中，可能导致严重的 CPU 高速缓存行颠簸现象（ CPU cacheline bouncing），即多个 CPU 上的高速缓存行反复失效，大大降低系统整体性能。</p><blockquote><p>MCS 算法可以解决自旋锁遇到的问题，显著缓解 CPU 高速缓存行颠簸问题。</p></blockquote><p>MCS 算法的核心思想是每个锁的申请者只在本地 CPU 的变量上自旋，而不是全局的变量上，大大降低锁的争用。</p><h1 id="osq-锁">OSQ 锁</h1><p>早期 MCS 算法的实现需要比较大的数据结构，在 Linux4.2 内核中引进了基于 MCS 算法的排队自旋锁（One Spinlock, Qspinlock）OSQ 锁的实现需要两个数据结构：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/osq_lock.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An MCS like lock especially tailored for optimistic spinning for sleeping</span></span><br><span class="line"><span class="comment"> * lock implementations (mutex, rwsem, etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_node</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_node</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line"><span class="type">int</span> locked; <span class="comment">/* 1 if lock acquired */</span></span><br><span class="line"><span class="type">int</span> cpu; <span class="comment">/* encoded CPU # + 1 value */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> {</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stores an encoded value of the CPU # of the tail node in the queue.</span></span><br><span class="line"><span class="comment"> * If the queue is empty, then it's set to OSQ_UNLOCKED_VAL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> tail;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>每个 MCS 锁有一个 optimistic_spin_queue 数据结构，该数据结构只有一个成员 tail, 初始化为 0。 optimistic_spin_node 数据结构表示本地 CPU 上的节点，它可以组织成一个双向链表包含 next 和 prev 指针， locked 成员用于表示加锁状态，cpu 成员用于重新编码 CPU 编号，表示该节点在哪个 CPU 上。 optimistic_spin_node 数据结构会定义成 per-CPU 变量，即每个 CPU 有一个节点结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/locking/osq_lock.c&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An MCS like lock especially tailored for optimistic spinning for sleeping</span></span><br><span class="line"><span class="comment"> * lock implementations (mutex, rwsem, etc).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using a single mcs node per CPU is safe because sleeping locks should not be</span></span><br><span class="line"><span class="comment"> * called from interrupt context and we have preemption disabled while</span></span><br><span class="line"><span class="comment"> * spinning.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="params">(<span class="keyword">struct</span> optimistic_spin_node, osq_node)</span>;</span><br></pre></td></tr></tbody></table></figure><p>MCS 锁在 osq_lock_init() 函数中初始化。如互斥锁会初始化为一个 MCS 锁，因为 __mutex_init() 函数会调用 osq_lock_init() 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/locking/mutex.c&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__mutex_init(<span class="keyword">struct</span> mutex *lock, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span><br><span class="line">{</span><br><span class="line">atomic_long_set(&amp;lock-&gt;owner, <span class="number">0</span>);</span><br><span class="line">raw_spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;lock-&gt;wait_list);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">osq_lock_init(&amp;lock-&gt;osq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">debug_mutex_init(lock, name, key);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(__mutex_init);</span><br></pre></td></tr></tbody></table></figure><p>OSQ 自旋锁的特点：</p><ul><li>集成 MCS 算法到自旋锁中，继承了 MCS 算法的所有优点，有效解决了 CPU 高速缓存行颠簸问题。</li><li>没有增加 spinlock 数据结构的大小，把 val 细分成多个域，完美实现了 MCS 算法。</li><li>当只有两个 CPU 试图获取自旋锁时，使用 pending 域就可以完美解决问题，第 2CPU 只需要设置 pending 域，然后自旋等待锁释放。当有第 3 个或者更多 CPU 来争用时，则需要使用额外的 MCS 节点。第 3 个 CPU 会自旋等待锁被释放，即 pending 域和 locked 域被清零，而第 4 个 CPU 和后面的 CPU 只能在 MCS 节点中自旋等待 locked 域被置 1，直到前继节点把 locked 控制器过继给自己才能有机会自旋等待自旋锁的释放，从而完美解决激烈锁争用带来的高速缓存行颠簸问题 16 信号量。</li><li>解决 MCS 锁占内存大的问题。</li></ul><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDcyNzExMQ==">https://zhuanlan.zhihu.com/p/80727111<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84OTA1ODcyNg==">https://zhuanlan.zhihu.com/p/89058726<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDA1NDY5MzU=">https://zhuanlan.zhihu.com/p/100546935<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（十二）内存调优</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryOptimization/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryOptimization/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryOptimization.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM4OTk5NWU0MDFmZDA3MGJiNzI0OGI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="内存管理调优参数">内存管理调优参数</h1><p>对服务器或者嵌入式产品做性能调优的过程中，避免不了需要深入了解和使用 Linux 内内存管理模块提供的调优参数。Linux 内核支持的内存管理调优参数都在/proc/sys/vm 目录下面，共有 40 多个调优参数，如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/proc/sys/vm<span class="comment"># ls</span></span><br><span class="line">admin_reserve_kbytes         dirty_ratio                lowmem_reserve_ratio       mmap_rnd_bits            oom_kill_allocating_task  stat_refresh</span><br><span class="line">block_dump                   dirtytime_expire_seconds   max_map_count              mmap_rnd_compat_bits     overcommit_kbytes         swappiness</span><br><span class="line">compact_memory               dirty_writeback_centisecs  memory_failure_early_kill  nr_hugepages             overcommit_memory         unprivileged_userfaultfd</span><br><span class="line">compact_unevictable_allowed  drop_caches                memory_failure_recovery    nr_hugepages_mempolicy   overcommit_ratio          user_reserve_kbytes</span><br><span class="line">dirty_background_bytes       extfrag_threshold          min_free_kbytes            nr_overcommit_hugepages  page-cluster              vfs_cache_pressure</span><br><span class="line">dirty_background_ratio       hugetlb_shm_group          min_slab_ratio             numa_stat                panic_on_oom              watermark_boost_factor</span><br><span class="line">dirty_bytes                  laptop_mode                min_unmapped_ratio         numa_zonelist_order      percpu_pagelist_fraction  watermark_scale_factor</span><br><span class="line">dirty_expire_centisecs       legacy_va_layout           mmap_min_addr              oom_dump_tasks           stat_interval             zone_reclaim_mode</span><br></pre></td></tr></tbody></table></figure><p>内存管理的调优参数定义在 kerne.c 文件中，通过 proc 文件系统机制来实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">vm_table</span>[] =</span> {</span><br><span class="line">{</span><br><span class="line">.procname= <span class="string">"overcommit_memory"</span>,</span><br><span class="line">.data= &amp;sysctl_overcommit_memory,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(sysctl_overcommit_memory),</span><br><span class="line">.mode= <span class="number">0644</span>,</span><br><span class="line">.proc_handler= overcommit_policy_handler,</span><br><span class="line">.extra1= SYSCTL_ZERO,</span><br><span class="line">.extra2= &amp;two,</span><br><span class="line">},</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>procname：表示这个节点的名称，显示在 proc/sys/vm 目录下面</li><li>data：传递的数据，通常是某个全局变量，如 sysctl_overcommit_memory</li><li>maxlen：参数 data 的长度。</li><li>mode 节点的文件权限。0644 表示用户具有读写权限，组用户和其他用户具有只读权</li><li>proc_handler：该节点在内核中的回调函数</li><li>extral：表示这个参数的最小值</li><li>exra2：表示这个参数的最大值，如。 overcommit_memory 调优参数的最大值为 2，最小值为 0</li></ul><h2 id="影响内存管理区水位的调优参数-min_free_kbytes">影响内存管理区水位的调优参数 min_free_kbytes</h2><p>Linux 内核为了防止内存被恶意进程占用，在每个内存管理区设置了一部分预留内存，即最低警戒水位（watermark[WMARK_MIN]）。进程分配内存的行为是有优先级的，对于普通优先级的分配行为，是不能访问预留内存的，只有对于高优先级的分配行为，才能访问，如高优先级的进程可以通过设置 __GFP_HIGH、__GFP_ATOMIC 甚至 __GFP_MEMALLOC 来访问预留内存。若系统预留内存小于 1024KB，那么可能会导致系统出问题，具有高优先级分配行为的进程没办法得到内存。 系统初始化时通过 init_per_zone_wmark_min() 函数来计算 min_free_kbytes 的大小，然后计算每个内存管理区的水位。 min_free_kbytes 的计算公式如下</p><pre><code>min_free_bytes = 4 sqrt(lowmem_kbytes)</code></pre><p>lommen_kbytes 是系统中所有内存管理区的管理页面数量减去高水位页面数量（ managed_pages - high_pages）的总和。最后计算出来的 min_free_kbytes 有范围限制，最小值为 128KB, 最大值为 64MB. min_free_kbytes 的值会影响每个内存管理区的水位，它是在 __setup_per_zone_marks() 函数中设置的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __setup_per_zone_wmarks(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pages_min = min_free_kbytes &gt;&gt; (PAGE_SHIFT - <span class="number">10</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> lowmem_pages = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">for_each_zone(zone) {</span><br><span class="line"><span class="keyword">if</span> (!is_highmem(zone))</span><br><span class="line">lowmem_pages += zone_managed_pages(zone);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for_each_zone(zone) {</span><br><span class="line">u64 tmp;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">tmp = (u64)pages_min * zone_managed_pages(zone);</span><br><span class="line">do_div(tmp, lowmem_pages);</span><br><span class="line"><span class="keyword">if</span> (is_highmem(zone)) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> min_pages;</span><br><span class="line"></span><br><span class="line">min_pages = zone_managed_pages(zone) / <span class="number">1024</span>;</span><br><span class="line">min_pages = clamp(min_pages, SWAP_CLUSTER_MAX, <span class="number">128UL</span>);</span><br><span class="line">zone-&gt;_watermark[WMARK_MIN] = min_pages;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">zone-&gt;_watermark[WMARK_MIN] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tmp = <span class="type">max_t</span>(u64, tmp &gt;&gt; <span class="number">2</span>,</span><br><span class="line">    mult_frac(zone_managed_pages(zone),</span><br><span class="line">      watermark_scale_factor, <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">zone-&gt;watermark_boost = <span class="number">0</span>;</span><br><span class="line">zone-&gt;_watermark[WMARK_LOW]  = min_wmark_pages(zone) + tmp;</span><br><span class="line">zone-&gt;_watermark[WMARK_HIGH] = min_wmark_pages(zone) + tmp * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* update totalreserve_pages */</span></span><br><span class="line">calculate_totalreserve_pages();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>内存管理区的 3 个水位的计算都和 min_free_kbytes 有关。当系统只有一个内存管理区时最低警戒水位（watermark[WMARK_MIN]）等于 min_free_kbytes 低水位、高水位与 watermark_scale_factor 参数、内存管理区管理的内存大小（ managed_pages）有关。 watermark_boost 表示临时提高的水位（它是在 Linux5.0 内核中引入的）。 读者可以通过查看 proc/zoneinfo 节点来获取每个内存管理区水位的值。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~/workspace/blog$ <span class="built_in">cat</span> /proc/zoneinfo</span><br><span class="line">Node 0, zone      DMA</span><br><span class="line">  per-node stats</span><br><span class="line">      nr_inactive_anon 161</span><br><span class="line">      nr_active_anon 376283</span><br><span class="line">      nr_inactive_file 1510629</span><br><span class="line">      nr_active_file 1654655</span><br><span class="line">      nr_unevictable 0</span><br><span class="line">      nr_slab_reclaimable 206993</span><br><span class="line">      nr_slab_unreclaimable 106507</span><br><span class="line">      nr_isolated_anon 0</span><br><span class="line">      nr_isolated_file 0</span><br><span class="line">      workingset_nodes 0</span><br><span class="line">      workingset_refault 0</span><br><span class="line">      workingset_activate 0</span><br><span class="line">      workingset_restore 0</span><br><span class="line">      workingset_nodereclaim 0</span><br><span class="line">      nr_anon_pages 377602</span><br><span class="line">      nr_mapped    54793</span><br><span class="line">      nr_file_pages 3164200</span><br><span class="line">      nr_dirty     0</span><br><span class="line">      nr_writeback 0</span><br><span class="line">      nr_writeback_temp 0</span><br><span class="line">      nr_shmem     1299</span><br><span class="line">      nr_shmem_hugepages 0</span><br><span class="line">      nr_shmem_pmdmapped 0</span><br><span class="line">      nr_file_hugepages 0</span><br><span class="line">      nr_file_pmdmapped 0</span><br><span class="line">      nr_anon_transparent_hugepages 0</span><br><span class="line">      nr_unstable  0</span><br><span class="line">      nr_vmscan_write 0</span><br><span class="line">      nr_vmscan_immediate_reclaim 0</span><br><span class="line">      nr_dirtied   6882886</span><br><span class="line">      nr_written   6439960</span><br><span class="line">      nr_kernel_misc_reclaimable 0</span><br></pre></td></tr></tbody></table></figure><p>在实际内存调优过程中，设置 min_free_kbytes 值过大或者过小都会有相应的副作用。若 min_free_kbytes 值过大，会影响内存管理区的 3 个水位，因此把该值设置过大，相当于提高了低水位。若页面分配器在低水位情况下分配失败，则唤醒 kswapd 内核线程异步扫描 LRU 链表和回收内存。这相当于提前唤醒了 kswapd 内核线程。另外，留给普通优先级分配请求的内存就少了，这样可能导致进程提前使用 OOM Killer 机制。但是凡事都不能太绝对，当系统发现有外碎片化现象发生时，临时提高水位并且提前唤醒 kswapd 内核线程，反而可以缓解外片化的进一步恶化，这是 Linux5.0 内核新增的优化特性。</p><p>若 min_free_kbytes 值过小，内存管理区中预留的内存就越少，这样导致系统有一些高优先级分配行为的进程（或内核路径）在特别紧急情况下分配内存失败。若访向预留内存也失那么可能会导致系统进入死锁状态，如 kswapd 内核线程等通过没置 PF_MEMALLOC 标志位来告诉页面分配器，它们在紧急情况下访间少量的系统预留内存以保证程序的正确运行。</p><h2 id="影响页面分配的参数-lowmem_reserve_ratio">影响页面分配的参数 lowmem_reserve_ratio</h2><p>Linux 内核把内存节点分成了多个内存管理区，位于低地址的称为低端内存管理区，位于高地址的称为高端内存管理区。在一个 x86_64 计算机上，通常分成如下几个内存管理区</p><ul><li>ZONE_DMA</li><li>ZONE_DMA32</li><li>ZONE_NORMAL</li><li>ZONE_MOVAR</li><li>ONE_DEVICBLE</li></ul><p>可以通过查看/proc/zoneinfo 节点来获取每个内存管理区中的一些重要参数，如内存管理区的空闲内存、最低警戒水位、低水位、高水位、管理页面数量等。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pages free     3971</span><br><span class="line">      min      8</span><br><span class="line">      low      11</span><br><span class="line">      high     14</span><br><span class="line">      spanned  4095</span><br><span class="line">      present  3999</span><br><span class="line">      managed  3971</span><br><span class="line">      protection: (0, 1776, 31892, 31892, 31892)</span><br></pre></td></tr></tbody></table></figure><p>一个非常重要的参数就是 protection，它读取内存管理区中 lowmem_reserve[] 数组的值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/mmzone h&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> {</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don't know if the memory that we're going to allocate will be</span></span><br><span class="line"><span class="comment"> * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment"> * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment"> * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment"> * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment"> * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment"> * changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>lowmem_reserve[] 数组的单位是页面，设置 lowmem_reserve[] 数组是为了防止页面分配器过度地从低端内存管理区中分配内存，因为低端内存管理区的内存一般是有特殊用途的，如 ZONE_DMA 用于 ISA 总线的设备。通常有些应用程序分配内存之后会使用 mlock() 来锁住这都分内存，因此这些内存就不能被交换到交换分区，从而导致 ZONE_DMA 变少了。另外，防止系统过早在低端内存管理区中触发 OOM Killer 机制，而系统的高端内存管理区却有大量空内存。因此， Linux 内核设置 lowmem_reserve[] 数组为了防止进程过度使用低端内存管理区的内存。 那 Linux 内核是如何使用这个数组呢？ 从 /proc/zoneinfo 节点可以看到，ZONE_DMA 的 lowmem_reserve[] 数组值要比 ZONE_DMA32 的大。另外， ZONE_NORMAL 的 lowmem_reserve[] 数组元素全是 0，这说明不需要做额外保护。 判断一个内存管理区是否满足这次分配任务的函数是__zone_watermark_ok()。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/page_alloc.c&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if free base pages are above 'mark'. For high-order checks it</span></span><br><span class="line"><span class="comment"> * will return true of the order-0 watermark is reached and there is at least</span></span><br><span class="line"><span class="comment"> * one free page of a suitable size. Checking now avoids taking the zone lock</span></span><br><span class="line"><span class="comment"> * to check in the allocation paths if no pages are free.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> __zone_watermark_ok(<span class="keyword">struct</span> zone *z, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">unsigned</span> <span class="type">long</span> mark,</span><br><span class="line"> <span class="type">int</span> highest_zoneidx, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span><br><span class="line"> <span class="type">long</span> free_pages)</span><br><span class="line">{</span><br><span class="line"><span class="type">long</span> min = mark;</span><br><span class="line"><span class="type">int</span> o;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> alloc_harder = (alloc_flags &amp; (ALLOC_HARDER|ALLOC_OOM));</span><br><span class="line"></span><br><span class="line">free_pages -= __zone_watermark_unusable_free(z, order, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_HIGH)</span><br><span class="line">min -= min / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(alloc_harder)) {</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_OOM)</span><br><span class="line">min -= min / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min -= min / <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (free_pages &lt;= min + z-&gt;lowmem_reserve[highest_zoneidx])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If this is an order-0 request then the watermark is fine */</span></span><br><span class="line"><span class="keyword">if</span> (!order)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (o = order; o &lt; MAX_ORDER; o++) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span> =</span> &amp;z-&gt;free_area[o];</span><br><span class="line"><span class="type">int</span> mt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!area-&gt;nr_free)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (mt = <span class="number">0</span>; mt &lt; MIGRATE_PCPTYPES; mt++) {</span><br><span class="line"><span class="keyword">if</span> (!free_area_empty(area, mt))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alloc_harder &amp;&amp; !free_area_empty(area, MIGRATE_HIGHATOMIC))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中 z 表示当前扫描的内存管理区， classzone_idx 表示这次分配请求通过分配掩码计算出来的首选的内存管理区，如 GFP_KERNEL 会首选 ZONE_NOMAL。min 表示 z 内存管理区中判断水位的条件，free_pages 表示 z 内存管理区的空闲内存。 假设现在分配请求中 order 为 2，分配掩码为 GFP_KERNEL，为了判断当前的 ZONE_DMA 是否适合这次分配请求，假设判断水位条件为低水位。 在这种情况下需要读取 ZONE_DMA 中 lowmem_reserve[] 的值，从 /proc/zoneinfo 节点中我们可以读出值为 7610，7610KBx4=30440KB，加上 43KB，因此内存管理区的空闲页 面必须要大于 30484KB 才能满足分配请求。 每个内存管理区的 lowmem_reserve[] 值可以通过设置 lowmem_reserve_ratio 节点的值来修改，最终它是调用 setup_per_zone_lowmem_reserver[] 函数来实现的。</p><h1 id="影响页面回收的参数">影响页面回收的参数</h1><h2 id="sappiness">sappiness</h2><p>swampiness 用于控制 kswapd 内核线程把页面写入交换分区的活跃程度，该值可以设置为 0~100 该值越小，说明写入交换分区的活跃度越低，这样有助于提高系统的 I/O 性能该值越大，说明越来越多进程的匿名页面被写入交換分区了，这样有利于系统腾出内存空间，但是发生磁盘交换会导致大量的 I/O，影响系统的用户体验和系统性能。0 表示不写入匿名页面到磁盘，直到系统的空闲页面加上文件映射页面的总数少于内存管理区的高水位オ启动匿名页面回收并将其写入交换磁盘。 swampiness 的默认值为 60。</p><h2 id="zone_reclaim_mode">zone_reclaim_mode</h2><p>当页面分配器在一个内存管理区里分配失败时，若 zone_reclaim_mode 为 0，则表示可以从下一个内存管理区或者下一个内存节点中分配内存；否则，表示可以在这个内存管理区中进行一些内存回收，然后继续尝试在该内存管理区中分分配内存。 在 kernel/sysctl.c 文件中， zone_reclaim_mode 的值由 node_reclaim_mode 去来存储。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">vm_table</span>[] =</span> {</span><br><span class="line">{</span><br><span class="line">.procname= <span class="string">"overcommit_memory"</span>,</span><br><span class="line">.data= &amp;sysctl_overcommit_memory,</span><br><span class="line">.maxlen= <span class="keyword">sizeof</span>(sysctl_overcommit_memory),</span><br><span class="line">.mode= <span class="number">0644</span>,</span><br><span class="line">.proc_handler= overcommit_policy_handler,</span><br><span class="line">.extra1= SYSCTL_ZERO,</span><br><span class="line">.extra2= &amp;two,</span><br><span class="line">},</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">{</span><br><span class="line">.procname       = <span class="string">"nr_hugepages_mempolicy"</span>,</span><br><span class="line">.data           = <span class="literal">NULL</span>,</span><br><span class="line">.maxlen         = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>),</span><br><span class="line">.mode           = <span class="number">0644</span>,</span><br><span class="line">.proc_handler   = &amp;hugetlb_mempolicy_sysctl_handler,</span><br><span class="line">},</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 get_page_from_freelist() 函数中，当 zone_watermark_fast() 判断当前的内存管理区不能满足分配请求时，若 node_reclaim_mode 的值不为 0，则调用 node_reclaim() 函数对该内存管理区进行页面回收。下面是 get page_ from freelis 函数的代码片段。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">z = ac-&gt;preferred_zoneref;</span><br><span class="line">for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">ac-&gt;nodemask) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ac-&gt;spread_dirty_pages) {</span><br><span class="line"><span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) {</span><br><span class="line">last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">    zone != ac-&gt;preferred_zoneref-&gt;zone) {</span><br><span class="line"><span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line"><span class="keyword">if</span> (zone_to_nid(zone) != local_nid) {</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line"><span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">       gfp_mask)) {</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!node_reclaim_enabled() ||</span><br><span class="line">    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line"><span class="keyword">switch</span> (ret) {</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line"><span class="comment">/* did not scan */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line"><span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* did we reclaim enough */</span></span><br><span class="line"><span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="keyword">if</span> (page) {</span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_fallback) {</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>zone_reclaim_mode 是一个按位或操作的数值，读者可以根据如下位来设置不同的组合。</p><ul><li>1(bit[0])：表示打开内存管理区回收模式・扫描该内存管理区的页面并进行页面回收。</li><li>2(bit[1]）：表示只回收该内存管理区的内容缓存页面，将脏的内容缓存页面回写到磁盘，从而回收页面。</li><li>4(bit[2]）：表示只回收该内存管理区的匿名页面。</li></ul><p>通常情况下， zone_reclaim_mode 模式是关闭的。但是，读者可以根据不同的场景来选择打开或者关闭。</p><ul><li>打开的场景。如果应用场景对跨 NUMA 内存节点的访问延时比较敏感，可以打开 zone_reclaim_mode 模式，这样页面分配器会优先从本地内存节点回收内存并分配内存。</li><li>关闭的场景。如文件服务器中，系统需要大量的内容来作为内容缓存，即使内容缓存在远端 NUMA 节点上，读其中的内容也比直接读磁盘中的内容要快。</li></ul><h2 id="watermark_boost_factor">watermark_boost_factor</h2><p>watermark_boost_factor 用于优化内存外碎片化。它临时提高内存管理区的水位，即 zone-&gt;watermark_boost 从而提高内存管理区的高水位（ WMARK_HIGH），这样 kswapd 可以回收更多内存，内存规整模块（ compactd 内核线程）就比较容易合并大块的连续物理内存。 watermark_boost_factor 的默认值是 15000，表示会临时把原来的高水位提升到 150%。若把这个值设置为 0，则关闭临时提高内存管理区水位的机制。临时提高 zone-&gt;watermark_boost 是在 boost_watermark() 函数中实现的。</p><h2 id="watermark_scale_factor">watermark_scale_factor</h2><p>除了和 min_free_kbyt 有关外， watermark_scale_factor 还会影响每个内存管理区的低水位 WMARK_LOW）和高水位 内存管理区的低水位会影响 kswapd 内核线程唤醒的时机，内存管理区的高水位会影响 kswapd 内核线程进入睡眠的时机。通常，当页面分配器发现在低水位分配失败时，会唤醒 kswapd 内核线程：而当内存管理区水位高于高水位时，会让 kswapd 内核线程停止工作并进入睡眠状态。</p><p>在__setup_per_zone_marks() 函数中，watermark_scale_factor 的默认值为 10，分母为 10000 因比表示两个水位之间的距离是系统总内存的 0.1%，如最低警戒水位与低水位的差距是总内存的 0.1% watermark_scale_factor 最大可以设置为 1000 即两个水位之间的差距最大为总内存的 10%。</p><h1 id="影响脏页回写的参数">影响脏页回写的参数</h1><p>内存的回收和胜页回写有密切的关系，尽管本节没有介绍文件系统的相关内容，但是对于系统调优来说，影响脏页回写的参数不可忽视。</p><ul><li>dirty_background_bytes：当脏页所占的内存数量（指所有可用内存，即空闲页面+可回收内存页面）超过 dirty_background_bytes 时，内核回写线程（ writeback thread）开始回写脏页。</li><li>dirty_background_ratio：当脏页所占的百分比达到 dirty_background_ratio 时，内核回写线程开始回写脏页数据，直到脏页比例低于此值。注意，对于 dirty_backgound_byts 和 dirty_background_ratio，我们只能设置其中一个。当设置其中一个时。另外一个立即变成 0。 dirty_background_ratio 的默认值为 10。</li><li>diry_bytes：当系统的脏页总数达到 diry_bytes 值时， wrte 系统调用会被阻塞，并开始回写脏页数据，直到脏页总数低于此值。注意，该值不能设置为小于两个页面大小的字节数，否则，设置不生效并且系统会默认加载之前的旧值。</li><li>dirty_ratio：当脏页所占的百分比（空闲内存页+可回收内存页）达到 dirty_ratio 时，write 系统调用被阻塞并开始回写脏页数据，直到脏页比例低于此值。 dirty_ratio 的默认值为 20。注意，对于 dirty_ratio 和 dirty_bytes，我们只能设置其中一个。</li><li>dirty_expire_centisecs：脏数据的过期时间。当内核回写线程被唤醒后会检査哪些数据的存在时间超过了这个时间，并将这些脏数据回写到磁盘，单位是百分之一秒，也就是 10ms。该值默认是 3000，即若脏数据的存在时间超过 30s，那么内核回写线程唤醒之后优先回写这些脏数据。</li><li>dirty_writeback_centisecs：内核回写线程周期性唤醒的时间间隔，默认是 5。</li><li><p>drop_caches：用来回收干净的页面高速缓存和一些可以回收的 sab 对象，如文件系统中 inode、dentries 等。其默认值的含义如下：</p><ul><li>1、回收和释放内容缓存页面</li><li>2、回收和释放可回收的 sab 对象。</li><li>3、同时回收和释放内容缓存页面、slb 对象</li></ul></li></ul><p>读者可能会对 dirty_background_* 和 dirty_* 这两组参数产生疑感。其实它们之间不冲突，下面以 ratio 为例来说明， dirty_background_ratio 是内存可以产生脏页的百分比。若系统脏页超过这个比例，这些脏页会在稍后某个时刻回写到磁盘里，这由内核回写线程来完成。而 dirty_ratio 的语义是脏页的限制，即脏页的百分比不能超过这个值。如果脏数据超过这个数量，新的 I/O 请求（ write 系统调用）将会被阻塞，直到脏数据被写进磁盘。这是造成 I/O 延迟的重要原因，但这是保证内存中不会存在过量脏数据的保护机制</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（十一）调试信息</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryDebug/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryDebug/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryDebug.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM4OTE1MGYzNDZmYjA3MjVmYmIzZjM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="procmeminfo">/proc/meminfo</h1><p>在 Linux 系统中查看内存信息最准确的方法是查看/proc/meminfo 节点信息，他包含当前时刻系统的所有的物理页面信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~/workspace/blog$ <span class="built_in">cat</span> /proc/meminfo</span><br><span class="line">MemTotal:       32766544 kB</span><br><span class="line">MemFree:        18617392 kB</span><br><span class="line">MemAvailable:   31598252 kB</span><br><span class="line">Buffers:          829808 kB</span><br><span class="line">Cached:         11869936 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:          7991876 kB</span><br><span class="line">Inactive:        4838568 kB</span><br><span class="line">Active(anon):     125680 kB</span><br><span class="line">Inactive(anon):      628 kB</span><br><span class="line">Active(file):    7866196 kB</span><br><span class="line">Inactive(file):  4837940 kB</span><br><span class="line">Unevictable:           0 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:      92274680 kB</span><br><span class="line">SwapFree:       92274680 kB</span><br><span class="line">Dirty:               248 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        130960 kB</span><br><span class="line">Mapped:           164660 kB</span><br><span class="line">Shmem:              5180 kB</span><br><span class="line">KReclaimable:     746412 kB</span><br><span class="line">Slab:            1116388 kB</span><br><span class="line">SReclaimable:     746412 kB</span><br><span class="line">SUnreclaim:       369976 kB</span><br><span class="line">KernelStack:       11840 kB</span><br><span class="line">PageTables:         3800 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:    108657952 kB</span><br><span class="line">Committed_AS:    1769632 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">VmallocUsed:       56828 kB</span><br><span class="line">VmallocChunk:          0 kB</span><br><span class="line">Percpu:            58368 kB</span><br><span class="line">HardwareCorrupted:     0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemHugePages:        0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FileHugePages:         0 kB</span><br><span class="line">FilePmdMapped:         0 kB</span><br><span class="line">CmaTotal:              0 kB</span><br><span class="line">CmaFree:               0 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">Hugetlb:               0 kB</span><br><span class="line">DirectMap4k:      722824 kB</span><br><span class="line">DirectMap2M:    16992256 kB</span><br><span class="line">DirectMap1G:    17825792 kB</span><br></pre></td></tr></tbody></table></figure><p>meminfo 节点实现在 meminfo_proc_show() 函数里，该函数在 fs/proc/meminfo.c 文件里。</p><ul><li>MemTotal：系统当前可用物理内存总量，通过读取全局变量 _totalram_pages 来获得</li><li>MemFree: 系统当前剩余空闲物理内存，通过读取全局变量 wm_zone_stat[] 数组中的 NR_FREE_PAGES 来获得</li><li>Memavailable: 系统中可使用页面的数量，由 si_mem_available() 函数计算而来，计算公式为 Available= memfree + pagecache + reclaimable - totalreserve_pages。这里包括了空闲页面（ memfree）、文件映射页面（ pagecache）、可回收的页面（ reclaimable），最后减去系统保留的页面</li><li>Buffers：用于块层的缓存，由 nr_blockdev_pages() 函数来计算</li><li>Cached: 用于页面高速缓存的页面。计算公式为 Cached= NR_FILE_PAGES - swap_cache - Buffers</li><li>SwapCached: 这里统计交换缓存的数量，交换缓存类似于内容缓存，只不过它对应的是交换分区，而内容缓存对应的是文件。这里表示匿名页面曾经被交換出去，现在又被交換回来，但是页面内容还在交换缓存中</li><li>Active：活跃的匿名页面（ LRU_ACTIVE_ANON）和活跃的文件映射页面（ LRU_ACTIVE_FILE）</li><li>Inactive: 不活跃的匿名页面（ LRU_INACTIVE_ANON）和不活跃的文件映射页面（ LRU_INACTIVE_FILE）</li><li>Active(anon): 活跃的匿名页面（ LRU_ACTIVE_ANON）</li><li>Inactive(anon): 不活跃的匿名页面（ LRU_INACTIVE_ANON）</li><li>Active(file): 活跃的文件映射页面（ LRU_ACTIVE_FILE）</li><li>Inactive(file): 不活跃的文件映射页面（ LRU_INACTIVE_FILE）</li><li>Unevictable: 不能回收的页面（ LRU_UNEVICTABLE）</li><li>Mlocked: 不会被交换到交换分区的页面，由全局的 vm_zone_stat[] 中的 NR_MLOCK 来统计</li><li>SwapTotal: 交换分区的大小</li><li>Swapfree: 交换分区的空闲空间大小</li><li>Dirty: 脏页的数量，由全局的 vm_node_stat[] 中的 NR_FILE_DIRTY 来统计</li><li>Writeback: 正在回写的页面数量，由全局的 vm_node_stat[] 中的 NR_WRITEBACK 来统计</li><li>Anonpages: 统计有反向映射（RMAP）的页面，通常这些页面都是匿名页面并且都映射到了用户空间，但是并不是所有匿名页面都配置了反向映射，如部分的 shmem 和 tmps 页面就没有设置反向映射。这个计数由全局的 vm_node_stat[] 中的 NR_ANON_MAPPED 来统计</li><li>Mapped: 统计所有映射到用户地址空间的内容级存页面，由全局的 vm_node_stat[] 中的 NR_FILE_MAEED 来统计</li><li>Shmem: 共享内存（基于 tmps 实现的 shmem、 devtmfs 等）页面的数量，由全局的 vm_node_stat[] 中的 NR_SHMEM 来统计</li><li>KReclaimable: 内核可回收的内存，包括可回收的 slab 页面（ NR_SLAB_RECLAIMABLE）和其他的可回收的内核页面（ NR_KERNEL_MISC_RECLAIMABLE）</li><li>Slab: 所有 slab 页面，包括可回收的 slab 页面（ NR_SLAB_RECLAIMABLE）和不可回收的 slab 页面 (NR_SLAB_UNRECLAIMABLE)</li><li>Reclaimable: 可回收的 slab 页面（ NR_SLAB_RECLAIMABLE）</li><li>SUnreclaim: 不可回收的 slab 页面（NR_SLAB_UNRECLAIMABLE）</li><li>Kernelstack: 所有进程内核栈的总大小，由全局的 vm_zone_stat[] 中的 NR_KERNEL_STACK_KB 来统计</li><li>Pagetables: 所有用于页表的页面数量，由全局的 vm_zone_stat[] 中的 NR_PAGETABLE 来统计</li><li>NFS_Unstable: 在 NFS 中，发送到服务器端但是还没有写入磁盘的页面（INR_UNSTABLE_NFS）</li><li>WritebackTmp: 回写过程中使用的临时缓存（ NR_WRITEBACK_TEMP）</li><li>VmallocTotal: vmalloc 区域的总大小</li><li>VmallocUsed: 已经使用的 vmalloc 区域总大小</li><li>Percpu： percpu 机制使用的页面，由 pcpu_nr_pages() 函数统计</li><li>AnonHugePage： 统计透明巨页的数量</li><li>ShmemHugePages： 统计在 shmem 或者 tmpfs 中使用的透明巨页的数量</li><li>ShmemPmdMapped： 使用透明巨页并且映射到用户空间的 shmem 或者 tmps 的页面数量</li><li>CmaTotal： CMA 机制使用的内存</li><li>CmaFree： CMA 机制中空闲的内存</li><li>HugePages_Total: 普通巨页的数量，普通巨页的页面是预分配的</li><li>Hugepages_Free: 空闲的普通巨页的数量</li><li>Hugepageslze: 普通巨页的大小，通常是 2MB 或者 1GB</li><li>Hugetlb: 普通巨页的总大小，单位是 KB</li></ul><p>读者可能会对上述内容感到疑惑，下面归纳常见的问题。</p><h2 id="为什么-memtotal-不等于-qemu-虚拟机中分配的内存大小">为什么 MemTotal 不等于 QEMU 虚拟机中分配的内存大小？</h2><p>读者可能会发现 MemTotal 显示的总内存大小并不等于物理系统中真实的内存大小或者 QEMU 虚拟机中分配的内存大小，如在 QEMU 虚拟机启动参数中指定内存大小为 1GB 进入 QEMU 虚拟机后发现 MemTotal 为“99984KB"。这是因为内核静态使用的内存（如内核代码等）在启动阶段需要用到，它没有计入 MemTotal 统计项中，而是统计到 reserved 中。下面是一个计算机的内核启动日志信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0.000000] Memory: 929640K/1048576K available(23228K kernel code, 1090K rwdata, 3872K rodata, 4608K init, 503K bss, 53400K reserved, 65536K cma-reserved)</span><br><span class="line">[8.910031] Freeing unused kernel memory: 4608K</span><br></pre></td></tr></tbody></table></figure><p>从上述内核日志可以看到，在启动初始化时有 53400 大小的内容被保留了，用于内核代码等。在内核初始化完成之后，init 段的内存会被释放，因此被保留的内存大小为 53400KB-4608KB=48792KB，加上 MemTotal 正好是 1GB 内存</p><h2 id="memavailable-究竟是什么意思">MemAvailable 究竟是什么意思？</h2><p>MemavAilable 表示系统中有多少可以利用的内存，这些内存不包括交换分区。 MemAvailable 的计算和 MemFree、可回收的 slab 页面、内容页面以及每个内存管理区的最低水位等有密切关系。</p><h2 id="为什么-sab-分配器要区分-sreclaimable-和-sunreclaim">为什么 sab 分配器要区分 SReclaimable 和 SUnreclaim</h2><p>一个 slab 分配器由一个或者多个连续的物理页面组成。在为 slab 分配器分配物理页面时根据 slab 描述符（ cache-&gt;flags）是否设置了 SLAB_RECLAIM_ACCOUNT 标志位来判断这些页面是属于 SReclaimable 还是属于 SUnreclaim.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/slab.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">kmem_getpages</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">        mod_lruvec_page_state(page, NR_SLAB_RECLAIMABLE, nr_pages);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE, nr_pages);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而在创建 sab 描述符时若发现设置了 SLAB_RECLAIM_ACCOUNT，那么分配物理页面的行为就是可回收的，即设置 __GFP_RECLAIMABLE，表示这些页面是可以被 sab 机制的收割机回收的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/slab.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __kmem_cache_create(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">slab_flags_t</span> flags)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">        cachp-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因此，这些 slb 分配器的页面的迁移类型是 MIGRATE_RECLAIMABLE。在页面回收机中会调用 slab 收割机的回调函数（ shrinker-&gt;scan_objects）来回收一些 slab 对象，但是在 scan_objects 回调函数的实现中并没有判断哪些 slab 分配器的页面设置了__GFP_RECLAIMABLE，哪些页面没有设置__GFP_RECLAIMABLE。在 slab 机制里，有一个定时器会定时扫描和检查哪些 slab 分配器可以被销毁，如果一个 slab 分配器中都是空闲的 slab 对象那么这个 slab 分配器就可以被回收，并且 slab 分配器占用的页面会被释放，见 cache_reap() 数。因此，统计 SReclaimable 和 SUnreclaim 页面的含义是在于计算系统可用的总内存数 meminfo 中的 MemAvailable，详见 si_mem_available() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/page_alloc.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">si_mem_available</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    reclaimable = global_node_page_state(NR_SLAB_RECLAIMABLE) +</span><br><span class="line">        global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);</span><br><span class="line">    available += reclaimable  - min(reclaimable / <span class="number">2</span>, wmar_low);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> available;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="为什么-activeanon-nactiveanon不等于-anonpages">为什么 Active（anon）+ nactive（anon）不等于 Anonpages</h2><p>我们知道 Active（anon）表示 LRU 链表中的活跃匿名页面， Inactive（anon）表示不活跃匿名页面，这两个值相加，表示系统的 LRU 链表中的总匿名页面数量。而 AnonPages 表示和用户态进程地址空间建立映射关系。当一个匿名页面和进程地址空间建立映射关系时会调用 page_add_new_anon_mmap() 函数来新增一个 RMAP。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_add_new_anon_rmap</span> <span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    __mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是 shmem（基于 tmpfs 实现）使用的页面会被添加到系统的匿名页面的 LRU 链表中因此它会被计入 Active（anon）或者 Inactive（anon）之中。主要原因是 shmem 使用的页面基于 RAM 内存，它可以被写入交换分区里。在分配 shmem 页面时设置了 PG_SwapBacked 标志位，见 shmem_alloc_and_acct_page() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">shmem_alloc_and_acct_page</span> <span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    page =shmem_alloc_page(gfp, info, index);</span><br><span class="line">    __SetPageLocked(page);</span><br><span class="line">    __SetPageSwapbacd(page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过判断 PG_SwapBacked 标志位来定将页面加到名页面的 LRU 链表中还是文件映射的 LRU 链表中，见 page_is_file_cache() 函数。若没有设置 PG_SwapBacked 标志位，则页面是文件映射的页面，会被添加到文件映射的 LRU 链表中否则，被添加到名页面的 LRU 链表中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">page_is_file_cache</span><span class="params">(<span class="keyword">struct</span> page * page)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> !PageSwapBacked(page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外， shmem 页面并没有计入 Anonpages 中，而是计入了 MM_SHMEMPAGES 类型的计数值（即 Shmem）中，见 do_shared_fault()-&gt;finish_fault()-&gt;alloc_set_pte() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">alloc_set_pte</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    inc_mm_counter_fast(vma-&gt;vm_mm, mm_counter_file(page));</span><br><span class="line">    page_add_file_rmap(page, <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 page_add_file_rmap() 中会把这个页面计入 NR_FILE_MAPPED 计数值中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_add_file_rmap</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总之， shmem 页面一方面被添加到了置名页面的 LRU 链表里，另一方面被统计到文件映射页面的计数中，真是个“另类的”页面。</p><h2 id="为什么-activefile-inactivefile-不等于-mapped">为什么 Active（file) + Inactive（file) 不等于 Mapped?</h2><p>Active（file）+ nactive(file) 表示系统 LRU 链表中所有文件映射页面的总和，而 Mapped 表示统计所有映射到用户地址空间的内容缓存页面，由 NR_FILE_MAPPED 来统计。当一个内容缓存映射到用户态的进程地址空间时，会调用 page_add_file_map() 函数来建立 RMAP，并增加 NR_FILE_MAPPED 计数值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_add_file_rmap</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    __mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有一个特殊情况需要考虑，就是 shmem 页面。它会被计入 NR_FILE_MAPPED 计数值中但是它会设置 PG_SwapBacked 标志位，因此它会被计入匿名页面。 当创建一个 shmem 页面时会把它计入 NR_FILE_PAGES 和 NR_SHMEM 计数值中，见 shmem_add_to_page_cache() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_add_to_page_cache</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    __mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);</span><br><span class="line">    __mod_node_page_state(page_pgdat(page), NR_SHMEM, nr);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="为什么-activefile-inactivefile不等于-cached">为什么 Active（file）+ Inactive（file）不等于 Cached？</h2><p>Cached 计数值的计算公式是 Cached = NR_FILE_PAGES - swap_cache - Buffers。但是 shmem 页面被计入 NR_FILE_PAGES 里，同时，它也在匿名页面 LRU 链表的计数值里 Active(file) + Inactive（file）表示系统的 LRU 链表中所有文件映射页面的总和，因此 LRU 表所有文件映射页面总和不等于 Cached 计数值。</p><h1 id="伙伴系统信息">伙伴系统信息</h1><p>/proc/buddyinfo 节点包含当前系统的伙件系统简要信息 而 proc/pagetypeinfo 节点则包含当前系统的伙伴系统详细信息，包括每个迁移类型和每个链表的成员数量等。当前系统只有一个 DMA32 的内存管理区，支持的迁移类型有 Unmovable、 Movable、Reclaimable、 HighAtomic、CMA 以及 Isolate 等迁移类型，其中页面数量最多的迁移类型是 Movable 类型。迁移类型的最小的单位是页块，在 ARM64 架构中，页块的大小是 2MB，即 order 为 9 其中一共有 512 个页面：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/home/vooxle/workspace/blog<span class="comment"># cat /proc/pagetypeinfo</span></span><br><span class="line">Page block order: 9</span><br><span class="line">Pages per block:  512</span><br><span class="line"></span><br><span class="line">Free pages count per migrate <span class="built_in">type</span> at order       0      1      2      3      4      5      6      7      8      9     10</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>    Unmovable      1      1      0      0      2      1      1      0      1      0      0</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>      Movable      0      0      0      0      0      0      0      0      0      1      3</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>  Reclaimable      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>   HighAtomic      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>          CMA      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone      DMA, <span class="built_in">type</span>      Isolate      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>    Unmovable      1      0      0      0      0      0      1      1      1      1      0</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>      Movable      9      5      5      5      4      6      6      5      5      3    459</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>  Reclaimable      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>   HighAtomic      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>          CMA      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone    DMA32, <span class="built_in">type</span>      Isolate      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>    Unmovable      1    499    477    515    204     39     28      5      0      0      0</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>      Movable   8557  24298  10230   7542   2723    231    664    257    371     94   3641</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>  Reclaimable      8      1     62     35     38     12      0      1      0      1      0</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>   HighAtomic      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>          CMA      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line">Node    0, zone   Normal, <span class="built_in">type</span>      Isolate      0      0      0      0      0      0      0      0      0      0      0</span><br><span class="line"></span><br><span class="line">Number of blocks <span class="built_in">type</span>     Unmovable      Movable  Reclaimable   HighAtomic          CMA      Isolate</span><br><span class="line">Node 0, zone      DMA            1            7            0            0            0            0</span><br><span class="line">Node 0, zone    DMA32            2         1014            0            0            0            0</span><br><span class="line">Node 0, zone   Normal          394        14596          370            0            0            0</span><br></pre></td></tr></tbody></table></figure><p>读者需要注意，页块的大小和普通巨页有关。当系统配置了 CONFIG_HUGETLB_PAGE 时，页块的 order 大小等于 HUGETLB_PAGE_ORDER，通常是 9：否则，页块的 order 大小是 10，如下图所示。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pageblock_order HUGETLB_PAGE_ORDER</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pageblock_order (MAX_ORDER-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="查看内存管理区的信息">查看内存管理区的信息</h2><p>/proc/zoneinfo 节点包含当前系统所有内存管理区的信息。/proc/zoneinfo 节点是显示如下几部分信息。</p><h4 id="当前内存节点的内存统计信息">当前内存节点的内存统计信息</h4><p>下面是/proc/zoneinfo 节点的第一部分信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/home/vooxle/workspace/blog<span class="comment"># cat /proc/zoneinfo</span></span><br><span class="line">Node 0, zone      DMA</span><br><span class="line">  per-node stats</span><br><span class="line">      nr_inactive_anon 157</span><br><span class="line">      nr_active_anon 31943</span><br><span class="line">      nr_inactive_file 1209487</span><br><span class="line">      nr_active_file 1968292</span><br><span class="line">      nr_unevictable 0</span><br><span class="line">      ...</span><br><span class="line">      nr_kernel_misc_reclaimable 0</span><br></pre></td></tr></tbody></table></figure><p>在第 2 行中，表示当前内存节点是第 0 个内存节点，当前内存管理区为 DMA。 在第 3 行中，表示下面是该内存节点的总体信息。如果当前内存管理区是内存节点的第一个内存管理区，那么会显示该内存节点的总信息。它通过 node_page_state() 函数来读取内存节点的数据结构 plist_data 中的 vm_stat 计数值。 上述信息是在 zoneinfo_show_print() 函数中输出的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/vmstat.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zoneinfo_show_print</span><span class="params">(<span class="keyword">struct</span> seq_file * m, <span class="type">pg_data_t</span> *pgdat,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> zone *zone)</span></span><br></pre></td></tr></tbody></table></figure><h4 id="当前内存管理区的总信息下面继续看proczoneinfo-节点的信息">当前内存管理区的总信息下面继续看/proc/zoneinfo 节点的信息</h4><p>下面继续看/proc/zoneinfo 节点的第二部分信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pages free     3971</span><br><span class="line">      min      8</span><br><span class="line">      low      11</span><br><span class="line">      high     14</span><br><span class="line">      spanned  4095</span><br><span class="line">      present  3999</span><br><span class="line">      managed  3971</span><br><span class="line">      protection: (0, 1776, 31892, 31892, 31892)</span><br></pre></td></tr></tbody></table></figure><ul><li>pages free: 表示这个内存管理区中空闲页面的数量</li><li>min：表示这个内存管理区中处于最低警戒水位的页面数量</li><li>low：表示这个内存管理区中处于低水位的页面数量</li><li>high：表示这个内存管理区中处于高水位的页面数量</li><li>spanned：表示这个内存管理区包含的页面数量</li><li>present：表示这个内存管理区里实际管理页面的数量</li><li>managed：表示这个内存管理区中被伙伴系统管理的页面数量</li><li>protection：表示这个内存管理区预留的内存</li></ul><h3 id="内存管理区详细的页面信息">内存管理区详细的页面信息</h3><p>接下来是内存管理区详细的页面信息/proc/zoneinfo 节点的第三部分信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nr_free_pages 3971</span><br><span class="line">nr_zone_inactive_anon 0</span><br><span class="line">nr_zone_active_anon 0</span><br><span class="line">nr_zone_inactive_file 0</span><br><span class="line">nr_zone_active_file 0</span><br><span class="line">nr_zone_unevictable 0</span><br><span class="line">nr_zone_write_pending 0</span><br><span class="line">nr_mlock     0</span><br><span class="line">nr_page_table_pages 0</span><br><span class="line">nr_kernel_stack 0</span><br><span class="line">nr_bounce    0</span><br><span class="line">nr_zspages   0</span><br><span class="line">nr_free_cma  0</span><br><span class="line">numa_hit     0</span><br><span class="line">numa_miss    0</span><br><span class="line">numa_foreign 0</span><br><span class="line">numa_interleave 0</span><br><span class="line">numa_local   0</span><br><span class="line">numa_other   0</span><br></pre></td></tr></tbody></table></figure><p>上述是这个内存管理区详细的页面信息。它通过 zone_page_state() 函数来读取 zone 数据结构中的 vm_stat 计数值。</p><h4 id="每个-cpu-内存分配器的信息">每个 CPU 内存分配器的信息</h4><p>最后是每个 C 内存分配器的/proc/zonelnf。节点的第四部分信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pagesets</span><br><span class="line">  cpu: 0</span><br><span class="line">            count: 0</span><br><span class="line">            high:  0</span><br><span class="line">            batch: 1</span><br><span class="line">vm stats threshold: 12</span><br><span class="line">  cpu: 1</span><br><span class="line">            count: 0</span><br><span class="line">            high:  0</span><br><span class="line">            batch: 1</span><br><span class="line">  ...</span><br><span class="line">vm stats threshold: 12</span><br><span class="line">node_unreclaimable:  0</span><br><span class="line">start_pfn:           1</span><br></pre></td></tr></tbody></table></figure><ul><li>pagesets：表示每个 CPU 内存分配器中每个 CPU 缓存的页面信息。</li><li>node_unreclaimable：表示页面回收失败的次数。</li><li>start_pfn：表示内存管理区的起始页帧号</li></ul><h2 id="查看与进程相关的内存信息">查看与进程相关的内存信息</h2><p>进程的 mm_struct 数据结构中有一个 rss_stat 成员，它用于记录进程的内存使用情况。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When updating this, please also update struct resident_page_types[] in</span></span><br><span class="line"><span class="comment"> * kernel/fork.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">MM_FILEPAGES,<span class="comment">/* Resident file mapping pages */</span></span><br><span class="line">MM_ANONPAGES,<span class="comment">/* Resident anonymous pages */</span></span><br><span class="line">MM_SWAPENTS,<span class="comment">/* Anonymous swap entries */</span></span><br><span class="line">MM_SHMEMPAGES,<span class="comment">/* Resident shared memory pages */</span></span><br><span class="line">NR_MM_COUNTERS</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS &amp;&amp; defined(CONFIG_MMU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPLIT_RSS_COUNTING</span></span><br><span class="line"><span class="comment">/* per-thread cached information, */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_rss_stat</span> {</span></span><br><span class="line"><span class="type">int</span> events;<span class="comment">/* for synchronization threshold */</span></span><br><span class="line"><span class="type">int</span> count[NR_MM_COUNTERS];</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_SPLIT_PTE_PTLOCKS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_rss_stat</span> {</span></span><br><span class="line"><span class="type">atomic_long_t</span> count[NR_MM_COUNTERS];</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br></pre></td></tr></tbody></table></figure><p>进程的 mm_struct 数据结构会记录下面 4 种页面的数量</p><ul><li>MM_FILEPAGES：进程使用的文件映射的页面数量。</li><li>MM_ANONPAGES：进程使用的匿名页面数量。</li><li>MM_SWAPENTS：进程使用的交换分区的匿名页面数量</li><li>MM_SHMEMPAGES：进程共享的内存的页面数量</li></ul><p>增加和减小进程内存计数的接口函数有如下几个。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#获取 member 计数值</span><br><span class="line">unsigned long get_mm_counter(struct mm_struct *mm, int member)</span><br><span class="line"># 使 member 计数值增加 value</span><br><span class="line">void add_mm_counter(struct mm_struct *mm, int member, long value)</span><br><span class="line">#使 member 计数值增加 1</span><br><span class="line">void inc_mm_counter(struct mm_struct *mm, int member)</span><br><span class="line">#使 member 计数值减小 1</span><br><span class="line">roid dec_mm_counter(struct mm_struct *mm, int member)</span><br><span class="line">#当 page 不是匿名页面时，若 page 设置了 PageSwapbacked，那么返回 MM_SHMEMPAGES，否则返回 MM_EILEPAGES</span><br><span class="line">int mm_counter_file(struct page *page)</span><br><span class="line">#返回 page 对应的统计类型</span><br><span class="line">int mm_counter(struct page *page)</span><br></pre></td></tr></tbody></table></figure><p>proc 文件系统包含每个进程的相关信息，其中 /proc/PID/status 节点有不少和具体进程内存相关的信息。下面是 sshd 线程的状态信息，只截取了和内存相关的信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/proc/2<span class="comment"># cat status</span></span><br><span class="line">Name:kthreadd</span><br><span class="line">Umask:0000</span><br><span class="line">State:S (sleeping)</span><br><span class="line">Tgid:2</span><br><span class="line">Ngid:0</span><br><span class="line">Pid:2</span><br><span class="line">PPid:0</span><br><span class="line">TracerPid:0</span><br><span class="line">Uid:0000</span><br><span class="line">Gid:0000</span><br><span class="line">FDSize:64</span><br><span class="line">Groups:</span><br><span class="line">NStgid:2</span><br><span class="line">NSpid:2</span><br><span class="line">NSpgid:0</span><br><span class="line">NSsid:0</span><br><span class="line">Threads:1</span><br><span class="line">SigQ:0/127633</span><br><span class="line">SigPnd:0000000000000000</span><br><span class="line">ShdPnd:0000000000000000</span><br><span class="line">SigBlk:0000000000000000</span><br><span class="line">SigIgn:ffffffffffffffff</span><br><span class="line">SigCgt:0000000000000000</span><br><span class="line">CapInh:0000000000000000</span><br><span class="line">CapPrm:0000003fffffffff</span><br><span class="line">CapEff:0000003fffffffff</span><br><span class="line">CapBnd:0000003fffffffff</span><br><span class="line">CapAmb:0000000000000000</span><br><span class="line">NoNewPrivs:0</span><br><span class="line">Seccomp:0</span><br><span class="line">Speculation_Store_Bypass:thread vulnerable</span><br><span class="line">Cpus_allowed:ffff,ffffffff</span><br><span class="line">Cpus_allowed_list:0-47</span><br><span class="line">Mems_allowed:00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001</span><br><span class="line">Mems_allowed_list:0</span><br><span class="line">voluntary_ctxt_switches:3335</span><br><span class="line">nonvoluntary_ctxt_switches:0</span><br></pre></td></tr></tbody></table></figure><ul><li>Name：进程的名称</li><li>Pid:PID。</li><li>VmPeak：进程使用的最大虚拟内存，通常情况下它等于进程的内存描述符 mm 中的 total_vm</li><li>VmSize：进程使用的虚拟内存，它等于 mm-&gt;total_vm</li><li>VmLck：进程锁住的内存，它等于 m-&gt;locked_vm，这里指使用 mlock() 锁住的内存。</li><li>VmPin：进程固定住的内存，它等于 mm-&gt;pinned_vm，这里指使用 get_user_page() 固定住的内存。</li><li>VmHWM：进程使用的最大物理内存，它通常等于进程使用的匿名页面、文件映射页面以及共享内存页面的大小总和</li><li>VmRSS：进程使用的最大物理内存，它常常等于 VmHWM，计算公式为 VmRSS = RssAnon + RssFile + RssShmem</li><li>RssAnon：进程使用的匿名页面，通过 get_mm_counter（mm， MM_ANONPAGES）获取。</li><li>RssFile：进程使用的文件映射页面，通过 get_mm_counter（mm， MM_FILEPAGES）获取</li><li>RssShmem：进程使用的共享内存页面，通过 get_mm_counter（mm， MM_SHMEMPAGES）获取。</li><li>VmData：进程私有数据段的大小，它等于 mm-&gt;data_vm</li><li>VmStk：进程用户栈的大小，它等于 mm-&gt;stack_vm</li><li>VmExe：进程代码段的大小，通过内存描述符 mm 中的 start_code 和 end_code 两个成员获取</li><li>VmLib：进程共享库的大小，通过内存描述符 mm 中的 exec_vm 和 VmExe 计算。</li><li>VmPTE：进程页表大小，通过内存描述符 mm 中的 pgtables_byes 成员获取。</li><li>VmSwap：进程使用的交换分区的大小，通过 get_mm_counter(mm， MM_SWAPENTS) 获取</li><li>HugetlbPages：进程使用巨页的大小，通过内存描述符 mm 中的 hugetlb_usage 成员获取</li></ul><h2 id="为什么-s_swap-与-p_swap-不相等">为什么 S_swap 与 P_swap 不相等</h2><p>proc/meminfo 节点中 SwapTotal 减去 SwapFree 等于系统中已经使用的交换内存大小，我们称之为 S_swap。另外，我们写一个小程序来遍历系统中所有的进程，并把进程中 /proc/PID/status 节点的 VmSwap 值都累加起来，我们把它称为 P_swap。为什么这两个值不相等？在 Linux 内核中通过 si_mapinfo() 函数来查看 S_swap 的值，由 nr_swap_pages 和 swap_info_struct 中的 flags 来统计，见 si_swapinfo() 函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/swapfile. c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">si_swapinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *val)</span></span><br></pre></td></tr></tbody></table></figure><p>当一个页面需要被交换到交换分区时，它需要在 kswapd 内核线程中经历活跃和不活跃 LRU 链表老化过程。一个页面被选为候选交换页面后，它需要调用 try_to_unmap_one() 函数来断开所有和用户进程地址空间映射的 PTE。 try_to_unmap_one() 函数的代码片段如下。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static bool try_to_unmap_one()</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    if (PageAnon(page)) {</span><br><span class="line">        dec_mm_counter(mm, MM_ANONPAGES);</span><br><span class="line">        inc_mm_counter(mm, MM_SWAPENTS);</span><br><span class="line">        swp_pte = swp_entry_to_pte(entry);</span><br><span class="line">        set_pte_at(mm, address, pvmw.pte, swp_pte);</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 try_to_unmap_one() 函数中，对于匿名页面，会减小进程的 MM_ANONPAGES 计数，增加 MM_SWAPENTS 计数，这里通过 PageAnon() 来判断页面是否为匿名页面。 shmem（共享内存）比较特殊，它是基于 tmpfs 来实现的，本质上它是基于 RAM 的一个文件系统，因此它具有文件的属性，如有文件节点、页面高速缓存等。另外，它的内容不能随便丢弃。当系统内存短缺时会把 shmem 暂时写入交换分区以便腾出内存，因此它有部分匿名页面的属性。那它究竟属于匿名页面还是文件映射页面呢？</p><p>创建 shmem 页面时，使用 shmem_fault() 函数，它的 page-&gt;mmaping 字段指向 inode-&gt;i_mapping，因此我们没法通过 PageAnon() 来判定它是否是传统的匿名页面。在 try_to_unmap_one() 函数中， shmem 页面并没有被统计到进程的 MM_SWAPENTS 计数中，/proc/PID/status 节点中的 VmSwap 不包含被写入交换分区的 shmem 页面。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（十）KSM</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryKSM/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryKSM/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryKSM.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM4NjUyOGYzNDZmYjA3MjVmYjQ1YmI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>KSM 指 Kernel SamePage Merging，即内核同页合并，用于合并内容相同的页面。KSM 的出现是为了优化虚拟化中产生的冗余页面。 KSM 允许合并同一个进程或不同进程之间内容相同的匿名页面，这对应用程序来说是不可见的。把这些相同的页面合并成一个只读的页面，从而释放出多余的物理页面，当应用程序需要改变页面内容时，会发生写时复制。</p><h1 id="使能-ksm">使能 KSM</h1><p>KSM 只会处理通过 madvise 系统调用显式指定的用户进程地址空间，因此用户程序想使用这个功能就必须在分配地址空间时显式地调用 madvise（addr，length，MADV_MERGEA BLE）。如果用户想在 KSM 中取消某一个用户进程地址空间的合并功能，也需要显式地调用 madvise（addr，length,MADV_UNMERGEABLE)。 下面是测试 KSM 的 test.c 程序的代码片段，使用 mmap()：来创建一个文件的私有映射，并且调用 memset() 写入这些私有映射的内容缓存页面中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">《测试 KSM 的 test.c 程序的代码片段》</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">64</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">int</span> size =<span class="number">100</span>*<span class="number">4096</span>;</span><br><span class="line">    <span class="type">int</span> fd =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(filename, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fd = open(filename,O_RDWR | O_CREAT,<span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">    fstat(fd, &amp;stat);</span><br><span class="line"></span><br><span class="line">    buf = mmap (<span class="literal">NULL</span>,stat.st_size,PROT_WRITE,MAP_PRIVATE,fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0x55</span>,stat.st_size);</span><br><span class="line"></span><br><span class="line">    madvise(buf,stat.st_size, MADV_MERGEABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译上述 test.c 程序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p>使用 dd 命令创建一个 ksm.dat 文件，即创建 100MB 大小的文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=ksm.dat bs=1M count=100</span><br></pre></td></tr></tbody></table></figure><p>使能 KSM。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/sys/kernel/mm/ksm/run</span><br></pre></td></tr></tbody></table></figure><p>运行 test.c 程序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#./test ksm.dat</span></span><br></pre></td></tr></tbody></table></figure><p>过一段时间之后，查看系统有多少页面合并了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@benshushu#cat /sys/kernel/mm/ksm/pages_sharing</span><br><span class="line">25500</span><br><span class="line">root@benshushu#cat /sys/kernel/mm/ksm/pages_shared</span><br><span class="line">100</span><br><span class="line">root@benshushu:/home#cat /sys/kernel/mm/ksm/pages_unshared</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure><p>可以看到 pages_shared 为 100 说明系统有 100 个共享的页面。若有 100 个页面的内同，它们可以合并成一个页面，这时 pages_shared 为 1。 pages_sharing 为 25500 说明有 25500 个页面合并了。 100MB 的内存可存放 25600 个页面。因此，我们可以看到，KSM 把这 25600 个页面分别合并成 1 共享的页面，每一个共享页面里共享了其他的 255 个页面，为什么会这样？我们稍后详细解析。 pages_unshared 表示当前未合并页面的数量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rootebenshushut cat /sys/kernel/mn/ksm/stable_node_chains</span><br><span class="line">1</span><br><span class="line">rootebenshushut cat /sys/kernel/mm/ksm/stable_node_dups</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure><p>stable_node_chains 表示包含了链式的稳定节点的个数，当前系统中为 1，说明只有一个链式的稳定节点，但是这个稳定的节点里包含了链表。 stable_node_dups 表示稳定的节点所在的链表包含的元素总数。 KSM 的 sysfs 节点在/sys/kernel/mm/ksm/目录下，其主要节点的描述如下所示。</p><ul><li>run：可以设置为 0~2。若设置 0，暂停 ksmd 内核线程；若设置 1，启动 ksmd 内核线程；若设置 2，取消所有已经合并好的页面</li><li>full_scans: 完整扫描和合并区域的次数</li><li>pages_volatile: 表示还没扫描和合并的页面数量。若由于页面内容更改过快导致两次计算的校验值不相等，那么这些页面是无法添加到红黑树里的</li><li>sleep_millisecs: ksmd 内核线程扫描一次的时间间隔</li><li>pages_to_scan: 单次扫描页面的数量</li><li>pages_shared: 合并后的页面数。如果 100 个页面的内容相同，那么可以把它们合并成一个页面，这时 pages_shared 的值为 1</li><li>pages_sharing: 共享的页面数。如果两个页面的内容相同，它们可以合并成一个页面，那么有一个页面要作为稳定的节点，这时 pages_shared 的值为 1，pages_sharing 也为 1。第 3 个页面也合并进来后，pages_sharing 的值为 2，表示两个页面共享同一个稳定的节点</li><li>pages_unshared: 当前未合并页面数量</li><li>max_page_sharing: 这是在 Linux4.3 内核中新增的参数，表示一个稳定的节点最多可以合并的页面数量。这个值默认是 256</li><li>stable_node_chains: 链表类型的稳定节点的个数。每个链式的稳定节点代表页面内容相同的 KM 页面。这个链式的稳定节点可以包含多个 dup 成员，每个 dup 成员最多包含 256 个共享的页面</li><li>stable_node_dups: 链表中 dup 成员的个数。这些 dup 成员会连接到链式的稳定节点的 hlist 链表中</li></ul><p>KSM 在初始化时会创建一个名为 ksmd 的内核线程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/ksm.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ksm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    ksm_thread = kthread_run(ksm_scan_thread, <span class="literal">NULL</span>, <span class="string">"ksmd"</span>);</span><br><span class="line">}</span><br><span class="line">subsys_initcall(ksm_init);</span><br></pre></td></tr></tbody></table></figure><p>在 tes.c 程序中创建私有映射（MAP_PRIVATE）之后，显式地调用 madvise 系统调用把用户进程地址空间添加到 Linux 内核的 KSM 系统中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;madvise()-&gt;ksm_madvise()-&gt; ksm_enter()&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __ksm_enter(<span class="keyword">struct</span> mm_struct *mm)</span><br><span class="line">{</span><br><span class="line">    mm_slot = alloc_mm_slot();</span><br><span class="line">    insert_to_mm_slots_hash(mm, mm_slot);</span><br><span class="line">    list_add_tail(&amp;mm slot-&gt;mm_list, &amp;ksm_scan.mm_slot-&gt;mm <span class="built_in">list</span>);</span><br><span class="line">    set_bit(MME_VM_MERGEABLE, &amp;mm-&gt;flags);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ksm_enter() 函数会把当前的 mm_struct 数据结构添加到 mm_slots_hash 哈希表中。另外把 mm_slot 添加到 ksm_scan.mm_slot-&gt;mm_list 链表中。最后，设置 mm-&gt;flags 中的 MMF_VM_MERGEABLE 标志位，表示这个进程已经被添加到 KSM 系统中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ksm 内核线程&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksm_scan_thread</span><span class="params">(<span class="type">void</span> *nothing)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (!kthread_should_stop())</span><br><span class="line">        <span class="keyword">if</span> (ksmd_should_run())</span><br><span class="line">            ksm_do_scan(ksm_thread_pages_to_scan)</span><br><span class="line">    <span class="keyword">if</span> (ksmd_should_run()) {</span><br><span class="line">        sleep_ms =READ_ONCE(ksm_thread_sleep_millisecs);</span><br><span class="line">        wait_event_interruptible_timeout(ksm_iter_wait,</span><br><span class="line">        sleep_ms != READ_ONCE(ksm_thread_sleep_millisecs),</span><br><span class="line">        secs_to_jiffies(sleep_ms));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ksm_scan_thread() 是 ksmd 内核线程的主干，它运行 ksm_do_scan() 函数，扫描和合并 100 个页面，见 ksm_thread_pages_to_scan 参数，然后等待 20ms，见 ksm_thread_sleep_millisecs 参数，这两个参数可以在/sys/kernel/mm/ksm 目录下设置和修改。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ksmd 内核线程&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ksm_do_scan</span><span class="params">(unsignd <span class="type">int</span> scan_npages)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(scan_npages-- &amp;&amp; likely(!freezing(current))) {</span><br><span class="line">        cond_resched();</span><br><span class="line">        rmap_item = scan_get_next_rmap_item(&amp;page);</span><br><span class="line">        <span class="keyword">if</span> (!rmap_item)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cmp_and_merge_page(page, rmap_item);</span><br><span class="line">        put_page(page)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ksm_do_scan() 函数在 while 循环中尝试合并 scan_npages 个页面， scan_get_next_rmap_item() 获取一个合适的匿名页面。 cmp_and_merge_page() 函数会让页面在 KSM 中稳定和不稳定的两棵红黑树中查找是否有可以合并的对象，并且尝试合并他们。</p><h1 id="ksm-基本实现">KSM 基本实现</h1><p>为了让读者先有一个初步的认识，本节先介绍 Lnux4.13 内核之前的 KSM 实现，后文会介绍 Linux5.0 内核中的实现。</p><p>KSM 机制下采用两棵红黑树来管理扫描的页面和己经合并的页面。第一棵红黑树称为不稳定红黑树，里面存放了还没有合并的页面；第二棵红黑树称为稳定红黑树，已经合并的页面会生成一个节点，这个节点为稳定节点。如两个页面的内容是一样的，KSM 扫描并发现了它们，因此这两个页面就可以合并成一个页面。对于这个合并后的页面，会设置只读属性，其中一个页面会作为稳定的节点挂载到稳定的红黑树中之后，另外一个页面就会被释放了。但是这两个页面的 rmap_item 数据结构会被添如到稳定节点中的 hist 链表中，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm1.png"></p><p>我们假设有 3 个 VMA（表示进程地址空间，VMA 的大小正好是一个页面的大小，分别有 3 个页面映射这 3 个 VMA。这 3 个页面准备通过 KSM 来扫描和合并，这 3 个页面的内容是相同的。具体步骤如下。</p><ul><li>3 个页面会被添加到 KSM 中，第一轮扫描中分别给这 3 个页面分配 rmap_item 数据结构来描述它们，并且分别给它计算校验和，如图（a）所示</li><li>第二轮扫描中，先扫描 page0，若当前稳定的红黑树没有成员，那么不能比较和加入稳定的红黑树。接着，第二次计算校验值，如果 page0 的校验值没有发生变化，那么把 page0 的 rmap_item() 添加到不稳定的红黑树中，如图（b）所示。如果此时校验值发生了变化，说明页面内容发生变化，这种页面不适合添加到不稳定的红黑树中</li><li>扫描 page1，当前稳定的红黑树中没有成员，略过稳定的红黑树的搜索。搜索不稳定的红黑树，遍历红黑树中所有成员。 page1 发现自己的内容与不稳定的红黑树中的 rmap_item() 一致，因此尝试将 page0 和 page1 合并成一个稳定的节点，合并过程就是让 WMA0 对映的虚拟地址、vaddr0 映时到 page1 上。，并且把对应的 PTE 属性修改成只读展性。另外，VMA1 映射到 page1 的 PTE 属性也设置为只读属性。新创建一个稳定的节点，这个节点包含了 page1 的页帧号等信息，把这个稳定的节点添加到稳定的红黑树中。把代表 page0 的 map _item0 和 page1 的 rmap_item1 添加到这个稳定的节点的 hlist 链表中，最后释放 page0 页面，如图（c）所示</li><li>扫描 page2。因为稳定的红黑树中有成员，因此，先和稳定的红黑树中的成员进行比较，检査是否可以合并。若发现 page2 的内容和稳定的节点内容一致，那么把 VMA2 中的 vaddr2 映射到稳定的节点对应的 page1 上，并且把 PTE 属性设置为只读属性。把代表 page2 的 rmap_item2 添加到稳定的节点的 hlist 链表中，最后释放 page2 页面，如图（d）所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm2.png"></li></ul><p>上述步骤完成之后，VMAO~VMA2 这 3 个 VMA 对应的虚拟地址（vadr）都映射到 page1 上，并且映射的 3 个 PTE 属性都是只读属性，page1 生成一个稳定的节点并被添加到了稳定的红黑树中，page0 和 page2 被释放了。</p><h1 id="新版本-ksm-的新特性">新版本 KSM 的新特性</h1><p>新版本的 KSM（如 Linux5.0 内核的 KSM）比 Linux4.0 内核的 KSM 新增了两项特性。</p><ul><li>对内容全是零的页面进行特殊处理</li><li>对稳定的节点的 hlis 链表进行改造，以防止大量的相同的页面聚集在一个稳定的节点中，导致页面迁移、内存规整等机制长时间等待这个页面</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm3.png"></p><p>新特性中，第一项实现起来比较简单，系统中己经存在了系统零页，我们可以对这个系统零页预先计算检査和。若在扫描页面时发现页面的检査和等于系统零页的检查和，那么直接修改这个页面的映射关系，让其映射到系统零页，这样可以释放这个页面。 第二项新特性实现起来就比较复杂了。主要原因是在一些大型的服务器中，会把大量的页面（如几百万个页面）合并到一个稳定的节点中。 页面迁移机制会调用 RMAP 机制来遍历这个稳定节点中所有的 rmap_item，如图所示。在 try_to_unmap_one() 函数解除页表映射关系时，需要调用 flush_tlb_page() 函数来刷新 TLB。CPU 内部发送 IPI 广播来通知其他 CPU 做了这个 TLB 刷新动作，这个页面的 PTE 已经被解除映射关系，大概需要 10pus 的时间。若需要遍历 1 万个页表项，那么将持续 100ms；若需要遍历几十万甚至几百万个页面，那么将持续更长时间。在调用 my_to_unmap() 函数之前需要申请这个页面的锁，但是其他进程有可能在等待这个页锁，那将会是一场“灾难”，足以让服务器宕机。具体流程如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grate_pages ()</span><br><span class="line">  -&gt;unmap_and_move()</span><br><span class="line">    -&gt;unmap_and_move()</span><br><span class="line">      -&gt;申请页锁</span><br><span class="line">        -&gt;try_to_unmap()</span><br><span class="line">          -&gt;rmap_walk()</span><br><span class="line">            -&gt;rmap_walk_ksm()</span><br><span class="line">            遍历稳定的节点的 hlist 链表中几百万个 rmap_items</span><br><span class="line">              -&gt;try_to_unmap_one()</span><br><span class="line">                -&gt;ptep_clear_flush()</span><br><span class="line">                  -&gt;flush_tlb_page()</span><br></pre></td></tr></tbody></table></figure><p>在 Linux4.13 内核中， Red Hat 工程师 Andrea Arcangeli 对这个问题进行了修复。新办法是限制共享页面的数量在 256 以内，这样遍历 256 个页表项的时间将会限制在毫秒不会导致系统宕机。新的解决方案扩充了稳定节点的 hlist 链表结构， rmap_items 超过 256 个之后，扩展稳定的节点为链表。每个链表的成员都是一个稳定的节点，每个稳定的节点有一个链表，这个 hlist 链表中可以添加新的 rmap_items。另外，还需要把稳定的节点和链表的头在红黑树中做一个交换。 新版本的稳定的节点包含两个形态，而且它们同时存放在稳定的红黑树中，如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm4.png"></p><ul><li>传统的稳定的节点：兼容旧版本的稳定的节点格式。</li><li>链式稳定的节点：新版本的链式节点格式。</li></ul><p>下面以 test.c 程序为例，假设现在系统产生了 1000 个页面，并且这 1000 个页面的内容都是相同的，每个页面对应不同的 VMA，这些 VMA 的大小正好是一个页面大小。接下来观察新版本的 KSM 如何处理这些页面，如何创建新版本的链式稳定的节点。</p><p>第 1 次扫描这 1000 个页面。第 1 次扫描页面时会计算每个页面的检验和。部分代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">statc <span class="type">void</span> <span class="title function_">cmp_and_merge_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> rmap_item *rmap_item)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    checksum =calc_checksum(page);</span><br><span class="line">    <span class="keyword">if</span>(rmap_item-&gt;oldchecksum != checksum) {</span><br><span class="line">        rmap_item-&gt;oldchecksum = checksum;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 2 次扫描中，先看第一个页面（编号为 page0，以此类推）的情况，它首先进入 cmp_and_merge_page() 函数。具体过程如下：</p><ul><li>cmp_and_merge_page() 函数会遍历稳定的红黑树中每个稳定的节点，并和 page0 进行比较，判断内容是否一致。若内容一致，则将页面合并到稳定的节点中。因为这时 stable 红黑树还是空的，所以跳过 stable_tree_searche() 函数</li><li>如果页面校验值不变，则遍历 unstable 红黑树中的每一个 rmap_item 节点。这时，不稳定的红黑树也还是空的，因此直接把 rmap_item0 添加到不稳定的红黑树中，扫描第 i 个页面，如图所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm5.png"></li></ul><p>部分代码如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rmap_item * <span class="title function_">unstable_tree_search_insert</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    rmap_item-&gt;address |= UNSTABLE_FLAGA;</span><br><span class="line">    rmap_item-&gt;address |= (ksm_scan.seqnr &amp; SEONR_MASKD);</span><br><span class="line">    DO_NUMA(rmap_item-&gt;nid = nid);</span><br><span class="line">    rb_link_node(&amp;rmap_item-&gt;node, parent, new);</span><br><span class="line">    rb_insert_color(&amp;rmap_item-&gt;node, root);</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>接下来，扫描第 2 个页面（pge）。具体过程如下</p><ul><li>略过稳定的红黑树</li><li>遍历不稳定的红黑树，现在不稳定的红黑树中有个成员 rmap_item0, unstable_tree_search_insert() 函数取出 rmap_item0，然后和 page1 进行内容比较。 try_to_merge_two_page() 函数会比较 rmap_item0 对应的 page0 和 page1，若发现内容一致，则将其合并成一个页面。过程就是让 VMA0 对应的虚拟地址 vaddr0 映射到 page1 上，并且把对应的 PTE 属性修改成只读属性。另外，WMA1 映射到 page1 的 PTE 属性也设置为只读属性</li><li>在 stable_tree_inserter() 函数中，因为 stable 红黑树为空，所以会新建一个稳定的节点 (stable node 数据结构），我们称它为 stable_node_dup0 或者 node_dup0</li><li>page1 的页帧号也会记录在 stable_node_dup0-&gt;kpfn 中，并且 rmap_list_len 值为 0. 调用 set_page_stable_node() 数把 page1 设置成 KSM 页面，详见 mm/ksm.c 文件中的代码</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/ksm.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">set_page_stable_node</span><span class="params">(<span class="keyword">struct</span> page page, <span class="keyword">struct</span> stable_node *stable_node)</span></span><br><span class="line">{</span><br><span class="line">    page-&gt;mapping =(<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)stable_node | PAGE_MAPPING_KSM);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>由于这时不需要为稳定的节点建立链表，因此第 1884 行代码的 need_chain 为 ifalse 最后直接把 stable_node_dup0 添加到稳定的红黑树中</li><li>调用 stable_tree_append()，分别把 page0 对应的 rmap_item0 和 page1 对应的 rmap_item1 添加到 stable_node_dup0-&gt;hlist 链表中。增加 ksm_pages_ shared 和 ksm_pages_sharing 计数，这时 ksm_pages_sharing 为 1， ksm_pages_shared 为 1， stable_node_dup0-&gt;rmap_hlist_len 为 2</li><li>释放 page0。</li></ul><p>合并过程如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm6.png"></p><p>接下来，扫描第 3 个页面（page2）。具体过程如下。</p><ul><li>遍历 stable 红黑树，见 stable_tree_search() 函数。通过 rb_entry() 取出稳定的红黑树节点这时，稳定的红黑树只有一个节点，那就是 stable_node_dup()</li><li>调用 chain_prune() 函数。在内部调用__stable_node_chain() 函数时会对稳定的点行判断</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;chain_prune()-&gt;__stable_node_chain()&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * __<span class="title">stable_node_chain</span>()</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">stable_node</span> =</span>*_stable_node;</span><br><span class="line">    <span class="keyword">if</span> (!is_stable_node_chain(stable_node)) {</span><br><span class="line">        <span class="keyword">if</span> (is_page_sharing_candidate(stable_node)) {</span><br><span class="line">            *stable_node_dup = stable_node;</span><br><span class="line">            <span class="keyword">return</span> get_ksm_page(stable_node, <span class="literal">false</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><ul><li>is_stable_node_chain 判断这个稳定的节点是否为链式稳定的节点。判断依据是 rmap_hlist_len 是否为 STABLE_NODE_CHAIN。链式稳定的节点所在的 hlist 链表是不存放 rmap_item 的，并且它的 rmap_hlist_len 会初始化为一个固定值， STABLE_NODE_CHAIN（默认初始值为-1024），我们由此来判断该节点是否为链式稳定的节点</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define STABLE_NODE_CHAIN <span class="number">-1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">is_stable_node_chain</span><span class="params">(<span class="keyword">struct</span> stable node *chain)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> chain-&gt;rmap_hlist_len == STABLE_NODE_CHATNI;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>stable_node_dup0 显然不是链式的稳定的节点，它是传统的稳定的节点。 is_page_sharing_candidate() 判断这个节点中是否还能存放 rmap_item。默认情况下，我们规定每个节点的 hlist 链表最多只能存放 256 个成员</li><li>调用 get_ksm_page() 函数返回 stable_node_dup0 节点对应的 page 数据结构</li><li>比较 stable_node_dup0 对应的页面（即 tree_page）和 page2 的页面内容是否一样，若一样， stable_tree_searche() 函数会返回 tree_page</li><li>调用 ty_to_merge_with_ksm_page() 函数尝试合并 tree_page 和 pge2。若能合并，那么调用 stable_tree_append() 函数把 page2 对应的 rmap_item2 添加到 stable_node_dup0-&gt;hlist 链表中。增加 ksm_pages_sharing 的值，此时 ksm_pages_sharing 的值为 2。这时， stable_node_dup0-&gt;hlist_len 为 3</li><li>释放 page2</li></ul><p>上述过程如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm7.png"></p><p>接下来，扫描第 4 个页面，一直到第 256 个页面。和扫描第 3 个页面一样，这些页面都会合并到 stable_node_dup0 对应的 tree_page 中，其对应的 rmap_item 都会被添加到 stable_node_dup0-&gt;hlist 链表中，这时 stable_node_dupO-&gt;rmap_hlist_len 的值为 256， ksm_pages_sharing 的值为 255.</p><p>接下来，扫描第 257 个页面（p2ge256）。具体过程如下：</p><ul><li>遍历稳定的红黑树，见 stable_tree_search() 函数</li><li>如果在 chain_prune-&gt;__stable_node_chain()-&gt;is_page_sharing_candidate() 函数中发现 hlist 链表的成员个数已经到达最大值（ ksm_max_page_ sharing），那么会返回 NULL，并且 stable_node_dup 参数也返回 NULL</li><li>stable_tree_search() 函数调用 stable_node_dup_any() 来获取稳定的节点，get_ksm_page() 获取这个稳定的节点对应的 tree_page。比较 tree_page 和 page256 的内容时发现二者是一致的，但是因为 stable_node_dup 参数为 NULL，所以在第 1653~1666 行里会返回 NULL。这里在注释里对代码做了解释，当我们发现被扫描页面的内容和稳定的节点的页面内容一致时，但是因为这时稳定的节点的 hlist 链表已经满了，所以我们必须从不稳定的红黑树中找到另外一个页面、进行合并，创建一个新的 KSM 共享页面</li><li>因为 stable_tree_search() 函数返回 NULL，所以直接遍历不稳定的红黑树。此时，不稳定的红黑树没有成员，因此可以直接把 page256 对应的 map_item 添加到不稳定的红黑树中</li></ul><p>接下来，扫描第 258 个页面（page257）。具体过程如下。</p><ul><li>遍历稳定的红黑树，见 stable_tree_search() 函数。和步骤（6）一样，因为 stable_node_dup0-&gt;hlist 链表满了，所以直接返回 NULL</li><li>调用 unstable_tree_search_insert() 函数。若发现 page257 和不稳定红黑树的成员内容一致，返回 tree_rmap_item</li><li>调用 tyy_merge_two_pages() 函数尝试合并 pge257 和 tree_page。假如它们符合合并条件，那么尝试将其合并成一个页面</li><li>调用 stable_tree 把这个合并后的页面添加到稳定的红黑树中。在 stable_tree_insert() 函数中，遍历稳定的红黑树中的所有成员，当发现稳定的节点的页面内容和当前页面内容一致时，设置 need_chain 为 true 并退出遍历，说明找到一个内容相同的“小伙伴”了（见 1870 行代码）</li><li>在第 1875 行中，新健一个稳定的节点，称为 stable_node_dup1 或者 node_dup1。设置新合并页面的页帧号到 stable_node_dup1-&gt;kpfn 中。 set_page_stable_node() 函数把这个新合并面设置为 KSM 页面。这时 stable_node_dup1-&gt;rmap_hlist_len 的值为 0</li><li>在第 188 行中，稳定的红黑树的节点为 stable_node_dup0，它是传统的稳定的节点在第 1891 行中，调用 alloc_stable_node_chain() 函数重新创建一个链式稳定的节点。 chain-&gt;rmap_hlist_len 的值初始化为 STABLE_NODE_CHAN，表明该节点是链式稳定的节点。増加 ksm_stable_node_chains 计数</li><li>把链式稳定的节点替換到稳定的红黑树上的 stable_node_dup0 节点，并且把 stable_node_dup0 节点添加到链式稳定的节点所在的 hlist 链表中，这样一个新的链式稳定的节点就创建成功了</li><li>在第 1897 行中，把刚才新创建的 stable_node_dup1 节点也添加到链式稳定的节点的 hlist 链表中。此时，链式稳定的节点的 hlist 链表中有两个成员，一个是 stable_node_dup0 节点，另一个是 stable_node_dup1 节点。此时， ksm_stable_node_chain 为 1 ksm_stable_node_dups 为 2</li><li>在第 2145~2147 行中，分别调用 stable_tree_append() 函数，把 rmap_item257 和 tree_rmap_item 添加到 table_node_dup1-&gt;hlist 链表中。此时， stable_nodde_dup1-&gt;rmap_hist_len 的值为 2， ksm_pages_shared 为 2， ksm_pages_sharing 为 256 整个过程如图所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm8.png"></li></ul><p>接下来，扫描第 259 个页面（page258）。具休过程如下。</p><ul><li>遍历 stable 红黑树，见 stable_tree_searen() 函数。</li><li>调用 chain_prune()-&gt;__stable_node_chain() 函数，由于当前的节点是链式稳定的节点，因此直接调用 stabie_node_dup() 函数，详见 stable_node_dup() 函数</li><li>在 stabie_node_dup() 函数中遍历稳定的节点所在的 hlist 链表中所有的 rmap_item，查找一个 hlist 链表中还有空间的 rmap_item。然后返回这个 rmap_item 对应的页面，另外 stabie_node_dup 指向 rmap_item. 此时，链式稳定的节点有两个 stable_nale_dup() 分别是 stabie_node_dup0 和 stabie_node_dup1，只有 stable_node_dup1 还有空间容纳 rmap_item, 因此返回 stabie_node_dup1 对应的页面。</li><li>在 stable_tree_search() 函数中，发现第 259 个页面和 stabie_node_dup1 对应的页面内容相同，因此返回 stabie_node_dup1 对应的页面，它称为 tree_page</li><li>调用 try_to_merge_with_ksm_page() 尝试合并 page258 到 tree_page 中。调用 stable_tree_append() 函数把 rmap_item258 添加到 stable_node_dup1 的 hlist 链表中， rmap_hlist_len 的值变成了 3，ksages_sharing 变成了 257 整个过程如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ksm9.png"></li></ul><p>接下来，扫描其他页面。具体过程如下。</p><p>（1）继续扫描其他页面，直到 stable_node_dup1-&gt;hlist 链表满员为止。 （2）重复扫描第 257 个和第 258 个页面，新创建一个 node_dup2 节点，添加到链式稳定的节点的 hlist 链表中，新的 rmap_item 就可以继续添加到 node_dup2-&gt;hlist 链表中了。 综上所述，我们们发现新版本的 KSM 机制有：</p><ul><li>上述 1000 个相同页面会生成多个 KSM 页面，上图 9 所示的 page1 是第一个 KSM 页面，page257 是第二个 KSM 页面，以此类推。而在旧版本的 KSM 机制中，1000 个页面会生成一个 KSM 页面，另外的 999 个页面都会合并到这个 KSM 页面中。</li><li>每个 KSM 页面最多把 256 个页面合并在一起，其中还包括 KSM 页面自己，即最多有 255 个其他的页面被合并。</li></ul><p>当 RMAP 机制需要遍历 KSM 页面时，它只需要遍历 256 个 rmap_items 即可。如当需要迁移 page1 时，可以通过 page1 找到 stable_node_dup0 节点，因此只需要遍历和处理 node_dup0-&gt;hlist 链表中的第 256 个 rmap_items 就可以迁移 page1.</p><blockquote><p>malloc 函数分配的内存是不能被 KSM 扫描的，malloc() 函数分配的虚拟内存没办法保证一定是按照页面对齐的，但在 madvise 系统调用中，要求起始地址是按照页面对齐的。</p></blockquote><h1 id="小结">小结</h1><p>KSM 的核心设计思想基于写时复制机制，也就是内容相同的页面可以合并成一个只读页面，从而释放空闲页面。 KSM 最早是为了 KVM 虚拟机而设计的，KVM 虚拟机在宿主机上使用的页面大部分是匿名页面，并且它们在宿主机中存在大量的冗余内存。对于典型的应用程序，KSM 只考虑进程分配使用的匿名页面，暂时不考虑页面高速缓存的情况。一个典型的应用程序可以由以下 5 个内存部分组成</p><ul><li>可执行文件的内存映射（页面高速缓存）</li><li>程序打开使用的匿名页面</li><li>进程打开的文件映射（包括常用的或者不常用的，甚至只用一次的页面高速缓存）</li><li>进程访问文件系统时产生的内容缓存</li><li>进程访问内核产生时的内核缓冲器（如 slab）等</li></ul><p>设计的关键是如何寻找和比较两个相同的页面，如何让这个过程变得高效而且占用的系统资源最少，这就是一个好的设计人员应该思考的问题。首先不能用哈希算法来比较两个页面的专利问题。KSM 虽然使用了 memcmp 来比较，最糟糕的情况是两个页面最后的 4 字节不一样但是 KSM 使用红黑树来设计了两棵树，分别是稳定的红黑树和不稳定的红黑树，可以有效地避免最糟糕的情况。另外，KSM 也巧妙地利用页面的校验和来比较不稳定的红黑树的页面最近是否被修改过，从而避开了该专利的缺陷。 页面分为物理页面和虚拟页面，多个虚拟页面可以同时映射到一个物理页面，因此需要把映射到该页面的所有 PTE 都解除后，才是算真正释放（这里说的 PTE 是指用户进程地止空间的虚拟地址映射的该页面的 PTE，简称用户 PTE，因此 page-&gt;__mapcount 成员里描述的 PTE 数量不包含内核线性映射的 PTE）。目前有两种做法，一种做法是扫描每个进程中用户地址进程空间，由用户地址进程空间的虚拟地址查询 MMU 页表，找到对应的 page 数据结构，这样就找到了用户 PTE。然后对比 KSM 中的稳定树和不稳定树，如果找到页面内容相同的，就把该 PTE 设置成写时复制，映射到 KSM 页面中，从而释放出一个 PTE。注意，这里是释放出一个用户 PTE，而不是一个物理页面（如果该物理页面只有一个 PTE 映射，那就是释放该页）。另外一种做法是直接扫描系统中的物理页面，然后通过 RMAP 来解除该页面所有的用户 PTE，从而一次性地释放出物理页面。显然，目前内核的 KSM 是基于第一种做法。 KSM 的作者在他的论文中有实测数据，但作者依然覚得有一些情况下会比较糟糕。如在一个很大内存的服务器上，很多的匿名页面都同时映射了多个虚拟页面。假设每个匿名页面都映射了 1000 个虚拟页面，这些虚拟页面又同时分布在不同的子进程中，那么要释放一个物理页面，需要扫描完 1000 个虚拟页面所在的用户地址进程空间，每次都要利用 follow_page()&nbsp;查询页表，然后査询稳定树，还需要多次执行 memcmp 比较，合并 10000 次 PTE 也就意味着 memcmp 要执行 10000 次，这个过程会很漫长，在实际项目中，有很多人抱怨 KSM 的效率低，在很多项目是关闭该特性的。也有很多人在思考如何提高 KSM 的效率，包括利用新的软件算法或者利用硬件机制。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（九）页面迁移和内存规整</title>
      <link href="/next/2021/LinuxKernel/LinuxMemorymigrate/"/>
      <url>/next/2021/LinuxKernel/LinuxMemorymigrate/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Memorymigrate.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM4NjE3MTYzNzY4OTA3MTA1ZTU2Mzk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><blockquote><p>声明本文转载自知乎 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzAzNjY4Mjc=">Linux 内存管理：页面迁移<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL1pPSlByUWdvZHYv">Linux 内存管理 (16) 内存规整<i class="fa fa-external-link-alt"></i></span> 内存相关文章</p></blockquote><h1 id="页面迁移">页面迁移</h1><h2 id="概述">概述</h2><p>页面迁移 (migrate) 是内存管理中很多功能实现的基础，比方说内存规整、NUMA balance、内存热插拔、CMA、HugeTLB、内存气球等等，本文主要讲一下页面迁移的主要流程和应用。</p><h2 id="页面迁移的-api">页面迁移的 API</h2><p>migrate_pages( ) 这是页面迁移在内核态的主要接口，内核中涉及到页面迁移的功能大都会调到它。当然，在用户空间也存在着内存迁移相关的系统调用，最终也会调到它。这里我们通过 migrate_pages( ) 的几个形参展开全文。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * migrate_pages - migrate the pages specified in a list, to the free pages</span></span><br><span class="line"><span class="comment"> *                 supplied as the target for the page migration</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @from:               The list of pages to be migrated.</span></span><br><span class="line"><span class="comment"> * @get_new_page:       The function used to allocate free pages to be used</span></span><br><span class="line"><span class="comment"> *                      as the target of the page migration.</span></span><br><span class="line"><span class="comment"> * @put_new_page:       The function used to free target pages if migration</span></span><br><span class="line"><span class="comment"> *                      fails, or NULL if no special handling is necessary.</span></span><br><span class="line"><span class="comment"> * @private:            Private data to be passed on to get_new_page()</span></span><br><span class="line"><span class="comment"> * @mode:               The migration mode that specifies the constraints for</span></span><br><span class="line"><span class="comment"> *                      page migration, if any.</span></span><br><span class="line"><span class="comment"> * @reason:             The reason for page migration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">migrate_pages</span><span class="params">(<span class="keyword">struct</span> list_head *from, <span class="type">new_page_t</span> get_new_page,</span></span><br><span class="line"><span class="params">                <span class="type">free_page_t</span> put_new_page, <span class="type">unsigned</span> <span class="type">long</span> private,</span></span><br><span class="line"><span class="params">                <span class="keyword">enum</span> migrate_mode mode, <span class="type">int</span> reason)</span></span><br></pre></td></tr></tbody></table></figure><p>形参含义根据上面的注释很好理解，我们单独说下 mode 和 reason，他们分别表示迁移模式和迁移原因。</p><h2 id="迁移模式">迁移模式</h2><p>迁移模式主要会影响迁移过程中对一些行为的过滤：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE_ASYNC        <span class="comment">//异步迁移，过程中不会发生阻塞</span></span><br><span class="line">MIGRATE_SYNC_LIGHT   <span class="comment">//轻度同步迁移，允许大部分的阻塞操作，唯独不允许脏页的回写操作</span></span><br><span class="line">MIGRATE_SYNC         <span class="comment">//同步迁移，迁移过程会发生阻塞，若需要迁移的某个 page 正在 writeback 或被 locked 会等待它完成</span></span><br><span class="line">MIGRATE_SYNC_NO_COPY <span class="comment">//同步迁移，但不等待页面的拷贝过程。页面的拷贝通过回调 migratepage()，过程可能会涉及 DMA</span></span><br></pre></td></tr></tbody></table></figure><p>举例：内存规整 (compact) 中会调用 migrate_pages()，同时也会设置迁移模式（位于 compact_control-&gt;mode)。若是 sysfs 主动触发的内存规整会用 MIGRATE_SYNC 模式；若是 kcompactd 触发的规整会用 MIGRATE_SYNC_LIGHT 模式；若是内存分配 slowpath 中触发的会根据 compact prior 去设置用 MIGRATE_ASYNC 或 MIGRATE_SYNC_LIGHT 模式。</p><h2 id="迁移原因">迁移原因</h2><p>迁移原因主要使用来记录是什么功能触发了迁移的行为，毕竟页面迁移对系统本身是个不小的 overhead，所以知道迁移的原因很有必。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MR_COMPACTION      <span class="comment">//内存规整导致的迁移</span></span><br><span class="line">MR_MEMORY_FAILURE  <span class="comment">//当内存出现硬件问题 (ECC 校验失败等）时触发的页面迁移。 参考 memory-failure.c</span></span><br><span class="line">MR_MEMORY_HOTPLUG  <span class="comment">//内存热插拔导致的迁移</span></span><br><span class="line">MR_SYSCALL         <span class="comment">//应用层主动调用 migrate_pages() 或 move_pages() 触发的迁移</span></span><br><span class="line">MR_MEMPOLICY_MBIND <span class="comment">//调用 mbind 系统调用设置 memory policy 时触发的迁移</span></span><br><span class="line">MR_NUMA_MISPLACED  <span class="comment">//numa balance 触发的页面迁移 (node 之间）</span></span><br><span class="line">MR_CONTIG_RANGE    <span class="comment">//调用 alloc_contig_range() 为 CMA 或 HugeTLB 分配连续内存时触发的迁移（和 compact 相关）</span></span><br></pre></td></tr></tbody></table></figure><p>延伸：对上面 MR_SYSCALL 迁移原因中提到的两个 API（位于 libnuma 库）的简单介绍。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 含义：把某 pid 进程的所有页面从源 numa node 迁移到目标 numa nodes 组中，对应系统调用 sys_migrate_pages()</span></span><br><span class="line">migrate_pages()  <span class="comment">//和 kernel 中接口同名，别搞混了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 含义：把进程到部分页面迁移目标 numa node 中，对应系统调用 sys_move_pages()</span></span><br><span class="line">move_pages()</span><br></pre></td></tr></tbody></table></figure><h2 id="migrate_pages-介绍">migrate_pages() 介绍</h2><p>通过上面对迁移原因的介绍，我们知道了页面迁移的原因各种各样，这里我们通过内存规整 (memory compact) 这样一个实际的例子展开介绍，下图主要体现了内存规整和页面迁移的关系： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/migrate1.jpg"></p><p>通过上图，我们看出页面迁移在内存规整中举足轻重的地位。下面则是内存规整调用 migrate_pages() 的函数关系：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compact_zone           <span class="comment">//内存规整</span></span><br><span class="line">  -&gt;migrate_pages      <span class="comment">//页面迁移的入口函数</span></span><br><span class="line">    -&gt;unmap_and_move   <span class="comment">//页面迁移的核心实现</span></span><br></pre></td></tr></tbody></table></figure><p>现在切入重点，页面迁移 (migrate) 过程做了那些事情：</p><h2 id="迁移前的准备">迁移前的准备</h2><ul><li>获取 old page 的页面锁 PG_locked （异步模式拿不到锁就直接跳过此页面）</li><li>若是正在 writeback 的页面，则根据迁移模式判断是否等待页面 wirteback（MIGRATE_SYNC_LIGHT 和 MIGRATE_ASYNC 不等待）</li><li>获取 new page 的页面锁 PG_locked (new page 正常情况下不会获取失败）</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/migrate2.jpg"></p><h2 id="解除-old-page-的页表映射">解除 old page 的页表映射</h2><p>调用 try_to_unmap()，通过反向映射机制解除 old page 所有相关的 PTEs <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/migrate3.jpg"></p><h2 id="设置-new-page-的页面内容元数据及映射关系">设置 new page 的页面内容、元数据及映射关系</h2><p>调用 move_to_new_page 拷贝 old page 的内容和 struct page 元数据到 new page，并通过反向映射机制建立 new page 的映射关系。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/migrate4.jpg"></p><h2 id="页面迁移的收尾工作">页面迁移的收尾工作</h2><ul><li>迁移完成释放新旧页面的 PG_locked</li><li>设置迁移原因</li><li>调用 put_page 释放 old page 引用计数 (_refcount 减 1)</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/migrate5.jpg"></p><p>补充：什么样的页面才支持迁移呢？</p><ul><li>lru 上的 page，因为上面挂的是 user spcace 用的 pages，都是从 buddy 分配器 migrate type 为 movable 或 reclaim 的 pageblock 上分来的</li><li>no-lru 但是 movable 的页面。no-lru 的页面通常是为 kernel space 分配的 page，这种页面通常是 unmovable 的，但是下面这个 commit 使得驱动中用到的页面也可以支持迁移。但是在驱动实现的过程中需要置位 page-&gt;mapping 中的 second bit，并且实现 page-&gt;mapping-&gt;a_ops 中的相关方法</li></ul><h1 id="内存规整">内存规整</h1><p>内存碎片的产生：伙伴系统以页为单位进行管理，经过大量申请释放，造成大量离散且不连续的页面。这时就产生了很多碎片。 n 内存规整也即内存碎片整理，内存碎片也是以页面为单位的。实现基础是内存页面按照可移动性进行分组。内存规整的实现基础是页面迁移。 Linux 内核以 pageblock 为单位来管理页的迁移属性。</p><h2 id="内存规整的触发">内存规整的触发</h2><p>下面是内存页面分配，以及分配失败之后采取的措施，以便促成分配成功。 可以看出采取的措施，越来越重。首先采用 kswapd 来进行页面回收，然后尝试页面规整、直接页面回收，最后是 OOM 杀死进程来获取更多内存空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alloc_pages-------------------------------------页面分配的入口</span><br><span class="line">  -&gt;__alloc_pages_nodemask</span><br><span class="line">    -&gt;get_page_from_freelist--------------------直接从 zonelist 的空闲列表中分配页面</span><br><span class="line">    -&gt;__alloc_pages_slowpath--------------------在初次尝试分配失败后，进入 slowpath 路径分配页面</span><br><span class="line">      -&gt;wake_all_kswapds------------------------唤醒 kswapd 内核线程进行页面回收</span><br><span class="line">      -&gt;get_page_from_freelist------------------kswapd 页面回收后再次进行页面分配</span><br><span class="line">      -&gt;__alloc_pages_direct_compact------------进行页面规整，然后进行页面分配</span><br><span class="line">      -&gt;__alloc_pages_direct_reclaim------------直接页面回收，然后进行页面分配</span><br><span class="line">      -&gt;__alloc_pages_may_oom-------------------尝试触发 OOM</span><br></pre></td></tr></tbody></table></figure><p>另一条路径是在 kswapd 的 balance_pgdat 中会判断是否需要进行内存规整。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kswapd</span><br><span class="line">  -&gt;balance_pgdat-------------------------------遍历内存节点的 zone，判断是否处于平衡状态即 WMARK_HIGH。</span><br><span class="line">    -&gt;compact_pgdat-----------------------------针对整个内存节点进行内存规整</span><br></pre></td></tr></tbody></table></figure><p>其中 compact_pddat-&gt;__compact_pgdat-&gt;compact_zone，最终的实现和__alloc_pages_direct_compact 调用 compact_zone 一样。</p><h2 id="内存规整相关节点">内存规整相关节点</h2><p>内存规整相关有两个节点，compact_memory 用于触发内存规整；extfrag_threshold 影响内核决策是采用内存规整还是直接回收来满足大内存分配。</p><p>节点入口代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">vm_table</span>[] =</span> {</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    {</span><br><span class="line">        .procname    = <span class="string">"compact_memory"</span>,</span><br><span class="line">        .data        = &amp;sysctl_compact_memory,</span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode        = ,</span><br><span class="line">        .proc_handler    = sysctl_compaction_handler,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        .procname    = <span class="string">"extfrag_threshold"</span>,</span><br><span class="line">        .data        = &amp;sysctl_extfrag_threshold,</span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode        = ,</span><br><span class="line">        .proc_handler    = sysctl_extfrag_handler,</span><br><span class="line">        .extra1        = &amp;min_extfrag_threshold,</span><br><span class="line">        .extra2        = &amp;max_extfrag_threshold,</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_COMPACTION */</span></span></span><br><span class="line">...</span><br><span class="line">    { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>/proc/sys/vm/compact_memory： 打开 compaction Tracepoint：echo 1 &gt; /sys/kernel/debug/tracing/events/compaction/enable<br>触发内存规整：sysctl -w vm.compact_memory=1<br>查看 Tracepoint：cat /sys/kernel/debug/tracing/trace</p></li><li><p>/proc/sys/vm/extfrag_threshold： 在 compact_zone 中调用函数 compaction_suitable-&gt;__compaction_suitable 进行判断是否进行内存规整<br>和 extfrag_threshold 相关部分如下，如果当前 fragindex 不超过 sysctl_extfrag_threshold，则不会继续进行内存规整<br>所以这个参数越小越倾向于进行内存规整，越大越不容易进行内存规整</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __compaction_suitable(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order,</span><br><span class="line">                    <span class="type">int</span> alloc_flags, <span class="type">int</span> classzone_idx)</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">    fragindex = fragmentation_index(zone, order);</span><br><span class="line">    <span class="keyword">if</span> (fragindex &gt;= <span class="number">0</span> &amp;&amp; fragindex &lt;= sysctl_extfrag_threshold)</span><br><span class="line">        <span class="keyword">return</span> COMPACT_NOT_SUITABLE_ZONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> COMPACT_CONTINUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置 extfrag_threshold：sysctl -w vm.extfrag_threshold=500</p></li><li><p>其它 Debug 信息： /sys/kernel/debug/extfrag/extfrag_index /sys/kernel/debug/extfrag/unusable_index</p></li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzAzNjY4Mjc=">https://zhuanlan.zhihu.com/p/270366827<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL1pPSlByUWdvZHYv">https://www.bbsmax.com/A/ZOJPrQgodv/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（八）页面回收</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryPageRecycle/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryPageRecycle/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryRecycle.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM4NTkyMDFlMDg1MzA2ZjhjODBhY2Q=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>Linux 操作系统会使用存储设备作为交换分区，内核将很少使用的内存换出到交换分区，以便释放出物理内存，这个机制称为页交换（swapping），这些处理机制统称为页面回收 (pagereclaim)。</p><h1 id="lru-链表">LRU 链表</h1><p>Linux 内核中采用的页交换算法主要是经典 LRU 链表算法和第二次机会（secondchance）法。 LRU 是 Least Recently Used 的缩写，意为最近最少使用。根据局部性原理，LRU 假定最近不使用的页面在较短的时间内也不会频繁使用，在内存不足时，这些页面将成为被换出的候选者。内核使用双向链表来定义 LRU 链表，并且根据页面的类型将 LRU 链表分为 LRU_ANON 和 LRU_FILE。每种类型根据页面的活跃性分为活跃 LRU 链表和不活跃 LRU 链表，所以内核中一共有如下 5 个 LRU 链表。</p><ul><li>不活跃匿名页面链表 LRU_INACTIVE_ANON</li><li>活跃匿名页面链表 LRU_ACTIVE_ANON</li><li>不活跃文件映射页面链表 LRU_INACTIVE_FILE</li><li>活跃文件映射页面链表 LRU_ACTIVE_FILE</li><li>不可回收页面链表 LRU_UNEVICTABLE</li></ul><p>LRU 链表之所以要分成这样，是因为当内存紧缺时总是优先换出文件映射的文件缓存页面（LRU FILE 链表中的页面）而匿名页面总是要在写入交换分区之后，才能被换出。</p><p>LRU 链表按照内存节点（之前版本是 zpone）配置，也就是说，每个内存节点中都有一整套 LRU 链表，因此内存节点的描述符数据结构（pglist_data）中有一个成员 lruvec 指向这些链表。枚举类型变量 lru_list 列举出上述各种 LRU 链表的类型，lruvec 数据结构中定义了上述各种 LRU 类型的链表。</p><h1 id="第二次机会法">第二次机会法</h1><p>第二次机会法的改进是为了避免把经常使用的页面置换出去。当选择置换页面时，依然和经典 LRU 链表算法一样，选择最早置入链表的页面，第二次机会法设置了一个访问状态位（硬件控制的位），所以要检查页面的访问位。如果访问位是 0，就淘汰这个页面；如果访问位是 1，就给它第二次机会，并选择下一个页面来换出。当该页面得到第二次机会时，它的访问位被清零，如果该页面在此期间再次被访问过，则访问位设置为 1。于是，给了第二次机会的页面将不会被淘汰，直至其他页面被淘汰（或者也给了第二次机会）。因此，如果一个页面经常被使用，其访问位总保持为 1，它一直不会被淘汰。</p><p>Linux 内核使用 PG_active 和 PG_referenced 这两个标志位来实现第二次机会法。PG_active 表示该页面是否活跃，PG_referenced 表示该页面是否被引用过。</p><h1 id="实现">实现</h1><h2 id="lru-链表维护">LRU 链表维护</h2><p>我们需要有 timestamp 来标识一个 page 最近被访问的时间，然而像 x86 这样的架构并没有从硬件上提供这种机制。</p><p>Linux 采用的方法是维护 2 个双向链表，一个是包含了最近使用页面的 active list，另一个是包含了最近不使用页面的 inactive list，并且在 struct page 的 page flags 中使用了 PG_referenced 和 PG_active 两个标志位来标识页面的活跃程度。</p><ul><li>PG_active 标志位决定 page 在哪个链表，也就是说 active list 中的 pages 的 PG_active 都为 1，而 inactive list 中的 pages 的 PG_active 都为 0。</li><li>PG_referenced 标志位则是表明 page 最近是否被使用过。当一个 page 被访问，mark_page_accessed() 会检测该 page 的 PG_referenced 位，如果 PG_referenced 为 0，则将其置为 1。</li></ul><p>如果 inactive list 上 PG_referenced 为 1 的 page 在回收之前被再次访问到，也就是说它在 inactive list 中时被访问了 2 次，mark_page_accessed() 就会调用 activate_page() 将其置换到 active list 的头部，同时将其 PG_active 位置 1，PG_referenced 位清 0（可以理解为两个 PG_referenced 才换来一个 PG_active），这个过程叫做 promotion（逆袭）。</p><p>这 3 种情景的代码实现是这样的（为了演示需要在源代码的基础上做了简化和修改）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mark_page_accessed</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!PageActive(page) &amp;&amp; PageReferenced(page)) {</span><br><span class="line">    activate_page(page);</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!PageReferenced(page)) {</span><br><span class="line">    SetPageReferenced(page);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 active list 中的一个 page 在到达链表尾端时，如果其 PG_referenced 位为 1，则被放回链表头部，但同时其 PG_referenced 会被清 0。如果其 PG_referenced 位为 0，那么就会被放入 inactive list 的头部，这个过程叫做 demotion。可见，Linux 采用的这种 active list 和 inactive list 并不是严格按照时间顺序来置换 page 的，所以是一种伪 LRU 算法。</p><p>Inactive list 中尾端的页面不断被释放，相当于一个消费者，active list 则不断地将尾端 PG_referenced 为 0 的页面放入 inactive list，相当于一个生产者。不难想象，这 2 个链表的锁（lru_lock）应该是高度竞争的，如果从 active list 向 inactive list 的页面转移是一个一个进行的，那对锁的争抢将会十分严重。</p><p>为了解决这个问题，内核加入了一个 per-CPU 的 lru cache（用 struct pagevec 表示），从 active list 换出的页面先放入当前 CPU 的 lru cache 中，直到 lru cache 中已经积累了 PAGEVEC_SIZE（15）个页面，再获取 lru_lock，将这些页面批量放入 inactive list 中。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru1.jpg"></p><p>如果 inactive list 比较长，那么每个页面在被回收之前有充分的时间被再次访问，从而被 promote 到 active list，这样可以减少刚刚被回收又发生 refault 的页面数量（page thrashing）。但是由于内存总量有限，inactive list 较长就意味着 active list 相对较短，那这 2 个链表应该分别多长比较合适呢？</p><p>我们可以在一个页面被回收时记录一个 timestamp，当这个页面 refault 被换入时再记录一个 timestamp，如果将 inactive list 的长度增加，使得页面回收增长的时间超过这 2 个 timestamp 的差值时，那么这个页面就可以因为在 inactive list 中被再次访问，避免了被回收的命运，也减小了 refault 造成的开销。</p><p>可是前面也提到过，由于硬件的限制，给每个 page 维护一个 timestamp 是不现实的。还是类似的解决办法，用 inactive 中回收页面的个数来替代 timestamp，每回收一个页面，计数器加 1（相当于用 counter 替代了 timer）。那这个 counter 的值保存在哪里呢？</p><p>对于属于 page cache 的页面，由于其被换出之前是放在 radix tree/xarray 中的，当页面被回收时，我们可以把它曾经所在的 entry 利用起来，记录一下当前的 counter 值，页面被换入的时候再比较一下 entry 中的 counter 值，这种 entry 被称为 shadow entry。</p><p>对于一个基于文件的 page frame，好像它既在 page cache 结构中，又在 active/inactive list 结构中？没错，放在 page cache 中以 radix tree/xarray 的方式组织，是为了方便快速查找和读写它的内容，放在 active/inactive list 中则是为了方便内存回收。当一个基于文件的 page frame 被创建时，它就已经被加入到这 2 个结构中了：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_to_page_cache_lru</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">  <span class="type">pgoff_t</span> offset, <span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">{</span><br><span class="line">    __add_to_page_cache_locked(page, mapping, offset,  gfp_mask, &amp;shadow);</span><br><span class="line">    lru_cache_add(page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里同样是先放入 lru cache，而不是直接放进 active/inactive list 中。</p><h2 id="匿名页面的处理">匿名页面的处理</h2><p>对于 anonymous pages，总是需要先写入 swap area 才能回收。而对于 page cache，有一些可以直接 discard（比如 elf 的 text 段对应的页面，data 段对应的页面中 clean 的部分），有一些 dirty 的页面需要先 write back 同步到磁盘。</p><p>由于有 flusher thread 定期的 write back，回收时还是 dirty 的 page cache 页面不会太多。而且，page cache 中的页面有对应的文件和在文件中的位置信息，需要换入恢复的时候也更加容易。</p><p>因此，内核通常更倾向于换出 page cache 中的页面，只有当内存压力变得相对严重时，才会选择回收 anonymous pages。用户可以根据具体应用场景的需要，通过"/proc/sys/vm/swappiness"调节内存回收时 anonymous pages 和 page cache 的比重。</p><p>swappiness 的值从 0 到 100 不等（默认一般是 60），这个值越高，则回收的时候越优先选择 anonymous pages。当 swappiness 等于 100 的时候，anonymous pages 和 page cache 就具有相同的优先级。至于为什么不从开销最小的角度将 swappiness 设为 0，将在后面给出答案。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With swappiness at 100, anonymous and file have the same priority.</span></span><br><span class="line"><span class="comment"> * This scanning priority is essentially the inverse of IO cost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">anon_prio = swappiness;</span><br><span class="line">file_prio = <span class="number">200</span> - anon_prio</span><br></pre></td></tr></tbody></table></figure><p>早期的 Linux 实现中，每个 zone 中有 active 和 inactive 两个链表，每个链表上存放的页面不区分类型。为了实现优先回收 page cache，之后每个链表拆分成了 LRU_ANON 和 LRU_FILE，因此形成了 LRU_INACTIVE_ANON, LRU_ACTIVE_ANON, LRU_INACTIVE_FILE 和 LRU_ACTIVE_FILE 四种链表，而且改成了一个 node 对应一组链表（per-node），由代表 node 的 struct pglist_data 中的 struct lruvec 包含各个链表的头结点 。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BASE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_ACTIVE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_FILE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> {</span></span><br><span class="line">LRU_INACTIVE_ANON = LRU_BASE,</span><br><span class="line">LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,</span><br><span class="line">LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE</span><br><span class="line">LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,</span><br><span class="line">LRU_UNEVICTABLE,</span><br><span class="line">NR_LRU_LISTS</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">NR_LRU_LISTS</span>];</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里还有一个 LRU_UNEVICTABLE 链表。这个链表存储了 flag 为 PG_unevictable 的页面，因为 unevictable 的页面是不可以回收的，扫描的时候忽略 LRU_UNEVICTABLE 链表，将可以减少回收时扫描页面的总体时间。</p><p>可以通过"/proc/zoneinfo"查看这 4 种链表在 node 的各个 zone 上的分布： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru2.jpg"></p><p>更丰富的信息则包含在"/proc/meminfo"中，比如"Dirty"表示修改后还没有 write back 的页面，"Writeback"表示正在执行 I/O 操作进行回写的页面，还有就是系统所有"active"和"inactive"的 page cache 和 anonymous page 的统计数据。</p><p>如果 swappiness 的值为 0，那么内核在启动内存回收时，将完全忽略 anonymous pages，这将带来一个好处，就是内核只需要扫描 page cache 对应的 inactive list（LRU_ACTIVE_FILE）就可以了，根本不用扫描 anonymous pages 对应的 inactive list（LRU_ACTIVE_ANON），这样能极大的节约内存回收时花在扫描 LRU 链表上的时间。</p><p>但是，swappiness 设置为 0 只适用于系统中 page cache 比较多的场景，如果系统中 anonymous pages 比 page cache 多很多，只回收 page cache 的话，可能无法满足 direct relaim 或者 kswapd 的需求。</p><p>这时本来系统中还有很多 anonymous pages 可供回收以释放内存，由于 swappiness 的限制，内核也许只有选择 OOM killer 了，所以用户在设置 swappiness 参数的时候，需要对自己的应用场景和内存的使用情况有比较深入的了解，要不然你可能会困惑：明明 available 的内存还很多啊，为啥老有进程被 OOM kill 呢。</p><h1 id="触发机制">触发机制</h1><p>Linux 内核中触发页面回收的机制大致有 3 个。</p><ul><li>直接页面回收机制。在内核态里调用页面分配接口函数 alloe_pages() 分配物理页面时，由于系统内存短缺，不能满足分配请求，因此内核会直接自陷到页面回收机制，这称为直接页面回收</li><li>周期性回收内存机制。这是 kswapd 内核线程的工作职责。当内核路径调用 alloc_pages() 分配物理页面时，由于系统内存短缺，没法在低水位情况下分配出内存，因此会唤醒 kswapd 内核线程来异步回收内存</li><li>slab 收割机（slab shrinker）机制。这是用来回收 slb 对象的。当内存短缺时，直接页面回收和周期性回收内存两种机制都会调用 slab 收割机机制来回收 slab 对象。slab 机制分配的内存主要用于 slab 对象和 kmalloc 接口，也可用于内核空间的内存分配，而本节重点介绍的是用户内存的回收</li></ul><p>读者需要注意的是，直接回收内存的进程主体是调用者本身。另外，还有一个重要的特点一直接回收内存是同步回收，这会阻塞调用者进程的执行。 kswapd 本身是内核线程，它和调用者的关系是异步的。</p><p>一个理想的情况是，我们能在内存压力不那么大的时候，就提前启动内存回收。而且，在某些场景下（比如在 interrupt context 或持有 spinlock 时），内存分配根本就是不能等待的。因此，Linux 中另一种更为常见的内存回收机制是使用 kswapd。</p><p>每个 node 对应一个内核线程 kswapd，kswapd 在被唤醒后将扫描各个 zone 的内存使用状态，并据此进行必要的内存回收操作，因此 kswapd 的回收方式又被称为"background reclaim"。至于什么情况下触发 direct reclaim，什么情况下又会触发 background reclaim，是由内存的"watermark"决定的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru3.jpg"></p><p>Kswapd 虽然名字中含有"swap"，但它不光处理 anonymous page 的 swap out 回收，同样处理 page cache 的回收，而且它还肩负着平衡 active list 和 inactive list 的重任，所以被它调用的函数叫做 balance_pgdat()。</p><p>不管是 direct reclaim，还是 kswapd，最终都是调用 shrink_zone() --&gt; shrink_page_list() 进行回收操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">shrink_list</span><span class="params">(<span class="keyword">enum</span> lru_list lru, <span class="type">unsigned</span> <span class="type">long</span> nr_to_scan,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> lruvec *lruvec, <span class="keyword">struct</span> scan_control *sc)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (is_active_lru(lru)) {</span><br><span class="line"><span class="keyword">if</span> (inactive_list_is_low(lruvec, is_file_lru(lru), sc, <span class="literal">true</span>))</span><br><span class="line">shrink_active_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shrink_inactive_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 inactive list 中的页面比较少时，shrink_active_list() 会从 active list 尾端转移一部分页面到 inactive list 中。这里的“少”是相对的，通常物理内存越大，inactive list 的页面占比可以越小（页面总数还是增加的），因为 inactive list 的长度主要是用来减少短时间内 refault 的。</p><p>shrink_inactive_list --&gt; shrink_page_list 将从 inactive list 尾端移除选定数目的页面，进行释放。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru4.jpg"></p><p>回收一个页面之前，如果该页面当前是被映射的（根据 struct page 的_mapcount 域判断），需要调用 try_to_unmap()，通过 reserve mapping 更改所有指向这个页面的 PTEs。对于 anonymous page，还需要在 swap space 中分配 slot，并且将这个 page 标记为 dirty 的。anonymous page 是没有 backing store 的，从 dirty 的角度，它可以算是一直 dirty 的。</p><p>前面提到过，不是所有的页面都可以被回收的。如果检测到页面的 flag 是 PG_locked 或者是 PG_reserved 的，则只能跳过。对于正在回写的（flag 是 PG_writeback 的），通常也是放弃回收，有这功夫去等待回写完成，还不如去找链表上其他的 clean page。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru5.jpg"></p><p>之后，对于 flag 是 PG_dirty 的页面，启动 pageout() 将这些页面备份或者同步到外部磁盘，这里“备份”针对的是 anonymous page，“同步”针对的是 page cache。</p><h2 id="设置不回收">设置不回收</h2><p>进程可以用申请 swap token，拥有了 swap token，就可以被内存回收算法暂时豁免，除非，内存实在已经紧张的不行了。在 3.4 版本中被移除了。</p><h2 id="oom">OOM</h2><p>虽然 OOM killer 有时候可能导致严重的损失，但总比系统完全崩溃要好。这个无辜的 bad process 可不是随便挑的，应该优先选择这些：</p><ul><li>占有 page frames 比较多的，占有的多释放的才多，kill 掉才有意义</li><li>静态优先级比较低的</li></ul><p>而不能选择这些：</p><ul><li>内核线程，因为内核线程往往执行的都是比较关键的任务</li><li>进程号为 1 的 init 进程。如果父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将被 init 进程托管，kill 掉 init 进程是内核不允许的行为</li><li>直接访问硬件设备的进程，如果强行终结这样的进程，可能将硬件置于一个不确定的状态</li></ul><h1 id="refault-distance-算法">Refault Distance 算法</h1><p>在学术界和 Linux 内核社区，页面回收算法的优化一直没有停止过，其中 Refault Distance 算法在 Linux3.15 内核中加入，作者是社区专家 Johannes Weiner，该算法目前只针对页面高速缓存类型的页面。 如下图所示，对于内容缓存类型的 LRU 链表来说，有两个链表值得关注，分别是活跃 LRU 链表和不活跃 LRU 链表。新产生的页面总是被添加到不活跃 LRU 链表的头部，页面回收也总是从不活跃 LRU 链表的尾部开始。不活跃 LRU 链表的页面第二次访问时会升级（promote）为活跃 LRU 链表的页面，防止被回收；另一方面，如果活跃 LRU 链表增长太快，那么活跃页面也会被降级（demote）到不活跃 LRU 链表中。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/lru6.png"></p><p>实际上，一些场景下，某些页面经常被访问，但是在下一次访问之前在不活跃 LRU 链表中回收并释放了它们，因此须从存储系统中读取这些内容缓存页面，这会产生颠簸（thrashing）现象。当我们观察文件缓存中不活跃 LRU 链表的行为特征时，会发现如下有趣特征。</p><ul><li>第一次访问一个文件缓存页面时，它被添加到不活跃 LRU 链表头，然后慢慢从链表头向链表尾方向移动，链表尾的内容缓存会被移出 LRU 链表且释放页面，这个过程叫作移出</li><li>当第二次访问时，页面高速缓存被升级为活跃 LRU 链表中的页面高速缓存，这样不活跃 LRU 链表也空出一个位置，在不活跃 LRU 链表的页面整体移动了一个位置，这个过程叫作激活</li><li>从宏观时间轴来看，移出过程处理的页面数量与激活过程处理的页面数量的总和等于不活跃 LRU 链表的长度 NR_inactive</li><li>要从不活跃 LRU 链表中释放一个页面，需要移动 N 个页面（N 表示不活跃链表长度）</li></ul><p>综合上面的一些行为特征，定义了 Refault Distance 的概念。第一次访问内容缓存称为 fault，第二次访问该页称为 refault。内容缓存页面第一次被移出 LRU 链表并回收的时刻称为 E，第二次再访问该页面的时刻称为 R，那么 R-E 的时间里需要移动的页面个数称为 Refault Distance。</p><p>Refault Distance 概念再加上第一次访问的时刻，可以用一个公式来概括第一次和第二次访问的间隙（read distance）。</p><pre><code>read_distance=nr_inactive + (R - E)</code></pre><p>如果页面想一直保持在 LRU 链表中，那么 read_distance 不应该比内存的大小还大；否则，该页面永远会被移出 LRU 链表。因此，下式成立。</p><pre><code>NR_inactive + (R - E) ≤ NR_inactive + NR_active(R - E) ≤ NR_active</code></pre><p>换句话说，Refault Distance 可以理解为不活跃 LRU 链表的“财政赤字”。如果不活跃 LRU 链表的长度至少再延长到 Refault Distance，就可以保证该内容缓存在第二次访间之前不会被移出 LRU 链表并释放内存：否则，就要把该内容缓存重新加入活跃 LRU 链表加以保护，以防颠簸。在理想情况下，内容缓存的平均访问间隙要大于不活跃 LRU 链表的大小、小于总的内存大小。 上述内容讨论了两次读的间隙小于或等于内存大小的情况，即 NR_inactive+（R-E）≤ NR_inactive - NR_active。如果两次读的间隙大于内存大小呢？这种特殊情况不是 Refault Distance 算法能解决的，因为它在第二次访问时己经永远被移出 LRU 链表，可以假设第二次访向发生在遥远的末来，但谁都无法保证它在 LRU 链表中。其实 Refault Distance 算法用于在第二次访问时，人为地把内容缓存添加到活跃 LRU 链表中，从而防止该内容缓存被移出 LRU 链表而带来的内存颠簸。</p><p>Refault Distance：算法如下图所示。T0 时刻表示第一次访问一个内容缓存这时会调用 add_to_page_cache_lru 而配一个 shadow 来存储 zone-&gt;inactive_age 值。每当有页面被升级为活跃 LRU 链表中的页面时，zone-&gt;inactive_age 值会加 1 每当有面被移出不活跃 LU 表时，zone-&gt;inactive_age 值也加 1. T1 时刻，该页面被移出 LRU 链表并从 LRU 链表中回收释放因此把当前 T1 时刻的 zone-&gt;inactive_age 的值编码存放到 shadow 中。T2 时刻，第二次访问该页面，因此要计算 Refault Distance，Refault Distance：=T2-T1，如果 Retault Distances ≤ NR_active. 说明该内容缓存极有可能在下一次读时已经被移出 LRU 链表，因此要人为地激活该页面并且将其加入活跃 LRU 链表中。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/RefaultDistance.png"></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83MDk2NDE5NQ==">https://zhuanlan.zhihu.com/p/70964195<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83Mjk5ODYwNQ==">https://zhuanlan.zhihu.com/p/72998605<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（七）进程地址空间</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryProcessSpace/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryProcessSpace/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryProcessSpace.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM3NDZmYzU2NTNiYjA3MWU3MTM0NTc=">原图<i class="fa fa-external-link-alt"></i></span></p><h1 id="进程地址空间">进程地址空间</h1><p>进程地址空间在内核中使用 vm_area_struct 数据结构来描述，简称 VMA，表示进程地址空间或进程线性区。由于这些地址空间属于各个用户进程，因此在用户进程的 mm_struct 数据结构中有相应的成员，用于对这些 VMA 进行管理。</p><span id="more"></span><h2 id="内存区域">内存区域</h2><p>进程地址空间（process address space）是指进程可寻址的虚拟地址空间，进程可以通过内核的内存管理机制动态地添加和删除内存区域，这些内存区域在 Linux 内核采用 VMA 数据结构来抽象描述。</p><p>每个内存区域具有相关的权限，如可读、可写或者可执行权限。若一个进程访问了不在有效范围的内存区域，或者非法访问了内存区域，或者以不正确的方式访问了内存区域，那么处理器会报告缺页异常。在 Linux 内核的缺页异常处理中会处理这些情况，严重的会报告“SegmentFault'”并终止该进程。</p><p>内存区域主要包含内容如下：</p><ul><li>代码段映射：可执行文件中包含只读并可执行的程序头，如代码段和 init 段等</li><li>数据段映射：可执行文件中包含可读/可写的程序头，如数据段和未初始化数据段等</li><li>用户进程栈：通常位于用户空间的最高地址，从上往下延伸。它包含栈帧，里面包含了局部变量和函数调用参数等</li><li>mmap 映射区域：位于用户进程栈下面，主要用于 mmap 系统调用</li><li>堆映射区域：malloc() 函数分配的进程虚拟地址就是这段区域</li></ul><p>每个进程都有一套页表，这样每个进程地址空间就是相互隔离的。即使两个进程地址空间的虚拟地址是相同的，但是经过两套不同页表的转换之后，它们也会对应不同的物理地址。</p><h2 id="mm_struct-数据结构">mm_struct 数据结构</h2><p>Linux 内核需要管理每个进程所有的内存区域以及它们对应的页表映射，所以必须抽象出一个数据结构，这就是 mm_struct 数据结构。进程控制块（Process Control Block，PCB）数据结构 task_struct 中有一个指针 mm，该指针指向这个 mm_struct 数据结构。mm_struct 数据结构定义在 include/linux/mm_types.h 文件中，下面是它的主要成员。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span><span class="comment">/* list of VMAs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">u64 vmacache_seqnum;                   <span class="comment">/* per-thread vmacache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_base;<span class="comment">/* base of mmap area */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base;<span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES</span></span><br><span class="line"><span class="comment">/* Base addresses for compatible mmap() */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_compat_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_compat_legacy_base;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> task_size;<span class="comment">/* size of task vm space */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;<span class="comment">/* highest vma end address */</span></span><br><span class="line"><span class="type">pgd_t</span> * pgd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMBARRIER</span></span><br><span class="line"><span class="type">atomic_t</span> membarrier_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> mm_users;</span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> mm_count;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">atomic_long_t</span> pgtables_bytes;<span class="comment">/* PTE page table pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> map_count;<span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> page_table_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hiwater_rss; <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;  <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_vm;   <span class="comment">/* Total pages mapped */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> locked_vm;   <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line"><span class="type">atomic64_t</span>    pinned_vm;   <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data_vm;   <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> exec_vm;   <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_vm;   <span class="comment">/* VM_STACK */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> def_flags;</span><br><span class="line"></span><br><span class="line"><span class="type">seqcount_t</span> write_protect_seq;</span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> arg_lock; <span class="comment">/* protect the below fields */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_rss_stat</span> <span class="title">rss_stat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line"><span class="type">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line"><span class="type">spinlock_t</span>ioctx_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kioctx_table</span> __<span class="title">rcu</span>*<span class="title">ioctx_table</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">exe_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_subscriptions</span> *<span class="title">notifier_subscriptions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line"><span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> numa_next_scan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Restart point for scanning and setting pte_numa */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> numa_scan_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* numa_scan_seq prevents two threads setting pte_numa */</span></span><br><span class="line"><span class="type">int</span> numa_scan_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">atomic_t</span> tlb_flush_pending;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span></span><br><span class="line"><span class="comment">/* See flush_tlb_batched_pending() */</span></span><br><span class="line"><span class="type">bool</span> tlb_flush_batched;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uprobes_state</span> <span class="title">uprobes_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></span><br><span class="line"><span class="type">atomic_long_t</span> hugetlb_usage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">async_put_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IOMMU_SUPPORT</span></span><br><span class="line">u32 pasid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cpu_bitmap[];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>mm_struct 数据结构中主要成员的含义如下：</p><ul><li>mmap：进程里所有的 VMA 形成一个单链表，这是该链表的头</li><li>mmrb：VMA 红黑树的根节点</li><li>get_unmapped_area：用于判断虚拟内存空间是否有足够的空间，返回一段没有映射过的空间的起始地址，这个函数会使用具体的处理器架构的实现</li><li>mmap_base：指向 mmap 空间的起始地址。在 32 位处理器中，mmap 空间的起始地是 0x4000 0000</li><li>pgd：指向进程的 PGD（一级页表）</li><li>mm_users：记录正在使用该进程地址空间的进程数目，如果两个线程共享该地址空间那么 mm_users 的值等于 2</li><li>mm_count：mm_struct 结构体的主引用计数</li><li>mmap_sem：保护 VMA 的一个读写信号量</li><li>mmlist：所有的 mm_struct 数据结构都连接到一个双向链表中，该链表的头是 init_mm 内存描述符，它是 init 进程的地址空间</li><li>start_code，end_code：代码段的起始地址和结束地址</li><li>start_data，end_data：数据段的起始地址和结束地址</li><li>start_brk：堆空间的起始地址</li><li>brk：表示当前堆中的 VMA 的结束地址</li><li>total_vm：已经使用的进程地址空间总和</li></ul><p>从进程的角度来观察内存管理，可以沿着 mm_struct 数据结构进行延伸和思考，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma1.png"></p><h2 id="vma-数据结构">VMA 数据结构</h2><p>VMA（vm_area_struct）数据结构定义在 mm_types.h 文件中，其主要成员如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">include/<span class="number">1</span>inux/mm_types.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> {</span></span><br><span class="line"><span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_start;<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_end;<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span><span class="comment">/* The address space we belong to. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_flags;<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">} shared;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_lock &amp;</span></span><br><span class="line"><span class="comment">  * page_table_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span><span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Information about our backing store: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">   units */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span><span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line"><span class="type">void</span> * vm_private_data;<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SWAP</span></span><br><span class="line"><span class="type">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span><span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span><span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><p>VMA 数据结构中各个成员的含义如下：</p><ul><li>vm_start 和 vm_end：指定 VMA 在进程地址空间的起始地址和结束地址</li><li>vm_next 和 vm_prev：进程的 VMA 都连接成一个链表</li><li>vmrb：VMA 作为一个节点加入红黑树，每个进程的 mm_struct 数据结构中都有一棵红黑树 mm-&gt;mm_rb</li><li>vm_mm：指向该 VMA 所属进程的 mm_struct 数据结构</li><li>vm_page_prot：VMA 的访问权限</li><li>vm_flags：描述该 VMA 的一组标志位</li><li>anon_vma_chain 和 anon_vma：用于管理反向映射（Reverse Mapping，RMAP）</li><li>vm_ops：指向许多方法的集合，这些方法用于在 VMA 中执行各种操作，通常用于文件映射</li><li>vm_pgoff：指定文件映射的偏移量，这个变量的单位不是字节，而是页面的大小件映射。（PAGE SIZE）。对于匿名页面来说，它的值可以是 0 或者 vm_addr/PAGE_SIZE</li><li>vm_file：指向 file 的实例，描述一个被映射的文件</li></ul><p>mm_struct 数据结构是描述进程内存管理的核心数据结构，该数据结构提供了管理 VMA 所需要的信息，每个 VMA 都要连接到 mm_struct 中的链表和红黑树，以方便查找。</p><p>VMA 按照起始地址以递增的方式插入 mm_struct-&gt;mmp 链表中。当进程拥有大量的 VMA 时，扫描链表和查找特定的 VMA 是非常低效的操作，如在云计算的机器中，所以内核中通常需要红黑树来协助，以便提高查找速度。 站在进程的角度来看，我们可以从进程控制块。task_struct 数据结构里顺藤摸瓜找到该进程所有的 VMA，如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma1.png"></p><ul><li>task_struct 结结构中有一个 mm 成员指向进程的内存管理描述符 mm_struct 数据结构</li><li>可以通过 mm_struct 数据结构中的 mmap 成员来遍历所有的 VMA</li><li>也可以通过 mm_struct 数据结构中的 mm_rb 成员来遍历和查找 VMA</li><li>mm_struct 数据结构的 pgd 成员指向进程的页表，每个进程都有一份独立的页表</li><li>当 CPU 第一次访问虚拟地址空间时会触发缺页异常。在缺页异常处理中，分配物理页面，利用分配的物理页面来创建页表项并且填充页表，完成虚拟地址到物理地址的映射关系的建立</li></ul><h2 id="vma-的属性">VMA 的属性</h2><p>作为一个进程地址空间的区间，VMA 是有属性的，如可读/可写、共享等属性。vm_flags 成员描述这些属性，描述了该 VMA 的全部页面信息，包括如何映射页面、访问每个页面的权限等信息，VMA 属性的标志位如下所示。</p><ul><li>VM_READ: 可读属性</li><li>VM_WRITE: 可写属性</li><li>VM_EXEC: 可执行</li><li>VM_SHARED: 允许被多个进程共享</li><li>VM_MAYREAD: 允许设置 VM_READ 属性</li><li>VM_MAYWRITE: 允许设置 VM WRITE 属性</li><li>VM_MAYEXEC: 允许设置 VM EXEC 属性</li><li>VM_MAYSHARE: 允许设置 VM SHARED 属性</li><li>VM_GROWSDOWN: 该 VMA 允许向低地址增长</li><li>VM_UFFD_MISSING: 表示该 VMA 适用于用户态的缺页异常处理</li><li>VM_PFNMAP: 表示使用纯正的 PFN，不需要使用内核的 page 数据结构来管理物理页面</li><li>VM_DENYWRITE: 表示不允许写入</li><li>VM_UFFD_WP: 用于页面的写保护跟踪</li><li>VM_LOCKED: 表示该 VMA 的内存会立刻分配物理内存，并且页面被锁定，不会被交换到交换分区</li><li>VM_IO: 表示 I/0 内存映射</li><li>VM_SEQ_READ: 表示应用程序会顺序读该 VMA 的内容</li><li>VM_RAND_READ: 表示应用程序会随机读该 VMA 的内容</li><li>VM_DONTCOPY: 表示在创建分支时不要复制该 VMA</li><li>VM_DONTEXPAND: 通过 mremapo 系统调用禁止 VMA 扩展</li><li>VM_ACCOUNT: 在创建 IPC 以共享 VMA 时，检测是否有足够的空闲内存用于映射</li><li>VM_HUGETLB: 用于巨页的映射</li><li>VM_SYNC: 表示同步的缺页异常</li><li>VM_ARCH_1: 与架构相关的标志位</li><li>VM_WIPEONFORK: 表示不会从父进程相应的 VMA 中复制页表到子进程的 VMA 中</li><li>VM_DONTDUMP: 表示该 VMA 不包含到核心转储文件中</li><li>VM_SOFTDIRTY: 软件模拟实现的脏位。用于一些特殊的架构，需要打开 CONFIG_MEM_SOFT_DIRTY</li><li>VM_MIXEDMAP: 表示混合使用了纯 PFN 以及 page 数据结构的页面，如使用 vm_insert_page() 函数插入 VMA</li><li>VM_HUGEPAGE: 表示在 madvise 系统调用中使用 MADV_HUGEPAGE 标志位来标记该 VMA</li><li>VM_NOHUGEPAGE: 表示在 madvise 系统调用中使用 MADV_NOHUGEPAGE 标志位来标记该 VMA</li><li>VM_MERGEABLE: 表示该 VMA 是可以合并的，用于 KSM 机制</li><li>VM_SPECIAL: 表示该 VMA 是不可以合并的</li></ul><p>VMA 属性的标志位可以任意组合，但是最终要落实到硬件机制上，即页表项的属性中。VMA 属性到页表属性的转换如下图所示。vm_area_struct 数据结构中有两个成员和属性相关：一个是 vm_flags 成员，用于描述 VMA 的属性；另外一个是 vm_page_prot 成员，用于将 VMA 属性标志位转换成与处理器相关的页表项的属性，它和具体架构相关。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma2.png"></p><p>在创建一个新的 VMA 时使用 vm_get_page_prot() 函数可以把 vm_flags 标志位转化成具页表项的硬件标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/mmap.c&gt;</span><br><span class="line"><span class="type">pgprot_t</span> <span class="title function_">vm_get_page_prot</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> vm_flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">pgprot_t</span> ret = __pgprot(pgprot_val(protection_map[vm_flags &amp;</span><br><span class="line">(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |</span><br><span class="line">pgprot_val(arch_vm_get_page_prot(vm_flags)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arch_filter_pgprot(ret);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(vm_get_page_prot);</span><br></pre></td></tr></tbody></table></figure><p>这个转化过程得益于内核预先定义了一个内存属性数组 protection_map[], 我们只需要根据 vm_flag 标志位来查询这个数组即可，在这个场景下，通过查询 protection_map[] 数组可以获得页表属性。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pgprot_t</span> protection_map[<span class="number">16</span>] __ro_after_init = {</span><br><span class="line">__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,</span><br><span class="line">__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>protection_map[] 数组的每个成员代表一个属性的组合，如__P000 表示无效的 PTE 属性，__P001 表示只读属性，__P1O0 表示可执行属性（PAGE_EXECONLY）等。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __P000PAGE_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P001__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_READABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P010__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_WRITABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P011__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_READABLE \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_WRITABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P100__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_EXEC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P101__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_READABLE \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_EXEC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P110__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_WRITABLE \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_EXEC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __P111__pgprot(CF_PAGE_VALID \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_ACCESSED \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_READABLE \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_WRITABLE \</span></span><br><span class="line"><span class="meta"> | CF_PAGE_EXEC)</span></span><br></pre></td></tr></tbody></table></figure><p>下面以只读属性（PAGE_READONLY）来看，它究竟包含哪些页表项的标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_READONLY__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_RDONLY | PTE_NG | PTE_PXN | PTE_UXN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_DEFAULT(_PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PROT_DEFAULT(PTE_TYPE_PAGE | PTE_AF | PTE_SHARED)</span></span><br></pre></td></tr></tbody></table></figure><p>把上述的宏全部展开，我们可以得到如下页表项的标志位。</p><ul><li>PTE_TYPE_PAGE：表示这是一个基于页面的页表项，即设置页表项的 Bit[1:O]</li><li>PTE_AF：设置访问位</li><li>PTE_SHARED：设置内存共享属性</li><li>MT_NORMAL：设置内存属性为 normal</li><li>PTE_USER：设置 AP 访问位，允许通过用户权限访问该内存</li><li>PTE_NG：设置该内存对应的 TLB 只属于该进程</li><li>PTE_PXN：表示该内存不能在特权模式下执行</li><li>PTE_UXN：表示该内存不能在用户模式下执行</li><li>PTE_RDONLY：表示只读属性</li></ul><h1 id="内核如何管理内存">内核如何管理内存</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma100.png"></p><p>Linux 进程在内核中作为进程描述符 task_struct 的实例实现。task_struct 中的 mm 字段指向内存描述符 mm_struct ，它是程序内存的执行内容。它存储了如上所示的内存段的开始和结束、进程使用的物理内存页数（rss 代表 Resident Set Size）、使用的虚拟地址空间 以及其他信息。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma101.png"> 每个虚拟内存区域（VMA）是一个连续的虚拟地址范围；这些区域永远不会重叠。vm_area_struct 的实例完整地描述了一个内存区域，包括其起始和结束地址、用于确定访问权限和行为的标志，以及用于指定该区域映射的文件（如果有）的 vm_file 字段。不映射文件的 VMA 是匿名的。除了内存映射段之外，上面的每个内存段（例如，堆、堆栈）对应于单个 VMA。这不是必需的，尽管这在 x86 机器中很常见。VMA 不关心它们位于哪个段。 程序的 VMA 都以链表形式存储在其内存描述符中 mmap 字段，按起始虚拟地址排序，并作为以 mm_rb 字段为根的红黑树 。红黑树允许内核快速搜索覆盖给定虚拟地址的内存区域。当您读取文件/proc/pid_of_process/maps 时，内核只是遍历进程的 VMA 链接列表并打印每一个 VMA。</p><p>VMA 的大小必须是页面大小的倍数。处理器查阅页表以将虚拟地址转换为物理内存地址。每个进程都有自己的一组页表；每当发生进程切换时，用户空间的页表也会切换。Linux 在内存描述符的 pgd 字段中存储指向进程页表的指针。页表中的每个虚拟页都对应一个页表项 (PTE)，在常规 x86 分页中，它是一个简单的 4 字节记录，如下所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vma102.png"></p><h1 id="malloc-函数">malloc 函数</h1><p>malloc() 函数是 C 标准库封装的一个核心函数，C 标准库做一些处理后会调用 Linux 的系线调用接口 brk 向系统申请内存。</p><h2 id="brk-系统调用">brk 系统调用</h2><p>brk 系统调用主要实现在 mm/mmap.c 文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="type">unsigned</span> <span class="type">long</span>, brk)</span><br></pre></td></tr></tbody></table></figure><p>详细流程这里不一一列出来了，下面用一张图概括 brk 的流程，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/brk.png"></p><h2 id="malloc-流程">malloc 流程</h2><p>假设不考虑 libc 的因素，malloc() 分配 100 字节，那么内核会分配多少字节呢？处理器的 MMU 的最小处理单元是页面，所以内核分配内存、建立虚拟地址和物理地址映射关系都以页面为单位，PAGE_ALIGN（addr）宏让地址按页面大小对齐。 下图所示为 malloc() 函数的实现流程。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/malloc.png"></p><h1 id="mmap-函数">mmap 函数</h1><p>mmap/munmap 函数是用户空间中常用的系统调用函数，无论是在用户程序中分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到 mmp/munmap() 函数的身影。mmp/munmap 函数的声明如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span> <span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></tbody></table></figure><p>mmap/munmap 函数的参数如下。</p><ul><li>addr：用于指定映射到进程地址空间的起始地址，为了提高应用程序的可移植性，一般设置为 NULL，让内核来分配一个合适的地址</li><li>length：表示映射到进程地址空间的大小</li><li>prot：用于设置内存映射区域的读写属性等</li><li>flags：用于设置内存映射的属性，如共享映射、私有映射等</li><li>fd：表示这是一个文件映射，fd 是打开的文件的句柄</li><li>offset：在文件映射时，表示文件的偏移量。prot 参数通常表示映射页面的读写权限，有如下参数组合</li><li>PROT_EXEC：表示映射的页面是可以执行的</li><li>PROT_READ：表示映射的页面是可以读取的</li><li>PROT_WRITE：表示映射的页面是可以写入的</li><li>PROT_NONE：表示映射的页面是不可访问的</li></ul><p>flags 参数是一个很重要的参数，可以设置为以下值。</p><ul><li>MAP_SHARED：创建一个共享映射的区域。多个进程可以通过共享映射方式来映射一个文件，这样其他进程也可以看到映射内容的改变，修改后的内容会同步到磁盘文件中</li><li>MAP_PRIVATE：创建一个私有的写时复制的映射。多个进程可以通过私有映射的方式来映射一个文件，这样其他进程不会看到映射内容的改变，修改后的内容也不会同步到磁盘文件中</li><li>MAP_ANONYMOUS：创建一个匿名映射，即没有关联到文件的映射</li><li>MAP_FIXED：使用参数 addr 创建映射，如果在内核中无法映射指定的地址，那么 mmap 会返回失败，参数 addr 要求按页对齐。如果 addr 和 length 指定的进程地址空间和已有的 VMA 重叠，那么内核会调用 do_munmapO 函数把这段重叠区域销毁，然后重新映射新的内容</li><li>MAP_POPULATE：对于文件映射来说，会提前预读文件内容到映射区域，该特性只支持私用映射</li></ul><p>通过参数 fd 可以看出 mmap 映射是否和文件相关联，因此在 Linux 内核中，映射可以分成匿名映射和文件映射。</p><ul><li>匿名映射：没有映射对应的相关文件，匿名映射的内存区域的内容会初始化为 0</li><li>文件映射：映射和实际文件相关联，通常把文件内容映射到进程地址空间，这样应用程序就可以像操作进程地址空间一样读写文件</li></ul><h2 id="私有匿名映射">私有匿名映射</h2><p>当使用参数 fd=-1 且 flags = MAP_ANONYMOUS|MAP_PRIVATE 时，创建的 mmap 映射是私有匿名映射。私有匿名映射常见的用途是在 glbc 分配大内存块时，如果需要分配的内存大 MMAP_THREASHOLD（128KB），glibc 会默认使用 mmap 代替 brk 来分配内存。</p><h2 id="共享匿名映射">共享匿名映射</h2><p>当使用参数 fd=-1 且 flags = MAP_ANONYMOUS | MAP_SHARED 时，创建的 mmap 映射是共享匿名映射。共享匿名映射让相关进程共享一块内存区域，通常用于父、子进程之间的通信创建共享匿名映射有如下两种方式。</p><ul><li>使 fd=-1 且 flags = MAP_ANONYMOUS | MAP_SHARED。在这种情况下，do_mmap_pgoffO-&gt;mmap_region() 函数最终会调用 shmem_zero_setup()：来打开一个特殊的“/dev/zero”设备文件</li><li>直接打开“/dev/zero”设备文件，然后使用这个文件句柄来创建 mmap</li></ul><p>上述两种方式最终都调用 shmem 模块来创建共享匿名映射。</p><h2 id="私有文件映射">私有文件映射</h2><p>创建文件射时如果 flags 设置为 MAPP_PRIVATE，就会创建私有文件映射。私有文件映射常用的场景是加载动态共享库。</p><h2 id="共享文件映射">共享文件映射</h2><p>创建文件映射时，如果 flags 设置为 MAP_SHARED，就会创建共享文件映射。如果 prot 参数指定了 PROT_WRITE，那么打开文件时需要指定 O_RDWR 标志位。共享文件映射通常有 mmap 如下两个常用的场景。</p><ul><li>读写文件。把文件内容映射到进程地址空间，同时对映射的内容做了修改，内核的回写（writeback）机制最终会把修改的内容同步到磁盘中</li><li>进程间通信。进程之间的进程地址空间相互隔离，一个进程不能访问另外一个进程的地址空间。如果多个进程同时映射到一个文件，就实现了多进程间的共享内存通信。如果一个进程对映射内容做了修改，那么另外的进程是可以看到的</li></ul><h2 id="小结">小结</h2><p>mmap 机制在 Linux 内核中实现的代码框架和 brk 机制非常类似，其中有很多关于 VMA 的操作。mmap 机制和缺页中断机制结合在一起会变得复杂很多。mmap 机制在 Linux 内核中的实现流程如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mmap.png"></p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZXRydW5ndGhhbmcuYmxvZ3Nwb3QuY29tLzIwMTAvMTIvY2h1eWVuLXRpZXQta2llbS1tdWEtbmhhLWN1YS1naW9pLmh0bWw=">https://letrungthang.blogspot.com/2010/12/chuyen-tiet-kiem-mua-nha-cua-gioi.html<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（六）伙伴系统和 slab 分配器</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryslab/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryslab/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Memoryslab.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM3NDI1M2YzNDZmYjA3MjVmODQ0Yjg=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><blockquote><p>声明本文转载自知乎 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9sYW4teGluLXl1">兰新宇<i class="fa fa-external-link-alt"></i></span> 内存相关文章</p></blockquote><h1 id="内存池">内存池</h1><h2 id="空闲链表free-list">空闲链表（free list）</h2><p>将内存中所有的空闲内存块通过链表的形式组织起来，就形成了最基础的 free list。内存分配时，扫描 free list 的各个空闲内存块，从中找到一个大小满足要求的内存块，并将该内存块从 free list 中移除。内存释放时，释放的内存块被重新插入到 free list 中。</p><p>假设现在内存的使用情况是这样的： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list1.jpg"></p><p>灰色部分代表已经被分配的内存块，白色部分代表空闲的内存块，大小分别是 48 字节，16 字节和 96 字节。如果此时内存分配的申请是 12 个字节，那么将有以下三种策略可以选择：</p><ul><li><p>First fit（最先适配），就是从 free list 头部开始扫描，直到遇到第一个满足大小的空闲内存块，这里第一个 48 字节的内存块就可以满足要求。这种方法的优点是相对快一些，尤其是满足要求的空闲内存块位于链表前部的时候，但是在控制碎片数量上不是最优的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list2.jpg"></p></li><li><p>Best fit（最佳适配），就是遍历 free list 的所有空闲内存块，从中找到和所申请的内存大小最接近的空闲内存块，这里第二个 16 字节的内存块是最接近 12 字节的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list3.jpg"></p></li><li><p>Worst fit（最差适配），也是遍历 free list 的所有空闲内存块，如果找不到大小刚好匹配的，就从最大的空闲内存块中分配。初看起来很反直觉是不是？但假设接下来的内存申请是 64 个字节，那只有 worst fit 的这种方法才能满足需求，所以其价值体现在：分配之后剩下的空闲内存块很可能仍然足够大。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list4.jpg"></p></li></ul><p>以上讨论的是内存分配的情况，接下来看看内存释放的操作是怎样的。假设从第 80 字节到第 100 字节中间的 20 字节内存被释放了，那么它将和前面相邻的空闲内存块合并： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list5.jpg"></p><p>接下来从第 100 字节到第 112 字节中间的 12 字节内存也被释放了，那么它将同时和前后相邻的空闲内存块合并： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list6.jpg"></p><p>不过，既然用到了链表，那就需要指针，而指针本身也是要占用内存空间的。而且在内存释放时，要判断被释放的内存块前后的内存块是不是也是空闲的，这就需要每个内存块有一个空闲状态的标志位。可以采用的一种方式是 bitmap，假设以 4 个字节为最小分配单位，那么每 4 字节需要一个 bit，因此额外消耗的内存为 1/32。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_list7.jpg"></p><h2 id="内存池memory-pool">内存池（memory pool）</h2><p>空闲链表的分配方式简单，但分配效率不高，运行一段时间后容易产生大量的内存碎片，从而恶化了内存利用率。</p><p>如果能将一大块内存分成多个小内存（称为内存池），不同的内存池又按照不同的「尺寸」分成大小相同的内存块（比如分别按照 32, 64, 128……字节），同一内存池中的空闲内存块按照 free list 的方式连接。</p><p>每次分配的时候，选择和申请的的内存在「尺寸」上最接近的内存池，比如申请 60 字节的内存，就直接从单个内存块大小为 64 字节的内存池的 free list 上分配。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_pool1.jpg"></p><p>这样减少了 free list 链表的长度，能够缩短每次内存分配所需的线性搜索的时间，特别适合对实时性要求比较高的系统（比如 RTOS）。但要想取得好的效果，需要结合系统实际的内存分配需求，对内存池的大小进行合理的划分。比如一个系统常用的是 256 字节以下的内存申请，那设置过多的 256 字节以上的内存池，就会造成内存资源的闲置和浪费。</p><p>似乎不是很好把控到底怎样划分内存池最为合适？下文将要介绍的 Linux 中的 buddy 分配系统，将基于普通的内存池进行优化，以更贴合大型操作系统对内存管理的需求。</p><h1 id="buddy-分配算法">Buddy 分配算法</h1><p>上文介绍了内存池，它的分配快速，但这种“事先就划分好”的方法对系统的适应性较差，不同「尺寸」的内存池之间不能“互通有无”。而 buddy 分配系统在普通内存池的基础上，允许两个大小相同且相邻的内存块合并，合并之后的内存块的「尺寸」增大，因而将被移动到另一个内存池的 free list 上。</p><p>来看下面这个例子，内存共有 1024 字节，由 32, 64, 128, 256, 512 字节为「尺寸」的 5 个 free list 组织起来，最小分配单位为 32 字节（对应位图中的 1 个 bit）。假设现在 0 到 448 字节的内存已使用，448 到 1024 字节的内存为空闲（字母编号从 A 开始，表示分配顺序）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/buddy1.jpg"></p><p>现在我们要申请 128 字节的内存，那么首先应该查看「尺寸」为 128 字节的 free list，但很可惜没有，那再看看 256 字节的 free list，还是没有，只能再往上找，到 512 字节的 free list 这儿，终于有了一个空闲的内存块 A'。</p><p>那么将 A'划分为 256 字节的 E 和 E'，再将内存块 E 划分成 128 字节的 F 和 F'，内存块 F 即是我们需要的内存。之后，在此过程中产生的 E'和 F'将分别被挂接到「尺寸」为 256 字节和 128 字节的 free list 上，位图中 bits 的值也会相应变化。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/buddy2.jpg"></p><p>接下来释放 128 字节的内存块 C，由于 C 相邻的两个内存块都不是空闲状态，因此不能合并，之后 C 也将被挂接到「尺寸」为 128 字节的 free list 上。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/buddy3.jpg"></p><p>然后释放 64 字节的内存块 D，分配器根据位图可知，右侧的 D'也是空闲的，且 D 和 D'的大小相同，因此 D 和 D'将合并。按理合并后的空闲内存块 C'为 128 字节，应该被添加到「尺寸」为 128 字节的 free list 上，但因为左侧的 C 也是空闲的，且 C 和 C'的大小相同，因此 C 和 C'还将合并形成 B'，合并后的空闲内存块将被挂接到「尺寸」为 256 字节的 free list 上。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/buddy4.jpg"></p><p>在 buddy 分配系统中，从物理上，内存块按地址从小到大排列；从逻辑上，内存块通过 free list 组织。通过对相邻内存块的合并，增加了内存使用的灵活性，减少了内存碎片。</p><p>但是实现合并有一个前提，就是内存块的尺寸必须是 2 的幂次方（称为"order"），这也是 buddy 系统划分内存块的依据。此外，每次内存释放都要查找左右的 buddy 是否可以合并，还可能需要在 free list 之间移动，也是一笔不小的开销。</p><h1 id="slab">Slab</h1><p>Linux 中的 buddy 分配器是以 page frame 为最小粒度的，而现实的应用多是以内核 objects（比如描述文件的"struct inode"）的大小来申请和释放内存的，这些内核 objects 的大小通常从几十字节到几百字节不等，远远小于一个 page 的大小。</p><p>那可不可以把一个 page frame 再按照 buddy 的原理，以更小的尺寸（比如 128 字节，256 字节）组织起来，形成一个二级分配系统呢？这就是 slab 分配器。</p><h2 id="cache-和-slab">cache 和 slab</h2><p>在 slab 分配器中，每一类 objects 拥有一个"cache"（比如 inode_cache, dentry_cache）。之所以叫做"cache"，是因为每分配一个 object，都从包含若干空闲的同类 objects 的区域获取，释放时也直接回到这个区域，这样可以缓存和复用相同的 objects，加快分配和释放的速度。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab1.jpg"></p><p>object 从"cache"获取内存，那"cache"的内存又是从哪里来的呢？还是得从 buddy 分配器来。slab 层直接面向程序的分配需求，相当于是前端，而 buddy 系统则成为 slab 分配器的后端。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab2.jpg"></p><p>由于"cache"的内存是从 buddy 系统获得的，因此在物理上是连续的。如果一个"cache"中 objects 的数目较多，那么"cache"的体积较大，需要占用的连续物理内存较多。当 object 的数量增加或减少时，也不利于动态调整。因此，一个"cache"分成了若干个 slabs。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab3.jpg"></p><h2 id="数据结构">数据结构</h2><p>一个"cache"在 Linux 中由"struct kmem_cache"结构体描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gfporder;    <span class="comment">/* order of pages per slab (2^n) */</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags;         <span class="comment">/* force GFP flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num;         <span class="comment">/* objects per slab */</span></span><br><span class="line">    <span class="type">int</span> object_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> colour_off;  <span class="comment">/* colour offset */</span></span><br><span class="line">    <span class="type">size_t</span> colour;            <span class="comment">/* cache colouring range */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>    <span class="comment">/* cache creation &amp; removal */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个 slab 由一个或多个 page frame 组成（通常为一个），根据 buddy 系统的限制，在数量上必须是 2 的幂次方，"gfporder"实际就定义了一个"cache"中每个 slab 的大小。</p><p>既然涉及到 page frame 的分配，那自然离不开 GFP flags，比如要求从 DMA 中分配，就需要指定"GFP_DMA"。</p><pre><code>   s，数量由"num"表示，每个 object 的大小由"object_size"给出。一个 object 可能跨越 2 个 page frames。</code></pre><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab4.jpg"></p><p>如果 object 的内存地址能按一定字节数（比如总线宽度）或者按硬件 cache line 的大小对齐，将可以提高读写性能。此外，不同 slabs 中具有相同偏移的 objects，大概率会落在同一 cache line 上，造成 cache line 的争用，所以最好加上不同的填充，以错开对 cache line 的使用。这些偏移和填充，共同构成了 slab 的 coloring 机制。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab5.jpg"></p><p>可见啊，slab cache 除了和硬件 cache 一样都使用了“缓存”的思想，它还在实现中充分利用了硬件 cache 提供的特性，以进一步提高运行效率。但付出的代价就是，不管对齐还是填充，都需要额外的字节，这对内存资源也会造成一定的消耗。</p><h2 id="统计信息">统计信息</h2><p>可通过"slabtop"命令查看当前系统的 slab 分配情况： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab6.jpg"></p><p>如上图所示，系统中 slab 分配器一共占据了 46059.92KB 内存，包括 115 个"caches"，12126 个"slabs"（平均每个 cache 拥有 105 个 slabs），170077 个"objects"（平均每个 slabs 拥有 14 个 objects）。在所有的 objects 中，最小的为 0.02KB，最大的为 4096KB，平均值是 0.27KB。</p><p>此外，还有细分的每类 objects 的信息，比如从"inode cache"可以得知打开了 9150 个文件，从"vm_area_struct"可以得知所有进程一共使用了 2140 个 VMA。并且，还能大致知道每类 object 的控制结构的大小，比如一个"struct dentry"大约占据 0.19KB 的内存空间。</p><p>虽然没有 per-slab 包含的 pages 数目信息，不过完全可以通过"OBJ/SLAB"乘以"SIZE"计算出来。比如通过这种方法算出来"dentry"的就是大约 4KB，说明每个"dentry"的 slab 包含一个 page frame。</p><p>其更重要的意义是体现在调试的时候：当你发现当前内存资源比较紧张，通过"/proc/meminfo"查到是"Slab"占据了较大内存，根据"slabtop"就可以快速知道是哪一类 object 消耗的最多（比如建立了过多的 socket）。</p><p>"slabtop"其实和可以显示 CPU 和内存占用率的"top"命令是类似的，都是动态地显示目前资源占用率最高的，只不过"top"针对的是进程，而"slabtop"针对的是"caches"。如果要获取全部"caches"的信息，应查看"/proc/slabinfo"文件。</p><h2 id="创建和初始化">创建和初始化</h2><p>创建一个新的"cache"的函数接口是 kmem_cache_create()，主要就是为"kmem_cache"的控制结构分配内存空间并初始化。而这个控制结构本身也是一个内核 object，按理也应该从 slab cache 中获取，那第一个"kmem_cache"从哪里来？这就形成了一个“先有鸡还是先有蛋”的问题，解决的办法是在 slab 子系统生效之前的启动阶段，用一段特殊的 boot cache 来分配。</p><p>"cache"创建后，一开始不含有任何的 slab，也就没有任何空闲的 objects，只有当产生分配一个新的 object 的需求时，才开始创建 slab。创建一个 slab 除了需要分配容纳 objects 的内存（相当于 user data），还需要生成管理这个 slab 的控制信息（相当于 meta data，这里称为 slab descriptor）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab7.jpg"></p><p>一个 slab 区域包括若干个大小相同的 objects，以及它们的 coloring 消耗的字节。一个"cache"的多个 slabs 通过双向链表连接，因而需要存储链表指针的空间。</p><p>根据 object 的大小不同，slab descriptor 本身占据的内存可以位于其管理的 slab 内存区域内部，也可以位于外部（off-slab） 。当位于内部时，链表指针存储在一个 slab 区域的末尾。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OFF_SLAB(cachep)) {</span><br><span class="line">    <span class="comment">/* Slab management obj is off-slab */</span></span><br><span class="line">    freelist = kmem_cache_alloc_node(cachep-&gt;freelist_cache, ...);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">/* We will use last bytes at the slab for freelist */</span></span><br><span class="line">    freelist = addr + (PAGE_SIZE &lt;&lt; cachep-&gt;gfporder) - cachep-&gt;freelist_size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分配-object">分配 object</h2><p>内核编程中如果需要申请在物理上连续的内存，最常用的函数就是 kmalloc() 了，而它的底层实现依靠的正是 slab cache。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *__do_kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, ...)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cachep</span> =</span> kmalloc_slab(size, flags);</span><br><span class="line">    <span class="type">void</span> * ret = slab_alloc(cachep, flags, ...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果传入的参数是"sizeof(struct inode)"这样的，可能刚好有 object 大小完全匹配的 cache。如果参数是一个普通的整数（比如 100），那就需要遍历 cache，并进行一定的计算，以寻找最合适的。</p><h3 id="第一级分配fast-path">第一级分配（fast path）</h3><p>每个"kmem_cache"除了包含多个 slabs 外，还包含一组"cpu_cache"，这是一种 per-CPU 的 cache，是 slab 的 cache。这么说可能有点绕口，其实就是一个软件层面的二级 cache。拿硬件 cache 来类比，"cpu_cache"就是 L1 cache，slab 就是 L2 cache。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> __<span class="title">percpu</span> *<span class="title">cpu_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> avail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="type">void</span> *entry[];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>"entry[]"表示了一个遵循 LIFO 顺序的数组（Last In, First Out），"avail"和"limit"分别指定了当前可用 objects 的数目和允许容纳的最大数目。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab8.jpg"></p><p>每当 object 试图从 slab 中分配内存时，都先从所在 CPU 对应的"entry[]"数组中获取。per-CPU 的设计可以减少 SMP 系统对全局 slab 的锁的竞争，一些 CPU bound 的线程尤其适合使用 CPU bound 的内存分配。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *____cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span><br><span class="line">{</span><br><span class="line">    <span class="type">void</span> *objp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span> =</span> cpu_cache_get(cachep);</span><br><span class="line">    <span class="keyword">if</span> (likely(ac-&gt;avail)) {</span><br><span class="line">        objp = ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line">        <span class="keyword">return</span> objp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    objp = cache_alloc_refill(cachep, flags);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二级分配slow-path">第二级分配（slow path）</h3><p>如果在申请时数组为空，那么就需要从全局的 slab 中 refill，那选择哪个 slab 呢？为了减少内存碎片，一个 cache 的 slabs 在每个内存 node 中（per-node），根据使用状态被分成了三类：</p><ul><li>全部分配完，没有空闲 objects 的 full slabs。</li><li>分配了一部分，尚有部分空闲的 partial slabs。</li><li>完全空闲可用的 free slabs。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>应首先从 partial slabs 中选择，等 partial slabs 都满了，成为了 full slab，这时再从 free slabs 中选择。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab9.jpg"></p><p>又是 per CPU，又是 per node，在大型系统中，这是一笔不小的开销。</p><h3 id="第三级分配very-slow-path">第三级分配（very slow path）</h3><p>如果一个 cache 连 free slab 都没有了，那就需要新增一个 slab 来“扩容”了。新增 slab 的方法在上文已经介绍过了，最终是向 buddy 系统申请，回到这篇文章描述的 page level 分配器的代码路径。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab10.jpg"></p><h2 id="释放-object">释放 object</h2><p>释放时也归还到所在 CPU 的"cpu_cache"数组，如果释放导致数组溢出，则数组中的一部分 entries 将被返还到全局的 slab 中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ___cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp, ..)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span> =</span> cpu_cache_get(cachep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;avail &gt;= ac-&gt;limit) {</span><br><span class="line">        <span class="comment">// 归还到对应的 slab</span></span><br><span class="line">        cache_flusharray(cachep, ac);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ac-&gt;entry[ac-&gt;avail++] = objp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们平时常调用的接口是 kfree()，只有一个表示地址的参数，那如何知道应该归还到哪个 slab 中？寻找的方法是首先根据 object 的虚拟地址找到 object 所在的 page frame，进而找到这个 page frame 所在 compound page 的中的 head page，而 head page 中的"slab_cache"指针就指向了这个 object 所属的 slab。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">c</span> =</span> virt_to_cache(objp);</span><br><span class="line">    __cache_free(c, (<span class="type">void</span> *)objp, _RET_IP_);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">virt_to_cache</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> virt_to_head_page(obj);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;slab_cache;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">virt_to_head_page</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// object 所在的 page frame</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> virt_to_page(x);</span><br><span class="line">    <span class="comment">// 所在 compound page 的 head page</span></span><br><span class="line">    <span class="keyword">return</span> compound_head(page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>借助这条路径，进而还可以知道一个 object 的大小。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> __ksize(<span class="type">const</span> <span class="type">void</span> *objp)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">c</span>=</span> virt_to_cache(objp);</span><br><span class="line">    <span class="type">size_t</span> size = c ? c-&gt;object_size : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结">小结</h2><p>至此，slab 分配器的原理和在 Linux 中的实现就粗略的介绍完了，可以借助下面这张图来一览它的构成，包括 kernel object, page frame 和 slab cache 的关系，物理内存的组织和分配等。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/slab11.jpg"></p><p>slab 分配器对内存的利用率是比较高的，因为充分借助了各种缓存机制，分配和释放的速度也比较理想。存在的缺点就是要为内核中众多的 objects 维护独立的 cache，这会带来相当的管理上的开销。</p><h1 id="kmalloc">kmalloc</h1><p>内核中常用的 kmalloc() 函数的核心实现是 slab 机制。类似于伙伴系统机制，在内存块中按照$ 2^{order} $字节来创建多个 slab 描述符，如 16 字节、32 字节、64 字节、128 字节等大小，系统会分别创建 kmalloc-16、kmalloc-32、kmalloc-64 等 slab 描述符，在系统启动时这在 create_kmalloc_caches() 函数中完成。例如，要分配 30 字节的一个小内存块，可以用“kmalloc(30，GFP_KERNEL) 实现，之后系统会从 kmalloc-32 slab 描述符中分配一个对象。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) {</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!index)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">flags, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>kmalloc_index 可以用于查找使用的是哪个 slab 缓冲区，这很形象的展示了 kmalloc 的设计思想。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kmalloc_index(s) __kmalloc_index(s, true)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">int</span> __kmalloc_index(<span class="type">size_t</span> size,</span><br><span class="line">    <span class="type">bool</span> size_is_constant)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line"><span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((IS_ENABLED(CONFIG_CC_IS_GCC) || CONFIG_CLANG_VERSION &gt;= <span class="number">110000</span>)</span><br><span class="line">    &amp;&amp; !IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)</span><br><span class="line">BUILD_BUG_ON_MSG(<span class="number">1</span>, <span class="string">"unexpected size in kmalloc_index()"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BUG();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与 vmalloc 区别（都是分配内核空间内存）：</p><ul><li>kmalloc 分配物理连续的地址，而 vmalloc 分配虚拟地址连续的空间。</li><li>kmalloc 可以通过 gfp_mask 标志控制分配内存时不能休眠，因此可以用于中断上下文（softirq 和 tasklet 也处于中断上下文），而 vmalloc 的调用可能引起睡眠不能用于中断上下文。</li><li>kmalloc 性能更好（内核空间更多实用这个函数），而 vmalloc 为了把物理上不连续的页转换为虚拟地址空间上连续的页，需要建立专门的页表项，会导致 TLB 抖动等问题，性能不佳（主要用于用户空间分配内存）。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYxMDYwMDg=">https://zhuanlan.zhihu.com/p/106106008<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（五）页面分配器</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryPageAllocate/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryPageAllocate/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryPageAllocate.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM3MmRhZDA3OTEyOTA2ZjUwYTdmYWI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><p>分配物理页面是内存管理中最复杂的部分，它涉及页面回收、内存规整、直接回收内存等相当错综复杂的机制。本节关注在内存充足的情况下如何分配连续物理内存。</p><h1 id="page-数据结构">page 数据结构</h1><p>Linux 内核内存管理的实现以 page 数据结构为核心，其他的内存管理设施都基于 page 数据结构，如 VMA 管理、缺页中断、RMAP、页面分配与回收等。page 数据结构定义在 include/linux/mm_types.h 头文件中。</p><h2 id="refcount-_refcount-和__mapcount-是-page-数据结构中非常重要的两个引用计数且都是-atomic_t-类型的变量-_refcount-表示内核中引用该页面的次数">_refcount _refcount 和__mapcount 是 page 数据结构中非常重要的两个引用计数，且都是 atomic_t 类型的变量。 _refcount 表示内核中引用该页面的次数。</h2><ul><li>当_refcount 的值为 0 时，表示该页面为空闲页面或即将要被释放的页面</li><li>当_refcount 的值大于 0 时，表示该页面已经分配给内核正在使用，暂时不会被释放</li></ul><h2 id="mapcount-_mapcount-表示这个页面被进程映射的个数即已经映射了多少个用户-pte每个用户进程都拥有各自独立的虚拟空间256tb和一份独立的页表所以可能出现多个用户进程地址空间同时映射到一个物理页面的情况rmap-系统就是利用这个特性来实现的_mapcount-主要用于-rmap-系统中">_mapcount _mapcount 表示这个页面被进程映射的个数，即已经映射了多少个用户 PTE。每个用户进程都拥有各自独立的虚拟空间（256TB）和一份独立的页表，所以可能出现多个用户进程地址空间同时映射到一个物理页面的情况，RMAP 系统就是利用这个特性来实现的。_mapcount 主要用于 RMAP 系统中。</h2><ul><li>若_mapcount 等于-1，表示没有 PTE 映射到页面</li><li>若_mapcount 等于 O，表示只有父进程映射到页面。匿名页面刚分配时，_mapcount 初始化为 O。例如，当 do_anonymous_page() 产生的匿名页面通过 page_add_new_anonrmap() 添加到 rmap 系统中时，会设置_mapcount 为 O，这表明匿名页面当前只有父进程的 PTE 映射到页面</li></ul><h2 id="rmap">RMAP</h2><p>用户进程在使用虚拟内存过程中，从虚拟内存页面映射到物理内存页面时，PTE 保留了这个记录。page 数据结构中的_mapcount 记录有多少个用户 PTE 映射到物理页面。有的页面需要迁移，有的页面需要交换到磁盘，在交换之前，必须找出哪些进程使用这个页面，然后解除这些映射的用户 PTE。</p><p>RMAP 的主要目的是从物理页面的 page 数据结构中找到有哪些映射的用户 PTE，这样页面回收模块就可以很快速和高效地把这个物理页面映射的所有用户 PTE 正都解除并回收这个页面。</p><p>RMAP 的典型应用场景如下。</p><ul><li>kswapd 内核线程为了回收页面，需要断开所有映射到该匿名页面的用户 PTE</li><li>页面迁移时，需要断开所有映射到匿名页面的用户 PTE</li></ul><h1 id="分配物理页面的接口函数扩展">分配物理页面的接口函数（扩展🙈）</h1><p>内核中分配物理内存页面的常用接口函数是 alloc_pages()，它用于分配一个或者多个连续的物理页面，分配的页面个数只能是 2 的整数次幂。</p><h2 id="分配物理页面的核心接口函数">分配物理页面的核心接口函数</h2><p>aloc_pages() 函数的参数有两个，gfp_mask 表示分配掩码，order 表示分配级数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/gfp.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>);</span></span><br></pre></td></tr></tbody></table></figure><p>alloc_paes() 函数用来分配 2 的 order 次幂个连续的物理页面，返回值是第一个物理页面 page 数据结构。第一个参数是 gfp_mask：第二个参数是 order，请求的 order 需要小于 MAX_ORDER，MAX_ORDER 通常默认是 11。 另一个很常见的接口函数是__get_free_pages()，其定义如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mm/page_alloc.c&gt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>) page_address(page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>__get_free_pages() 函数返回的是所分配内存的内核空间虚拟地址。如果所分配内存是线性映射的物理内存，则直接返回线性映射区域的内核空间虚拟地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="分配一个物理页面">分配一个物理页面</h2><p>如果需要分配一个物理页面，可以使用如下两个封装好的接口函数，它们最后仍调用 alloc_pages()，只是 order 的值为 0.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_pages_vma(gfp_mask, order, vma, addr, node, false)\</span></span><br><span class="line"><span class="meta">alloc_pages(gfp_mask, order)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __get_free_page(gfp_mask) \</span></span><br><span class="line"><span class="meta">__get_free_pages((gfp_mask), 0)</span></span><br></pre></td></tr></tbody></table></figure><p>如果需要返回一个全填充为 0 的页面，可以使用如下接口函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> __get_free_pages(gfp_mask | __GFP_ZERO, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 alloc_page() 分配的物理页面理论上可能被随机地填充了某些垃圾信息，因此在有些敏感的场合下需要先把分配的内存清零再使用，这样可以减少不必要的麻烦。</p><h2 id="页面释放函数">页面释放函数</h2><p>页面释放函数主要有如下几个。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __free_page(page) __free_pages((page), 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free_page(addr) free_pages((addr), 0)</span></span><br></pre></td></tr></tbody></table></figure><p>释放时需要特别注意参数，传递错误的 page 指针或者错误的 order 值会引起系统崩溃。</p><h1 id="分配掩码">分配掩码</h1><p>分配掩码是描述页面分配方法的标志，它影响着页面分配的整个流程。因为 Linux 内核是一个通用的操作系统，所以页面分配器被设计成一个复杂的系统。它既要高效，又要兼顾很多种情况，特别是在内存紧张的情况下的内存分配。gfp_mask 其实被定义成一个 unsigned 类型的变量。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __bitwise__ <span class="type">gfp_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>gfp_mask 定义在 include/inux/gfp.h 文件中。修饰符在 Linux4.4 内核中被重新归类，大致可以分成如下几类。</p><ul><li>内存管理区修饰符（zone modifier）</li><li>移动修饰符（mobility and placement modifier）</li><li>水位修饰符（watermark modifier）</li><li>页面回收修饰符（page reclaim modifier）</li><li>行为修饰符（action modifier）</li></ul><p>下面详细介绍各种修饰符的标志。</p><h2 id="内存管理区修饰符的标志">内存管理区修饰符的标志</h2><p>内存管理区修饰符主要用于表示应当从哪些内存管理区中来分配物理内存。内存管理区修饰符使用 gfp_mask 的低 4 位来表示，其标志如下所示。</p><ul><li>__GFP_DMA: 从 ZONE_DMA 中分配内存</li><li>__GFP_DMA32: 从 ZONE DMA32 中分配内存</li><li>__GFP_HIGHMEM: 优先从 ZONE_HIGHMEM 中分配内存</li><li>__GFP_MOVABLE: 页面可以被迁移或者回收，如用于内存规整机制</li></ul><h2 id="移动修饰符的标志">移动修饰符的标志</h2><p>移动修饰符主要用于指示分配出来的页面具有的迁移属性，其标志如下所示。在 Linux2.6.24 内核中，为了解决外碎片化的问题，引入了迁移类型，因此在分配内存时需要指定所分配的页面具有哪些迁移属性。</p><ul><li>__GFP_RECLAIMABLE: 在 slab 分配器中指定了 SLAB_RECLAIM_ACCOUNT 标志位，表示 slab 分配器中使用的页面可以通过收割机来回收</li><li>__GFP_HARDWALL: 使能 cpuset 内存分配策略</li><li>__GFP_THISNODE: 从指定的内存节点中分配内存，并且没有回退机制</li><li>__GFP_ACCOUNT: 分配过程会被 kmemcg 记录</li></ul><h2 id="水位修饰符的标志">水位修饰符的标志</h2><p>水位修饰符用于控制是否可以访问系统预留的内存。所谓系统预留内存指的是最低警戒水位以下的内存，一般优先级的分配请求是不能访问它们的，只有高优先级的分配请求才能访问，如__GFP_HIGH、__GFP_ATOMIC 等。水位修饰符的标志如下所示。</p><ul><li>__GFP_HIGH: 表示分配内存具有高优先级，并且这个分配请求是很有必要的，分配器可以使用系统预留的内存（即最低警戒水位线下的预留内存）</li><li>__GFP_ATOMIC: 表示分配内存的过程不能执行页面回收或者睡眠动作，并且具有很高的优先级，可以访问系统预留的内存。常见的一个场景是在中断上下文中分配内存</li><li>__GFP_MEMALLOC: 分配过程中允许访问所有的内存，包括系统预留的内存。分配内存进程通常要保证在分配内存过程中很快会有内存被释放，如进程退出或者页面回收</li><li>__GFP_NOMEMALLOC: 分配过程不允许访问系统预留的内存</li></ul><h2 id="页面回收修饰符的标志">页面回收修饰符的标志</h2><p>页面回收修饰符的常用标志如下所示。</p><ul><li>__GFP_IO: 允许开启 I/O 传输</li><li>__GFP_FS: 允许调用底层的文件系统。这个标志清零通常是为了避免死锁的发生，如果相应的文件系统操作路径上已经持有了锁，分配内存过程又递归地调用这个文件系统的相应操作路径，可能会产生死锁</li><li>__GFP_DIRECT_RECLAIM: 分配内存的过程中允许使用页面直接回收机制</li><li>__GFP_KSWAPD_RECLAIM: 表示当到达内存管理区的低水位时会唤醒 kswapd 内核线程，以异步地回收内存，直到内存管理区恢复到了高水位为止</li><li>__GFP_RECLAIM: 用于允许或者禁止直接页面回收和 kswapd 内核线程</li><li>__GFP_REPEAT: 当分配失败时会继续尝试</li><li>__GFP_NOFAIL: 当分配失败时会无限地尝试下去，直到分配成功为止。当分配者希望分配内存不失败时，应该使用这个标志位，而不是自己写一个 while 循环来不断地调用页面分配接口函数</li><li>__GFP_NORETRY: 当使用了直接页面回收和内存规整等机制还无法分配内存时，最好不要重复尝试分配了，直接返回 NULL</li></ul><h2 id="行为修饰符的标志">行为修饰符的标志</h2><p>行为修饰符的常见标志如下所示。</p><ul><li>__GFP_COLD: 分配的内存不会马上被使用。通常会返回一个空的高速缓存页面</li><li>__GFP_NOWARN: 关闭分配过程中的一些错误报告</li><li>__GFP_ZERO: 返回一个全部填充为 0 的页面</li><li>__GFP_NOTRACK: 不被 kmemcheck 机制跟踪</li><li>__GFP_OTHER_NODE: 在远端的一个内存节点上分配。通常在 khugepaged 内核线程中使用</li></ul><p>前文列出了 5 大类修饰符的标志，对于内核开发者或者驱动开发者来说，要正确使用这些标志是一件很困难的事情，因此定义了一些常用的标志的组合类型标志（type flag），如下所示。类型标志提供了内核开发中常用的标志的组合，推荐开发者使用这些类型标志。</p><ul><li>GFP_KERNEL: 内核分配内存常用的标志之一。它可能会被阻塞，即分配过程中可能会睡眠</li><li>GFP_ATOMIC: 调用者不能睡眠并且保证分配会成功。它可以访问系统预留的内存</li><li>GFP_NOWAIT: 分配中不允许睡眠等待</li><li>GFP_NOFS: 不会访问任何的文件系统的接口和操作</li><li>GFP_NOIO: 不需要启动任何的 I/O 操作。如使用直接回收机制丢弃干净的页面或者为 slab 分配的页面</li><li>GFP_USER: 通常用户空间的进程用来分配内存，这些内存可以被内核或者硬件使用。常用的一个场景是硬件使用的 DMA 缓冲器要映射到用户空间，如显卡的缓冲器</li><li>GFP_DMA/ GFP_DMA32: 使用 ZONE_DMA 或者 ZONE_DMA32 来分配内存</li><li>GFP_HIGHUSER: 用户空间进程用来分配内存，优先使用 ZONE_HIGHMEM，这些内存可以映射到用户空间，内核空间不会直接访问这些内存。另外，这些内存不能迁移</li><li>GFP_HIGHUSER_MOVABLE: 类似于 GFP_HIGHUSER，但是页面可以迁移</li><li>GFP_TRANSHUGE / GFP_TRANSHUGE_LIGHT: 通常用于透明页面分配</li></ul><p>上面这些都是常用的类型标志，在实际使用过程中需要注意以下事项。</p><ul><li>GFP_KERNEL 主要用于分配内核使用的内存，在分配过程中会引起睡眠，在中断上下文和不能睡眠的内核路径里使用该类型标志需要特别警惕，因为这会引起死锁或者其他系统异常。</li><li>GFP_ATOMIC 正好和 GFP_KERNEL 相反，它可以使用在不能睡眠的内存分配路径（如中断处理程序、软中断以及 tasklet 等）中。GFP_KERNEL 可以让调用者睡眠等待系统页面回收来释放一此内存，但 GFP_ATOMIC 不可以，所以可能会分配失败。</li><li>GFP_USER、 GFP_HIGHUSER 和 GFP_HIGHUSER_MOVABLE 这几个类型标志都是为用户空间进程分配内存的。不同之处在于，GFP_HIGHUSER 首先使用高端内存，GFP_HIGHUSER MOVABLE 优先使用高端内存并且分配的内存具有可移动属性。</li><li>GFP_NOIO 和 GFP_NOFS 都会产生阻塞，它们用于避免某些其他的操作。GFPNOIO 表示分配过程中绝不会启动任何磁盘 I/O 的操作。GFP_NOFS 表示可以启动磁盘 I/O，但是不会启动文件系统的相关操作。举一个例子，假设进程 A 在执行打开文件的操作中需要分配内存但内存短缺，那么进程 A 会睡眠等待，系统的 OOM Killer 机制会选择一个进程来终止。假设选择了进程 B，而进程 B 退出时需要执行一些文件系统的操作，这些操作可能会申请锁，而恰巧进程 A 持有这个锁，所以死锁就发生了。</li><li>GFP_KERNEL 分配的页面通常是不可迁移的，GFP_HIGHUSER_MOVABLE 分配的页面是可迁移的。</li></ul><h1 id="alloc_pages-函数">alloc_pages() 函数</h1><p>下面以 GFP_KERNEL 为例，看在理想情况下 alloc_pages() 函数是如何分配物理内存的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">《分配物理内存的例子》</span><br><span class="line">page = alloc_pages(GFP_KERNEL, order);</span><br></pre></td></tr></tbody></table></figure><p>GFP_KERNEL 类型标志定义在 gfp.h 头文件中，是一个标志组合。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL(__GFP_RECLAIM | __GFP_IO | __GFP_FS)</span></span><br></pre></td></tr></tbody></table></figure><p>所以 GFP_KERNEL 类型标志包含了__GFP_RECLAIM、__GFP_IO 和__GFP_FS 这 3 个标志，其地址换算成十六进制是 0x60 00 C0。</p><p>其函数流程如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/alloc_pages.png"></p><h1 id="小结">小结</h1><p>页面分配器是 Linux 内核内存管理中最基本的分配器，伙伴系统分配页面就是使用该方法，理解页面分配器需要关注如下几个方面。</p><ul><li>从分配掩码中知道可以从哪些 zone 中分配内存，分配内存的属性属于哪些 MIGRATE_TYPES 类型。</li><li>页面分配时应从哪个方向来扫描 zone。</li><li>zone 水位的判断。</li></ul><p>本节介绍了理想情况下页面分配器如何分配物理页面，但是在 Linux 内核处于内存短缺的情况下又该如何分配内存呢？这涉及内存管理中最难的几个主题，如页面回收、直接内存回收内存规整和 OOM Killer 机制等。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（四）虚拟内存管理</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryPageMngr/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryPageMngr/</url>
      
        <content type="html"><![CDATA[<h1 id="页表寻址过程">页表寻址过程</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/pagefindAddress.png"></p><p>这里就是 cpu 将一个虚拟地址转换为物理地址的过程，整个过程是比较繁琐耗时的，因此这个过程一般在一个专门的硬件中完成就是 MMU、MMU 中为了可以加快速度引入了 TLB cache 快速查找 pte。我们需要注意到一点就是到了 PTE 这一级需要提供的是物理地址的页起始地址，这个地址是以 page size 为单位的，对于 4k 的 page，那么 pte 的低 12bit 就是没有使用的，而这 12bit 就正好用来作为 page 的权限控制位，对于 ARM64（39bit va）其高位 [40-63] 也没有使用因此也可以用来做一些其他事情。这里来看看 arm-v8 对低 12bit 的定义：</p><span id="more"></span><p>《Architecture Reference Manual ARMv8, for ARMv8-A architecture profile》里的 D4.3.2 ARMv8 translation table level 3 descriptor formats 一节中有相关描述： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/VMSAV8-64.png"></p><p>ARM-v8 支持 5 种 L3 页表格式，其中我们关心的是 Page 4K granule 这一种，对此有如下说明：</p><ul><li><strong>Bit 0：</strong> Value bit，1 is valued and 0 is invaled</li><li><strong>Bit 1：</strong> identifies the descriptor type； 0 is Reserved, invalid and 1 is Page<ul><li><p><strong>4KB translation granule</strong></p><p>Bits[47:12] are bits[47:12] of the output address for a page of memory.</p></li><li><p><strong>16KB translation granule</strong></p><p>Bits[47:14] are bits[47:14] of the output address for a page of memory.</p></li><li><p><strong>64KB translation granule</strong></p><p>Bits[47:16] are bits[47:16] of the output address for a page of memory.</p></li></ul></li><li><p><strong>Lower attributes：</strong>（Attribute fields in stage 1 VMSAv8-64 Block and Page descriptors） <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AttributeFieldsForVMSAv8.png"></p></li><li><p><strong>UXN or XN, bit[54] （</strong>页面在用户模式下不能执行<strong>）</strong></p><p>This bit is called UXN (Unprivileged execute never) in the EL1&amp;0 translation regime, where it only determines whether execution at EL0 of instructions fetched from the region is permitted. In the other translation regimes the bit is called XN (Execute never).</p></li><li><p>**PXN, bit<a href="**该页面在特权模式下不能执行">53</a></p><p>The Privileged execute-never bit. Determines whether the region is executable at EL1。</p></li><li><p><strong>Contiguous, bit[52] （</strong>表示当前页表项处在一个连续物理页面集合中，可以使用一个单一的 TLB 表项进行优化<strong>）</strong></p><p>A hint bit indicating that the translation table entry is one of a contiguous set or entries, that might be cached in a single TLB entry。</p></li><li><p><strong>nG, bit<a href="非全局比特位，**用于%20TLB%20管理。TLB%20的表项分成全局的和进程持有的。当设置该比特位时表示这个页面对应的%20TLB%20表项是进程持有的**">11</a></strong></p><p>The not global bit. Determines whether the TLB entry applies to all ASID values, or only to the current ASID value。</p></li><li><p>**AF, bit<a href="**当第一次访问页面时硬件会自动设置这个访问比特位">10</a></p><p>The Access flag。</p></li><li><p><strong>SH 内存缓存共享属性</strong></p><p>Shareability field</p><ul><li>00：没有共享</li><li>01：保留</li><li>10：Outer Shareable</li><li>11：Inner Shareable</li></ul></li><li><strong>AP[2:1]</strong><ul><li>AP[1]: 表示该内存允许用户权限 (EL0) 还是更高权限的特权异常等级 (EL1) 来访问。<ul><li>1：表示可以被 EL0 以及更高特权的异常等级访问</li><li>0：表示不能被 EL0 访问，但是可以被 EL1 访问</li></ul></li><li>AP[2]: 只读权限还是可读可写权限<ul><li>1：表示只读</li><li>0：表示可读可写</li></ul></li></ul><p>Data Access Permissions bits</p></li><li><p><strong>NS, bit[5] （</strong>非安全比特位。当处于安全模式时用来指定访问的内存地址是安全映射的还是非安全映射的<strong>）</strong></p><p>Non-secure bit. For memory accesses from Secure state, specifies whether the output address is in the Secure or Non-secure address map</p></li><li><p><strong>AttrIndx[2:0], bits<a href="内存的属性、设备内存、普通内存等">4:2</a></strong></p><p>Stage 1 memory attributes index field</p><ul><li>0：DEVICE_nGnRnE</li><li>1：DEVICE_nGnRE</li><li>2：DEVICE_GRE</li><li>3：NORMAL_NC</li><li>4：NORMAL</li><li>5：NORMAL_WT</li></ul></li></ul><h1 id="在-linux-下的定义">在 linux 下的定义</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable-hwdef.h&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Level 3 descriptor (PTE).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_VALID(_AT(pteval_t, 1) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TYPE_MASK(_AT(pteval_t, 3) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TYPE_PAGE(_AT(pteval_t, 3) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TABLE_BIT(_AT(pteval_t, 1) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_USER(_AT(pteval_t, 1) &lt;&lt; 6)<span class="comment">/* AP[1] */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_RDONLY(_AT(pteval_t, 1) &lt;&lt; 7)<span class="comment">/* AP[2] */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SHARED(_AT(pteval_t, 3) &lt;&lt; 8)<span class="comment">/* SH[1:0], inner shareable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_AF(_AT(pteval_t, 1) &lt;&lt; 10)<span class="comment">/* Access Flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_NG(_AT(pteval_t, 1) &lt;&lt; 11)<span class="comment">/* nG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_GP(_AT(pteval_t, 1) &lt;&lt; 50)<span class="comment">/* BTI guarded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_DBM(_AT(pteval_t, 1) &lt;&lt; 51)<span class="comment">/* Dirty Bit Management */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_CONT(_AT(pteval_t, 1) &lt;&lt; 52)<span class="comment">/* Contiguous range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PXN(_AT(pteval_t, 1) &lt;&lt; 53)<span class="comment">/* Privileged XN */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_UXN(_AT(pteval_t, 1) &lt;&lt; 54)<span class="comment">/* User XN */</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="整体初始化流程">整体初始化流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/VMMstartKernel.png"></p><h1 id="idmp-映射恒等映射为了开启-mmu">idmp 映射（恒等映射，为了开启 MMU）</h1><p>text：__idmap_text_start~__idmap_text_end</p><p>data：idmap_pg_dir~idmap_pg_end</p><p>一旦启动 MMU 就需要使用虚拟地址，现代处理器大多数是多级流水线，处理器会提前预取多条指令到流水线中，打开 MMU 时，这些指令都是物理地址预取的；在 MMU 开启后，将以虚拟地址访问，这样就会出错，所以引入了“恒等映射”，即在过渡阶段的代码，虚拟地址和物理地址相等。恒等映射完成后，就启动 MMU，进入虚拟地址访问阶段。恒等映射的代码在 __idmap_text_start~__idmap_text_end，可以从 System.map 文件中查询到。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ffffffc081206000 T __idmap_text_start</span><br><span class="line">ffffffc081206000 t enter_vhe</span><br><span class="line">ffffffc081206038 T cpu_resume</span><br><span class="line">ffffffc081206068 T primary_entry</span><br><span class="line">ffffffc0812060a8 T init_kernel_el</span><br><span class="line">ffffffc0812060b8 t init_el1</span><br><span class="line">ffffffc0812060e0 t init_el2</span><br><span class="line">ffffffc0812062f0 T secondary_holding_pen</span><br><span class="line">ffffffc081206318 t pen</span><br><span class="line">ffffffc081206330 T secondary_entry</span><br><span class="line">ffffffc081206340 t secondary_startup</span><br><span class="line">ffffffc081206368 T __enable_mmu</span><br><span class="line">ffffffc0812063b0 T __cpu_secondary_check52bitva</span><br><span class="line">ffffffc0812063b8 t __no_granule_support</span><br><span class="line">ffffffc0812063e0 t __relocate_kernel</span><br><span class="line">ffffffc081206430 t __primary_switch</span><br><span class="line">ffffffc0812064a0 T idmap_cpu_replace_ttbr1</span><br><span class="line">ffffffc0812064d0 T idmap_kpti_install_ng_mappings</span><br><span class="line">ffffffc08120667c t __idmap_kpti_secondary</span><br><span class="line">ffffffc0812066c8 T __cpu_setup</span><br><span class="line">ffffffc0812067bc T __idmap_text_end</span><br></pre></td></tr></tbody></table></figure><p>恒等映射目的就是为__idmap_text_start~__idmap_text_end 这段代码创建一个映射页表，使其虚拟地址和物理地址是相等的。在 vmlinux.lds.S 中，事先已经分配了 IDMAP_DIR_SIZE 的空间用于存储页表，通常页表为 3 个连续的 4KB 页面，分别对于 PGD,PUD,PMD 页表，这里没有使用 PTE，所以粒度是 2MB 的大小。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_idmap_pg_dir = .;</span><br><span class="line">. += INIT_IDMAP_DIR_SIZE;</span><br><span class="line">init_idmap_pg_end = .;</span><br></pre></td></tr></tbody></table></figure><h1 id="粗粒度的内核映像映射为了进入内核空间">粗粒度的内核映像映射（为了进入内核空间）</h1><p>text: kernel_text</p><p>data：init_pg_dir~init_pg_end（定义在 arch/arm64/kernel/vmlinux.lds.S 链接文件中）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init_pg_dir = .;</span><br><span class="line">. += INIT_DIR_SIZE;</span><br><span class="line">init_pg_end = .;</span><br><span class="line">/* end of zero-init region */</span><br></pre></td></tr></tbody></table></figure><p>之所以要创建第二个页表，是因为 cpu 刚启动时，物理内存一般都在低地址（不会超过 256TB），恒等映射的地址实际也在用户空间，即 MMU 启用后 idmap_pg_dir 会填入 TTBR0，而内核空间链接地址（虚拟地址）都是在高地址，需要填入 TTBR1，因此需要再创建一张表，映射整个内核镜像，且虚拟地址空间是在高地址 0xffff xxxx xxxx xxxxarch/arm64/kernel/head.S:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adrp x1, _text</span><br><span class="line">adrp x2, init_pg_dir</span><br><span class="line">adrp x3, init_pg_end</span><br><span class="line">bic x4, x2, #SWAPPER_BLOCK_SIZE - 1</span><br><span class="line">mov_q x5, SWAPPER_RW_MMUFLAGS</span><br><span class="line">mov x6, #SWAPPER_BLOCK_SHIFT</span><br><span class="line">bl remap_region</span><br></pre></td></tr></tbody></table></figure><h2 id="流程">流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/primaryEntry.png"></p><h1 id="fixmap-映射">fixmap 映射</h1><p>Linux 内核要访问物理内存，一旦开启 MMU 后，就只能通过虚拟地址查询页表找到物理地址进行访问，上一章节中建立恒等映射和粗粒度内核映像映射的页表，因此只能保证内核镜像正常访问。如果要解析 DTB，访问设备 I/O 等依然是无法访问的，因为查询不到对应的页表。因此内核引入了 fixmap 机制，就是事先分配一段虚拟地址空间，然后给定其虚拟地址创建好页表，页表中的表项最后一级指向的物理页帧号先不填充，等到实际要访问那段物理内存后再将其填充，然后通过 fixmap 这段虚拟地址范围就可以通过查询页表访问到物理内存。 Fixmap 最关键要实现的目的就是将一段空间的虚拟地址与物理地址对应上，linux 内核通过虚拟地址访问到物理空间，那既然是通过虚拟地址访问到物理地址，那必须构建填充这段虚拟地址到物理地址的页表，这样 Linux 内核经过 MMU 利用查找页表找到对应的物理地址进行访问。</p><p>fixmap 虚拟地址空间又被平均分成两个部分 permanent fixed addresses 和 temporary fixed addresses。permanent fixed addresses 是永久映射，temporary fixed addresses 是临时映射。永久映射是指在建立的映射关系在 kernel 阶段不会改变，仅供特定模块一直使用。临时映射就是模块使用前创建映射，使用后解除映射。</p><p>fixmap 区域又被继续细分，分配给不同模块使用。kernel 中定义枚举类型作为 index，根据 index 可以计算该模拟在 fixmap 区域的虚拟地址。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fixed_addresses</span> {</span></span><br><span class="line">FIX_HOLE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reserve a virtual window for the FDT that is a page bigger than the</span></span><br><span class="line"><span class="comment"> * maximum supported size. The additional space ensures that any FDT</span></span><br><span class="line"><span class="comment"> * that does not exceed MAX_FDT_SIZE can be mapped regardless of</span></span><br><span class="line"><span class="comment"> * whether it crosses any page boundary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FIX_FDT_END,</span><br><span class="line">FIX_FDT = FIX_FDT_END + DIV_ROUND_UP(MAX_FDT_SIZE, PAGE_SIZE) + <span class="number">1</span>, <span class="comment">// 映射设备树使用。在 ARM64 架构，大小是 4M</span></span><br><span class="line"></span><br><span class="line">FIX_EARLYCON_MEM_BASE, <span class="comment">// console 使用，大小 1 页。1 页虚拟地址空间完全够了</span></span><br><span class="line">FIX_TEXT_POKE0,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ACPI_APEI_GHES</span></span><br><span class="line"><span class="comment">/* Used for GHES mapping from assorted contexts */</span></span><br><span class="line">FIX_APEI_GHES_IRQ,</span><br><span class="line">FIX_APEI_GHES_SEA,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_SDE_INTERFACE</span></span><br><span class="line">FIX_APEI_GHES_SDEI_NORMAL,</span><br><span class="line">FIX_APEI_GHES_SDEI_CRITICAL,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ACPI_APEI_GHES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">FIX_ENTRY_TRAMP_TEXT4,<span class="comment">/* one extra slot for the data page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">FIX_ENTRY_TRAMP_TEXT3,</span><br><span class="line">FIX_ENTRY_TRAMP_TEXT2,</span><br><span class="line">FIX_ENTRY_TRAMP_TEXT1,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMP_VALIAS(__fix_to_virt(FIX_ENTRY_TRAMP_TEXT1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span></span></span><br><span class="line">__end_of_permanent_fixed_addresses,</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Temporary boot-time mappings, used by early_ioremap(),</span></span><br><span class="line"><span class="comment"> * before ioremap() is functional.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_FIX_BTMAPS(SZ_256K / PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIX_BTMAPS_SLOTS7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_FIX_BTMAPS(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)</span></span><br><span class="line"></span><br><span class="line">FIX_BTMAP_END = __end_of_permanent_fixed_addresses,</span><br><span class="line">FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - <span class="number">1</span>, <span class="comment">// early_ioremap() 接口使用，这部分属于动态映射。大小是 7 × 256KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used for kernel page table creation, so unmapped memory may be used</span></span><br><span class="line"><span class="comment"> * for tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FIX_PTE,</span><br><span class="line">FIX_PMD,</span><br><span class="line">FIX_PUD,</span><br><span class="line">FIX_P4D,</span><br><span class="line">FIX_PGD,</span><br><span class="line"></span><br><span class="line">__end_of_fixed_addresses</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="fixmap-映射流程">Fixmap 映射流程</h2><p>fixmap 初始化操作在 early_fixmap_init 函数中完成。主要是建立 PGD/PUD/PMD 页表。fixmap 映射调用栈如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">--&gt;setup_arch</span><br><span class="line">--&gt;early_fixmap_init</span><br><span class="line">--&gt;early_fixmap_init_pud <span class="comment">// 页表存在 bm_pud</span></span><br><span class="line">--&gt;early_fixmap_init_pmd <span class="comment">// 页表存在 bm_pmd</span></span><br><span class="line">--&gt;early_fixmap_init_pte <span class="comment">// 页表存在 bm_pte</span></span><br><span class="line">--&gt;early_ioremap_init <span class="comment">// kernel 启动早期不能使用 ioremap 操作，我们必须借助 early_ioremap 接口</span></span><br><span class="line">--&gt;early_ioremap_setup</span><br><span class="line">--&gt;slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i)</span><br></pre></td></tr></tbody></table></figure><p>early ioremap 利用 slot 管理映射，最多支持 FIX_BTMAPS_SLOTS 个映射，每个映射最大支持映射 256KB。slot_virt 数组存储每个 slot 的虚拟地址首地址。prev_map 数组用来记录已经分配出去的虚拟地址，数组值为 0 代表没有分配。prev_size 记录映射的 size。 其中 bm_pud、bm_pmd 和 bm_pte 都在内核 image 的全局数组中，也就是在。data 段中，在 idmp 映射阶段对内核做一个粗粒度的映射，在这个映射后就可以通过 mmu 访问内核数据了。这里正好利用这个建立 fixmap 映射。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(a)  (((a) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1)) <span class="comment">// PGDIR_SHIFT = 30  PTRS_PER_PGD = 512</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgd_t</span> *<span class="title function_">pgd_offset_pgd</span><span class="params">(<span class="type">pgd_t</span> *pgd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (pgd + pgd_index(address));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, address)pgd_offset_pgd((mm)-&gt;pgd, (address))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> {</span><br><span class="line">.mm_mt= MTREE_INIT_EXT(mm_mt, MM_MT_FLAGS, init_mm.mmap_lock),</span><br><span class="line">.pgd= swapper_pg_dir,</span><br><span class="line">.mm_users= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">.mm_count= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">.write_protect_seq = SEQCNT_ZERO(init_mm.write_protect_seq),</span><br><span class="line">MMAP_LOCK_INITIALIZER(init_mm)</span><br><span class="line">.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">.arg_lock=  __SPIN_LOCK_UNLOCKED(init_mm.arg_lock),</span><br><span class="line">.mmlist= LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PER_VMA_LOCK</span></span><br><span class="line">.mm_lock_seq= <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.user_ns= &amp;init_user_ns,</span><br><span class="line">.cpu_bitmap= CPU_BITS_NONE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IOMMU_SVA</span></span><br><span class="line">.pasid= IOMMU_PASID_INVALID,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">INIT_MM_CONTEXT(init_mm)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset_k(address)pgd_offset(&amp;init_mm, (address))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="fixmap-虚拟地址空间视图">Fixmap 虚拟地址空间视图</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/FixmapAddress.png"></p><h2 id="fixmap-寻址流程">Fixmap 寻址流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/FixmapAddressFind.png"> 以上就是 Fixmap 的地址空间和寻址流程。其中比较重要的是 BITMAP 区域始于 IO 映射区域，而 FDT 属于设备树映射区域，经过 FixedMap 映射后就 kernel 就可以访问 dtb 和 io 了。</p><h1 id="线性映射">线性映射</h1><h2 id="构建-pgd-映射表">构建 PGD 映射表</h2><p>页目录直接使用的是 swapper_pg_dir，一个条目映射的空间本身就很大，一个 entry 对应范围有 512GB。 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm64/kernel/vmlinux.lds.S</span><br><span class="line">    swapper_pg_dir = .;</span><br><span class="line">. += PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">swapper_pg_dir 是实现分配的一段空间，处于内核镜像的 data 段。</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __fix_to_virt(x)(FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_fix(x)((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fix_to_virt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> idx)</span></span><br><span class="line">{</span><br><span class="line">BUILD_BUG_ON(idx &gt;= __end_of_fixed_addresses);</span><br><span class="line"><span class="keyword">return</span> __fix_to_virt(idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer with offset calculated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_fixmap_offset(idx, phys, flags)\</span></span><br><span class="line"><span class="meta">({\</span></span><br><span class="line"><span class="meta">unsigned long ________addr;\</span></span><br><span class="line"><span class="meta">__set_fixmap(idx, phys, flags);\</span></span><br><span class="line"><span class="meta">________addr = fix_to_virt(idx) + ((phys) &amp; (PAGE_SIZE - 1));\</span></span><br><span class="line"><span class="meta">________addr;\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fixmap_offset(idx, phys) \</span></span><br><span class="line"><span class="meta">__set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_set_fixmap(addr)((pgd_t *)set_fixmap_offset(FIX_PGD, addr))</span></span><br><span class="line"></span><br><span class="line"><span class="type">pgd_t</span> *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));</span><br></pre></td></tr></tbody></table></figure><p>fixmap 区域可以想象成一块内存以页为单位被平均分成__end_of_permanent_fixed_addresses 块。而这些枚举值就是这块内存的 index。因此虚拟地址可以根据 index 进行计算。 通过__pa_symbol 先将 swapper_pg_dir 转化为物理地址，然后通过 pgd_set_fixmap 对其进行映射，映射工作主要在__set_fixmap 里，映射完成后返回 FIX_PGD 的虚拟地址+swapper_pg_dir 物理地址的 offset 部分作为 pgdp。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/LineMapAddressFind.png"> 有了 pgdp 之后就可以对 kernel、memblock 等进行下一步的映射了。</p><h2 id="两个重要的宏__pa-和__va-__pa-宏分析">两个重要的宏__pa 和__va ### __pa 宏分析 <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/memory.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys_nodebug(x) ({\</span></span><br><span class="line"><span class="meta">phys_addr_t __x = (phys_addr_t)(__tag_reset(x));\</span></span><br><span class="line"><span class="meta">__is_lm_address(__x) ? __lm_to_phys(__x) : __kimg_to_phys(__x);\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys(x)__virt_to_phys_nodebug(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x)__virt_to_phys((unsigned long)(x))</span></span><br></pre></td></tr></tbody></table></figure></h2><h4 id="tag_reset-宏-__tag_resetx-是去掉虚拟地址中的-tag如果有-tag-的话.">__tag_reset 宏 __tag_reset(x) 是去掉虚拟地址中的 tag（如果有 tag 的话）.</h4><h4 id="is_lm_address用于判断虚拟地址-addr-是否在-arm64-的虚拟地址空间的线性地址区域">__is_lm_address（用于判断虚拟地址 addr 是否在 arm64 的虚拟地址空间的线性地址区域） <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether an arbitrary address is within the linear map, which</span></span><br><span class="line"><span class="comment"> * lives in the [PAGE_OFFSET, PAGE_END) interval at the bottom of the</span></span><br><span class="line"><span class="comment"> * kernel's TTBR1 address range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __is_lm_address(addr)(((u64)(addr) - PAGE_OFFSET) &lt; (PAGE_END - PAGE_OFFSET)</span></span><br></pre></td></tr></tbody></table></figure></h4><p>先看 PAGE_OFFSET 定义： </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.config 里</span><br><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS(CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_OFFSET(va)(-(UL(1) &lt;&lt; (va)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET(_PAGE_OFFSET(VA_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开就是</span></span><br><span class="line">PAGE_OFFSET= (UL(<span class="number">-1</span>) &lt;&lt; <span class="number">39</span>) <span class="comment">// 0xFFFFFF80 00000000</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>再看 PAGE_END 定义： </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS(CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS_MIN(VA_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_END(va)(-(UL(1) &lt;&lt; ((va) - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_END(_PAGE_END(VA_BITS_MIN))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开就是</span></span><br><span class="line">PAGE_END= (UL(<span class="number">-1</span>) &lt;&lt; (<span class="number">39</span> - <span class="number">1</span>)) <span class="comment">// 0xFFFFFFC0 00000000</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>线性地址空间为 [0xFFFFFF80 00000000, 0xFFFFFFC0 00000000].</p><h4 id="lm_to_phys线性地址空间内虚拟地址转物理地址">__lm_to_phys（线性地址空间内虚拟地址转物理地址） <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __lm_to_phys(addr)(((addr) - PAGE_OFFSET) + PHYS_OFFSET)</span></span><br></pre></td></tr></tbody></table></figure></h4><p>这里主要是 PHYS_OFFSET 宏的定义： </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_OFFSET({ VM_BUG_ON(memstart_addr &amp; 1); memstart_addr; })</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>memstart_addr 在 arch/arm64/mm/init.c 里设置 (DRAM 的起始地址）： </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Select a suitable value for the base of physical memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">memstart_addr = round_down(memblock_start_of_DRAM(),</span><br><span class="line">   ARM64_MEMSTART_ALIGN);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 如果线性地址空间小于实际物理地址需要调整 memstart_addr */</span></span><br><span class="line"><span class="keyword">if</span> (memstart_addr + linear_region_size &lt; memblock_end_of_DRAM()) {</span><br><span class="line"><span class="comment">/* ensure that memstart_addr remains sufficiently aligned */</span></span><br><span class="line">memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size,</span><br><span class="line"> ARM64_MEMSTART_ALIGN);</span><br><span class="line">memblock_remove(<span class="number">0</span>, memstart_addr);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>这里打印出来就是 0. 到这里就是分析清楚。</p><h4 id="kimg_to_phys内核-image-物理地址转虚拟地址">__kimg_to_phys（内核 image 物理地址转虚拟地址） <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the offset between the kernel virtual and physical mappings */</span></span><br><span class="line"><span class="keyword">extern</span> u64kimage_voffset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __kimg_to_phys(addr)((addr) - kimage_voffset)</span></span><br></pre></td></tr></tbody></table></figure></h4><p>这里知道 kimage_voffset 是内核镜像的虚拟地址和物理地址之间的偏移就可以了，暂时用不到不用分析，基本上就是内核加载到内存中后在内存的物理地址与链接地址之间的偏差。</p><h3 id="va-宏分析-分析完__pa-之后看__va-就简单多了这里只做线性区域的映射且-phys_offset-和-page_offset-都已经分析过了这里不做过多说明了">__va 宏分析 <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __phys_to_virt(x)((unsigned long)((x) - PHYS_OFFSET) | PAGE_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)((void *)__phys_to_virt((phys_addr_t)(x)))</span></span><br></pre></td></tr></tbody></table></figure> 分析完__pa 之后看__va 就简单多了，这里只做线性区域的映射，且 PHYS_OFFSET 和 PAGE_OFFSET 都已经分析过了，这里不做过多说明了</h3><h2 id="映射过程mem_map">映射过程（mem_map）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map_mem(pgdp)</span><br><span class="line">--&gt;__map_memblock(pgdp, start, __phys_to_virt(start), end - start,</span><br><span class="line">     prot, early_pgtable_alloc, flags)</span><br><span class="line">--&gt;__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,</span><br><span class="line">     prot, early_pgtable_alloc, flags)</span><br></pre></td></tr></tbody></table></figure><p>其中__create_pgd_mapping 的调用流程如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/createpgdMappingLocked.png"></p><p>通过__create_pgd_mapping 函数建立线性映射的页表，其中参数虚拟地址通过 __phys_to_virt(start) 来转换，而 __phys_to_virt 就是__va 宏的实现对物理地址做一个固定的偏移 PAGE_OFFSET（ 0xFFFFFF80 00000000）。有了虚拟地址和物理地址后剩下的就是建立虚拟地址到物理地址的映射就可以了，就是填充 pud、pmd、pte 页表。</p><h2 id="线性映射地址空间">线性映射地址空间</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/LineMapSpace.png"> 整个 ddr 空间中除了 secmon、kernel image 外其他都是线性映射范围。</p><h1 id="vmalloc-映射">VMALLOC 映射</h1><h2 id="vmalloc-函数">vmalloc() 函数</h2><ul><li>vmalloc 用于分配虚拟地址连续（物理地址不连续）的内存空间，vzmalloc 相对于 vmalloc 多了个 0 初始化</li><li>vmalloc/vzmalloc 分配的虚拟地址范围在 VMALLOC_START/VMALLOC_END 之间</li><li>linux 管理 vmalloc 分别有两个数据结构：vm_struct,&nbsp;vm_area_struct；前者是内核虚拟地址空间的映射，后者是应用进程虚拟地址空间映射</li><li>内核 vmalloc 区具体地址空间的管理是通过 vmap_area 管理的，该结构体记录整个区间的起始和结束</li><li>vmalloc 在申请内存时逐页分配，确保在物理内存有严重碎片的情况下，vmalloc 仍然可以工作</li><li>vmalloc&nbsp;() 函数的工作方式与 kmalloc() 类似，只不过它分配的内存只是虚拟连续的，而不一定物理连续。用户空间分配函数的工作方式如下：malloc() 返回的页面在处理器的虚拟地址空间中是连续的，但不能保证它们在物理 RAM 中实际上是连续的。kmalloc&nbsp;() 函数保证页面在物理上是连续的（并且虚拟连续）。vmalloc&nbsp;() 函数仅确保页面在虚拟地址空间中是连续的。它通过分配可能不连续的物理内存块并“修复”页表以将内存映射到逻辑地址空间的连续块来实现这一点。</li></ul><h2 id="数据组织形式">数据组织形式</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/vmapAreaList.png"></p><p>初始化流程如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/mmCoreInit.png"></p><h1 id="vmap-和-vmalloc">vmap() 和 vmalloc()</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/vmapmap.png"> vmalloc 流程与 vmap 差不多，只是 page 结构体在 vmap 中是通过参数传递过去的，而 vmalloc 是通过 page_alloc 巷 buddy system 申请的。</p><h1 id="vmemmap-映射">VMEMMAP 映射</h1><p>vmemmap 是内核中 page 数据的虚拟地址，针对 sparse 内存模型。内核申请 page 获取的 page 地址从此开始。vmemmap 区域是一块起始地址是 VMEMMAP_START，范围是 2TB 的虚拟地址区域，位于 kernel space。以 section 为单位来存放 strcut page 结构的虚拟地址空间，然后线性映射到物理内存。详细过程可参考如下连接：</p><h1 id="附录一宏定义快查">附录一：宏定义快查</h1><h2 id="config-配置">config 配置</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PGTABLE_LEVELS=<span class="number">3</span></span><br><span class="line">CONFIG_ARM64_VA_BITS_39=y</span><br><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line">CONFIG_ARM64_PA_BITS_48=y</span><br><span class="line">CONFIG_ARM64_PA_BITS=<span class="number">48</span></span><br><span class="line">CONFIG_ARM64_4K_PAGES=y</span><br><span class="line">CONFIG_HZ_250=y</span><br><span class="line">CONFIG_HZ=<span class="number">250</span></span><br><span class="line">CONFIG_ARM64_PAGE_SHIFT=<span class="number">12</span></span><br><span class="line">CONFIG_ARM64_CONT_PTE_SHIFT=<span class="number">4</span></span><br><span class="line">CONFIG_ARM64_CONT_PMD_SHIFT=<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><h2 id="page-定义">PAGE 定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/page-def.h&gt;</span><br><span class="line"><span class="comment">/* PAGE_SHIFT determines the page size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFTCONFIG_ARM64_PAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE(_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK(~(PAGE_SIZE-1))</span></span><br></pre></td></tr></tbody></table></figure><p>PAGE 占 12bit，一页大小是 2^12=4096 = 4k</p><h2 id="pte-定义">PTE 定义：</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PTE(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br></pre></td></tr></tbody></table></figure><p>PTRS_PER_PTE = 1 &lt;&lt; (12 - 3) = 512</p><h2 id="pmd-定义">PMD 定义</h2><p>因为 CONFIG_PGTABLE_LEVELS 定义为 3 所以有如下定义： </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PMD_SHIFT determines the size a level 2 page table entry can map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(2) <span class="comment">//21</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SIZE(_AC(1, UL) &lt;&lt; PMD_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK(~(PMD_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PMD(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>PMD_SHIFT = (PAGE_SHIFT - 3) * (4 - 2) + 3 = 21</li><li>PTRS_PER_PMD = 1 &lt;&lt; (12 - 3) = 512</li></ul><h2 id="pud-定义">PUD 定义</h2><p>只有 4 级页表才有 PUD，三级页表没有 PUD: </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PUD_SHIFT determines the size a level 1 page table entry can map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_SIZE(_AC(1, UL) &lt;&lt; PUD_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK(~(PUD_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PUD(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>PUD_SHIFT = (PAGE_SHIFT - 3) * (4 - 1) + 3 = 30</li><li>PTRS_PER_PUD = 1 &lt;&lt; (12 - 3) = 512</li></ul><h2 id="pgd-定义">PGD 定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PGDIR_SHIFT determines the size a top-level page table entry can map</span></span><br><span class="line"><span class="comment"> * (depending on the configuration, this level can be 0, 1 or 2).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_SHIFTARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_SIZE(_AC(1, UL) &lt;&lt; PGDIR_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_MASK(~(PGDIR_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PGD(1 &lt;&lt; (VA_BITS - PGDIR_SHIFT))</span></span><br></pre></td></tr></tbody></table></figure><ul><li>PGDIR_SHIFT = (PAGE_SHIFT - 3) * (4 - 1) + 3 = 30</li><li>PTRS_PER_PGD = 1 &lt;&lt; (39 - 30) = 512</li></ul><h1 id="附录二相关数据类型定义">附录二：相关数据类型定义</h1><h2 id="表项数据类型定义">表项数据类型定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable-types.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pteval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pudval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">p4dval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pgdval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pteval_t</span> pte; } <span class="type">pte_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_val(x)((x).pte)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pte(x)((pte_t) { (x) } )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pmdval_t</span> pmd; } <span class="type">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_val(x)((x).pmd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pmd(x)((pmd_t) { (x) } )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pudval_t</span> pud; } <span class="type">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_val(x)((x).pud)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pud(x)((pud_t) { (x) } )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pgdval_t</span> pgd; } <span class="type">pgd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_val(x)((x).pgd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgd(x)((pgd_t) { (x) } )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pteval_t</span> pgprot; } <span class="type">pgprot_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_val(x)((x).pgprot)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgprot(x)((pgprot_t) { (x) } )</span></span><br></pre></td></tr></tbody></table></figure><h2 id="获取表项索引值">获取表项索引值</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/pgtable.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(a)  (((a) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pud_index</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pud_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (address &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_index pud_index</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pmd_index</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pmd_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (address &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_index pmd_index</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pte_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="获取表项地址">获取表项地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgd_t</span> *<span class="title function_">pgd_offset_pgd</span><span class="params">(<span class="type">pgd_t</span> *pgd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (pgd + pgd_index(address));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a shortcut to get a pgd_t in a given mm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pgd_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, address)pgd_offset_pgd((mm)-&gt;pgd, (address))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find an entry in the second-level page table.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pmd_offset</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmd_t</span> *<span class="title function_">pmd_offset</span><span class="params">(<span class="type">pud_t</span> *pud, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> pud_pgtable(*pud) + pmd_index(address);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_offset pmd_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pud_offset</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pud_t</span> *<span class="title function_">pud_offset</span><span class="params">(<span class="type">p4d_t</span> *p4d, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> p4d_pgtable(*p4d) + pud_index(address);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_offset pud_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>通过 pgd_offset_pgd 就可以找到一个虚拟内存地址在 PGD 中的页目录项了。</p><blockquote><p>说明：这里的 PGD、PUD、PMD 为什么都是使用 9bit，这个是因为在 64bit 系统下，每个地址要占 8 字节，而对于 page size=4k 大小的页面，一个页面所能容纳的地址数量正好是 4096 / 8 = 512，而要寻址这 512 个索引需要 2^9=512 也就是需要 9bit。这里也是使用 9bit 的原因，如果用更大的 page size 则更合理的做法是相应的增大 PGD、PUD、PMD 占的 bit 数，这样可以更充分的利用空间。</p></blockquote><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（三）物理地址管理</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryBasic/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryBasic/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Memorybasic1.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM3MjRjNTU2NTNiYjA3MWU3MGVjMmY=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="内存管理发展史">内存管理发展史</h1><h2 id="内存管理的远古时代">内存管理的“远古时代”</h2><p>在分页机制出现之前，操作系统有很多不同的内存管理机制，如动态分区法。如图（a）所示。剩余的 4MB 内存不足以装载进程 D，如图（b）所示，因为进程 D 需要 5MB 内存，这个内存末尾就成了第一个空洞（内存碎片）。假设某个时刻，操作系统需要运行进程 D，因为系统中没有足够的内存，所以需要选择一个进程来换出，为进程 D 腾出足够的空间。假设操作系统选择进程 B 来换出，这样进程 D 就装载到了原来进程 B 的地址空间里，于是产生了第二个空洞，如图（c）所示。假设操作系统某个时刻需要运行进程 B，也需要选择一个进程来换出，假设进程 A 被换出，那么操作系统中又产生了第三个空洞，如图（d）所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Dynamic_partition.png"></p><p>这种动态分区法在开始时是很好的，但是随着时间的推移会出现很多内存空洞，内存的利用率随之下降，这些内存空洞便是我们常说的内存碎片，动态分区法依然存在以下问题。</p><ul><li>进程地址空间保护问题。所有的进程都可以访问全部的物理内存，所以恶意的程序可以修改其他程序的内存数据，这使进程一直处于危险的状态下。</li><li>内存使用效率低。如果即将运行的进程所需要的内存空间不足，就需要选择一个进程以进行整体换出，这种机制导致大量的数据需要换出和换入，效率非常低下。</li><li>程序运行地址重定位问题。从上图中看到，进程在每次换出、换入时使用的地址都是不固定的，这给程序的编写带来一定的麻烦，因为访问数据和指令跳转时的目标地址通常是固定的，这就需要重定位技术。</li></ul><p>因此产生了分段机制和分页机制。</p><h2 id="分段机制">分段机制</h2><ul><li>把程序所需的内存空间的虚拟地址映射到某个物理地址空间中，解决地址空间保护问题。</li><li>分段机制把进程分成若干段（代码段、数据段栈段与堆段等），每个段的大小是不固定的，有点类似于动态分区法，这些段的物理地址可以不连续这样可以一定程度上解决内存碎片问题。</li></ul><p>分段机制是一个比较明显的改进，但是它的内存使用效率依然比较低。分段机制对虚拟内存到物理内存的映射依然以进程为单位。进程在运行时，根据局部性原理，只有一部分数据是一直在使用的，若把那些不常用的数据交换出磁盘，就可以节省很多系统带宽。</p><h2 id="分页机制">分页机制</h2><p>分页机制把分段机制的单位继续细分成固定大小的页面（page），进程的虚拟地址空间也按照页面来分割，这样常用的数据和代码就可以以页面为单位驻留在内存中，而那些不常用的页面可以交换到磁盘中。物理内存也以页面为单位来管理，这些物理内存称为物理页面（physical page）或者页帧（page frame）。进程的虚拟地址空间中的页面称为虚拟页面（virtualpage）。操作系统为了管理这些页帧需要按照物理地址给每个页帧编号，这个编号称为页帧号（Page Frame Number，PFN）。</p><h1 id="从进程的角度看内存管理">从进程的角度看内存管理</h1><p>在 Linux 系统中，应用程序常用的可执行文件格式是可执行与可链接格式（Executable Linkable Format，ELF）。ELF 最开始的部分是 ELF 文件头（ELF Header），它包含了描述整个文件的基本属性，如 ELF 文件版本、目标计算机型号、程序入口地址等信息。ELF 文件头后面是程序的各个段，包括代码段、数据段、未初始化数据段等。后面是段头表，用于描述 ELF 文件中包含的所有段的信息，如每个段的名字、段的长度、在文件中的偏移量、读写权限以及段的其他属性等，后面紧跟着是字符串表和符号表等。ELF 结构如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ELF.png"></p><p>下面介绍常见的几个段，这些段与内核映像中的段也是基本类似的。</p><ul><li>代码段：存放程序源代码编译后的机器指令。</li><li>数据段：存放已初始化的全局变量和已初始化的局部静态变量。</li><li>未初始化数据段：存放未初始化的全局变量以及未初始化的局部静态变量。下面编写一个简单的 C 程序。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (100*1024)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> * buf = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x58</span>, SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc buffer 0x%p\n"</span>, buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个 C 程序很简单，首先通过 malloc() 函数来分配 100KB 的内存，然后通过 memset() 函写入这块内存，最后用 while 循环是为了不让这个程序退出。我们通过如下命令来把它编成 ELF 文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aarch64-linux-gnu-gcc-static test.c -o test.elf</span><br></pre></td></tr></tbody></table></figure><p>可以使用 objdump 或者 readelf 工具来查看 ELF 文件包含哪些段。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ aarch64-linux-gnu-readelf -S test.elf</span><br><span class="line">There are 29 section headers, starting at offset 0x92548:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.build-i NOTE             0000000000400190  00000190</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             00000000004001b4  000001b4</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .rela.plt         RELA             00000000004001d8  000001d8</span><br><span class="line">       00000000000000a8  0000000000000018  AI       0    21     8</span><br><span class="line">  [ 4] .init             PROGBITS         0000000000400280  00000280</span><br><span class="line">       0000000000000014  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 5] .plt              PROGBITS         00000000004002a0  000002a0</span><br><span class="line">       0000000000000070  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 6] .text             PROGBITS         0000000000400340  00000340</span><br><span class="line">       00000000000516ac  0000000000000000  AX       0     0     64</span><br><span class="line">  [ 7] __libc_freeres_fn PROGBITS         00000000004519f0  000519f0</span><br><span class="line">       0000000000000b44  0000000000000000  AX       0     0     8</span><br><span class="line">  [ 8] .fini             PROGBITS         0000000000452534  00052534</span><br><span class="line">       0000000000000010  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 9] .rodata           PROGBITS         0000000000452550  00052550</span><br><span class="line">       000000000001be28  0000000000000000   A       0     0     16</span><br><span class="line">  [10] __libc_subfreeres PROGBITS         000000000046e378  0006e378</span><br><span class="line">       0000000000000048  0000000000000000   A       0     0     8</span><br><span class="line">  [11] __libc_IO_vtables PROGBITS         000000000046e3c0  0006e3c0</span><br><span class="line">       00000000000005e8  0000000000000000   A       0     0     8</span><br><span class="line">  [12] __libc_atexit     PROGBITS         000000000046e9a8  0006e9a8</span><br><span class="line">       0000000000000008  0000000000000000   A       0     0     8</span><br><span class="line">  [13] .eh_frame         PROGBITS         000000000046e9b0  0006e9b0</span><br><span class="line">       000000000000a158  0000000000000000   A       0     0     8</span><br><span class="line">  [14] .gcc_except_table PROGBITS         0000000000478b08  00078b08</span><br><span class="line">       000000000000009e  0000000000000000   A       0     0     1</span><br><span class="line">  [15] .tdata            PROGBITS         0000000000489978  00079978</span><br><span class="line">       0000000000000020  0000000000000000 WAT       0     0     8</span><br><span class="line">  [16] .tbss             NOBITS           0000000000489998  00079998</span><br><span class="line">       0000000000000040  0000000000000000 WAT       0     0     8</span><br><span class="line">  [17] .init_array       INIT_ARRAY       0000000000489998  00079998</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .fini_array       FINI_ARRAY       00000000004899a0  000799a0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .data.rel.ro      PROGBITS         00000000004899b0  000799b0</span><br><span class="line">       0000000000000594  0000000000000000  WA       0     0     8</span><br><span class="line">  [20] .got              PROGBITS         0000000000489f48  00079f48</span><br><span class="line">       00000000000000a0  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .got.plt          PROGBITS         0000000000489fe8  00079fe8</span><br><span class="line">       0000000000000050  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         000000000048a038  0007a038</span><br><span class="line">       0000000000001950  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           000000000048b988  0007b988</span><br><span class="line">       00000000000015d0  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] __libc_freeres_pt NOBITS           000000000048cf58  0007b988</span><br><span class="line">       0000000000000028  0000000000000000  WA       0     0     8</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  0007b988</span><br><span class="line">       000000000000002a  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  0007b9b8</span><br><span class="line">       0000000000010110  0000000000000018          27   1726     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  0008bac8</span><br><span class="line">       0000000000006954  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  0009241c</span><br><span class="line">       0000000000000128  0000000000000000           0     0     1</span><br></pre></td></tr></tbody></table></figure><p>可以看到刚才编译的 test.elf 文件一共有 28 个段，除了常见的代码段、数据段之外，还有一些其他的段，这些段在进程加载时起辅助作用，暂时先不用关注它们。程序在编译、链接时会尽量把相同权限属性的段分配在同一个空间里，如把可读、可执行的段放在一起，包括代码段、init 段等；把可读、可写的段放在一起，包括数据段和未初始化数据段等。ELF 把这些属性相似并且链接在一起的段叫作分段（segment），进程在加载时是按照这些分段来映射可执行文件的。描述这些分段的结构叫作程序头（program header），它描述了 ELF 文件是如何映射到进程地址空间的，这是我们比较关心的。我们可以通过 readelf -l 命今来查看这些程序头。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ aarch64-linux-gnu-readelf -l test.elf</span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is EXEC (Executable file)</span><br><span class="line">Entry point 0x400558</span><br><span class="line">There are 6 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000078ba6 0x0000000000078ba6  R E    0x10000</span><br><span class="line">  LOAD           0x0000000000079978 0x0000000000489978 0x0000000000489978</span><br><span class="line">                 0x0000000000002010 0x0000000000003608  RW     0x10000</span><br><span class="line">  NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  TLS            0x0000000000079978 0x0000000000489978 0x0000000000489978</span><br><span class="line">                 0x0000000000000020 0x0000000000000060  R      0x8</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000079978 0x0000000000489978 0x0000000000489978</span><br><span class="line">                 0x0000000000000688 0x0000000000000688  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.build-id .note.ABI-tag .rela.plt .init .plt .text __libc_freeres_fn .fini .rodata __libc_subfreeres __libc_IO_vtables __libc_atexit .eh_frame .gcc_except_table</span><br><span class="line">   01     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs</span><br><span class="line">   02     .note.gnu.build-id .note.ABI-tag</span><br><span class="line">   03     .tdata .tbss</span><br><span class="line">   04</span><br><span class="line">   05     .tdata .init_array .fini_array .data.rel.ro .got</span><br></pre></td></tr></tbody></table></figure><p>从上面可以看到之前的 28 个段被分成了 6 个分段，我们只关注其中两个 LOAD 类型的分段。因为在加载时需要映射它，其他的分段在加载时起辅助作用。 先看第一个 LOAD 类型的分段，它是具有只读和可执行的权限，包含。init 段、代码段、只读数据段等常见的段，它映射的虚拟地址是 0x400000，长度是 0x78ba6。 第二个 LOAD 类型的分段具有可读和可写的权限，包含数据段和未初始化数据段等常见的段，它映射的虚拟地址是 0x489978，长度是 0x3608 上面从静态的角度来看进程的内存管理，我们还可以从动态的角度来看。Linux 操作系统提供了“proc”文件系统来窥探 Linux 内核的执行情况，每个进程执行之后，在/proc/pid/maps 节点会列出当前进程的地址映射情况。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/721/maps</span><br><span class="line">00400000-0046000 r-xp 00000000 00:26 52559883   test.elf</span><br><span class="line">0047e000-00481000 rw-p 0006e000 00:26 52559883  test.elf</span><br><span class="line">272dd000-272ff000 rw-p 00000000 00:00 0         [heap]</span><br><span class="line">ffffa97ea000-ffffa97eb000 r--p 00000000 00:00 0 [vvar]</span><br><span class="line">ffffa97eb000-ffffa97ec000 r-xp 00000000 00:00 0 [vdso]</span><br><span class="line">ffffcb6c6000-ffffcb6e7000 rw-p 00000000 00:00 0 [stack]</span><br></pre></td></tr></tbody></table></figure><p>第 1 行显示了地址 0x400000~0x46f000，这段进程地址空间的属性是只读和可执行的，由此我们知道它是代码段，也就是之前看到的代码段的程序头。<br>第 2 行显示了地址 0x47e000~0x48100，这段进程地址空间的属性是可读和可写的，也就是我们之前看到的数据段的程序头。<br>第 3 行显示了地址 0x272dd00~0x272ff000，这段进程地址空间叫作堆（heap）空间，也就是通常使用 malloc() 分配的内存，大小是 140KB。test 进程主要使用 malloc() 分配 100KB 的内存，这里看到 Linux 内核会分配比 100KB 稍微大一点的内存空间。<br>第 4 行显示了名为 vvar 的特殊映射。<br>第 5 行显示了名为 vdso 的特殊映射，VDSO 指 Virtual Dynamic Shared Object，用于解决内核和 libc 之间的版本问题。<br>第 6 行显示了 test 进程的栈（stack）空间。<br>对于这里的进程地址空间，在 Linux 内核中使用一个叫作 VMA 的术语来描述它，它是 vm_area_struct 数据结构的简称。 另外，/proc/pid/smaps 节点会提供更多地址映射的细节。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/test_process.png"></p><h1 id="物理内存管理之预备知识">物理内存管理之预备知识</h1><h2 id="内存架构之-uma-和-numa">内存架构之 UMA 和 NUMA</h2><ul><li><p>UMA 统一内存访问架构：内存有统一的结构并且可以统一寻址。目前大部分嵌入式系统、手机操作系统以及台式机操作系统等采用 UMA 架构 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/UMA.png"></p></li><li><p>NUMA 非统一内存访问架构：系统中有多个内存节点和多个 CPU 簇，CPU 访问本地内存节点的速度最快，访问远端的内存节点的速度要慢一点 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/NUMA.png"></p></li></ul><h2 id="基本概念">基本概念</h2><p>从 Linux 内核的角度来看，DDR 存储设备其实就是一段物理内存空间。在 Linux 内核中，和内存硬件物理特性相关的一些数据结构主要集中在 MMU（如页表、高速缓存/TLB 操作等）中。因此大部分的 Linux 内核中关于内存管理的相关数据结构是软件层面的概念，如 mm、VMA、内存管理区（zone）、页面、pg_data 等。Linux 内核内存管理中的数据结构错综复杂，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_struct.png"></p><p>和物理内存管理相关的数据结构有内存节点（pglist data）、内存管理区、物理页面（page）、mem_map[] 数组、页表项（PTE）、页帧号（PFN）、物理地址（paddress）。</p><p>其中，pglist data 数据结构用来描述一个内存节点的所有资源。在 UMA 架构中，只有一个内存节点，即系统有一个全局的变量 contig_page_data 来描述这个内存节点。在 NUMA 架构中，整个系统的内存由一个 pglist_data *的指针数组 node_data[] 来管理，在系统初始化枚举 BIOS 固件（ACPI）来完成。</p><p>Linux 内核用内存管理区来划分物理内存是有以下历史原因的。</p><ul><li>由于地址数据线位宽的限制，32 位处理器通常最多支持 4GB 的物理内存，如果打开了 LPAE 特性，可以支持更大的物理内存。在 4Gb 的地址空间中，通常内核空间只有 1GB 大小，因此对于大小为 4GB 的物理内存是无法进行--线性映射的。Linux 内核的做法是把物理内存分成两部分，其中一部分是线性映射的。如果用一个内存管理区来描述它，那就是 ZONE_NORMAL。剩余的部分叫从高端内存（high memory）同样使用一个内存管理区来描述它，称为 ZONE_HIGHMEM。</li><li>内存管理区的分布和架构相关，如在 x86 架构中，ISA 设备只能访问物理内存的前 16MB，所以在 x86 架构中会有一个名为 ZONE_DMA 的管理区域。在 x86_64 架构中，由于有足够大的内核空间可以线性映射物理内存，因此就不需要 ZONE_HIGHMEM 这个管理区域了。</li></ul><p>在 Linux 操作系统中常见的内存管理区可以分为以下几种：</p><ul><li>ZONE_DMA：用于 ISA 设备的 DMA 操作，范围是 0~16MB，只适用于 Intel x86 架构，ARM 架构没有这个内存管理区。</li><li>ZONE_DMA32：用于最低 4GB 的内存访问的设备，如只支持 32 位的 DMA 设备。</li><li>ZONE_NORMAL：4GB 以后的物理内存，用于线性映射物理内存。若系统内存小于 4GB，则没有这个内存管理区。</li><li>ZONE_HIGHMEM：用于管理高端内存，这些高端内存是不能线性映射到内核地址空间的。注意，在 64 位 Linux 操作系统中没有这个内存管理区。</li></ul><p>Linux 内核中使用一个 page 数据结构来描述一个物理页面。Linux 内核为每个物理页面都分配了一个 page 数据结构，采用 mem_map[] 数组来存放这些 page 数据结构，并且它们和物理页面是一对一的映射关系，如下图所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_map.png"></p><p>每个 node 由一个或多个 zone 组成，每个 zone 又由若干 page frames 组成（一般 page frame 都是指物理页面）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/framebuffer.jpg"></p><h1 id="memblock">Memblock</h1><p>Linux内核使用伙伴系统管理内存，在伙伴系统之前，内核通过memblock来管理内存。在系统启动阶段，使用memblock记录理内存的使用情况，可以分成好几块。</p><ul><li>永久分配给系统内核：内核镜像占用的部分，如代码、数据段、设备树DTB等。</li><li>预留给外设的连续内存：如GPU/Camera/多核共享等需要预留大量连续内存。</li><li>其他部分：以上的剩余部分内存，需要进行内存管理。</li></ul><h2 id="初始化流程">初始化流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/MemoryStartKernelMemblock.png"></p><ul><li>解析设备树二进制文件 /memory 节点, 将所有物理内存纳入到 memblock 分配器管理之下。</li><li>将kernel、dtb以及memory节点下的reserved内存组织为reserved内存，提供申请和释放内存的接口，避免使用到reserved内存。</li></ul><h2 id="数据结构">数据结构</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/MemoryBlockStruct.png"> struct memblock结构体通过struct memblock_type管理mem和reserved内存，memblock_type里通过struct memblock_regions指针分别指向系统的可以内存和reserver内存。如上图Memblock将Secmon、DSP、dtb和kernel的内存组织位reserver，其他内存为mem。</p><h2 id="memblock_alloc接口">memblock_alloc接口</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">memblock_alloc</span><br><span class="line">- memblock_alloc_try_nid</span><br><span class="line">- memblock_alloc_internal</span><br><span class="line">- kzalloc_node (exec it <span class="keyword">if</span> slab is enable and then <span class="keyword">return</span>)</span><br><span class="line">- memblock_alloc_range_nid</span><br><span class="line">- memblock_find_in_range_node</span><br><span class="line">- phys_to_virt</span><br></pre></td></tr></tbody></table></figure><p>可见&nbsp;memblock_alloc&nbsp;函数和&nbsp;memblock_phy_alloc&nbsp;函数均是调用&nbsp;memblock_find_in_range_node&nbsp;实现物理内存的分配，不同的是&nbsp;memblock_alloc&nbsp;会在分配后调用了&nbsp;phys_to_virt&nbsp;函数将物理地址转换成虚拟地址。这里有个疑问phys_to_virt&nbsp;是转为线性映射区，此时线性映射区以及映射好了？</p><blockquote><p>对于Paging_init之前应该是不能直接调用phys_to_virt&nbsp;的因为这个时候线性映射还没完成，这个时候应该是利用fixedmap映射区的fix_{pud、pmd、pte}页表完成映射，在paging_init之后因为完成了线性映射，这个ddr（除了no map外）都在线性映射范围内，这个时候是可以直接调用phys_to_virt&nbsp;将Memblock分配的物理内存转为虚拟地址供内核使用的.</p></blockquote><p>另外，调用&nbsp;memblock_alloc_range_nid&nbsp;之前会检查是否启用了 slab 分配器，如果已启用，说明&nbsp;memblock&nbsp;已将管理权移交给伙伴系统。这时会直接调用&nbsp;kzalloc_node&nbsp;从 slab 分配器分配内存。</p><h2 id="memblock调试">memblock调试</h2><p>在内核启动bootargs，可以加入"memblock=debug"，会打开memblock的dbg打印，通过打印可以看出memblock的预留、分配等操作。 在内核编译时使能了内核debug功能后，还可以通过以下操作查看memblock信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/memblock/memory </span><br><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/memblock/reserved</span><br></pre></td></tr></tbody></table></figure><h1 id="node-zone-pagelinux掌管物理内存的神">Node-Zone-Page（Linux掌管物理内存的神）</h1><p>为什么有了Memblock后还要设计Node-Zone来管理内存呢，Memblock管理内存太粗糙了，没有对内存的访问权限划分，以及内存属性等进行管理。为了对物理内存进行更精细的划分管理于是有了Node-Zone，在多cpu阵列中不同cpu对相同内存或相同cpu对不同内存的访问权限速度可能不同，这个时候需要对内存进行划分管理，设备DMA可能不能访问所有内存空间，只能访问部分空间这个时候DMA访问的地址空间需要划分出来管理，对于支持内存插拔的场景也需要一套机制来管理而这些是Memblock做不到的。</p><h2 id="内存模型">内存模型</h2><p>Linux使用两种内存模型FLATMEM和SPARSEM。所有的内存模型都使用排列在一个或多个数组中的 struct page 来跟踪物理页帧的状态。 无论选择哪种内存模型，物理页框号（PFN）和相应的 struct page 之间都存在一对一的映射关系。 每个内存模型都定义了 pfn_to_page 和 page_to_pfn helper函数，允许从PFN到 struct page 的转换，反之亦然。</p><h3 id="flatmem">FLATMEM</h3><p>在FLATMEM内存模型中，有一个全局的 mem_map 数组来映射整个物理内存。对于大多数架构，孔隙在 mem_map 数组中都有条目。与孔洞相对应的 struct page对象从未被完全初始化。</p><h3 id="sparsemem">SPARSEMEM</h3><p>SPARSEMEM是Linux中最通用的内存模型，它是唯一支持若干高级功能的内存模型，如物理内存的热插拔、非易失性内存设备的替代内存图和较大系统的内存图的延迟初始化。</p><p>SPARSEMEM模型将物理内存显示为一个部分的集合。一个区段用mem_section结构体表示，它包含 section_mem_map ，从逻辑上讲，它是一个指向 struct page阵列的指针。然而，它被存储在一些其他的magic中，以帮助分区管理。区段的大小 和最大区段数是使用 SECTION_SIZE_BITS 和 MAX_PHYSMEM_BITS 常量来指定的，这两个常量是由每个支持SPARSEMEM的架构定义的。 MAX_PHYSMEM_BITS是一个架构所支持的物理地址的实际宽度，而 SECTION_SIZE_BITS 是一个任意的值。</p><p>mem_section 对象被安排在一个叫做 mem_sections 的二维数组中。这个数组的大小和位置取决于 CONFIG_SPARSEM_EXTREME 和可能的最大段数:</p><ul><li>当 CONFIG_SPARSEMEM_EXTREME 被禁用时， mem_sections 数组是静态的，有NR_MEM_SECTIONS 行。每一行持有一个 mem_section 对象。</li><li>当 CONFIG_SPARSEMEM_EXTREME 被启用时， mem_sections 数组被动态分配。每一行包含价值 PAGE_SIZE 的 mem_section 对象，行数的计算是为了适应所有的内存区。</li></ul><p>架构设置代码应该调用sparse_init()来初始化内存区和内存映射。</p><p>通过SPARSEMEM，有两种可能的方式将PFN转换为相应的 struct page --"classic sparse"和"sparse vmemmap"。选择是在构建时进行的，它由 CONFIG_SPARSEMEM_VMEMMAP 的值决定。</p><p>Classic sparse在page-&gt;flags中编码了一个页面的段号，并使用PFN的高位来访问映射该页框的段。在一个区段内，PFN是指向页数组的索引。</p><p>Sparse vmemmapvmemmap使用虚拟映射的内存映射来优化pfn_to_page和page_to_pfn操作。有一个全局的 struct page *vmemmap 指针，指向一个虚拟连续的 struct page对象阵列。PFN是该数组的一个索引，struct page 从 vmemmap 的偏移量是该页的PFN。</p><p>为了使用vmemmap，一个架构必须保留一个虚拟地址的范围，以映射包含内存映射的物理页，并确保 vmemmap指向该范围。此外，架构应该实现 vmemmap_populate 方法，它将分配物理内存并为虚拟内存映射创建页表。如果一个架构对vmemmap映射没有任何特殊要求，它可以使用通用内存管理提供的默认 vmemmap_populate_basepages。</p><h2 id="mem_section组织下的内存">mem_section组织下的内存</h2><h3 id="section相关宏定义">Section相关宏定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section)) <span class="comment">// sizeof (struct mem_section) = 16  SECTIONS_PER_ROOT = 4096 / 16 = 256</span></span></span><br><span class="line"></span><br><span class="line">CONFIG_ARM64_PA_BITS=<span class="number">48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_SIZE_BITS 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PHYSMEM_BITSCONFIG_ARM64_PA_BITS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_SHIFT(MAX_PHYSMEM_BITS - SECTION_SIZE_BITS) <span class="comment">// 48 - 27 = 21</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_MEM_SECTIONS(1UL &lt;&lt; SECTIONS_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_SECTION_ROOTSDIV_ROUND_UP(NR_MEM_SECTIONS, SECTIONS_PER_ROOT) <span class="comment">// NR_SECTION_ROOTS = 2^21 / 256 = 8192</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_NR_TO_ROOT(sec)((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></tbody></table></figure><p>SECTION_SIZE_BITS 为什么要定义成27呢，我们知道我们的PAGE_SIZE是4096，而2^27 / 4096 = 32768，这刚好是一个s16类型能表示的范围这个是section_to_node_table的数据类型。</p><p>每一个mem_section可以用来描述SECTION_SIZE_BITS个bit位的地址，也就是2^27 = 32768 * 4k = 128M 用一个page来表示SECTIONS_PER_ROOT，每个SECTIONS_PER_ROOT里面有256个struct mem_section结构体，每个struct mem_section结构体可以描述一个128M，则SECTIONS_PER_ROOT能描述的地址空间是256 * 128M = 32G</p><p>32 * 8192 = 262144G = 256T = 2^48</p><h3 id="数据结构与组织形式概览">数据结构与组织形式概览</h3><p>先来一张整体图，表示mem_section是怎么组织内存的。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/MemorySectionStruct.png"></p><p>通过一个struct mem_section指针数组来表示所有PA范围，当然实际内存没有那么多，那么会浪费掉一些指针占用的空间，而这个浪费相对而言就比较小了。mem_section指针数组的每一项都指向一个mem_section结构体，一个mem_section结构体管理128MByte内存。mem_section通过一定的编码方式可以找到对于的struct page结构体，而每一个struct page对应着一块物理内存，而struct page结构体的虚拟地址空间在vmemmap映射区域，struct page的物理地址可能不连续，但是虚拟地址连续，这样可以方便将page与pfn进行快速转换。</p><h2 id="数据结构-1">数据结构</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/MemorySectionStruct2.png"></p><h2 id="组织形式">组织形式</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/pglistOrigin.png"></p><p>pglist_data就是node节点，对于UMA内存来讲就是一个node，node下管理数个zone，在我的ARM64设备上实际就一个zone就是Zone DMA（ARM64下没有ZONE HIGHT，因为虚拟内存足够大，不需要）ZONE DMA按照2^order次方组织page，有MAX_ORDER-1个数组，每个数组下又根据page是否可移动、是否可回收等权限分MIGRATE_MAX个链表来组织page，这为伙伴系统提供了page的组织和管理形式。</p><h2 id="调试">调试</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/zoneinfo</span><br><span class="line"><span class="built_in">cat</span> /proc/pagetypeinfo</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82ODQ2NTk1Mg==">https://zhuanlan.zhihu.com/p/68465952<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82ODQ3MzQyOA==">https://zhuanlan.zhihu.com/p/68473428<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（二）ARM64 的虚拟地址转换在 linux 中的实现</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryARM64linux/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryARM64linux/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MemoryARM64linux.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM3MTc1NjFlMDg1MzA2ZjhjNGRlZDk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="arm64-内存管理">arm64 内存管理</h1><p>如图所示，ARM 处理器内核的 MMU 包括 TLB 和页表遍历单元（Table Walk Unit）两个部件。TLB 是一个高速缓存。一个完整的页表翻译和查找的过程叫作页表查询，页表查询的过程由硬件自动完成，但是页表的维护需要软件来完成。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mmu.png"></p><p>下图为进程地址空间和物理地址空间的映射关系，左边是进程地址空间视图，右边是物理地址空间视图。进程地址空间又分成内核空间（Kermel Space）和用户空间（User Space）。无论是内核空间还是用户空间都可以通过处理器提供的页表机制映射到实际的物理地址。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/process_address.png"></p><h2 id="页表">页表</h2><p>在 AArch64 架构中的 MMU 支持单一阶段的页表转换，同样也支持虚拟化扩展中两阶段的页表转换。</p><ul><li>单一阶段的页表转换，把虑虚拟地址（VA）翻译成物理地址（PA）。</li><li>两阶段的页表转换：包括两个阶段。在阶段 1，把虚拟地址翻译成中间物 （Intermediate Phvsical Address，IPA）；在阶段 2，把 IPA 翻译成最终 PA 另外，ARMv8 架构支持多种页表格式。具体如下。<ul><li>ARMv8 架构的长描述符页表格式（Long Descriptor Translation Table Format）</li><li>ARMv7 架构的长描述符页表格式，需要打开大物理地址扩展（Large PhysicalA Extention, LPAE）</li><li>ARMv7 加构的短描述符页表格式（Short Descriptor Translation Table Format）</li></ul></li></ul><p>ARMv8 架构还支持 4KB、16KB 或 64KB 这 3 种页面粒度。</p><h2 id="页表映射">页表映射</h2><p>在 AArch64 架构中，因为地址总线位宽最多支持 48 位，所以 VA 被划分为两个空间，每个空间最多支持 256TB。</p><ul><li>低位的虚拟地址空间位于 0x0000 0000 0000 0000 到 0x0000 FFFF FFFF FFFF。虚拟地址的最高位等于 0，就使用这个虚拟地址空间，并且使用 TTBRO_ELx 来存放的基地址。</li><li>高位的虚拟地址空间位于 0xFFFF 0000 0000 0000 到 0xFFFF FFFF FFFF FFFF。虚拟地址的最高位等于 1，就使用这个虚拟地址空间，并且使用 TTBR1_ELx 来存放的基地址。</li></ul><p>AArch64 架构中的页表支持如下特性。</p><ul><li>最多可以支持 4 级页表</li><li>输入地址的最大有效位宽为 48 位</li><li>输出地址的最大有效位宽为 48 位</li><li>翻译的页面粒度可以是 4KB、16KB 或 64KB</li></ul><p>注意，本文以 4KB 大小的页面和 48 位地址宽度为例来说明 AArch64 架构页表映射。如下图所示为 AArch64 架构的地址映射，其中页面是 4KB 的小页面。当 TLB 未命中时，处理器查询页表的过程如下。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/aarch64_addr.png"></p><ul><li>处理器根据页表基地址控制寄存器和虚拟地址来判断使用哪个页表基地址寄存器 TTBRO 还是 TTBR1。当虚拟地址第 63 位简称 VA[63] 为 1 时选择 TTBR1；当 VA[63] 为 0 时选择 TTBR0。页表基地址寄存器中存放着 1 级页表</li><li>处理器将 VA[47:39] 作为 L0 索引，在 1 级页表（L0 页表）中找到页表项，1 级页表有 512 个页表项</li><li>1 级页表的页表项中存放着 2 级页表（L1 页表）的物理基地址。处理器将 VA[38] 作为 L1 索引，在 2 级页表中找到相应的页表项，2 级页表有 512 个页表项</li><li>2 级页表的页表项中存放着 3 级页表（L2 页表）的物理基地址。处理器以 VA[29:21] 作为 L2 索引，在 3 级页表（L2 页表）中找到相应的页表项，3 级页表有 512 个页表项</li><li>3 级页表的页表项中存放着 4 级页表（L3 页表）的物理基地址。处理器以 VA[20:12] 作为 L3 索引，在 4 级页表（L3 页表）中找到相应的页表项，4 级页表有 512 个页表项</li><li>4 级页表的页表项里存放着 4KB 页面的物理基地址，然后加上 VA[11：0]，就构成了新的物理地址，因此处理器就完成了页表的查询和翻译工作</li></ul><h2 id="页表项描述符">页表项描述符</h2><p>从下图可知，AArch64 架构页表分成 4 级页表，每一级页表都有页表项，我们把它们称为页表项描述符，每个页表项描述符占 8 字节，那么这些页表项描述符的格式和内容是否都一样？</p><h3 id="l0l2-页表项描述符">L0~L2 页表项描述符</h3><p>AArch64 架构中 L0 ~ L3 页表项描述符的格式不完全一样，其中 L0 ~ L2 页表项的内容比较类似，如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/l0_l2.png"></p><p>L0~L2 页表项根据内容可以分成 3 类，一是无效的页表项，二是块（block）类型的页表项，三是页表（table）类型的页表项。</p><ul><li>当页表项描述符 Bit[0] 为 1 时，表示有效的描述符；当 Bit[0] 为 0 时，表示无效描述符</li><li>页表项描述符 Bit[1] 用来表示类型<ul><li>页表类型：当 Bit[1] 为 1 时，表示该描述符包含了指向下一级页表的基地址，是一个页表类型的页表项</li><li>块类型，当 Bit[1] 为 0 时表示一个大内存块（memory block）的页表项，其中包含了最终的物理地址。大内存块通常是用来描述大的连续的物理内存，如 2MBit 或者 1GB 大小的连续物理内存</li></ul></li><li>在块类型的页表项中，Bit[47：n] 表示最终输出的物理地址<ul><li>若页面粒度是 4KB，在 L1 页表项描述符中 n 为 30，表示 1GB 大小的连续物存。在 L2 页表项描述符中 n 为 21，用来表示 2MB 大小的连续物理内存</li><li>若页面粒度为 16KB，在 L2 页表项描述符中 n 为 25，用来表示 32MB 大小的连续物理内存</li></ul></li><li>在块类型的页表项中，Bit[11：2] 是低位属性（lower attribute），Bit[63:52] 是高位属性 (upper attribute)</li><li>在页表类型的页表项描述符中，Bit[47：m] 用来指向下一级页表的基地址<ul><li>当页面粒度为 4KB 时 m 为 12</li><li>当页面粒度为 16KB 时 m 为 14</li><li>当页面粒度为 64KB 时 m 为 16</li></ul></li></ul><h3 id="l3-页表项描述符">L3 页表项描述符</h3><p>如下图所示，L3 页表项描述符包含 5 种页表项，分别是无效的页表项、保留的页表项 4KB 粒度的页表项、16KB 粒度的页表项、64KB 粒度的页表项。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/l3.png"></p><p>L3 页表项描述符的格式如下。</p><ul><li>当页表项描述符 Bit[0] 为 1 时，表示有效的描述符；当 Bit[0] 为 0 时，表示无效描述符</li><li>当页表项描述符 Bit[1] 为 0 时，表示保留页表项；当 Bit[1] 为 1 时，表示页表类型的页表项</li><li>页表描述符 Bit[11：2] 是低位属性，Bit[63:51] 是高位属性</li><li>页表描述符中间的位域中包含了输出地址（output address），也就是最终物理页面的高地址段<ul><li>当页面粒度为 4KB 时输出地址为 Bit[47:12]</li><li>当页面粒度为 16KB 时输出地址为 Bit[47:14]</li><li>当页面粒度为 64KB 时输出地址为 Bit[47:16]</li></ul></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/page_attr.png"></p><h1 id="linux-内核中的页表">Linux 内核中的页表</h1><p>在 ARM64 的 Linux 内核中采用以下 4 级分页模型：</p><ul><li>页全局目录（Page Global Directory，PGD）</li><li>页上级目录（Page Upper Directory，PUD）</li><li>页中间目录（Page Middle Directory，PMD）</li><li>页表（Page Table，PT）</li></ul><p>上述 4 级分页模型分别对应 ARMv8 架构页表的 L0~L3 页表。上述 4 级分页模型在 64 位虚拟地址的划分如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Linux_page.png"></p><p>64 位的虚拟地址分成如下几个部分。</p><ul><li>Bit[63]：用来选择页表基地址寄存器</li><li>Bit[62:48]：保留</li><li>Bit[47:39]：表示 PGD 索引，即 ARM64 中的 L0 索引</li><li>Bit[38:30]：表示 PUD 索引，即 ARM64 中的 L1 索引</li><li>Bit[29:21]：表示 PMD 索引，即 ARM64 中的 L2 索引</li><li>Bit[20:12]：表示 PT 索引，即 ARM64 中的 L3 索引</li><li>Bit[11:0]：表示页面内的偏移量</li></ul><p>基于 ARMv8-A 架构的处理器可以通过配置 ARM64_VA_BITS 宏来设置虚拟地址的宽度。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/Kconfig&gt;</span><br><span class="line">config ARM64_VA_BITS</span><br><span class="line">    int</span><br><span class="line">    default 39 if ARM64_VA_BITS_39</span><br><span class="line">    default 42 if ARM64_VA_BITS_42</span><br><span class="line">    default 48 if ARM64_VA_BITS_48</span><br></pre></td></tr></tbody></table></figure><p>另外，基于 ARMv8-A 架构的处理器支持的最大物理地址宽度也是 48 位。 Linux 内存空间布局与地址映射的粒度和地址映射的层级有关。基于 ARMv8-A 架构的处理器支持的页面粒度可以是 4KB、16KB 或者 64KB。映射的层级可以是 3 级或者 4 级。</p><h2 id="aarch64-在-linux-中的内存布局">AArch64 在 Linux 中的内存布局</h2><p>AArch64 Linux 使用 3 级或 4 级转换表，其页大小配置为 4KB，对于用户和内核分别都有 39-bit (512GB) 或 48-bit (256TB) 的虚拟地址空间。对于页大小为 64KB 的配置，仅使用 2 级转换表，有 42-bit (4TB) 的虚拟地址空间，但内存布局相同。</p><p>用户地址空间的 63:48 位为 0，而内核地址空间的相应位为 1。TTBRx 的选择由虚拟地址的 63 位给出。swapper_pg_dir 仅包含内核（全局）映射，而用户 pgd 仅包含用户（非全局）映射。swapper_pg_dir 地址被写入 TTBR1 中，且从不写入 TTBR0。</p><p>AArch64 Linux 在页大小为 4KB，并使用 4 级转换表时的内存布局：</p><pre><code>起始地址            结束地址            大小      用途-----------------------------------------------------------------------0000000000000000    0000ffffffffffff     256TB      用户空间ffff000000000000    ffffffffffffffff     256TB      内核空间</code></pre><p>AArch64 Linux 在页大小为 64KB，并使用 2 级转换表时的内存布局：</p><pre><code>起始地址            结束地址            大小      用途-----------------------------------------------------------------------0000000000000000    000003ffffffffff       4TB      用户空间fffffc0000000000    ffffffffffffffff       4TB      内核空间</code></pre><p>更详细的内核虚拟内存布局，请参阅内核启动信息。</p><p>4KB 页大小的转换表查找：</p><pre><code>+--------+--------+--------+--------+--------+--------+--------+--------+|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|+--------+--------+--------+--------+--------+--------+--------+--------+ |                 |         |         |         |         | |                 |         |         |         |         v |                 |         |         |         |   [11:0]  页内偏移 |                 |         |         |         +-&gt; [20:12] L3 索引 |                 |         |         +-----------&gt; [29:21] L2 索引 |                 |         +---------------------&gt; [38:30] L1 索引 |                 +-------------------------------&gt; [47:39] L0 索引 +-------------------------------------------------&gt; [63] TTBR0/1</code></pre><p>64KB 页大小的转换表查找：</p><pre><code>+--------+--------+--------+--------+--------+--------+--------+--------+|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|+--------+--------+--------+--------+--------+--------+--------+--------+ |                 |    |               |              | |                 |    |               |              v |                 |    |               |            [15:0]  页内偏移 |                 |    |               +----------&gt; [28:16] L3 索引 |                 |    +--------------------------&gt; [41:29] L2 索引 |                 +-------------------------------&gt; [47:42] L1 索引 +-------------------------------------------------&gt; [63] TTBR0/1</code></pre><p>当使用 KVM 时，管理程序（hypervisor）在 EL2 中通过相对内核虚拟地址的一个固定偏移来映射内核页（内核虚拟地址的高 24 位设为零）:</p><pre><code>起始地址            结束地址            大小      用途-----------------------------------------------------------------------0000004000000000    0000007fffffffff     256GB      在 HYP 中映射的内核对象</code></pre><h1 id="高速缓存管理">高速缓存管理</h1><p>ARM64 指今集提供了对高速缓存进行管理的指令，包括管理无效高速缓存和清除高速缓存的指令。高速缓存的管理主要有如下 3 种情况。</p><ul><li>使整个高速缓存或者某个高速缓存行无效。</li><li>清除（clean）整个高速缓存或者某个高速缓存行。之后，相应的高速缓存行会被标为脏的，数据会写回到下一级高速缓存中或者主存储器中。</li><li>清零（zero）操作。在某些情况下，对高速缓存进行清零操作以起到一个预取和加速的作用。例如，当程序需要使用较大的临时内存时，如果在初始化阶段对这个内存行清零操作，高速缓存控制器就会主动把这些零数据写入高速缓存行中。若程序主动使用高速缓存的清零操作，那么将大大减少系统内部总线的带宽。</li></ul><p>对高速缓存的操作可以指定如下不同的范围。</p><ul><li>整块高速缓存</li><li>某个虚拟地址</li><li>特定的高速缓存行或者组和路</li></ul><p>另外，在 ARMv8 架构中最多可以支持 7 级的高速缓存，即 L1~L7 高速缓存。当对一个高速缓存行进行操作时，我们需要知道高速缓存操作的范围。ARMv8 架构中将从以下角度观察内存。</p><ul><li>全局缓存一致性角度（Point of Coherency，PoC）：系统中所有可以发起内存访问的硬件单元（如处理器、DMA 设备、GPU 等）都能保证观察到的某一个地址上的数据是一致的或者是相同的副本。通常 PoC 表示站在系统的角度来看高速缓存的一致性问题。</li><li><p>处理器缓存一致性角度（Point of Unification，PoU）：表示站在处理器角度来看高速缓存的一致性问题。对于一个内部共享（inner shareable）的 PoU，所有的处理器都能看到相同的内存副本 假设在一个双核处理器系统中，每一个处理器都有独自的 L1 高速缓存，它们共享一个 L2 高速缓存，它们都可以共同访问 DDR4 内存。另外，系统中还有 GPU 等硬件单元。</p></li><li>如果以 PoU 看高速缓存，那么这个观察点就是 L2 高速缓存，因为两个处理器都可以在 L2 高速缓存中看到相同的副本。</li><li><p>如果以 PoC 看高速缓存，那么这个观察点是 DDR4 内存，因为 CPU 和 GPU 都能共同访问 DDR4 内存。</p></li></ul><p>ARMv8 架构提供 DC 和 IC 两条与高速缓存相关的指令，它们根据不同的辅助操作符可以有不同的含义，如下所示。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//DC 指令的格式</span><br><span class="line">DC &lt;dc_op&gt;, &lt;Xt&gt;</span><br><span class="line">//IC 指令的格式</span><br><span class="line">Ic &lt;ic_op&gt; &lt;Xt&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>DC：<ul><li>cisw：清除并使指定的组和路的高速缓存无效</li><li>civac：从 PoC，清除并使指定的虚拟地址对应的高速缓存无效</li><li>csw：清除指定的组或路的高速缓存</li><li>cvac：从 PoC，清除指定的虚拟地址对应的高速缓存</li><li>cvau：从 PoU，清除指定的虚拟地址对应的高速缓存</li><li>isw：使指定的组或路的高速缓存无效</li><li>ivac：从 PoC，使指定的虚拟地址中对应的高速缓存无效</li><li>zva：把虚拟地址中的高速缓存清零</li></ul></li><li>IC：<ul><li>ialluis：从 PoU，使所有的指令高速缓存无效，内部共享属性</li><li>iallu：从 PoU，使所有的指令高速缓存无效</li><li>ivau：从 PoU，使指定虚拟地址对应的指令高速缓存无效</li></ul></li></ul><p>Linux 内核提供了多个与高速缓存管理相关的接口函数，它们定义在 arch/arm64/include/asm/cacheflush.h 头文件中，它们实现在 arch/arm64/mm/cache.S 汇编文件中，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flush_cache_mm(mm) <span class="comment">//在修改页表之前清除和无效该进程的进程地址空间中所有的高速缓存页表项</span></span><br><span class="line">flush_icache_range(start, end)<span class="comment">//用于同步由虚拟地址 start 和 end 组成的区域的指令高速缓存与数据高速缓存的-致性</span></span><br><span class="line">flush_cache_page(vma, addr, pfin)<span class="comment">//用于清除由虚拟地址 addr 和页帧号 pfn 对应的高速缓存页表项</span></span><br><span class="line">flush_cache_range(vma, start, end)<span class="comment">//用于清除由虚拟地址 start 和 end 组成的区域中所有的高速缓存</span></span><br></pre></td></tr></tbody></table></figure><h1 id="内存属性">内存属性</h1><p>ARMv8 架构处理器实现了弱一致性内存模型，在某些情况下，处理器在执行指令时不一定完全按照程序员编写的指令顺序来执行。处理器为了提高指令执行效率会乱序执行指令和预测指令。现代处理器为了提高系统吞吐率都会做如下优化。</p><ul><li>并发执行多条指令（multiple issue ofinstructions）。处理器可以在一个时钟周期内发射和执行多条指令。</li><li>乱序执行（out of order execution）。处理器可以乱序执行没有依赖关系的指令。</li><li>预测执行（speculation）。处理器在遇到一个条件判断时会预测将来可能发生的情况并且提前执行分支代码。</li><li>预测加载。若可以预测一个加载指令，那么高速缓存就可以提前把数据预取到高速缓存行中，从而提高效率。</li><li>加载和存储优化。读写外部内存是一个耗时的操作，处理器应该尽量减少读写次数，如处理器将多次访问内存的操作合并为一次传输，这样可以提高系统效率。</li></ul><p>在一个单核处理器系统中，指令乱序和并发执行对于程序员来说是透明的，因为处理器会处理这些数据依赖关系。但是，在多核处理器系统中，多个处理器内核同时访问共享数据或内存时，与处理器相关的乱序和预测执行等优化手段就可能会对程序造成意想不到的麻烦。因此，了解内存属性和内存屏障就显得非常重要。</p><h2 id="内存属性-1">内存属性</h2><h3 id="普通内存">普通内存</h3><p>普通内存是弱一致性的（weakly ordered），没有额外的约束，可以提供最高的内存访问性能。通常代码段、数据段以及其他数据都会放在普通内存中。普通内存可以让处理器做很多的优化，如分支预测、数据预取、高速缓存行预取和填充、乱序加载等硬件优化。</p><h3 id="设备内存">设备内存</h3><p>处理器访问设备内存会有很多限制，如不能进行预测访问等。设备内存是严格按照指令顺序来执行的。ARMv8 架构定义了多种设备内存的属性：</p><ul><li>Device-nGnRnE</li><li>Device-nGnRE</li><li>Device-nGRE</li><li>Device-GRE</li></ul><p>Device 后的字母是有特殊含义的。</p><ul><li>G 和 nG：分别表示聚合（Gathering）与不聚合（non Gathering）。聚合表示在同一个内存属性的区域中允许把多次访问内存的操作合并成一次总线传输：<ul><li>若一个内存地址标记为“nG”，则会严格按照访问内存的次数和大小来访问内存，不会做合并优化</li><li>若一个内存地址标记为“G”，则会做总线合并访问，如合并两个相邻的字节访问为一次多字节访问。若程序访问同一个内存地址两次，那么处理器只会访问内存一次，但是在第二次访问内存指令后返回相同的值。若这个内存区域标记为“nG”，那么处理器则会访问内存两次</li></ul></li><li>R 和 nR：分别表示指令重排（Re-ordering）与不重排（non Re-ordering）。</li><li>E 和 nE：分别表示提前写应答（Early Write Acknowledgement）与不提前写应答 Early Write Acknowledgement）往外部设备写数据时，处理器先把数据写入写终 （write huffer）中，若使能了提前写应答，则数据到达写缓冲区时会发送写应答： 有使能提前写应答，则数据到达外设时才发送写应答。 Linux 内核中定义了如下几个内存属性。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL_TAGGED1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL_NC2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_DEVICE_nGnRnE3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_DEVICE_nGnRE4</span></span><br></pre></td></tr></tbody></table></figure><ul><li>MT_DEVICE_nGnRnE：设备内存属性，不支持聚合操作，不支持指令重排，不支提前写应答</li><li>MT_DEVICE_nGnRE：设备内存属性，不支持聚合操作，不支持指令重排，支持提写应答</li><li>MT_DEVICE_GRE：设备内存属性，支持聚合操作，支持指令重排，支持提前写应</li><li>MT_NORMAL_NC：普通内存属性，关闭高速缓存，其中 NC 是 Non-Cacheable 意思</li><li>MT_NORMAL：普通内存属性</li><li>MT_NORMAL_WT：普通内存属性，高速缓存的回写策略为直写（write through）策内存属性并没有存放在页表项中，而是存放在 MAIR_ELn （Memory Attribute IndirectRegister Eln）中。页表项中使用一个 3 位的索引值来查找 MAIR_ELn</li></ul><p>MAIR_ELn 分成 8 段，每一段都可以用于描述不同的内存属性。</p><h2 id="高速缓存共享属性">高速缓存共享属性</h2><p>普通内存可以设置高速缓存为可缓存的和不可缓存的。进一步地，我们可以设置高速缓为内部共享和外部共享的高速缓存。一个处理器系统中，除了处理器之外，还有其他的可以访问内存的硬件单元，这些硬件单元通常具有访问内存总线（bus master）的能力，如 DMA 设备、GPU 等，这些硬件单元可以称为处理器之外的观察点。在一个多核系统中，DMA 设备和 GPU 通过系统总线连接到 DDR 内存，而处理器也通过系统总线连接到 DDR 内存，它们都能同时通过系统总线访问到内存。</p><ul><li>如果一个内存区域被标记为“不可共享的”表示它只能被一个处理器访问，其他处理器不能访问这个内存区域。</li><li>如果一个内存区域被标记为“内部共享的”，表示它可以被多个处理器访问和共享，但是系统中其他的访问内存的硬件单元就不能访问了，如 DMA 设备、GPU 等。</li><li>如果一个内存区域被标记为“外部共享的”，表示系统中很多访问内存的单元（如 DMA 设备、GPU 等）都可以和处理器一样访问这个内存区域。</li></ul><h1 id="内存屏障">内存屏障</h1><h2 id="内存屏障指令">内存屏障指令</h2><p>ARMv8 指令集提供了 3 条内存屏障指令。</p><ul><li>数据存储屏障（Data Memory Barrier，DMB）指令：仅当所有在它前面的存储器访问操作都执行完毕后，才提交（commit）在它后面的访问指令。DMB 指令保证的是 DMB 指令之前的所有内存访问指令和 DMB 指令之后的所有内存访问指令的顺序。</li><li>数据同步屏障（Data synchronization Barrier，DSB）指令：比 DMB 指令要严格一些，仅当所有在它前面的访问指令都执行完毕后，才会执行在它后面的指令，即任何指令都要等待 DSB 指令前面的访问指令完成。位于此指令前的所有缓存，如分支预测和 TLB 维护操作需全部完成。</li><li>指令同步屏障（Instruction synchronization Barrier，ISB）指令：比 DMB 指令和 DSB 指令严格，刷新流水线（flush pipeline）和预取缓冲区后，才会从高速缓存或者内存中预取 ISB 指令之后的指令。ISB 指令通常用来保证上下文切换的效果，如 ASID 更改、TLB 维护操作和 C15 寄存器的修改等。</li></ul><p>DMB 指令和 DSB 指令还可以带参数，来指定内存屏障指令的顺序以及共享属性等信息。 内存屏障指令参数如下所示。</p><ul><li>全系统共享：<ul><li>SY：内存读写指令</li><li>ST：内存写指令</li><li>LD：内存读指令</li></ul></li><li>内部共享：<ul><li>ISH：内存读写指令</li><li>ISHST：内存写指令</li><li>ISHLD：内存读指令</li></ul></li><li>不共享：<ul><li>NSH：内存读写指令</li><li>NSHST：内存写指令</li><li>NSHLD：内存读指令</li></ul></li><li>外部共享：<ul><li>OSH：内存读写指令</li><li>OSHST：内存写指令</li><li>OSHLD：内存读指令</li></ul></li></ul><h2 id="加载-获取屏障原语与存储-释放屏障原语">加载-获取屏障原语与存储-释放屏障原语</h2><p>ARMv8 指令集还支持隐含内存屏障原语的加载和存储指令，这些内存屏障原语影响了加和存储指令的执行顺序，它们对执行顺序的影响是单方向的。</p><ul><li>获取（acquire）屏障原语：该屏障原语之后的读写操作不能重排到该屏障原语前面，通常该屏障原语和加载指令结合</li><li>释放（release）屏障原语：该屏障原语之前的读写操作不能重排到该屏障原语后面通常该屏障原语和存储指令结合</li><li>加载-获取（load-acquire）屏障原语：含有获取屏障原语的读操作，相当于单方向向后的屏障指令。所有加载-获取内存屏障指令后面的内存访问指令只能在加载-获取内存屏障指令执行后才能开始执行，并且被其他 CPU 观察到。普通的读和写操作可以向后越过该屏障指令，但是之后的读和写操作不能向前越过该屏障指令</li><li>存储-释放（store-release）屏障原语：含有释放屏障原语的写操作，相当于单方向前的屏障指令。只有所有存储-释放屏障原语之前的指令完成了，才能执行存储-释屏障原语之后的指令，这样其他 CPU 可以观察到存储-释放屏障原语之前的指令已执行完。普通的读和写可以向前越过存储-释放屏障指令，但是之前的读和写操作不能向后越过存储-释放屏障指令</li></ul><p>加载-获取和存储-释放屏障指令相当于是单方向的半条 DMB 指令，而 DMB 指令相当于是全方向的栅障。任何读写操作都不能跨越该栅障。它们组合使用可以增强代码灵活性并提高执行效率。</p><p>如图所示，加载-获取屏障指令和存储-释放屏障指令组成了一个临界区，这相当于一个栅栏。在加载-获取屏障指令之前的内存访问指令（如读指令 1 和写指令 1）可以挪到加载-获取屏障指令后面执行，但是不能向前越过存储-释放屏障指令。而存储-释放屏障指令后面的内存访问指令（如读指令 2 和写指令 2）不能向前穿越过加载-获取屏障指令。在临界区中的内存不能越过临界区，如读指令 2 必须在加载-获取屏障指令后开始执行；如读指令 2 和写指令 2 必须在存储-释放屏障指令之前完成，即保证其他 CPU 在存储-释放屏障指令执行完成时能观察到读指令 1 和写指令 1、读指令 2 和写指令 2 已经完成。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/mem_barrier.png"></p><p>ARM64 指令集中提供了如下指令。</p><ul><li>LDAR 和 STLR 指令：用于加载和存储</li><li>CAS 指令：用于比较和交换</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9hcm12OC1yZWYuY29kaW5nYmVsaWVmLmNvbS96aC9jaGFwdGVyX2Q0L2Q0M18zX21lbW9yeV9hdHRyaWJ1dGVfZmllbGRzX2luX3RoZV92bXNhdjgtNjRfdHJhbnNsYXRpb25fdGFibGVfZm9ybWF0c19kZXNjcmlwdG9ycy5odG1s">https://armv8-ref.codingbelief.com/zh/chapter_d4/d43_3_memory_attribute_fields_in_the_vmsav8-64_translation_table_formats_descriptors.html<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存管理（一）Cache</title>
      <link href="/next/2021/LinuxKernel/LinuxMemoryCache/"/>
      <url>/next/2021/LinuxKernel/LinuxMemoryCache/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MMCache.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2ZDczZDdkOWMwODA3MGU1MjAzMDM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><blockquote><p>声明： 本文转载自 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDIyOTM0Mzc=">Cache 的基本原理<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDcwOTYxMzA=">Cache 组织方式<i class="fa fa-external-link-alt"></i></span></p></blockquote><h1 id="多级-cache-存储结构">多级 cache 存储结构</h1><p>我们在 L1 cache 后面连接 L2 cache，在 L2 cache 和主存之间连接 L3 cache。等级越高，速度越慢，容量越大。不同等级 cache 速度之间关系如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache4.jpg"></p><p>经过 3 级 cache 的缓冲，各级 cache 和主存之间的速度最萌差也逐级减小。在一个真实的系统上，各级 cache 之间硬件上是如何关联的呢？我们看下 Cortex-A53 架构上各级 cache 之间的硬件抽象框图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache5.jpg"></p><p>在 Cortex-A53 架构上，L1 cache 分为单独的 instruction cache（ICache）和 data cache（DCache）。L1 cache 是 CPU 私有的，每个 CPU 都有一个 L1 cache。一个 cluster 内的所有 CPU 共享一个 L2 cache，L2 cache 不区分指令和数据，都可以缓存。所有 cluster 之间共享 L3 cache。L3 cache 通过总线和主存相连。</p><h1 id="多级-cache-之间的配合工作">多级 cache 之间的配合工作</h1><p>首先引入两个名词概念，命中和缺失。 CPU 要访问的数据在 cache 中有缓存，称为“命中” (hit)，反之则称为“缺失” (miss)。多级 cache 之间是如何配合工作的呢？我们假设现在考虑的系统只有两级 cache。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache6.jpg"></p><ul><li><p>inclusive cache（某一地址的数据可能存在多级缓存中） 当 CPU 试图从某地址 load 数据时，首先从 L1 cache 中查询是否命中，如果命中则把数据返回给 CPU 如果 L1 cache 缺失，则继续从 L2 cache 中查找。当 L2 cache 命中时，数据会返回给 L1 cache 以及 CPU 如果 L2 cache 也缺失，很不幸，我们需要从主存中 load 数据，将数据返回给 L2 cache、L1 cache 及 CPU</p></li><li><p>exclusive cache 这种 cache 保证某一地址的数据缓存只会存在于多级 cache 其中一级</p></li></ul><h2 id="直接映射缓存-direct-mapped-cache">直接映射缓存 (Direct mapped cache)</h2><p>cache 的大小称之为 cahe size。我们将 cache 平均分成相等的很多块，每一个块大小称之为 cache line。现在的硬件设计中，一般 cache line 的大小是 4-128 Byts。</p><blockquote><p>注意，cache line 是 cache 和主存（非 CPU）之间数据传输的最小单位。</p></blockquote><p>我们假设下面的讲解都是针对 64 Bytes 大小的 cache，并且 cache line 大小是 8 字节。我们可以类似把这块 cache 想想成一个数组，数组总共 8 个元素，每个元素大小是 8 字节。就像下图这样。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache7.jpg"></p><p>现在我们考虑一个问题，CPU 从 0x0654 地址读取一个字节，cache 控制器是如何判断数据是否在 cache 中命中呢？现在硬件采取的做法是对地址进行散列（可以理解成地址取模操作）。我们接下来看看是如何做到的？ <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache8.jpg"></p><p>我们一共有 8 行 cache line，cache line 大小是 8 Bytes。所以我们可以利用地址低 3 bits（如上图地址蓝色部分）用来寻址 8 bytes 中某一字节，我们称这部分 bit 组合为 offset。同理，8 行 cache line，为了覆盖所有行。我们需要 3 bits（如上图地址黄色部分）查找某一行，这部分地址部分称之为 index。</p><p>如果两个不同的地址，其地址的 bit3-bit5 如果完全一样的话，那么这两个地址经过硬件散列之后都会找到同一个 cache line。所以，我们又引入 tag array 区域。每一个 cache line 都对应唯一一个 tag，tag 中保存的是整个地址位宽去除 index 和 offset 使用的 bit 剩余部分（如上图地址绿色部分）。</p><p>tag、index 和 offset 三者组合就可以唯一确定一个地址了。因此，当我们根据地址中 index 位找到 cache line 后，取出当前 cache line 对应的 tag，然后和地址中的 tag 进行比较，如果相等，这说明 cache 命中。如果不相等，说明当前 cache line 存储的是其他地址的数据，这就是 cache 缺失。</p><p>我们可以从图中看到 tag 旁边还有一个 valid bit，这个 bit 用来表示 cache line 中数据是否有效（例如：1 代表有效；0 代表无效）。所以，上述比较 tag 确认 cache line 是否命中之前还会检查 valid bit 是否有效。只有在有效的情况下，比较 tag 才有意义。如果无效，直接判定 cache 缺失。</p><ul><li>offset 用于在一个 cache line 里确定是哪一个字节</li><li>index 寻址 cache line（确定是哪一个 cache line）</li><li>tag array 全地址匹配</li><li>valid bit 表示 cache 中的数据是否有效</li></ul><p>上面的例子中，cache size 是 64 Bytes 并且 cache line size 是 8 bytes。offset、index 和 tag 分别使用 3 bits、3 bits 和 42 bits（假设地址宽度是 48 bits）。我们现在再看一个例子：512 Bytes cache size，64 Bytes cache line size。根据之前的地址划分方法，offset、index 和 tag 分别使用 6 bits、3 bits 和 39 bits。如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache9.jpg"></p><h2 id="直接映射缓存的优缺点">直接映射缓存的优缺点</h2><p>直接映射缓存在硬件设计上会更加简单，因此成本上也会较低。根据直接映射缓存的工作方式，我们可以画出主存地址 0x00-0x88 地址对应的 cache 分布图。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache10.jpg"></p><p>我们可以看到，地址 0x00-0x3f 地址处对应的数据可以覆盖整个 cache。0x40-0x7f 地址的数据也同样是覆盖整个 cache。我们现在思考一个问题，如果一个程序试图依次访问地址 0x00、0x40、0x80，cache 中的数据，每次访问数据都要从主存中读取，所以 cache 的存在并没有对性能有什么提升。这种现象叫做 cache 颠簸（cache thrashing）。针对这个问题，我们引入多路组相连缓存。</p><h2 id="两路组相连缓存-two-way-set-associative-cache">两路组相连缓存 (Two-way set associative cache)</h2><p>我们依然假设 64 Bytes cache size，cache line size 是 8 Bytes。什么是路（way）的概念。我们将 cache 平均分成多份，每一份就是一路。因此，两路组相连缓存就是将 cache 平均分成 2 份，每份 32 Bytes。如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache11.jpg"></p><p>cache 被分成 2 路，每路包含 4 行 cache line。我们将所有索引一样的 cache line 组合在一起称之为组。例如，上图中一个组有两个 cache line，总共 4 个组。我们依然假设从地址 0x0654 地址读取一个字节数据。由于 cache line size 是 8 Bytes，因此 offset 需要 3 bits，这和之前直接映射缓存一样。不一样的地方是 index，在两路组相连缓存中，index 只需要 2 bits，因为一路只有 4 行 cache line。上面的例子根据 index 找到第 2 行 cache line（从 0 开始计算），第 2 行对应 2 个 cache line，分别对应 way 0 和 way 1。因此 index 也可以称作 set index（组索引）。先根据 index 找到 set，然后将组内的所有 cache line 对应的 tag 取出来和地址中的 tag 部分对比，如果其中一个相等就意味着命中。</p><p>因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应 2 个 cache line，而直接映射缓存一个地址只对应一个 cache line。那么这究竟有什么好处呢？</p><h2 id="两路组相连缓存优缺点">两路组相连缓存优缺点</h2><p>两路组相连缓存的硬件成本相对于直接映射缓存更高。因为其每次比较 tag 的时候需要比较多个 cache line 对应的 tag（某些硬件可能还会做并行比较，增加比较速度，这就增加了硬件设计复杂度）。好处是可以有助于降低 cache 颠簸可能性。根据两路组相连缓存的工作方式，我们可以画出主存地址 0x00-0x4f 地址对应的 cache 分布图。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache12.jpg"></p><h2 id="全相连缓存-full-associative-cache">全相连缓存 (Full associative cache)</h2><p>既然组相连缓存那么好，如果所有的 cache line 都在一个组内。岂不是性能更好。是的，这种缓存就是全相连缓存。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache13.jpg"></p><p>这可以最大程度的降低 cache 颠簸的频率。但是硬件成本上也是更高。</p><h1 id="cache-分配策略-cache-allocation-policy">Cache 分配策略 (Cache allocation policy)</h1><p>cache 的分配策略是指我们什么情况下应该为数据分配 cache line。cache 分配策略分为读和写两种情况。</p><ul><li><p>读分配 (read allocation) 当 CPU 读数据时，发生 cache 缺失，这种情况下都会分配一个 cache line 缓存从主存读取的数据。默认情况下，cache 都支持读分配</p></li><li><p>写分配 (write allocation) 当 CPU 写数据发生 cache 缺失时，才会考虑写分配策略。当我们不支持写分配的情况下，写指令只会更新主存数据，然后就结束了。当支持写分配的时候，我们首先从主存中加载数据到 cache line 中（相当于先做个读分配动作），然后会更新 cache line 中的数据</p></li></ul><h1 id="cache-更新策略-cache-update-policy">Cache 更新策略 (Cache update policy)</h1><p>cache 更新策略是指当发生 cache 命中时，写操作应该如何更新数据。cache 更新策略分成两种：写直通和回写。</p><ul><li><p>写直通 (write through) 当 CPU 执行 store 指令并在 cache 命中时，我们更新 cache 中的数据并且更新主存中的数据。cache 和主存的数据始终保持一致</p></li><li><p>写回 (write back) 当 CPU 执行 store 指令并在 cache 命中时，我们只更新 cache 中的数据。并且每个 cache line 中会有一个 bit 位记录数据是否被修改过，称之为 dirty bit（翻翻前面的图片，cache line 旁边有一个 D 就是 dirty bit）。我们会将 dirty bit 置位。主存中的数据只会在 cache line 被替换或者显示的 clean 操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在 cache 中。cache 和主存的数据可能不一致</p></li></ul><p>同时思考个问题，为什么 cache line 大小是 cache 控制器和主存之间数据传输的最小单位呢？这也是因为每个 cache line 只有一个 dirty bit。这一个 dirty bit 代表着整个 cache line 是否被修改的状态。</p><h1 id="cache-地址">Cache 地址</h1><p>我们都知道 cache 控制器根据地址查找判断是否命中，这里的地址究竟是虚拟地址 (virtual address，VA) 还是物理地址 (physical address，PA)？</p><h2 id="虚拟高速缓存-vivt">虚拟高速缓存 (VIVT)</h2><p>我们首先介绍的是虚拟高速缓存，这种 cache 硬件设计简单。在 cache 诞生之初，大部分的处理器都使用这种方式。虚拟高速缓存以虚拟地址作为查找对象。如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache14.jpg"></p><p>虚拟地址直接送到 cache 控制器，如果 cache hit。直接从 cache 中返回数据给 CPU。如果 cache miss，则把虚拟地址发往 MMU，经过 MMU 转换成物理地址，根据物理地址从主存 (main memory) 读取数据。 但是，正是使用了虚拟地址作为 tag，所以引入很多软件使用上的问题。 操作系统在管理高速缓存正确工作的过程中，主要会面临两个问题。歧义 (ambiguity) 和别名 (alias)。为了保证系统的正确工作，操作系统负责避免出现歧义和别名。</p><ul><li><p>歧义 (ambiguity)<br>歧义是指不同的数据在 cache 中具有相同的 tag 和 index，这就产生了歧义（不同进程相同虚拟地址映射了不同物理地址）。当我们切换进程的时候，可以选择 flush 所有的 cache。flush cache 操作有两种：<br>- 使主存储器有效。针对 write back 高速缓存，首先应该使主存储器有效，保证已经修改数据的 cacheline 写回主存储器，避免修改的数据丢失<br>- 使高速缓存无效。保证切换后的进程不会错误的命中上一个进程的缓存数据</p><p>因此，切换后的进程刚开始执行的时候，将会由于大量的 cache miss 导致性能损失。</p></li><li><p>别名 (alias) 当不同的虚拟地址映射相同的物理地址，通俗点来说就是指同一个物理地址的数据被加载到不同的 cacheline 中就会出现别名现象。</p></li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache15.jpg"></p><p>针对共享数据所在页的映射方式采用 nocache 映射。例如上面的例子中，0x2000 和 0x4000 映射物理地址 0x8000 的时候都采用 nocache 的方式，这样不通过 cache 的访问，肯定可以避免这种问题。</p><h2 id="物理高速缓存-pipt">物理高速缓存 (PIPT)</h2><p>基于对 VIVT 高速缓存的认识，我们知道 VIVT 高速缓存存在歧义和名别两大问题。主要问题原因是：tag 取自虚拟地址导致歧义，index 取自虚拟地址导致别名。所以，如果想让操作系统少操心，最简单的方法是 tag 和 index 都取自物理地址。物理的地址 tag 部分是独一无二的，因此肯定不会导致歧义。而针对同一个物理地址，index 也是唯一的，因此加载到 cache 中也是唯一的 cacheline，所以也不会存在别名。我们称这种 cache 为物理高速缓存，简称 PIPT(Physically Indexed Physically Tagged)。PIPT 工作原理如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache16.jpg"></p><p>CPU 发出的虚拟地址经过 MMU 转换成物理地址，物理地址发往 cache 控制器查找确认是否命中 cache。虽然 PIPT 方式在软件层面基本不需要维护，但是硬件设计上比 VIVT 复杂很多。因此硬件成本也更高。同时，由于虚拟地址每次都要翻译成物理地址，因此在查找性能上没有 VIVT 方式简洁高效，毕竟 PIPT 方式需要等待虚拟地址转换物理地址完成后才能去查找 cache。 在 Linux 内核中，可以看到针对 PIPT 高速缓存的管理函数都是空函数，无需任何的管理。</p><h2 id="物理标记的虚拟高速缓存-vipt">物理标记的虚拟高速缓存 (VIPT)</h2><p>为了提升 cache 查找性能，我们不想等到虚拟地址转换物理地址完成后才能查找 cache。因此，我们可以使用虚拟地址对应的 index 位查找 cache，与此同时（硬件上同时进行）将虚拟地址发到 MMU 转换成物理地址。当 MMU 转换完成，同时 cache 控制器也查找完成，此时比较 cacheline 对应的 tag 和物理地址 tag 域，以此判断是否命中 cache。我们称这种高速缓存为 VIPT(Virtually Indexed Physically Tagged)。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cache17.jpg"></p><p>VIPT 以物理地址部分位作为 tag，因此我们不会存在歧义问题。但是，采用虚拟地址作为 index，所以可能依然存在别名问题。是否存在别名问题，需要考虑 cache 的结构，我们需要分情况考虑。</p><ul><li><p>VIPT Cache 为什么不存在歧义 在这里重点介绍下为什么 VIPT Cache 不存在歧义。假设以 32 位 CPU 为例，页表映射最小单位是 4KB。我们假设虚拟地址&lt;12:4&gt;位（这是一个有别名问题的 VIPT Cache) 作为 index，于此同时将虚拟地址&lt;31:12&gt;发送到 MMU 转换得到物理地址的&lt;31:12&gt;，这里我们把&lt;31:12&gt;作为 tag，并不是&lt;31:13&gt;。这地方很关键，也就是说 VIPT 的 tag 取决于物理页大小的剩余位数，而不是去掉 index 和 offset 的剩余位数。物理 tag 是惟一的，所以不存在歧义。</p></li><li><p>VIPT Cache 什么情况不存在别名 我们知道 VIPT 的优点是查找 cache 和 MMU 转换虚拟地址同时进行，所以性能上有所提升。歧义问题虽然不存在了，但是别名问题依旧可能存在，那么什么情况下别名问题不会存在呢？Linux 系统中映射最小的单位是页，一页大小是 4KB。那么意味着虚拟地址和其映射的物理地址的位&lt;11...0&gt;是一样的。针对直接映射高速缓存，如果 cache 的 size 小于等于 4KB，是否就意味着无论使用虚拟地址还是物理地址的低位查找 cache 结果都是一样呢？是的，因为虚拟地址和物理地址对应的 index 是一样的。这种情况，VIPT 实际上相当于 PIPT，软件维护上和 PIPT 一样。如果示例是一个四路组相连高速缓存呢？只要满足一路的 cache 的大小小于等于 4KB，那么也不会出现别名问题。</p></li><li><p>VIPT Cache 的别名问题 假设系统使用的是直接映射高速缓存，cache 大小是 8KB，cacheline 大小是 256 字节。这种情况下的 VIPT 就存在别名问题。因为 index 来自虚拟地址位&lt;12...8&gt;，虚拟地址和物理地址的位&lt;11...8&gt;是一样的，但是 bit12 却不一定相等。 假设虚拟地址 0x0000 和虚拟地址 0x1000 都映射相同的物理地址 0x4000。那么程序读取 0x0000 时，系统将会从物理地址 0x4000 的数据加载到第 0x00 行 cacheline。然后程序读取 0x1000 数据，再次把物理地址 0x4000 的数据加载到第 0x10 行 cacheline。这不，别名出现了。相同物理地址的数据被加载到不同 cacheline 中。</p></li></ul><h2 id="如何解决-vipt-cache-别名问题">如何解决 VIPT Cache 别名问题</h2><p>我们接着上面的例子说明。首先出现问题的场景是共享映射，也就是多个虚拟地址映射同一个物理地址才可能出现问题。我们需要想办法避免相同的物理地址数据加载到不同的 cacheline 中。如何做到呢？那我们就避免上个例子中 0x1000 映射 0x4000 的情况发生。我们可以将虚拟地址 0x2000 映射到物理地址 0x4000，而不是用虚拟地址 0x1000。0x2000 对应第 0x00 行 cacheline，这样就避免了别名现象出现。因此，在建立共享映射的时候，返回的虚拟地址都是按照 cache 大小对齐的地址，这样就没问题了。如果是多路组相连高速缓存的话，返回的虚拟地址必须是满足一路 cache 大小对齐。在 Linux 的实现中，就是通过这种方法解决别名问题。</p><h2 id="不存在的-pivt-高速缓存">不存在的 PIVT 高速缓存</h2><p>按照排列组合来说，应该还存在一种 PIVT 方式的高速缓存。因为 PIVT 没有任何优点，却包含以上的所有缺点。</p><h2 id="总结">总结</h2><p>VIVT Cache 问题太多，软件维护成本过高，是最难管理的高速缓存。所以现在基本只存在历史的文章中。现在我们基本看不到硬件还在使用这种方式的 cache。现在使用的方式是 PIPT 或者 VIPT。如果多路组相连高速缓存的一路的大小小于等于 4KB，一般硬件采用 VIPT 方式，因为这样相当于 PIPT，岂不美哉。当然，如果一路大小大于 4KB，一般采用 PIPT 方式，也不排除 VIPT 方式，这就需要操作系统多操点心了。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDIyOTM0Mzc=">https://zhuanlan.zhihu.com/p/102293437<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDcwOTYxMzA=">https://zhuanlan.zhihu.com/p/107096130<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（番外篇）调度算法的演变</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskExt/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskExt/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskSchAlgoHistory.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2MDJmYTYzNzY4OTA3MTA1OWI5Mjk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="on调度器">O（n）调度器</h1><h2 id="如何组织-task">如何组织 task</h2><p>调度器模块定义了一个 runqueue_head 的链表头变量，无论进程是普通进程还是实时进程，只要进程状态变成可运行状态的时候，它会被挂入这个全局 runqueue 链表中。由于整个系统中的所有 CPU 共享一个 runqueue，为了解决同步问题，调度器模块定义了一个自旋锁来保护对这个全局 runqueue 的并发访问。</p><p>除了这个 runqueue 队列，系统还有一个囊括所有 task（不管其进程状态为何）的链表，链表头定义为 init_task，在一个调度周期结束后，重新为 task 赋初始时间片值的时候会用到该链表。</p><h2 id="动态优先级">动态优先级</h2><p>对于普通进程，计算动态优先级的策略如下：</p><ul><li>如果该进程的时间片已经耗尽，那么动态优先级是 0，这也意味着在本次调度周期中该进程已经再也没有机会获取 CPU 资源了。</li><li>如果该进程的时间片还有剩余，那么其动态优先级等于该进程剩余的时间片和静态优先级之和。之所以用（20-nice value）表示静态优先级，主要是为了让静态优先级变成单调上升。之所以要考虑剩余时间片是为了奖励睡眠的进程，因为睡眠的进程剩余的时间片较多，因此动态优先级也就会高一些，更容易被调度器调度执行。</li></ul><p>在计算普通进程的动态优先级的时候，除了考虑进程剩余时间片信息和静态优先级，调度器也会酌情考虑 cache 和 TLB 的性能问题。例如 A 和 B 进程优先级相同，剩余的时间片都是 3 个 tick，但是 A 进程上一次就是运行在本 CPU 上，如果选择 A，可能会有更好的 cache 和 TLB 的命中率，从而提高性能。在这种情况下，调度器会提升 A 进程的动态优先级。此外，如果备选进程和当前进程共享同一个地址空间，那么在计算调度指数的时候也会做小小的倾斜。</p><h2 id="主调度器算法">主调度器算法</h2><p>主调度器（schedule 函数）核心代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list_for_each(tmp, &amp;runqueue_head) {</span><br><span class="line">    p = list_entry(tmp, <span class="keyword">struct</span> task_struct, run_list);</span><br><span class="line">    <span class="type">int</span> weight = goodness(p, this_cpu, prev-&gt;active_mm);</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; c)</span><br><span class="line">        c = weight, next = p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>list_for_each 用来遍历 runqueue_head 链表上的所有的进程，临时变量 p 就是本次需要检查的进程描述符。如何判断哪一个进程是最适合调度执行的进程呢？我们需要计算进程的动态优先级（对应上面程序中的变量 weight），它是通过 goodness 函数实现的。动态优先级最大的那个进程就是当前最适合调度到 CPU 执行的进程。一旦选中，调度器会启动进程切换，运行该进程以替换之前的那个进程。</p><h2 id="时间片处理">时间片处理</h2><p>普通进程的时间片处理思路是这样：</p><ul><li>每个进程根据其静态优先级可以固定分配一个缺省的时间片，静态优先级越大，分配的时间片就越大。</li><li>一旦 Runqueue 中的进程被调度执行，那么其时间片就会在 tick 到来的时候递减，如果进程时间片耗尽，那么该进程将失去分配 CPU 资源的资格。</li><li>Runqueue 中的进程的时间片全部被用完之后，我们称一个调度周期结束，这时候需要为 runqueue 中的进程重新设定其缺省时间片，这样，一个新的调度周期又开始了。</li></ul><h1 id="o1调度器">O（1）调度器</h1><h2 id="why-o1调度器">Why O（1）调度器</h2><p>让我们一起来控诉 O（n）调度器的“七宗罪”，同时这也是 Ingo Molnar 发起 O（1）调度器项目背后的原因。</p><ul><li><p>算法复杂度问题： 让人最不爽的就是对 runqueue 队列的遍历，随着系统中 runnable 状态的进程数目增多，那么调度器 select next 的运算量也随之呈线性的增长，这也是我们为什么叫它 O（n）调度器的原因。此外，调度周期结束后，调度器会为所有进程的时间片进行“充值“的动作，为每一个进程计算其时间片的过程太耗费时间。</p></li><li>SMP 扩展性问题，2.4 内核的 O（n）调度器有非常差的 SMP 扩展性。</li><li><p>CPU 空转问题： 每当 runqueue 链表中的所有进程耗尽了其时间片，这时候就需要启动对系统中所有进程时间片重新计算的过程。这个计算过程异常丑陋，需要遍历系统中的所有进程，为进程描述符的 counter 成员赋一个新值。而这个操作足以把该 CPU 上的 L1 cache 全部干掉，这时候 L1 cache 的命中率急剧下降在只剩最后一个线程的时候多个 cpu 中就会有 cpu 处于 idle 状态，出现 cpu 空转问题</p></li><li><p>task bouncing issue： 一般而言，一个进程最好是从一而终，运行在一个 cpu 上，在 O（n）调度器下很多人都反映有进程在 CPU 之间跳来跳去的现象导致 cache 命中率下降</p></li><li><p>RT 进程调度性能问题： 实时进程和普通进程挂在一个链表中。当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的调度指数，从而选择出心仪的那个实时进程</p><p>当然，上面的这些还不是关键，最重要的是整个 linux 内核不是抢占式内核，在整个内核态都不能被抢占。除了内核抢占性之外，优先级翻转问题也需要引起调度器的重视，否则即便一个 rt 进程变成 runnable 状态了，但是也只能眼睁睁的看着比它优先级低的进程运行，直到该 rt 进程等待的资源被释放。</p></li><li><p>交互式普通进程的调度延迟问题： O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程</p></li><li><p>时间片粒度问题： 随着 runnable 进程增大，调度周期也变大。当一个进程耗尽其时间片之后，只能等待下一个调度周期到来。因此随着调度周期变大，系统响应也会变的较差</p></li></ul><p>虽然 O（n）调度器存在不少的 issue，但是社区的人还是基本认可这套算法的，O（1）基于 O（n）调度器进行改进。鉴于 O（1）调度器和 O（n）调度器没有本质区别，因此我们只是描述它们之间不同的地方。</p><h2 id="o1调度器的软件功能划分">O（1）调度器的软件功能划分</h2><p>下图是一个 O（1）调度器的软件框架： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/O1_sched.png"></p><p>O（n）调度器中只有一个全局的 runqueue，严重影响了扩展性，因此在 O（1）调度器中引入了 per-CPU runqueue 的概念。系统中所有的可运行状态的进程首先经过负载均衡模块挂入各个 CPU 的 runqueue，然后由主调度器和 tick 调度器驱动该 CPU 上的调度行为。</p><p>由于引入了 per-CPU runqueue，O（1）调度器删除了全局 runqueue 的 spin lock，而是把这个 spin lock 放入到 per-CPU runqueue 数据结构中（rq-&gt;lock），通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。这种方法在内核中经常使用，是一个比较通用的性能优化方法。</p><p>通过上面的软件结构划分可以解决 O（n）调度的 SMP 扩展性问题和 CPU 空转问题。此外，好的复杂均衡算法也可以解决 O（n）调度器的 task bouncing 问题。</p><h2 id="o1调度器的-runqueue-结构">O（1）调度器的 runqueue 结构</h2><p>O（1）调度器的基本优化思路就是把原来 runqueue 上的单链表变成多个链表，即每一个优先级的进程被挂入不同链表中。相关的软件结构可以参考下面的图片： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/O1_runqueue.png"></p><p>在调度器中，runqueue 是一个很重要的数据结构，它最重要的作用是管理那些处于可运行状态的进程。O（1）调度器引入了优先级队列的概念来管理 task，具体由 struct prio_array 抽象：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prio_array</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_active;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bitmap[BITMAP_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_PRIO</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>由于支持 140 个优先级，因此 queue 成员中有 140 个分别表示各个优先级的链表头，不同优先级的进程挂入不同的链表中。bitmap 是表示各个优先级进程链表是空还是非空。 nr_active 表示这个队列中有多少个 task。在这些队列中，100～139 是普通进程的优先级，其他的是实时进程的优先级。因此，在 O（1）调度器中，RT 进程和普通进程被区分开了，普通进程根本不会影响 RT 进程的调度。 Runqueue 中有两个优先级队列（struct prio_array）分别用来管理 active（即时间片还有剩余）和 expired（时间片耗尽）的进程。Runqueue 中有两个优先级队列的指针，分别指向这两个优先级队列。随着系统的运行，active 队列的 task 一个个的耗尽其时间片，挂入到 expired 队列。当 active 队列的 task 为空的时候，切换 active 和 expired 队列，开始一轮新的调度过程。</p><p>虽然在 O（1）调度器中 task 组织的形式发生了变化，但是其核心思想仍然和 O（n）调度器一致的。</p><h2 id="核心调度算法">核心调度算法</h2><p>主调度器（就是 schedule 函数）的主要功能是从该 CPU 的 runqueue 找到一个最合适的进程调度执行。其基本的思路就是从 active 优先级队列中寻找，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idx = sched_find_first_bit(<span class="built_in">array</span>-&gt;bitmap);</span><br><span class="line"><span class="built_in">queue</span> = <span class="built_in">array</span>-&gt;<span class="built_in">queue</span> + idx;</span><br><span class="line">next = list_entry(<span class="built_in">queue</span>-&gt;next, <span class="type">task_t</span>, run_list);</span><br></pre></td></tr></tbody></table></figure><p>首先在当前 active 优先级队列的 bitmap 寻找第一个非空的进程链表，然后从该链表中找到的第一个节点就是最适合下一个调度执行的进程。由于没有遍历整个链表的操作，因此这个调度器的算法复杂度是一个常量，从而解决了 O（n）算法复杂度的 issue。</p><p>如果当前 active 优先级队列中“空无一人”（nr_active 等于 0），那么这时候就需要切换 active 和 expired 优先级队列了：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(!<span class="built_in">array</span>-&gt;nr_active)) {</span><br><span class="line">    rq-&gt;active = rq-&gt;expired;</span><br><span class="line">    rq-&gt;expired = <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span> = rq-&gt;active;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>切换很快，并没有一个遍历所有进程重新赋 default 时间片的操作（大大缩减了 runqueue 临界区的 size）。这些都避免了 O（n）调度器带来的种种问题，从而提高了调度器的性能。</li><li>对于 O（1）调度器，时间片的重新赋值是分散处理的，在各个 task 耗尽其时间片之后立刻进行的。这样的改动也修正了 O（n）调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。</li><li>O（1）调度器使用非常复杂的算法来判断进程的用户交互指数以及进程是否是交互式进程，它总是比仅仅考虑睡眠时间的 O（n）调度器性能要好。</li><li>Linux 引入了抢占式内核的概念（CONFIG_PREEMPT），如果没有配置该选项，那么一切和 2.4 内核保持一致。</li></ul><h3 id="番外之番外-多级反馈队列算法">番外之番外-多级反馈队列算法</h3><p>多级反馈队列算法的核心思想是把进程按照优先级分成多个队列，相同优先级的进程在同一个队列中。如图所示，系统中有 5 个优先级，每个优先级有一个队列，队列 5 的优先级最高，队列 1 的优先级最低。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/MLFQ.png"></p><p>多级反馈队列算法有如下几条基本规则。</p><ul><li>规则 1：如果进程 A 的优先级大于进程 B 的优先级，那么调度器选择进程 A。</li><li>规则 2：如果进程 A 和进程 B 的优先级一样，那么它们同属一个队列，可使用轮转调度算法来选择。</li><li>规则 3：当一个新进程进入调度器时，把它放入优先级最高的队列里。</li><li>规则 4a：当一个进程吃满时间片时，说明这是一个 CPU 消耗型的进程，需要把优先级降一级，从高优先级队列中迁移到低一级的队列里。</li><li>规则 4b：当一个进程在时间片还没有结束之前放弃 CPU 时，说明这是一个 I/O 消耗型的进程，优先级保持不变，维持原来的高优先级。</li></ul><blockquote><p>其实多级反馈队列算法的精髓在于“反馈”二字，也就是说，调度器可以动态地修改进程的优先级。进程可以大致分成两类，一类是 I/O 消耗型这类进程很少会完全占用时间片，通常情况下在发送 I/O 请求或者在等待 I/O 请求，比如等待鼠标操作、等待键盘输入等，这里进程和系统的用户体验很相关：另一类是 CPU 消耗型这类进程会完全占用时间片，比如计算密集型的应用程序、批处理应用程序等。多级反馈队列算法需要区分进程属于哪种类型，然后做出不同的反馈。</p></blockquote><p>多级反馈队列算法看起来很不错，可是在实际应用过程中还是有不少问题的。</p><ul><li>第一个问题就是产生饥饿，当系统中有大量的 I/O 消耗型的进程时，这些 I/O 消耗型的进程会完全占用 CPU，它们的优先级最高，那些 CPU 消耗型的进程就得不到 CPU 时间片，产生饥饿。</li><li>第二个问题是有些进程会欺骗调度器。比如，有的进程在时间片快要结束时突然发起一个 I/O 请求并且放弃 CPU。</li><li>第三个问题是，一个进程在生命周期里，有可能一会儿是 I/O 消耗型的，一会儿是 CPU 消耗型的，所以很难判断一个进程究竟是哪种类型。</li></ul><p>针对第一个问题，多级反馈队列算法提出了一种改良方案，也就是在一定的时间周期后，把系统中的全部进程都提升到最高优先级，相当于系统中的进程过了一段时间又重新开始一样。</p><ul><li>规则 5：每隔时间周期 S 之后，把系统中所有进程的优先级都提到最高级别。规则 5 可以解决进程饥饿的问题，然而，将时间周期 S 设置为多少合适呢？如果 S 太长，那么 CPU 消耗型的进程会饥饿；如果 S 太短，那么会影响系统的交互性。</li></ul><p>针对第二个问题，需要对规则 4 做一些改进：</p><ul><li>新的规则 4：当一个进程使用完时间片后，不管它是否在时间片的最末尾发生 I/O 请求从而放弃 CPU，都把它的优先级降一级。经过改进后的规则 4 可以有效地避免进程的欺骗行为。</li></ul><p>在介绍完多级反馈队列算法的核心实现后，在实际工程应用中还有很多问题需要思考和解决，其中一个最难的问题是参数如何确定和优化。比如，系统需要设计多少个优先级队列？时间片应该设置成多少？规则 5 中的时间间隔 S 又应该设置成多少，才能实现既不会让进程饥饿，也不会降低系统的交互性？这些问题很难回答。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50L3NjaGVkdWxlci1oaXN0b3J5Lmh0bWw=">http://www.wowotech.net/process_management/scheduler-history.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（六）总结</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskSummery/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskSummery/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskSummery.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2ZDNiYzYzNzY4OTA3MTA1YTYyZTE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="一个例子">一个例子</h1><p>下面给出一个综合案例，在一个双核处理器的系统中，在 Shell 界面下运行 test 程序。CPUO 的就绪队列中有 4 个进程，而 CPU1 的就绪缓队列中有 1 个进程。test 程序和这 5 个进程的 nice 值都为 0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = O</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        i++;</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> O;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>站在用户空间的角度看问题，我们只能看到 test 程序被运行了，但是我们看不到新进程是如何创建的、它会添加到哪个 CPU 里、它是如何运行的，以及 CPU0 和 CPU1 之间如何做负载均衡等。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/test.png"></p><p>其中的操作步骤如下：</p><ul><li>调用系统调用 fork() 来创建一个新进程</li><li>使用 do_fork() 创建新进程：<ul><li>创建新进程的 task_struct 数据结构</li><li>复制父进程的 task_struct 数据结构到新进程</li><li>复制父进程相关的页表项到新进程</li><li>设置新进程的内核栈</li></ul></li><li>父进程调用 wake_up_new_task() 尝试去唤醒新进程：<ul><li>调用调度类的 select_taskirq()，为新进程寻找一个负载最轻的 CPU，这里选择 CPU1</li><li>调用调度类的 enqueue_task() 把新进程添加到 CPU1 的就绪队列里</li></ul></li><li>CPU1 重新选择一个合适的进程来运行：<ul><li>每次时钟节拍到来时，scheduler_tick() 会调用调度类的 task_tick() 检查是否需要重新调度。check_preempt_tick() 会做检查，当需要重新调度时会设置当前进程的 thread_info 中的 TIF_NEED_RESCHED 标志位。假设这时 CPU1 准备调度新进程，就会设置当前进程的 thread_info 中的 TIF_NEED_RESCHED 标志位</li><li>在中断返回前会检查当前进程是否需要调度。如果需要调度，调用 preempt_schedule_irq() 来切换进程运行</li><li>调度器的 schedule() 函数会调用调度类的 pick_next_task() 来选择下一个最合适运行的进程。在该场景中，选择新进程</li><li>switch_mm() 切换父进程和新进程的页表</li><li>在 CPU1 上，switch_to() 切换新进程来运行</li></ul></li><li>运行新进程：<ul><li>新进程第一次运行时会调用 ret_from_fork() 函数</li><li>返回用户空间运行 Shell 程序</li><li>Shell 程序调用 exec() 来运行 test 程序，最终新进程变成了 test 进程</li></ul></li><li>实现负载均衡：<ul><li>在每个时钟节拍到来时，检查是否需要触发软中断来实现 SMP 负载均衡，即调用 scheduler_tick()-&gt; trigger_load_balance()。下一次实现负载均衡的时间点存放在就绪队列的 next_balance 成员里。</li><li>触发 SCHED_SOFTIRQ 软中断</li><li>在软中断处理函数 run_rebalance_domains() 里，从当前 CPU 开始遍历 CPU 拓扑关系，从调度域的低层往高层遍历调度域，并寻找有负载不均匀的调度组。本例子中的 CPU 拓扑关系很简单，只有一层 MC 层级的调度域</li><li>CPU0 对应的调度域是 domain_mc_0，对应的调度组是 group_mc_0；CPU1 对应的调度域是 domain_mc_1，对应的调度组是 group_mc_1。CPU0 的调度域 domain_mc_0 管辖 CPU0 和 CPU1，其中 group_mc_0 和 group_mc_1 这两个调度组会被链接到 domain_mc_0 的一个链表中。同理，CPU1 的调度域 domain_mc_1 管理着 group_mc_1 和 group_mc_0 这两个调度组</li><li>假设当前运行的 CPU 是 CPU1，也就是说，运行 run_rebalance_domains() 函数的 CPU 为 CPU1，那么在当前 MC 的调度域（domain_mc_1）里找哪个调度组是最繁忙的。很容易发现 CPU0 的调度组（group_mc_0）是最繁忙的，然后计算需要迁移多少负载到 CPU1 上才能保持两个调度组负载平衡</li><li>从 CPU0 迁移部分进程到 CPU1</li></ul></li></ul><h1 id="调度的流程">调度的流程</h1><p>假设 Linux 内核只有 3 个线程，线程 0 创建了线程 1 和线程 2，它们永远不会退出。当系统时钟中断到来时，时钟中断处理函数会检查是否有进程需要调度。当有进程需要调度时，调度器会选择运行线程 1 或者线程 2。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/thread_example.png"></p><p>假设线程 0 先运行，那么在这个场景下会发生什么情况？ 这是一个有意思的问题，涉及调度器的实现机制、中断处理、内核抢占、新建进程如何被调度、进程切换等知识点。我们只有把这些知识点都弄明白了，才能真正搞明白这个问题。</p><h2 id="场景分析">场景分析</h2><p>这个场景中的主要操作步骤如下：</p><ul><li>start_kernel() 运行在线程 0 里。线程 0 创建了线程 1 和线程 2。函数调用关系是 start_kernel()-&gt;kerne_thread()-&gt;_do_fork()。在_do_fortk() 函数会创建新线程，并且把新线程添加到调度器的就绪队列中。线程 0 创建线程 1 和线程 2 后，进入 while 死循环，线程 0 不会退出，它正在等待被调度出去</li><li>产生时钟中断。时钟中断是普通外设中断的一种，调度器利用时钟中断来定时检测当前正在运行的线程是否需要调度</li><li>当时钟中断检测到当前线程需要调度时，设置 need_resched 标志位</li><li>当时钟中断返回时，根据 Linux 内核是否支持内核抢占来确定是否需要调度，下面分两种情况来讨论<ul><li>支持内核抢占的内核：发生在内核态的中断返回时，检查当前线程的 need_resched 标志位是否置位，如果置位，说明当前线程需要调度</li><li>不支持内核抢占的内核：发生在内核态的中断在返回时不会检查是否需要调度</li></ul></li></ul><p>在不支持内核抢占功能的 Linux 内核里，即使线程 0 的 need_resched 标志位置位置位了，Linux 内核也不会调度线程 1 或者线程 2。只有发生在用户态的中断返回或者系统调用返回用户空间时，才会检查是否需要调度。在不支持抢占的 Linux 内核中，判断与调度的流程如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/sched_example1.png"></p><ul><li>发生时钟中断。触发时钟中断时当前进程（线程）有可能在用户态执行，也可能在内核态执行。如果进程运行在用户态时发生了中断，那么会进入异常向量表的 el0_irq 汇编函数：如果进程运行在内核态时发生了中断，那么会进入异常向量表的 el1_irq 汇编函数中。在本场景中，因为 3 个线程都是内核线程，所以时钟中断只能跳转到 el1_irq 汇编函数里。当进入中断时 CPU 会自动关闭中断</li><li>在 el1_irq 汇编函数里，首先会保存中断现场（也称为中断上下文）到当前进程的栈中，Linux 内核使用 pt_regs 数据结构来实现 pt_regs 栈框，用来保存中断现场</li><li>中断处理过程包括切换到 Linux 内核的中断栈、硬件中断号的查询、中断服务程序的处理等</li><li>当确定当前中断源是时钟中断后，scheduler_tick() 函数会去检查当前进程的是否需要调度。如果需要调度，则设置当前进程的 need_resched 标志位（thread_info 中的 TIF_NEED_RESCHED 标志位）</li><li>中断返回。这里需要给中断控制器返回一个中断结束（End Of Interrupt，EOI）信号</li><li>在 el1_irq 汇编函数直接恢复中断现场，这里会使用线程 0 的 pt_regs 来恢复中断现场在不支持内核抢占的系统里，el1_irq 汇编函数不会检查是否需要调度。在中断返回时，CPU 打开中断，然后从中断的地方开始继续执行进程 0</li></ul><p>在支持内核抢占功能的 Linux 内核中，中断返回时会检查当前进程是否设置了 need_resched 标志位置位。如果置位，那么调用 preempt schedule_irq() 函数以调度其他进程（线程）并运行。如下图所示，在支持内核抢占的 Linux 内核中，中断与调度的流程和下图略有不一样。在 el1_irq 汇编函数即将返回中断现场时，判断当前进程是否需要调度。如果需要调度，调度器会选择下一个进程，并且进行进程的切换。如果选择了线程 1，则从线程 1 的 pt_regs 中恢复中断现场并打开中断，然后继续执行内核线程 1 的代码。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/sched_example2.png"></p><h2 id="如何让新进程执行">如何让新进程执行</h2><p>可能读者会有如下疑问：</p><ul><li>如果线程 1 是新创建的，它的栈应该是空的，那它第一次运行时如何恢复中断现场呢？</li><li>如果不能从线程 1 的栈中恢复中断现场，那是不是线程 1 一直在关闭中断的状态下运行？</li></ul><p>对于内核线程来说，在创建时会对如下两部分内容进行设置与保存。</p><ul><li>进程的硬件上下文。它是保存在进程中的 cpu_context 数据结构，进程硬件上下文包括 X19~X28 寄存器、FP 寄存器、SP 寄存器以及 PC 寄存器。对于 ARM64 处理器来说，设置 PC 寄存器为 ret_from_fork，即指向 ret_from_fork 汇编函数。设置 SP 寄存器指向栈的 pt_regs 栈框</li><li>ptregs 栈框</li></ul><p>上述操作是在 copy_thread() 函数里实现的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/kernel/process.c&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_thread</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    childregs-&gt;pstate = PSR_MODE_EL1h;</span><br><span class="line">    p-&gt;thread.cpu_context.x19 = stack_start;</span><br><span class="line">    p-&gt;thread.cpu_context.x20 = stk sz;</span><br><span class="line">    p-&gt;thread.cpu context.pc = (<span class="type">unsigned</span> <span class="type">long</span>)ret_from_fork;</span><br><span class="line">    p-&gt;thread.cpu_context.sp = (<span class="type">unsigned</span> <span class="type">long</span>)childregs;</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>stack_stat 指向内核线程的回调函数，而 x20 指向回调函数的参数。 在进程切换时，switch_to() 函数会完成进程硬件上下文的切换，即把下一个进程 (next 进程）的 cpu_context 数据结构保存的内容恢复到处理器的寄存器中，从而完成进程的切换。此时，处理器开始运行 next 进程了。根据 PC 寄存器的值、外理器会从 ret_from_fork 汇编函数里开始执行，新进程的执行过程如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/sched_context.png"></p><p>ret_from_fork 汇编函数实现在 arch/arm64/kernel/entry.S 文件中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(ret_from_fork)</span><br><span class="line">blschedule_tail</span><br><span class="line">cbzx19, 1f// not a kernel thread</span><br><span class="line">movx0, x20</span><br><span class="line">blrx19</span><br><span class="line">1:get_current_task tsk</span><br><span class="line">movx0, sp</span><br><span class="line">blasm_exit_to_user_mode</span><br><span class="line">bret_to_user</span><br><span class="line">SYM_CODE_END(ret_from_fork)</span><br><span class="line">NOKPROBE(ret_from_fork)</span><br></pre></td></tr></tbody></table></figure><p>在第 2 行中，调用 schedule_tail() 函数来对 prev 进程做收尾工作。在 finish_lock_switch() 函数里会调用 raw_spin_unlock_irq() 函数来打开本地中断。因此，next 进程是运行在打开中断的环境下的。 在第 3 行中，判断 next 线程是否为内核线程。如果 next 进程是内核线程，在创建时会设置 X19 寄存器指向 stack_start。如果 X19 寄存器的值为 0，说明这个 next 进程是用户进程，直接跳转到第 6 行，调用 ret_to_user 汇编函数，返回用户空间 在第 4~5 行中，如果 next 进程是内核线程，那么直接跳转到内核线程的回调函数里。 综上所述，当处理器切换到内核线程 1 时，它从 ret_from_fork 汇编函数开始执行 Schedule_tail() 函数会打开中断，因此，不用担心内核线程 1 在关闭中断的状态下运行。另外，此时，线程 1 不会从中断现场返回，因为到目前为止，线程 1 还没有触发任何一个中断。那么对于线程 0 触发的中断现场怎么处理呢？中断现场保存在中断进程的栈里，只有当调度器再、次调度该进程时，它才会从栈中恢复中断现场，然后继续运行该进程。</p><h2 id="调度的本质">调度的本质</h2><p>下面是一个常见的思考题</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raw_local_irq_disable()<span class="comment">//关闭本地中断</span></span><br><span class="line">schedule()<span class="comment">//调用 schedule() 函数来切换进程</span></span><br><span class="line">raw_local_irq_enable() <span class="comment">//打开本地中断</span></span><br></pre></td></tr></tbody></table></figure><p>有读者这么认为，假设进程 A 在关闭本地中断的情况下切换到进程 B 来运行，进程 B 会在关闭中断的情况下运行，如果进程 B 一直占用 CPU，那么系统会一直没有办法响应时钟中断，系统就处于瘫痪状态。 显然，上述分析是不正确的。因为进程 B 切换执行时会打开本地中断，以防止系统瘫痪我们接下来详细分析这个问题。 调度与中断密不可分，而调度的本质是选择下一个进程来运行。理解调度有如下几个关键点。</p><ul><li>什么情况下会触发调度？</li><li>如何合理和高效选择下一个进程？</li><li>如何切换到下一个进程来执行？</li><li>下一个进程如何返回上一次暂停的地方？</li></ul><p>我们以一个场景为例，假设系统中只有一个用户进程 A 和一个内核线程 B，在不考虑自愿调度和系统调用的情况下，请描述这两个进程（线程）是如何相互切换并运行的。 如图所示，用户进程 A 切换到内核线程 B 的过程如下。</p><ul><li>假设在 T0 时刻之前，用户进程 A 正在用户空间运行</li><li>在 T0 时刻，时钟中断发生</li><li>CPU 打断正在运行的用户进程 A，处于异常模式。CPU 会跳转到异常向量表中的 el0_irq 里。在 el0_irq 汇编函数里，首先把中断现场保存到进程 A 的 pt_regs 栈框中</li><li>处理中断</li><li>调度滴答处理函数。在调度滴答处理中，检查当前进程是否需要调度。如果需要调度，则设置当前进程的 need_resched 标志位（thread_info 中的 TIF_NEED_RESCHED 标志位）</li><li>中断处理完成之后，返回 el0_irq 汇编函数里。在即将返回中断现场前，ret_to_user 汇编函数会检查当前进程是否需要调度</li><li>若当前进程序需要调度，则调用 schedule() 函数来选择下一个进程并进行进程切换</li><li>在 switch_to() 函数里进行进程切换</li><li>T1 时刻，switch_to() 函数返回时，CPU 开始运行内核线程 B 了</li><li>CPU 沿着内核线程 B 保存的栈帧回溯，一直返回。返回路径为 finish_task_switch()-&gt;el1_preempt()-&gt;el1_irq</li><li>在 el1_irq 汇编函数里把上一次发生中断时保存在栈里的中断现场讲行恢复，最后从上一次中断的地方开始执行内核线程 B 的代码</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/thread1.png"></p><p>从栈帧的角度来观察，进程调度的栈帧变化情况如下图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/thread1_stk.png"></p><p>首先，对于用户进程 A，从中断触发到进程切换这段时间内，内核栈的变化情况如图 9.20 左边视图所示，栈的最高地址位于 pt_regs 栈框，用来保存中断现场。 然后，依次保存 el0_irq 汇编函数、ret_to_user 汇编函数、_schedule() 函数、context_switch() 函数以及 switch_to() 函数的栈帧，此时 SP 寄存器指向 switch_to() 函数栈帧，这个过程称为压栈。 接下来，切换进程。 switch_to() 函数返回之后，即完成了进程切换。此时，CPU 的 SP 寄存器指向了内核线程 B 的内核栈中的 switch_to() 函数栈帧。CPU 沿着栈帧一直返回，并且恢复了上一次保存在 pt_regs 栈框的中断现场，最后跳转到内核线程 B 中断的地方并开始执行，这个过程称为出栈。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（五）进程调度的调试</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskDebug/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskDebug/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskDebug.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2Y2ZlMzU2NTNiYjA3MWU3MDI5MDM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>Linux 内核为开发者提供了丰富的进程调度信息，这些调度信息都需要在内核配置时打开 CONFIG_SCHED_DEBUG 选项。</p><h1 id="查看与进程相关的调度信息">查看与进程相关的调度信息</h1><p>有时候我们需要查看进程相关的调度信息，如进程的 nice 值、优先级、调度策略、vruntime 及量化计算能力等信息。在 Linux 的 proc 目录中，为每个进程提供一个独立的目录，该目录包含了与进程相关的信息，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~<span class="comment"># cat /proc/1/sched</span></span><br></pre></td></tr></tbody></table></figure><p>得到：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">systemd (1, <span class="comment">#threads: 1)</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">se.exec_start                                :    5438471989.820758</span><br><span class="line">se.vruntime                                  :          3446.301246</span><br><span class="line">se.sum_exec_runtime                          :         66272.041453</span><br><span class="line">se.nr_migrations                             :                 4998</span><br><span class="line">nr_switches                                  :               172620</span><br><span class="line">nr_voluntary_switches                        :               169241</span><br><span class="line">nr_involuntary_switches                      :                 3379</span><br><span class="line">se.load.weight                               :              1048576</span><br><span class="line">se.runnable_weight                           :              1048576</span><br><span class="line">se.avg.load_sum                              :                  172</span><br><span class="line">se.avg.runnable_load_sum                     :                  172</span><br><span class="line">se.avg.util_sum                              :               176128</span><br><span class="line">se.avg.load_avg                              :                    0</span><br><span class="line">se.avg.runnable_load_avg                     :                    0</span><br><span class="line">se.avg.util_avg                              :                    0</span><br><span class="line">se.avg.last_update_time                      :     5438471989820416</span><br><span class="line">se.avg.util_est.ewma                         :                   10</span><br><span class="line">se.avg.util_est.enqueued                     :                    0</span><br><span class="line">policy                                       :                    0</span><br><span class="line">prio                                         :                  120</span><br><span class="line">clock-delta                                  :                  103</span><br><span class="line">mm-&gt;numa_scan_seq                            :                    0</span><br><span class="line">numa_pages_migrated                          :                    0</span><br><span class="line">numa_preferred_nid                           :                    0</span><br><span class="line">total_numa_faults                            :                  806</span><br><span class="line">current_node=0, numa_group_id=0</span><br><span class="line">numa_faults node=0 task_private=734 task_shared=72 group_private=0 group_shared=0</span><br><span class="line">numa_faults node=1 task_private=0 task_shared=0 group_private=0 group_shared=0</span><br></pre></td></tr></tbody></table></figure><p>上面就是 ID 为 1 的进程的 proc 目录，在进程 proc 目录里，看到和进程调度相关的节点为 sched，读者可以使用 cat 命令来读取这个节点的信息，我们可以得到很多有用的信息，这些信息是在 proc_sched_show_task() 函数中输出的，该函数实现在 kerel/sched/debug.c 文件中。这些信息如下：</p><ul><li>进程的名称为 systemd，ID 是 1，线程有 1 个</li><li>进程的优先级为 120</li><li>进程的调度策略是 SCHED_NORMAL，使用的调度类是 CFS 调度类（fair_sched_class）</li><li>当前进程的虚拟时间（vruntime）是 3446.301246ms。总运行时间为 66272.041453ms</li><li>进程发生过 4998 次迁移，172620 次进程上下文切换，其中主动调度有 169241 次，被抢占调度有 3379&nbsp;次</li><li>进程的权重 se.load.weight 和 se.runnable.weight 相等，都是 1048576。注意，这两个值均为原本的权重值乘以 1024。进程优先级为 120，nice 值为 0，它原本的权重值为 1024</li><li>当前时刻，进程的 se.avg.load_sum 值和 se.avg.runnable_load_sum 相等，都是 172</li><li>进程的 se.ave.load_avg 和 se.avg.runnable_load_avg 是相等的都是 0。对于该进和来说，它的量化负载的最大值就等于它的权重值，即 1024，这是在 100%占用 CPU 的情况下得到的</li><li>进程的量化计算能力（se.avg.util_avg）为 0</li></ul><p>Linux 内核还提供一个与调度信息相关的数据结构 sched_statistics，其中包含了非常多和调度相关的统计信息。要查看这些统计信息，需要打开 CONFIG_SCHEDSTATS 配置选项。另外，还需要打开 sched_schedstats 节点。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/sched_schedstats</span><br></pre></td></tr></tbody></table></figure><p>重新查看 ID 为 1 的进程调度信息，我们会发现里面多了很多统计信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/proc/1<span class="comment"># cat sched</span></span><br><span class="line">systemd (1, <span class="comment">#threads: 1)</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">se.exec_start                                :    5439456327.802850</span><br><span class="line">se.vruntime                                  :          3452.764216</span><br><span class="line">se.sum_exec_runtime                          :         66278.504423</span><br><span class="line">se.nr_migrations                             :                 4998</span><br><span class="line">se.statistics.sum_sleep_runtime              :             0.000000</span><br><span class="line">se.statistics.wait_start                     :             0.000000</span><br><span class="line">se.statistics.sleep_start                    :             0.000000</span><br><span class="line">se.statistics.block_start                    :             0.000000</span><br><span class="line">se.statistics.sleep_max                      :             0.000000</span><br><span class="line">se.statistics.block_max                      :             0.000000</span><br><span class="line">se.statistics.exec_max                       :             0.000000</span><br><span class="line">se.statistics.slice_max                      :             0.000000</span><br><span class="line">se.statistics.wait_max                       :             0.000000</span><br><span class="line">se.statistics.wait_sum                       :             0.000000</span><br><span class="line">se.statistics.wait_count                     :                    0</span><br><span class="line">se.statistics.iowait_sum                     :             0.000000</span><br><span class="line">se.statistics.iowait_count                   :                    0</span><br><span class="line">se.statistics.nr_migrations_cold             :                    0</span><br><span class="line">se.statistics.nr_failed_migrations_affine    :                    0</span><br><span class="line">se.statistics.nr_failed_migrations_running   :                    0</span><br><span class="line">se.statistics.nr_failed_migrations_hot       :                    0</span><br><span class="line">se.statistics.nr_forced_migrations           :                    0</span><br><span class="line">se.statistics.nr_wakeups                     :                    0</span><br><span class="line">se.statistics.nr_wakeups_sync                :                    0</span><br><span class="line">se.statistics.nr_wakeups_migrate             :                    0</span><br><span class="line">se.statistics.nr_wakeups_local               :                    0</span><br><span class="line">se.statistics.nr_wakeups_remote              :                    0</span><br><span class="line">se.statistics.nr_wakeups_affine              :                    0</span><br><span class="line">se.statistics.nr_wakeups_affine_attempts     :                    0</span><br><span class="line">se.statistics.nr_wakeups_passive             :                    0</span><br><span class="line">se.statistics.nr_wakeups_idle                :                    0</span><br><span class="line">avg_atom                                     :             0.383900</span><br><span class="line">avg_per_cpu                                  :            13.261005</span><br><span class="line">nr_switches                                  :               172645</span><br><span class="line">nr_voluntary_switches                        :               169266</span><br><span class="line">nr_involuntary_switches                      :                 3379</span><br><span class="line">se.load.weight                               :              1048576</span><br><span class="line">se.runnable_weight                           :              1048576</span><br><span class="line">se.avg.load_sum                              :                  286</span><br><span class="line">se.avg.runnable_load_sum                     :                  286</span><br><span class="line">se.avg.util_sum                              :               293807</span><br><span class="line">se.avg.load_avg                              :                    6</span><br><span class="line">se.avg.runnable_load_avg                     :                    6</span><br><span class="line">se.avg.util_avg                              :                    6</span><br><span class="line">se.avg.last_update_time                      :     5439456327801856</span><br><span class="line">se.avg.util_est.ewma                         :                   10</span><br><span class="line">se.avg.util_est.enqueued                     :                    0</span><br><span class="line">policy                                       :                    0</span><br><span class="line">prio                                         :                  120</span><br><span class="line">clock-delta                                  :                   56</span><br><span class="line">mm-&gt;numa_scan_seq                            :                    0</span><br><span class="line">numa_pages_migrated                          :                    0</span><br><span class="line">numa_preferred_nid                           :                    0</span><br><span class="line">total_numa_faults                            :                  806</span><br><span class="line">current_node=0, numa_group_id=0</span><br><span class="line">numa_faults node=0 task_private=734 task_shared=72 group_private=0 group_shared=0</span><br><span class="line">numa_faults node=1 task_private=0 task_shared=0 group_private=0 group_shared=0</span><br></pre></td></tr></tbody></table></figure><h1 id="查看-cfs-的信息">查看 CFS 的信息</h1><p>Linux 内核在调度方面实现了一些调试接口，为开发者提供窥探调度器内部信息的接口。 在 proc 目录下面有一个 sched_debug 节点，其信息如下所示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@liushuai:/proc<span class="comment"># cat sched_debug</span></span><br><span class="line">Sched Debug Version: v0.11, 5.4.0-81-generic <span class="comment">#91-Ubuntu</span></span><br><span class="line">ktime                                   : 5439613876.757507</span><br><span class="line">sched_clk                               : 5439566740.450647</span><br><span class="line">cpu_clk                                 : 5439566596.040965</span><br><span class="line">jiffies                                 : 5654795694</span><br><span class="line">sched_clock_stable()                    : 1</span><br><span class="line"></span><br><span class="line">sysctl_sched</span><br><span class="line">  .sysctl_sched_latency                    : 24.000000</span><br><span class="line">  .sysctl_sched_min_granularity            : 3.000000</span><br><span class="line">  .sysctl_sched_wakeup_granularity         : 4.000000</span><br><span class="line">  .sysctl_sched_child_runs_first           : 0</span><br><span class="line">  .sysctl_sched_features                   : 2059067</span><br><span class="line">  .sysctl_sched_tunable_scaling            : 1 (logarithmic)</span><br><span class="line">...</span><br><span class="line">rt_rq[0]:</span><br><span class="line">  .rt_nr_running                 : 0</span><br><span class="line">  .rt_nr_migratory               : 0</span><br><span class="line">  .rt_throttled                  : 0</span><br><span class="line">  .rt_time                       : 0.000000</span><br><span class="line">  .rt_runtime                    : 950.000000</span><br><span class="line"></span><br><span class="line">dl_rq[0]:</span><br><span class="line">  .dl_nr_running                 : 0</span><br><span class="line">  .dl_nr_migratory               : 0</span><br><span class="line">  .dl_bw-&gt;bw                     : 996147</span><br><span class="line">  .dl_bw-&gt;total_bw               : 0</span><br></pre></td></tr></tbody></table></figure><ul><li>Sched 调试信息的版本号：v0.11</li><li>Linux 内核版本号：5.4.0</li><li>内核时间（ktime）的值 5439613876.757507</li><li>sched_clock=5439566740.450647 和 cpu_clk=5439566596.040965 的值</li><li>当前 jiffies 的值 5654795694</li><li>和调度相关的 sysctl_sched 的值<ul><li>调度周期 sysctl_sched_latency 为 24.000000ms</li><li>调度最小粒度为 3.000000ms</li><li>唤醒的最小粒度为 4.000000ms</li><li>fork 调用完成之后禁止子进程先运行</li><li>调度支持的特性</li></ul></li></ul><p>cpu 相关信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cpu<span class="comment">#0, 2500.140 MHz</span></span><br><span class="line">  .nr_running                    : 0</span><br><span class="line">  .nr_switches                   : 57306500</span><br><span class="line">  .nr_load_updates               : 0</span><br><span class="line">  .nr_uninterruptible            : -2994</span><br><span class="line">  .next_balance                  : 5654.795676</span><br><span class="line">  .curr-&gt;pid                     : 0</span><br><span class="line">  .clock                         : 5439566591.813321</span><br><span class="line">  .clock_task                    : 5439566591.813321</span><br><span class="line">  .avg_idle                      : 1000000</span><br><span class="line">  .max_idle_balance_cost         : 500000</span><br><span class="line">  .yld_count                     : 1</span><br><span class="line">  .sched_count                   : 8189</span><br><span class="line">  .sched_goidle                  : 4044</span><br><span class="line">  .ttwu_count                    : 1273</span><br><span class="line">  .ttwu_local                    : 321</span><br></pre></td></tr></tbody></table></figure><ul><li>nr_running：有 0 个进程在就绪队列里</li><li>nr_switches：就绪队列发生进程切换的次数 57306500 次</li><li>nr_load_updates：就绪队列的 cpu_load[] 平滑负载更新的次数 0 次</li><li>next_balance：下一次做负载均衡的时间 5654.795676</li><li>curr-&gt;pid：正在运行状态的 PID</li><li>clock 和 clock_task：当前系统采样的时刻</li></ul><p>cfs 就绪队列相关信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cfs_rq[1]:/user.slice</span><br><span class="line">  .exec_clock                    : 12.379262</span><br><span class="line">  .MIN_vruntime                  : 0.000001</span><br><span class="line">  .min_vruntime                  : 2306434.555699</span><br><span class="line">  .max_vruntime                  : 0.000001</span><br><span class="line">  .spread                        : 0.000000</span><br><span class="line">  .spread0                       : -8049717.704115</span><br><span class="line">  .nr_spread_over                : 0</span><br><span class="line">  .nr_running                    : 1</span><br><span class="line">  .load                          : 1048576</span><br><span class="line">  .runnable_weight               : 1048576</span><br><span class="line">  .load_avg                      : 3</span><br><span class="line">  .runnable_load_avg             : 3</span><br><span class="line">  .util_avg                      : 3</span><br><span class="line">  .util_est_enqueued             : 0</span><br><span class="line">  .removed.load_avg              : 0</span><br><span class="line">  .removed.util_avg              : 0</span><br><span class="line">  .removed.runnable_sum          : 0</span><br><span class="line">  .tg_load_avg_contrib           : 3</span><br><span class="line">  .tg_load_avg                   : 1037</span><br><span class="line">  .throttled                     : 0</span><br><span class="line">  .throttle_count                : 0</span><br><span class="line">  .se-&gt;exec_start                : 5439566596.839807</span><br><span class="line">  .se-&gt;vruntime                  : 7544926.691548</span><br><span class="line">  .se-&gt;sum_exec_runtime          : 2240863.841914</span><br><span class="line">  .se-&gt;statistics.wait_start     : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_start    : 0.000000</span><br><span class="line">  .se-&gt;statistics.sleep_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.block_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.exec_max       : 0.303114</span><br><span class="line">  .se-&gt;statistics.slice_max      : 0.000000</span><br><span class="line">  .se-&gt;statistics.wait_max       : 0.000000</span><br><span class="line">  .se-&gt;statistics.wait_sum       : 0.000000</span><br><span class="line">  .se-&gt;statistics.wait_count     : 143</span><br><span class="line">  .se-&gt;load.weight               : 521740</span><br><span class="line">  .se-&gt;runnable_weight           : 521740</span><br><span class="line">  .se-&gt;avg.load_avg              : 2</span><br><span class="line">  .se-&gt;avg.util_avg              : 3</span><br><span class="line">  .se-&gt;avg.runnable_load_avg     : 2</span><br></pre></td></tr></tbody></table></figure><ul><li>exec_clock：CFS 就绪队列的总运行时间</li><li>MIN_vruntime：表示 CFS 就绪队列的红黑树中最左边节点的 vruntime 的值</li><li>min_vruntime：CFS 就绪队列里 min_vruntime 的值</li><li>max_vruntime: CFS 就绪队列的红黑树中最右边节点的 vruntime 的值</li><li>nr_running：CFS 就绪队列中的进程数</li><li>load：CFS 就绪队列的总权重</li><li>runnable_weight.CFS 就绪队列中可运行状态的进程总权重</li><li>load_avg: 调度队列中总的量化负载，这是 CFS 就绪队列中所有进程的量化负载之和</li><li>runnable_load_avg：CFS 就绪队列里所有可运行状态下的进程总量化负载，可以看到它的值和 load_avg 相等</li><li>util_avg：CFS 就绪队列当前的量化计算能力</li></ul><p>所有进程相关信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">runnable tasks:</span><br><span class="line"> S           task   PID         tree-key  switches  prio     wait-time             sum-exec        sum-sleep</span><br><span class="line">-----------------------------------------------------------------------------------------------------------</span><br><span class="line"> I         rcu_gp     3        13.968356         2   100         0.000000         0.003216         0.000000 0 0 /</span><br><span class="line"> I     rcu_par_gp     4        15.968978         2   100         0.000000         0.002189         0.000000 0 0 /</span><br><span class="line"> I   kworker/0:0H     6      4826.431210         4   100         0.000000         0.020363         0.000000 0 0 /</span><br><span class="line"> I   mm_percpu_wq    10        24.040288         2   100         0.000000         0.002587         0.000000 0 0 /</span><br><span class="line"> S    ksoftirqd/0    11  10356126.783742    181278   120         0.077741      3101.302842     18658.038816 0 0 /</span><br><span class="line"> S    migration/0    13         0.000000   1360506     0         0.000000     14628.664708         0.000000 0 0 /</span><br><span class="line"> S  idle_inject/0    14         0.000000         3    49         0.000000         0.005710         0.000000 0 0 /</span><br><span class="line"> S        cpuhp/0    15    298446.415933        21   120         0.000000         1.152329         0.000000 0 0 /</span><br><span class="line"> S      watchdogd   369        11.999994         2     0         0.000000         0.000000         0.000000 0 0 /</span><br><span class="line"> Secryptfs-kthrea   418      3181.658188         2   120         0.000000         0.007012         0.000000 0 0 /</span><br><span class="line"> I   kworker/0:1H   771  10354055.277526     23104   100         0.000000       515.468619         0.000000 0 0 /</span><br><span class="line"> S       rsyslogd  1230       100.894491      9129   120         0.000000       325.720995         0.000000 0 1230 /system.slice/rsyslog.service</span><br><span class="line"> S        dockerd 598258     31439.037574     27303   120         0.000000     28928.757364         0.000000 0 597670 /system.slice/snap.docker.dockerd.service</span><br><span class="line"> S     containerd 597865     31427.350714    113110   120         0.000000     13081.711696         0.030330 0 598167 /system.slice/snap.docker.dockerd.service</span><br><span class="line"> I    kworker/0:2 646991  10279557.062806    122739   120         0.000000      3114.131510         0.000000 0 0 /</span><br><span class="line"> I    kworker/0:0 649432  10356141.706616    369586   120         1.089386      9517.253921    103008.678000 0 0 /</span><br><span class="line"> S           smbd 651779   1641474.345475    460050   120        11.539434    246732.864126     64471.275817 0 651779 /system.slice/smbd.service</span><br><span class="line"> S           node 652105   3528667.050423      1354   120         0.000000      2331.451911         0.000000 0 652102 /user.slice</span><br><span class="line"> S       cpptools 652144   3527016.422624         6   120         0.000000         0.203793         0.000000 0 0 /user.slice</span><br><span class="line"> S       cpptools 652162   3527016.384935         6   120         0.000000         0.146937         0.000000 0 0 /user.slice</span><br><span class="line"> S       cpptools 652182   3527016.373736         6   120         0.000000         0.115269         0.000000 0 0 /user.slice</span><br><span class="line"> S       cpptools 652296   3527040.380268         1   120         0.000000         0.047959         0.000000 0 0 /user.slice</span><br><span class="line"> S   cpptools-srv 652246   3527028.332316         1   120         0.000000         0.076723         0.000000 0 0 /user.slice</span><br></pre></td></tr></tbody></table></figure><ul><li>第 1 列显示进程的状态。R 表示可运行状态，也就是在 CFS 就绪队列中的进程；S 表示睡眠状态的进程</li><li>第 2 列显示进程的名称</li><li>第 3 列显示 PID</li><li>第 4 列显示进程在 CFS 就绪队列的红黑树中的键值</li><li>第 5 列显示进程切换的次数</li><li>第 6 列显示进程的优先级</li><li>第 7 列显示进程等待时间</li><li>第 8 列显示进程运行的总时间</li><li>第 9 列显示进程休眠的总时间</li></ul><h1 id="查看调度域信息">查看调度域信息</h1><p>在理解 SMP 负载均衡机制的过程中，CPU 的拓扑关系是一个难点。Linux 内核新增了一个调试节点来帮助开发者理解（详见 kernel/sched/topology.c 文件）。在编译内核时，不仅需要打开 CONFIG_SCHED_DEBUG 选项，还需要在内核启动参数里传递 sched_debug 参数。 在内核启动之后，可以通过 dmesg 命令来得到 CPU 拓扑关系，如下所示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[0.224258] CPUO attaching sched-domain(s)</span><br><span class="line">[0.224422]    domain-0: span=0-3 level=MC</span><br><span class="line">[0.224780]        <span class="built_in">groups</span>: O:{ span=0 },1:{span=1},2:{span=2},3:{span=3}</span><br><span class="line">[0.227045] CPU1 attaching sched-domain(s):</span><br><span class="line">[0.227111]    domain-0: span=0-3 level=MC</span><br><span class="line">[0.227179]        <span class="built_in">groups</span>: 1:{span=1},2:{span=2 },3:{span=3 }, 0:{ span=0}</span><br><span class="line">[0.227347] CPU2 attaching sched-domain(s):</span><br><span class="line">[0.227407]    domain-0: span=0-3 level=MC</span><br><span class="line">[0.227471]        <span class="built_in">groups</span>: 2:{span=2},3:{span=3},0:{span=0},1:{span=1}</span><br><span class="line">[0.228416] CPU3 attaching <span class="built_in">sched</span>- domain(s):</span><br><span class="line">[0.228485]    domain-0: span=0-3 level=MC</span><br><span class="line">[02285530]         <span class="built_in">groups</span>: 3:{span=3 }, 0:{span=0 }, 1:{span=1},2:{span=2}</span><br><span class="line">[0.228757] root domain span: O-3 (max cpucapacity = 1024)</span><br></pre></td></tr></tbody></table></figure><p>可以看出，该系统只有 MC 层级，从 CPU0 角度看，它对应的调度域是 domain-0，管辖的范围是 CPU[0~3]，调度层级是 MC。同理，可以得出 CPU1、CPU2 以及 CPU3 的 CPU 拓扑关系。</p><h1 id="与调度相关的调试节点">与调度相关的调试节点</h1><p>和调度相关的调试节点在/proc/sys/kernel 目录下，下面来简单介绍一下。</p><ul><li>sched_cfs_bandwidth_slice_us：用于设置 CFS 的带宽限制，默认值为 5ms</li><li>sched_child_runs_first：通过 fork 调用创建进程之后，sched_child_runs_first 可以用于控制是父进程还是子进程先运行；若该值为 1，表示子进程先运行；默认值为 0</li><li>sched_domain：与调度域相关的目录</li><li>sched_latency_ns：设置 CFS 就绪队列调度的总时间片 sysctl_sched_latency，默认值为 6ms。 sched_latency_ns 表示一个运行队列中所有进程运行一次的时间片，它与运行队列的进程数有关。如果进程数超过 sched_nr_latency（默认是 8），那么调度周期就是 sched_min_granularity_ns 乘以运行队列里的进程数量；否则，就是 sysctl_sched_latency</li><li>sched_migration_cost_ns：判断一个进程是否可以利用高速缓存的热度。如果进程的运行时间（now-p-&gt;se.exec_start）小于它，那么内核认为它的数据还在高速缓存里，所以该进程可以利用高速缓存的热度，在迁移的时候就不会考虑它</li><li>sched_min_granularity_ns：设置 CPU 密集型进程最小的调度时间片，也就是进程最短运行时间，用于防止频繁切换。默认值为 0.75ms</li><li>sched_nr_migrate：设置在 SMP 负载均衡机制里每次最多可以从目标 CPU 迁移多少个进程到源 CPU 里。在迁移的过程中关闭了中断，包括软中断机制，因此增大该值会导致中断延迟，同时也增大了实时进程的延迟。该值默认设置为 32</li><li>sched_schedstats：用于打开调度统计信息</li><li>sched_wakeup_granularity_ns：待唤醒进程会检查是否需要抢占当前进程，若待唤醒进程的睡眠时间短于 sched_wakeup_granularity_ns，那么不会抢占当前进程。增加该值会减小待唤醒进程的抢占概率。若减小该值，那么发生抢占的概率就越大。默认值为 1ms</li></ul><p>另外，在/sys/kermel/debug/目录下也有几个和调度相关的节点。</p><ul><li>sched_features：表示调度器支持的特性，如 START_DEBIT（新进程尽量早调度），WAKEUP_PREEMPT（唤醒的进程是否可以抢占当前运行的进程）等。所有的特性详见 kerel/sched/sech_features.h 文件的定义</li><li>osched_debug：调度器的调试信息的开关。注意，该值仅仅控制 sched_debug_enabled，并不会控制/proc/sched_debug 节点 关于 sched_debug_enabled 的示例代码如下，</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sched_debug_setup</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">{</span><br><span class="line">    sched_debug_enabled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">early_param(<span class="string">"sched_debug"</span>, sched_debug_setup);</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（四）多核调度</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskSMP/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskSMP/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskSMP.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2YjhlYzFlZmFkNDA3NTI1MTE2NDk=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>SMP（Symmetrical MultiProcessing）的全称是“对称多处理”技术，是指在一台计算机上汇集了一组处理器，这些处理器都是对等的，它们之间共享内存子系统和系统总线。</p><p>下图所示为 4 核的 SMP 处理器架构，在 4 核处理器中，每个物理 CPU 核心拥有独立的 L1 缓存且不支持超线程技术，分成两个簇（cluster）簇 0 和簇 1，每个簇包含两个物理 CPU 核，簇中的 CPU 核共享 L2 缓存。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/smp.png"></p><h1 id="调度域和调度组">调度域和调度组</h1><p>根据处理器的实际物理属性，CPU 和 Linux 内核的分类如下所示。</p><ul><li><p>SMT（超线程）： Linux 内核配置项 CONFIG_SCHED_SMT 一个物理核心可以有两个或更多执行线程，被称为超线程技术。超线程使用相同的 cpu 资源且共享 L1 缓存，迁移进程不会影响高速缓存的利用率</p></li><li><p>MC（多核）： Linux 内核配置项 CONFIG_SCHED_MC 每个物理核心独享 L1 高速缓存，多个物理核心可以组成族，族里的 cpu 共享 L2 高速缓存</p></li><li><p>SOC（处理器）： 内核称为 DIE SOC 级别</p></li></ul><p>Linux 内核使用数据结构 sched_domain_topology_level 来描述 CPU 的层次关系，本节中简称为 SDTL。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/sched/topology.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_domain_topology_level</span> {</span></span><br><span class="line">sched_domain_mask_f mask; <span class="comment">//函数指针，用于指定某个 SDTL 的 cpumask 位图</span></span><br><span class="line">sched_domain_flags_f sd_flags;<span class="comment">//函数指针，用于指定某个 SDTL 的标志位</span></span><br><span class="line"><span class="type">int</span>    flags;</span><br><span class="line"><span class="type">int</span>    numa_level;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sd_data</span>      <span class="title">data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line"><span class="type">char</span>                *name;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>另外，Linux 内核默认定义了数组 default_topology[] 来概括 CPU 物理域的层次结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/sched/topology.c&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Topology list, bottom-up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_domain_topology_level</span> <span class="title">default_topology</span>[] =</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHED_SMT</span></span><br><span class="line">{ cpu_smt_mask, cpu_smt_flags, SD_INIT_NAME(SMT) },</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHED_MC</span></span><br><span class="line">{ cpu_coregroup_mask, cpu_core_flags, SD_INIT_NAME(MC) },</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">{ cpu_cpu_mask, SD_INIT_NAME(DIE) },</span><br><span class="line">{ <span class="literal">NULL</span>, },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Linux 内核使用 sched_domain 数据结构来描述调度层级，从 defaul_topology[] 数组可知，系统默认支持 DIE 类型层级、SMT 类型层级以及 MC 类型层级。另外，可在调度域里划分调度组，然后使用 sched_group 数据结构来描述调度组，调度组是负载均衡调度的最小单位。在最低层级的调度域中，通常用调度组描述 CPU 核心。 在支持 NUMA 架构的处理器中，假设支持 SMT 技术，那么整个系统的调度域和调度组的关系如图所示，可在默认的调度层级中新增 NUMA 层级的调度域。在超大系统中，系统会频繁访问调度域数据结构。为了提升系统的性能和可扩展性，调度域数据结构 sched_domain 采用 Per-CPU 变量来构建 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/sched_domain.png"></p><h1 id="负载的计算">负载的计算</h1><h3 id="例-1">例 1</h3><p>假设在如图所示的双核处理器里，CPU0 的就绪队列里有 4 个进程，CPU1 的就绪队列里有两个进程，那么究竟哪个 CPU 上的负载重呢？ <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/queue_cpu.png"></p><p>假设上述 6 个进程的 nice 值是相同的，也就是优先级和权重都相同，那么明显可以看出 CPU0 的就绪队列里有 4 个进程，相比 CPU1 的就绪队列里的进程数目要多，从而得出 CPU0 上的负载相比 CPU1 更重的结论。</p><pre><code>CPU 上的负载=就绪队列的总权重</code></pre><p>为了计算 CPU 上的负载，最简单的方法是计算 CPU 的就绪队列中所有进程的权重。</p><p>但是，仅考虑优先级和权重是有问题的，有的是 CPU 密集型的，也有的是 I/O 密集型的。如果延伸到多 CPU 之间的负载均衡，结果就显得不准确了。</p><h3 id="例-2">例 2</h3><p>在如图所示的双核处理器里，CPU0 和 CPU1 的就绪队列里都只有一个进程在运行，而且进程的优先级和权重相同。但是，CPUO 上的进程一直在占用 CPU，而 CPU1 上的进程走走停停，那么究竟 CPU0 和 CPU1 上的负载是不是相同呢？ <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/task_load.png"></p><p>从例 1 中的判断条件看，两个 CPU 上的负载是一样的。但是，从我们的直观感受看，CPU0 上的进程一直占用 CPU，CPU0 是一直满负荷运行的，而 CPU1 上的进程走走停停，CPU 使用率不高。为什么会得出不一样的结论呢？ 这是因为例 1 使用的计算方法没有考虑进程在时间因素下的作用，也就是没有考虑历史负载对当前负载的影响。那么该如何计算历史负载对 CPU 上的负载的影响呢？</p><p>CPU 上的负载的计算公式如下。 <span class="math display">\[CPU 上的负载 = \frac{运行时间}{总时间} \times  就绪队列总权重 \tag{2}\]</span> 其中，运行时间是指就绪队列占用 CPU 的总时间；总时间是指采样的总时间，包括 CPU 处于空闲的时间以及 CPU 正在运行的时间；就绪队列总权重是指就绪队列里所有进程的总权重。</p><p>式 2 把负载这个概念量化到了权重，这样不同运行行为的进程就有了量化的标准来衡量负载，本书把这种用运行时间与总时间的比值来计算的权重，称为量化负载。另外，我们把时间与权重的乘积称为工作负载。</p><p>式 2 并不完美，因为它把历史工作负载和当前工作负载平等对待了。</p><p>因此，自 Linux3.8 内核以后，进程的负载计算不仅要考虑权重，而且要跟踪每个调度实体的历史负载情况，因而称为 PELT （Per-Entitv Load Tracking）。PELT 算法引入了 "accumulation of an infinite geometric series”这个概念，英文字面意思是无穷几何级数的累加，本书把这个概念简单称为历史累计计算。</p><p>Linux 内核使用量化负载这个概念来计算和比较进程以及就绪队列的负载。 根据量化负载的定义，量化负载的计算如式 3 所示。 <span class="math display">\[decay\_avg\_load = (\frac{decay\_sum\_runnable\_time}{decay\_sum\_runnable\_time}) \times  weight \tag{3}\]</span></p><p>其中，decay_avg_load 表示量化负载；decay_sum_runnable_time 指的是就绪队列或调度实体在可运行状态下的所有历史累计衰减时间；decay_sum_period_time 指的是就绪队列或调度实体在所有的采样周期里全部时间的累加衰减时间。通常从进程开始执行时就计算和累计这些值。weight 表示调度实体或就绪队列的权重。 计算进程的量化负载的意义在于能够把负载量化到权重里。当一个进程的 decay_sumrunnable_time 无限接近 decay_sum_period_time 时，它的量化负载就无限接近权重值，说明这个进程一直在占用 CPU，满负荷工作，CPU 占用率很高。一个进程的 decay_sum_runnable_time 越小，它的量化负载就越小，说明这个进程的工作负荷很小，占用的 CPU 资源很少，CPU 占用率很低。这样，我们就对负载实现了统一和标准化的量化计算，不同行为的进程就可以进行标准化的负载计算和比较了。</p><h1 id="负载均衡算法">负载均衡算法</h1><p>SMP 负载均衡机制从注册软中断开始，系统每次调度 tick 中断时，都会检查当前是否需要处理 SMP 负载均衡。rebalance_domains() 函数是负载均衡的核心入口。load_balance() 函数中的主要流程如下。</p><ul><li>负载均衡以当前 CPU 开始，由下至上地遍历调度域，从最底层的调度域开始做负载均衡</li><li>允许做负载均衡的首要条件是当前 CPU 是调度域中的第一个 CPU，或者当前 CPU 是空闲 CPU。详见 should_we_balance() 函数</li><li>在调度域中查找最繁忙的调度组，更新调度域和调度组的相关信息，最后计算出调度域的不均衡负载值</li><li>最繁忙的调度组中找出最繁忙的 CPU，然后把繁忙 CPU 中的进程迁移到当前 CPU 上，迁移的负载量为不均衡负载值</li></ul><h1 id="per-cpu-变量">Per-CPU 变量</h1><p>Per-CPU 变量是 Linux 内核中同步机制的一种。当系统中的所有 CPU 都访问共享的一个变量 v 时，如果 CPU0 修改了变量 v 的值，而 CPU1 也在同时修改变量 v 的值，就会导致变量 v 的值不正确。一种可行的办法就是在 CPU0 访问变量 v 时使用原子加锁指令，这样 CPU1 访问变量 v 时就只能等待了，但这样做有两个比较明显的缺点。</p><ul><li>原子操作是比较耗时的</li><li>在现代处理器中，每个 CPU 都有 L1 缓存，因而多个 CPU 同时访问同一个变量就会导致缓存一致性问题。当某个 CPU 对共享的数据变量 v 进行修改后，其他 CPU 上对应的缓存行需要做无效操作，这对性能是有损耗的</li></ul><p>Per-CPU 变量是为了解决上述问题而出现的一种有趣的特性，它为系统中的每个处理器都分配自身的副本。这样在多处理器系统中，当处理器只能访问属于自己的那个变量副本时，不需要考虑与其他处理器的竞争问题，还能充分利用处理器本地的硬件缓存来提升性能。</p><h2 id="per-cpu-变量的定义和声明">Per-CPU 变量的定义和声明</h2><p>Per-CPU 变量的定义和声明有两种方式。一种是静态声明，另一种是动态分配。静态的 Per-CPU 变量可通过 DEFINE_PER_CPU 和 DECLARE_PER_CPU 宏来定义和声明。这类变量与普通变量的主要区别在于它们存放在一个特殊的段中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Variant on the per-CPU variable declaration/definition theme used for</span></span><br><span class="line"><span class="comment"> * ordinary per-CPU variables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_PER_CPU(type, name)\</span></span><br><span class="line"><span class="meta">DECLARE_PER_CPU_SECTION(type, name, <span class="string">""</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)\</span></span><br><span class="line"><span class="meta">DEFINE_PER_CPU_SECTION(type, name, <span class="string">""</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>用于动态分配和释放 per-cpu 变量的 API 函数如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_percpu(type)\</span></span><br><span class="line"><span class="meta">(typeof(type) __percpu *)__alloc_percpu(sizeof(type),\</span></span><br><span class="line"><span class="meta">__alignof__(type))</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_percpu</span><span class="params">(<span class="type">void</span> __percpu *__pdata)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="使用-per-cpu-变量">使用 Per-CPU 变量</h2><p>对于静态定义的 Per-CPU 变量，可以通过 get_cpu_var() 和 put_cpu_var() 函数来访问和修改，这两个函数内置了关闭和打开内核抢占的功能。另外需要注意的是，这两个函数需要配对使用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)\</span></span><br><span class="line"><span class="meta">(*({\</span></span><br><span class="line"><span class="meta">preempt_disable();\</span></span><br><span class="line"><span class="meta">this_cpu_ptr(&amp;var);\</span></span><br><span class="line"><span class="meta">}))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put_cpu_var(var)\</span></span><br><span class="line"><span class="meta">do {\</span></span><br><span class="line"><span class="meta">(void)&amp;(var);\</span></span><br><span class="line"><span class="meta">preempt_enable();\</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br></pre></td></tr></tbody></table></figure><p>对于动态分配的 Per-CPU 变量，需要通过以下接口来访问：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_ptr(var)\</span></span><br><span class="line"><span class="meta">({\</span></span><br><span class="line"><span class="meta">preempt_disable();\</span></span><br><span class="line"><span class="meta">this_cpu_ptr(var);\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put_cpu_ptr(var)\</span></span><br><span class="line"><span class="meta">do {\</span></span><br><span class="line"><span class="meta">(void)(var);\</span></span><br><span class="line"><span class="meta">preempt_enable();\</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br></pre></td></tr></tbody></table></figure><h1 id="tlb-处理">TLB 处理</h1><h2 id="单核处理">单核处理</h2><p>在进程切换的时候，需要有 tlb 的操作，以便清除旧进程的影响，具体怎样做呢？我们下面一一讨论。</p><ul><li><p>绝对没有问题，但是性能不佳的方案： 所有 TLB 和 Cache 的数据都全部 flush 掉。当然，稍微有一点遗憾的就是在 B 进程开始执行的时候，TLB 和 Cache 都是冰冷的</p></li><li><p>如何提高 TLB 的性能： 对于所有的进程（包括内核线程），内核地址空间是一样的，因此对于这部分地址翻译，无论进程如何切换，内核地址空间转换到物理地址的关系是永远不变的，不需要 flush TLB。对于用户地址空间，各个进程都有自己独立的地址空间，在进程 A 切换到 B 的时候，TLB 中的和 A 进程相关的 entry（上图中，青色的 block）需要 flush 掉 我们其实需要区分 global 和 local 这两种类型的地址翻译，因此，在页表描述符中往往有一个 bit 来标识该地址翻译是 global 还是 local 的，同样的，在 TLB 中，这个标识 global 还是 local 的 flag 也会被缓存起来。有了这样的设计之后，我们可以根据不同的场景而 flush all 或者只是 flush local tlb entry</p></li><li><p>特殊情况的考量： 对于多线程环境，切换可能发生在一个进程中的两个线程，这时候，线程在同样的地址空间，也根本不需要 flush tlb</p></li><li><p>进一步提升 TLB 的性能： 这里有一个术语叫做 ASID（address space ID）。原来 TLB 查找是通过虚拟地址 VA 来判断是否 TLB hit。有了 ASID 的支持后，TLB hit 的判断标准修改为（虚拟地址＋ASID），ASID 是每一个进程分配一个，标识自己的进程地址空间。TLB block 如何知道一个 tlb entry 的 ASID 呢？一般会来自 CPU 的系统寄存器（对于 ARM64 平台，它来自 TTBRx_EL1 寄存器），这样在 TLB block 在缓存（VA-PA-Global flag）的同时，也就把当前的 ASID 缓存在了对应的 TLB entry 中，这样一个 TLB entry 中包括了（VA-PA-Global flag-ASID）</p></li></ul><h2 id="多核处理">多核处理</h2><p>在多核系统中，进程切换的时候，TLB 的操作要复杂一些，原因是进程可以调度到任何一个 cpu core 上执行。</p><p>根据上一节的描述，我们了解到地址翻译有 global（各个进程共享）和 local（进程特定的）的概念，因而 tlb entry 也有 global 和 local 的区分。如果区分 global 和 local，那么 tlb 操作也基本类似，只不过进程切换的时候，不是 flush 该 cpu 上的所有 tlb entry，而是 flush 所有的 tlb local entry 就 OK 了。</p><p>对 local tlb entry 还可以进一步细分，那就是 ASID（address space ID）或者 PCID（process context ID）的概念了（global tlb entry 不区分 ASID）。如果支持 ASID（或者 PCID）的话，tlb 操作变得简单一些，或者说我们没有必要执行 tlb 操作了，因为在 TLB 搜索的时候已经可以区分各个 task 上下文了，这样，各个 cpu 中残留的 tlb 不会影响其他任务的执行。</p><p>不过，对于多核系统，这种情况有一点点的麻烦，其实也就是传说中的 TLB shootdown 带来的性能问题。在多核系统中，如果 cpu 支持 PCID 并且在进程切换的时候不 flush tlb，那么系统中各个 cpu 中的 tlb entry 则保留各种 task 的 tlb entry，当在某个 cpu 上，一个进程被销毁，或者修改了自己的页表（也就是修改了 VA PA 映射关系）的时候，我们必须将该 task 的相关 tlb entry 从系统中清除出去。这时候，你不仅仅需要 flush 本 cpu 上对应的 TLB entry，还需要 shootdown 其他 cpu 上的和该 task 相关的 tlb 残余。而这个动作一般是通过 IPI 实现（例如 X86），从而引入了开销。此外 PCID 的分配和管理也会带来额外的开销，因此，OS 是否支持 PCID（或者 ASID）是由各个 arch 代码自己决定。</p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》<br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50L2NvbnRleHQtc3dpdGNoLXRsYi5odG1s">http://www.wowotech.net/process_management/context-switch-tlb.html<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（三）CFS 调度器</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskCFS/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskCFS/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskCFS.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM2OTgxMzBlM2U3NDA3NGNmMGU2NGU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="公平调度思想的引入">公平调度思想的引入</h1><h2 id="传统调度器时间片悖论">传统调度器时间片悖论</h2><p>在 O（n）和 O（1）调度器中，时间片是固定分配的，静态优先级高的进程获取更大的 time slice。高优先级的进程会获得更多的连续执行的机会，这是 CPU-bound 进程期望的，但是实际上，CPU-bound 进程往往在后台执行，其优先级都是比较低的。</p><h2 id="rsdl-调度器">RSDL 调度器</h2><p>RSDL 调度器仍然沿用了 O（1）调度的数据结构和软件结构，当然删除了那些令人毛骨悚然的评估进程交互指数的代码。我们这一小节不可能详细描述 RSDL 算法，不过只讲清楚 Rotating、Staircase 和 Deadline 这三个基本概念。</p><p>首先看 Staircase 概念，它更详细表述应该是 priority staircase，即在进程调度过程中，其优先级会像下楼梯那样一点点的降低。在传统的调度概念中，一个进程有一个和其静态优先级相匹配的时间片，在 RSDL 中，同样也存在这样的时间片，但是时间片是散布在很多优先级中。例如如果一个进程的优先级是 120，那么整个时间片散布在 120～139 的优先级中，在一个调度周期，进程开始是挂入 120 的优先级队列，并在其上运行 6ms，一旦在 120 级别的时间配额使用完毕之后，该进程会转入 121 的队列中，发生一次 Rotating，更准确的说是 Priority minor rotating。之后，该进程沿阶而下，直到 139 的优先级，在这个优先级上如果耗尽了 6ms 的时间片，这时候，该进程所有的时间片就都耗尽了，就会被挂入到 expired 队列中去等待下一个调度周期。这次 rotating 被称为 major rotating。当然，这时候该进程会挂入其静态优先级对应的 expired 队列，即一切又回到了调度的起点。</p><p>Deadline 是指在 RSDL 算法中，任何一个进程可以准确的预估其调度延迟。一个简单的例子，假设 runqueue 中有两个 task，静态优先级分别是 130 的 A 进程和 139 的 B 进程。对于 A 进程，只有在进程沿着优先级楼梯从 130 走到 139 的时候，B 进程才有机会执行，其调度延迟是 9 x 6ms ＝ 54ms。</p><p>多么简洁的算法，只需要维持公平，没有对进程睡眠/运行时间的统计，没有对用户交互指数的计算，没有那些奇奇怪怪的常数……调度，就是这么简单。</p><h1 id="cfs-调度器">CFS 调度器</h1><p>Con Kolivas 的 RSDL 调度器始终没有能够进入 kernel mainline，取而代之的是同样基于公平调度思想的 CFS 调度器，在 CFS 调度器并入主线的同时，仍然提供了模块化的设计，为 RSDL 或者其他的调度器可以进入内核提供了方便。本章我们唯一需要描述的是 Ingo Molnar 如何把完全公平调度的理想照进现实。</p><h2 id="模块化思想的引入">模块化思想的引入</h2><p>从 2.6.23 内核开始，调度器采用了模块化设计的思想，从而把进程调度的软件分成了两个层次，一个是 core scheduler layer，另外一个是 specific scheduler layer： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/scheduler_layer.png"></p><p>从功能层面上看，进程调度仍然分成两个部分，第一个部分是通过负载均衡模块将各个 runnable task 根据负载情况平均分配到各个 CPU runqueue 上去。第二部分的功能是在各个 CPU 的 Main scheduler 和 Tick scheduler 的驱动下进行单个 CPU 上的调度。</p><h2 id="时间粒度">时间粒度</h2><p>Linux 内核的 CFS 调度器已经摒弃了传统的固定时间片的概念了，O（1）调度器会为每一个进程分配一个缺省的时间片。CFS 调度器没有传统的静态时间片的概念，她的时间片是动态的，和当前 CPU 的可运行状态的进程以及它们的优先级相关，因此 CFS 调度器中，时间片是动态变化的。</p><p>CFS 调度器是有一个时间粒度的定义，我们称之调度周期。也就是说，在一个调度周期内，CFS 调度器可以保证所有的可运行状态的进程平均分配 CPU 时间。</p><h2 id="如何保证有界的调度延迟">如何保证有界的调度延迟？</h2><p>传统的调度器无法保证调度延迟，为了说明这个问题我们设想这样一个场景：CPU runqueue 中有两个 nice value 等于 0 的 runnable 进程 A 和 B，传统调度器会为每一个进程分配一个固定的时间片 100ms，这时候 A 先运行，直到 100ms 的时间片耗尽，然后 B 运行。这两个进程会交替运行，调度延迟就是 100ms。随着系统负荷的加重，例如又有两个两个 nice value 等于 0 的 runnable 进程 C 和 D 挂入 runqueue，这时候，A、B、C、D 交替运行，调度延迟就是 300ms。因此，传统调度器的调度延迟是和系统负载相关的，当系统负载增加的时候，用户更容易观察到卡顿现象。</p><p>CFS 调度器设计之初就确定了调度延迟的参数，我们称之 targeted latency，这个概念类似传统调度器中的调度周期的概念，只不过在过去，一个调度周期中的时间片被固定分配给了 runnable 的进程，而在 CFS 中，调度器会不断的检查在一个 targeted latency 中，公平性是否得到了保证。下面的代码说明了 targeted latency 的计算过程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u64 __sched_period(<span class="type">unsigned</span> <span class="type">long</span> nr_running)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (unlikely(nr_running &gt; sched_nr_latency))</span><br><span class="line">    <span class="keyword">return</span> nr_running * sysctl_sched_min_granularity;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> sysctl_sched_latency;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 runqueue 中的 runnable 进程的数目小于 sched_nr_latency（8 个）的时候，targeted latency 就是 sysctl_sched_latency（6ms），当 runqueue 中的 runnable 进程的数目大于等于 sched_nr_latency 的时候，targeted latency 等于 runnable 进程数目乘以 sysctl_sched_min_granularity（0.75ms）。显然 sysctl_sched_min_granularity 这个参数就是一段一个进程被调度执行，它需要至少执行的时间片大小，设立这个参数是为了防止 overscheduling 而产生的性能下降。</p><p>CFS 调度器保证了在一个 targeted latency 中，所有的 runnable 进程都会至少执行一次，从而保证了有界的、可预测的调度延迟。</p><h2 id="为何引入虚拟时间">为何引入虚拟时间？</h2><p>虽然 Con Kolivas 提出了精采绝伦的设计思想，但是在具体实现的时候相对保守。CFS 调度器则不然，它采用了相对激进的方法，把 runqueue 中管理 task 的优先级链表变成了红黑树结构。有了这样一颗 runnable 进程的红黑树，在插入操作的时候如何确定进程在红黑树中的位置？也就是说这棵树的“key”是什么？</p><p>CFS 的红黑树使用 vruntime（virtual runtime）作为 key，为了理解 vruntime，这里需要引入一个虚拟时间轴的概念。在上一章中，我们已经清楚的表述了公平的含义：按照进程的静态优先级来分配 CPU 资源，当然，CPU 资源也就是 CPU 的时间片，因此在物理世界中，公平就是分配和静态优先级匹配的 CPU 时间片。但是红黑树需要一个单一数轴上的量进行比对，而这里有两个度量因素：静态优先级和物理时间片，因此我们需要把它们映射到一个虚拟的时间轴上，屏蔽掉静态优先级的影响：</p><h2 id="如何计算-virtual-runtime">如何计算 virtual runtime</h2><p>具体的计算公式如下：</p><p><span class="math display">\[Virtual runtime ＝ （physical runtime） * （nice value 0 的权重）/ 当前线程的权重\]</span></p><p>为了计算方便，Linux 内核约定 nice 值 0 对应的权值为 1024，其他 nice 值对应的权重值可以通过查表的方式来获取。内核预先计算好了 sched_prio_to_weight[40]，表的下标对应 nice 值。CFS 调度器规定 nice 值为 0 的进程具有基准权重，并且其值每增加 1 则减少 10%的 CPU 权重，每减少 1 则增加 10%的 CPU 权重（1024-1024*20% = 820）。其中线程的权重定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> sched_prio_to_weight[<span class="number">40</span>] = {</span><br><span class="line">    <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line">    <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line">    <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line">    <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line">    <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line">    <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line">    <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line">    <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>通过上面的公式，我们构造了一个虚拟的世界。二维的（load weight，physical runtime）物理世界变成了一维的 virtual runtime 的虚拟世界。在这个虚拟的世界中，各个进程的 vruntime 可以比较大小，以便确定其在红黑树中的位置，而 CFS 调度器的公平也就是维护虚拟世界 vruntime 的公平，即各个进程的 vruntime 是相等的。</p><p>根据上面的公式，我们可以看出：实际上对于静态优先级是 120（即 nice value 等于 0）的进程，其物理时间轴等于虚拟时间轴，而其他的静态优先级的虚拟时间都是根据其权重和 nice 0 的权重进行尺度缩放。对于更高优先级的进程，其虚拟时间轴过的比较慢，而对于优先级比较低的进程，其虚拟时间轴过的比较快。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/vruntime.png"></p><p>在进行进程调度时候，调度器需要选择下一个占用 CPU 资源的那个 next thread。对于 CFS 而言，其算法就是从红黑树中找到 left most 的那个 task 并调度其运行。这时候，失去 CPU 执行权的那个 task 会被重新插入红黑树，其在红黑树中的位置是由 task 的 vruntime 值决定的。</p><h1 id="进程切换">进程切换</h1><h2 id="调度时机">调度时机</h2><p>内核中实现调度的统一策略是：检查进程是否需要调度和实际的调度行为是分离的，比如在 tick 中断或者唤醒进程时检查到存在高优先级进程可以抢占当前执行进程，此时只是设置抢占标志 (TIF_NEED_RESCHED)，在特定的时间点再执行调度行为，而不是直接执行调度。毕竟在中断中是绝对不能直接执行调度的。schedule()（调用__schedule()）是调度器的核心函数，作用是让调度器选择和切换到一个合适的进程并运行。调度的时机可以分为如下 3 种。</p><ul><li>阻塞操作：比如互斥量（mutex）、信号量（semaphore）、等待队列（wait queue）sleep 等。</li><li>在中断返回前和系统调用返回用户空间时，检查 TIF_NEED_RESCHED 标志判断是否需要调度。</li><li>将要被唤醒的进程不会马上调用 schedule()，而是会被添加到 CFS 就绪队列中，并且设置 TIF_NEED_RESCHED 标志位。那么被唤醒的进程什么时候被调度呢？这要根据内核是否具有可抢占功能（CONFIG_PREEMPT=y）分两种情况：<ul><li>内核可抢占<ul><li>如果唤醒动作发生在系统调用或者异常处理上下文中，那么在下一次调用 preempt_enable() 时会检查是否需要抢占调度</li><li>如果唤醒动作发生在硬中断处理上下文中，那么在硬件中断处理返回前会检查是否要抢占当前进程</li></ul></li><li>内核不可抢占<ul><li>当前进程调用 cond_resched 时会检查是否需要调度</li><li>主动调用 schedule()</li><li>系统调用或者异常处理完后返回用户空间时</li><li>中断处理完成后返回用户空间时</li></ul></li></ul></li></ul><p>前文提到的硬件中断返回前和硬件中断返回用户空间前是两个不同的概念。前者在每次硬件中断返回前都会检查是否有进程需要被抢占调度，而不管中断发生点是在内核空间还是用户空间；后者仅当中断发生点在用户空间时才会检查。</p><p>在 Linux 内核里，schedule() 是内部使用的接口函数，有不少其他函数会直接调用该函数。除此之外，schedule() 函数还有不少变种。</p><ul><li>preempt_schedule() 用于可抢占内核的调度。</li><li>preempt_schedule_irq() 用于可抢占内核的调度，在中断结束返回时会调用该函数。</li><li>schedule_timeout（signed long timeout），进程睡眠到 timeout 指定的超时时间为止。 schedule() 函数的核心代码片段如下。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">sched_submit_work(tsk);</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">preempt_disable();</span><br><span class="line">__schedule(SM_NONE);</span><br><span class="line">sched_preempt_enable_no_resched();</span><br><span class="line">} <span class="keyword">while</span> (need_resched());</span><br><span class="line">sched_update_worker(tsk);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></tbody></table></figure><h2 id="进程切换-1">进程切换</h2><p>操作系统会把当前正在运行的进程挂起并且恢复以前挂起的某个进程的执行，这个过程称为进程切换或者上下文切换。Linux 内核实现进程切换的核心函数是 context_switch() 每个进程可以拥有属于自己的进程地址空间，但是所有进程都必须共享 CPU 的寄存器等资源。所以，在切换进程时必须把 next 进程在上一次挂起时保存的寄存器值重新装载到 CPU 里。在进程恢复执行前必须装入 CPU 寄存器的数据，则称为硬件上下文。进程的切执可以总结为如下两步。</p><ul><li>切换进程的进程地址空间，也就是切换 next 进程的页表到硬件页表中，这是 switch_mm() 函数实现的。</li><li>切换到 next 进程的内核态栈和硬件上下文，这是由 switch_to() 函数实现的。硬件上下文提供了内核执行 next 进程所需要的所有硬件信息。</li></ul><h4 id="switch_mm-函数">switch_mm() 函数</h4><p>switch_mm() 函数实质上是把新进程的页表基地址设置到页表基地址寄存器。对于 ARM64 处理器，switch_mm() 函数的主要作用是完成 ARM 架构相关的硬件设置，例如刷新 TLB 以及设置硬件页表等。</p><p>在运行进程时，除了高速缓存（cache）会缓存进程的数据外，MMU 内部还有叫作 TLB（Translation Lookaside Buffer，快表）的硬件单元，TLB 会为了加快虚拟地址到物理地址的转换速度而将部分页表项内容缓存起来，避免频繁访问页表。因此刚切换完进程时会出现很严重的 TLB 未命中和高速缓存未命中，导致系统性能下降。</p><p>如何提高 TLB 的性能？这是最近几十年来芯片设计人员和操作系统设计人员共同努力的方向。从 Linux 内核角度看，地址空间可以划分为内核地址空间和用户空间；对于 TLB 来说，可以划分成全局（global）类型和进程独有（process-specific）类型。</p><ul><li>全局类型的 TLB：内核空间是所有进程共享的空间，因此这部分空间的虚拟地址至物理地址的翻译是不会变化的，可以理解为全局的。</li><li>进程独有类型的 TLB：用户地址空间是每个进程独有的地址空间。将 prev 进程切换到 next 进程时，TLB 中缓存的 prev 进程的相关数据对于 next 进程是无用的，因此可以刷新，这就是所谓的进程独有类型的 TLB。</li></ul><p>为了支持进程独有类型的 TLB，ARM 架构提出了一种硬件解决方案，叫 ASID（Address Space ID），这样 TLB 就可以识别哪些 TLB 项是属于某个进程的。ASID 方案使得每个 TLB 项包含一个 ASID，ASID 用于标识每个进程的地址空间。因此，有了 ASID 硬件机制的支持，进程的切换就不需要刷新整个 TLB，只需要刷新进程独有的 TLB。</p><h4 id="switch_to-函数">switch_to() 函数</h4><p>处理完 TLB 和页表基地址后，还需要进行栈空间的切换，这样 next 进程才能开始运行，这正是 switch_to() 函数的目的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/<span class="keyword">asm</span>-generic/switch_to.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)\</span></span><br><span class="line"><span class="meta">do {\</span></span><br><span class="line"><span class="meta">((last) = __switch_to((prev), (next)));\</span></span><br><span class="line"><span class="meta">} while (0)</span></span><br></pre></td></tr></tbody></table></figure><p>switch_to() 函数一共有 3 个参数，第一个表示将要被调度出去的进程 prev，第二个表示将要被调度进来的进程 next，第三个参数 last 是什么意思呢？为什么 switch_to() 函数有 3 个参数？prev 和 next 就够了，为何还需要 last？</p><p>switch_to 宏由旧进程调用，在新进程结束，新进程如果想获取旧进程描述符地址，不能直接读取局部变量 prev（因为 prev 存放在该宏调用者，即旧进程的内核栈中，新进程无法访问旧进程的内核栈），所以就需要一个输出参数将旧进程描述符地址传递给新进程（实现方法就是利用 cpu 寄存器%eax，在切换过程中该寄存器的值不变，也就是说，在旧进程中，将 prev 存入%eax，在新进程恢复执行后，将%eax 的内容放入 last）。</p><p>task_struct 数据结构里的 thread_struct 用来存放和具体架构相关的一些信息。对于 ARM64 架构来说，thread_struct 数据结构定义在 arch/arm64/include/asm/processor.h 文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/processor.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_context</span><span class="title">cpu_context</span>;</span><span class="comment">/* cpu context */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>tp_value;<span class="comment">/* TLS register */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>tp2_value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_fpsimd_state</span> <span class="title">fpsimd_state</span>;</span></span><br><span class="line">} uw;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>fpsimd_cpu;</span><br><span class="line"><span class="type">void</span>*sve_state;<span class="comment">/* SVE registers, if any */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>sve_vl;<span class="comment">/* SVE vector length */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>sve_vl_onexec;<span class="comment">/* SVE vl after next exec */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fault_address;<span class="comment">/* fault info */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fault_code;<span class="comment">/* ESR_EL1 value */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_info</span><span class="title">debug</span>;</span><span class="comment">/* debugging */</span></span><br><span class="line">u64sctlr_user;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>cpu_context：保存进程上下文相关的信息到 CPU 相关的通用寄存器中</li><li>tp_value：TLS 寄存器。</li><li>tp2_value：TLS 寄存器。</li><li>fpsimd_state：与 FP 和 SMID 相关的状态。</li><li>fpsimd_cpu：FP 和 SMID 的相关信息。</li><li>sve_state：SVE 寄存器。</li><li>sve_vl：SVE 向量的长度。</li><li>sve_vl_onexec：下一次执行之后 SVE 向量的长度。</li><li>fault_address：异常地址。</li><li>fault_code：异常错误值，从 ESREL1 中读出。</li></ul><p>cpu_context 是一种非常重要的数据结构，它勾画了在切换进程时，CPU 需要保存哪些寄存器，我们称为进程硬件上下文。对于 ARM64 处理器来说，在切换进程时，我们需要把 prev 进程的 x19~x28 寄存器以及 fp、sp 和 pc 寄存器保存到 cpu_context 数据结构中，然后把 next 进程中上一次保存的 cpu_context 数据结构的值恢复到实际硬件的寄存器中，这样就完成了进程的上下文切换。 cpu_context 数据结构的定义如下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/processor.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_context</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x19;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x20;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x21;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x22;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x23;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x24;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x25;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x26;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x27;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x28;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pc;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>进程的上下文切换的流程如图所示。在进程切换过程中，进程硬件上下文中重要的寄存器已保存到 prev 进程的 cpu_context 数据结构中，进程硬件上下文包括 x19~x28 寄存器、fp 寄存器、sp 寄存器以及 pc 寄存器，如图（a）所示。然后，把 next 进程存储的上下文恢复到 CPU 中，如图（b）所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/context.png"></p><h1 id="参考文献">参考文献</h1><p>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（二）进程的创建和终止</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskCreate/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskCreate/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/TaskCreate.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1ZmQxYmYzNDZmYjA3MjVmNjhhYjg=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>最新版本的 POSIX 标准中定义了进程创建和终止的操作系统层面的原语。进程创建包括 fork() 和 execve() 函数族，进程终止包括 wait()、waitpid()、kill() 以及 exit() 函数族。Linux 在实现过程中为了提高效率，把 POSIX 标准的 fork 原语扩展成了 vfork 和 clone 两个原语。</p><p>我们最常见的一种场景是在 shell 界面中输入命令，然后等待命令返回，如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/shell_exec.png"></p><h1 id="用户空间如何创建进程">用户空间如何创建进程</h1><p>应用程序在用户空间创建进程有两种场景：</p><ul><li>创建的子进程和父进程共用一个 elf 文件：这种情况适合于大多数的网络服务程序</li><li>创建的子进程需要加载自己的 elf 文件：例如 shell</li></ul><p>应用程序可以通过 fork 系统调用创建进程，fork 之后，子进程复制了父进程的绝大部分的资源（文件描述符、信号处理、当前工作目录等）。完全复制父进程的资源的开销非常大且没有什么意义，特别是对于场景 2。不过，在引入 COW(copy-on-write) 技术后，fork 的开销其实也不算特别大，大部分的 copy 都是通过 share 完成的，主要的开销集中在复制父进程的页表上。linux 还提供了 vfork 函数，vfork 和 fork 是类似的，除了下面两点：</p><ul><li>阻塞父进程</li><li>不复制父进程的页表</li></ul><p>之所以 vfork 要阻塞父进程是因为 vfork 后父子进程使用的是完全相同的 memory descriptor, 也就是说使用的是完全相同的虚拟内存空间，包括栈也相同。所以两个进程不能同时运行，否则栈就乱掉了。除了 fork 和 vfork，Linux 内核还提供的 clone 的系统调用接口主要用于线程的创建。其实通过传递不同的参数，clone 接口可以实现 fork 和 vfork 的功能。</p><h1 id="创建进程">创建进程</h1><p>现代操作系统都采用写时复制（Copy On Write，cow）技术。写时复制技术就是父进程在创建子进程时不需要复制进程地址空间的内容给子进程，只需要复制父进程的进程地址空间的页表给子进程，这样父子进程就可以共享相同的物理内存。当父子进程中有一方需要修改某个物理页面的内容时，触发写保护的缺页异常，然后才把共享页面的内容复制出来，从而让父子进程拥有各自的副本，如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/cow.png"></p><h2 id="fork-函数">fork() 函数</h2><p>如果使用 fork() 函数来创建子进程，子进程和父进程将拥有各自独立的进程地址空间，但是共享物理内存资源，包括进程上下文、进程栈、内存信息、打开的文件描述符、进程优先级、资源限制等。在创建期间，子进程和父进程共享物理内存空间，当它们开始运行各自的程序时，它们的进程地址空间开始分道扬镳，这得益于写时复制技术的优势。子进程和父进程有如下一些区别。</p><ul><li>子进程和父进程的 ID 不一样</li><li>子进程不会继承父进程的内存方面的锁，比如 mlock()</li><li>子进程不会继承父进程的一些定时器，比如 setitimer()、alarm()、timer_create()</li><li>子进程不会继承父进程的信号量，比如 semop()</li></ul><p>尽管使用了写时复制技术，但还是需要复制父进程的页表，在某些场景下会比较慢，所以有了后来的 vfork 原语和 clone 原语。</p><h2 id="vfork-函数">vfork() 函数</h2><p>vfork() 函数通过系统调用进入 Linux 内核，然后通过 kernel_clone() 函数来实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(vfork)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> =</span> {</span><br><span class="line">.flags= CLONE_VFORK | CLONE_VM,</span><br><span class="line">.exit_signal= SIGCHLD,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kernel_clone(&amp;args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>vfork() 的实现比 fork() 多了两个标志位，分别是 CLONE_VFORK 和 CLONE_VM。CLONE_VFORK 表示父进程会被挂起，直至子进程释放虚拟内存资源。CLONE_VM 表示父子进程运行在相同的进程地址空间中。vfork() 的另一个优势是连父进程的页表项复制动作也被省去了。</p><h2 id="clone-函数">clone() 函数</h2><p>clone() 函数通常用来创建用户线程。clone() 函数功能强大，可以传递众多参数，可以有选择地继承父进程的资源，比如可以和 vfork() 一样与父进程共享进程地址空间，从而创建线程；也可以不和父进程共享进程地空间，甚至可以创建兄弟关系进程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*glibc 库的封装*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn) (voia*), voia* child_stack,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> flags, <span class="type">void</span> *arg, ...)</span>;</span><br><span class="line"><span class="comment">/*原始的系统调用*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">clone</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *child_stack,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *ptid, voia* ctid,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> pt_regs *regs)</span>;</span><br></pre></td></tr></tbody></table></figure><p>以 glibc 封装的 clone() 函数为例，fn 是子进程执行的函数指针；child_stack 用于为子进程分配栈；flags 用于设置 clone 标志位，表示需要从父进程继承哪些资源；arg 是传递给子进程的参数。clone() 函数通过系统调用进入 Linux 内核，然后通过 kernel_clone() 函数来实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(clone, <span class="type">unsigned</span> <span class="type">long</span>, clone_flags, <span class="type">unsigned</span> <span class="type">long</span>, newsp,</span><br><span class="line"> <span class="type">int</span> __user *, parent_tidptr,</span><br><span class="line"> <span class="type">int</span> __user *, child_tidptr,</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span>, tls)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> =</span> {</span><br><span class="line">.flags= (lower_32_bits(clone_flags) &amp; ~CSIGNAL),</span><br><span class="line">.pidfd= parent_tidptr,</span><br><span class="line">.child_tid= child_tidptr,</span><br><span class="line">.parent_tid= parent_tidptr,</span><br><span class="line">.exit_signal= (lower_32_bits(clone_flags) &amp; CSIGNAL),</span><br><span class="line">.<span class="built_in">stack</span>= newsp,</span><br><span class="line">.tls= tls,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kernel_clone(&amp;args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="内核线程">内核线程</h2><p>内核线程（kermel thread）其实就是运行在内核地址空间中的进程，它和普通用户进程的区别在于内核线程没有独立的进程地址空间，也就是 task_struct 数据结构中的 mm 指针被设置为 NULL，因而只能运行在内核地址空间中，和普通进程一样参与系统调度。所有的内核线程都共享内核地址空间。常见的内核线程有页面回收线程“kswapd”等。Linux 内核提供了多个接口函数来创建内核线程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_create(threadfn, data, namefmt, arg...) \</span></span><br><span class="line"><span class="meta">kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)   \</span></span><br><span class="line"><span class="meta">({   \</span></span><br><span class="line"><span class="meta">struct task_struct *__k   \</span></span><br><span class="line"><span class="meta">= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (!IS_ERR(__k))   \</span></span><br><span class="line"><span class="meta">wake_up_process(__k);   \</span></span><br><span class="line"><span class="meta">__k;   \</span></span><br><span class="line"><span class="meta">})</span></span><br></pre></td></tr></tbody></table></figure><p>kthread_create() 接口函数创建的内核线程被命名为 namefmt。新建的内核线程将运行 threadfn() 函数。新建的内核线程处于不可运行状态，需要调用 wake_up_process() 函数来将其唤醒并添加到就绪队列中，要创建一个马上可以运行的内核线程，可以使用 kthread_run() 函数。内核线程最终还是通过 kernel_clone() 函数来实现。</p><p>在内核中，fork()、vfork() 以及 clone() 这 3 个系统调用都通过调用同一个函数即 kernel_clone() 函数来实现，该函数定义在 fork.c 文件中，感兴趣的可以自行查看，这个函数最终调用调用 copy_process 函数。</p><h2 id="forkvfork-和-pthread_create-区别">fork、vfork 和 pthread_create 区别</h2><ul><li><p>fork： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/fork100.png"></p></li><li><p>vfork： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/fork101.png"></p></li><li><p>pthread_create： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/fork102.png"></p></li><li><p>do_fork 实现： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/fork103.png"></p></li></ul><h1 id="终止进程">终止进程</h1><p>进程的终止有两种方式：一种方式是主动终止，包括显式地执行 exit() 系统调用或者从某个程序的主函数返回；另一种方式是被动终止，在接收到终止的信号或异常时终止。</p><p>当一个进程终止时，Linux 内核会释放它所占有的资源，并把这条消息告知父进程。一个进程的终止可能有两种情况。</p><ul><li>它有可能先于父进程终止，这时子进程会变成僵尸进程，直到父进程调用 wait() 才算最终消亡</li><li>它也有可能在父进程之后终止，这时 init 进程将成为子进程新的父进程</li></ul><h1 id="僵尸进程和托孤进程">僵尸进程和托孤进程</h1><p>当一个进程通过 exit() 系统调用被终止之后，该进程将处于僵尸状态。在僵尸状态中，除了进程描述符依然保留之外，进程的所有资源都已经归还给内核。Linux 内核这么做是为了让系统可以知道子进程的终止原因等信息，因此进程终止时所需要做的清理工作和释放进程描述符是分开的。当父进程通过 wait() 系统调用获取了已终止的子进程的信息之后，内核才会释放子进程的 task_struct 数据结构。</p><p>所谓托孤进程，是指如果父进程先于子进程消亡，那么子进程就变成孤儿进程，这时 Linux 内核会让它托孤给 init 进程（1 号进程），于是 init 进程就成了子进程的父进程。</p><h1 id="进程-0-和进程-1">进程 0 和进程 1</h1><p>进程 0 是指 Linux 内核在初始化阶段从无到有创建的一个内核线程，它是所有进程的祖先，有好几个别名，比如进程 0、idle 进程或 swapper 进程。进程 0 的进程描述符是在 init/init_task.c 文件中静态初始化的。</p><p>初始化函数 start_kernel() 在初始化完内核所需要的所有数据结构之后会创建另一个内核线程，这个内核线程就是进程 1 或 init 进程。与进程 0 共享所有的数据结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">noinline <span class="type">void</span> __ref <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">rcu_scheduler_starting();</span><br><span class="line"></span><br><span class="line">pid = kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进程 1 会执行 kernel_init() 函数，它会通过 execve() 系统调用装入可执行程序 init（“sbin/init”,“/bin/init”或“bin/sh”），进程 1 变成一个用户进程，是内核启动的第一个用户级进程。init 有许多很重要的任务，比如像启动 getty（用于用户登录）、实现运行级别、以及处理孤立进程。进程 1 在从内核线程变成普通进程 init 之后，它的主要作用是根据/etc/inittab 文件的内容启动所需要的任务，包括初始化系统配置、启动一个登录对话等。</p><p>当检测到来自终端的连接信号时，getty 进程将通过函数 do_execve() 执行注册程序 login，此时用户就可输入注册名和密码进入登录过程，如果成功，由 login 程序再通过函数 execv() 执行 shell，该 shell 进程接收 getty 进程的 pid，取代原来的 getty 进程。再由 shell 直接或间接地产生其他进程。</p><p>上述过程可描述为：0 号进程-&gt;1 号内核进程-&gt;1 号用户进程（init 进程）-&gt;getty 进程-&gt;shell 进程</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50L1Byb2Nlc3MtQ3JlYXRpb24tMS5odG1s">http://www.wowotech.net/process_management/Process-Creation-1.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwODE3MzI3L2FydGljbGUvZGV0YWlscy8xMDgyODk2NDc=">https://blog.csdn.net/qq_20817327/article/details/108289647<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODQyMzA3">https://cloud.tencent.com/developer/article/1842307<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 进程管理（一）基本概念</title>
      <link href="/next/2021/LinuxKernel/LinuxTaskBasic/"/>
      <url>/next/2021/LinuxKernel/LinuxTaskBasic/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ProcessBasic.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1ZDg4NDFlMDg1MzA2ZjhjMzUxZjM=">原图<i class="fa fa-external-link-alt"></i></span></p><h1 id="进程的概念">进程的概念</h1><p>进程是处于执行期的程序以及相关的资源的总称。进程并不仅仅局限于一段可执行程序代码，通常进程还要包含其他资源，像数据段、打开的文件、挂起的信号、处理器状态、一个或多个具有内存映射的内存地址空间及一个或多个执行线程（thread of execution）等。</p><p>线程（thread），是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、线程栈和一组进程寄存器，内核调度的对象是线程，而不是进程。</p><p>在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。</p><ul><li>虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器</li><li>虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源</li></ul><span id="more"></span><h1 id="进程描述符">进程描述符</h1><p>进程是操作系统中调度的实体，需要对进程所必须拥有的资源做抽象描述，这种对象描述称为进程控制块（Process Control Block，PCB）。进程控制块需要描述如下几类信息：</p><ul><li>进程的运行状态：包括就绪、运行、阻塞、僵尸等状态</li><li>程序计数器：记录当前进程运行到哪条指令了</li><li>CPU 寄存器：主要保存当前运行的上下文，记录 CPU 所有必须保存下来的寄存器信息，以便当前进程调度出去之后还能调度回来并接着运行</li><li>CPU 调度信息：包括进程优先级、调度队列等相关信息</li><li>内存管理信息：进程使用的内存信息，比如进程的页表等</li><li>统计信息：包含进程运行时间等相关的统计信息</li><li>文件相关信息：包括进程打开的文件等</li></ul><p>在 Linux 内核里面采用名为 task_struct 的数据结构来描述，Linux 内核利用链表 task_list 来存放所有进程描述符，task_struct 数据结构定义在 include/inux/sched.h 文件中。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/task_list.png"></p><p>task_struct 数据结构很大，里面包含的内容很多，可以简单归纳成如下几类：</p><ul><li>进程属性的相关信息（包括进程状态、进程的 PID 等信息）</li><li>进程间的关系（父子、兄弟、进程组等）</li><li>进程调度的相关信息（优先级、调度类、policy 进程类型等）</li><li>内存管理的相关信息（mm）</li><li>文件管理的相关信息（fs）</li><li>信号的相关信息</li><li>资源限制的相关信息</li></ul><h1 id="进程的生命周期">进程的生命周期</h1><p>典型的操作系统中的进程如下图所示，其中包含如下状态： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/task_status.png"></p><ul><li>TASK_RUNNING（可运行态或就绪态）：它是指进程处于可执行状态，或许正在执行，或许在就绪队列中等待执行</li><li>TASK_INTERRUPTIBLE（可中断睡眠态）：进程进入睡眠状态（被阻塞）以等待，一旦条件达成或者资源就位，可以把进程的状态设置成可运行态（TASK_RUNNING）并加入就绪队列。也有人将这种状态称为浅睡眠状态</li><li>TASK_UNINTERRUPTIBLE（不可中断态）：进程在睡眠等待时不受干扰，对信号不做任何反应，所以这种状态又称为不可中断态。通常，使用 ps 命令看到的被标记为 D 状态的进程就是处于不可中断态的进程，不可以发送 SIGKILL 信号终止它们，因为它们不响应信号。也有人把这种状态称为深度睡眠状态</li><li>TASK_STOPPED（终止态）：进程停止运行了</li><li>EXIT_ZOMBIE （僵尸态），进程已经消亡，但是 task_struct 数据结构还没有释放这种状态叫作僵尸状态，每个进程在自己的生命周期中都要经历这种状态。子进程退出时，父进程可以通过 wait() 或 waitpid() 来获取子进程消亡的原因</li></ul><h1 id="进程标识">进程标识</h1><p>在创建时会为进程分配唯一的号码来标识，这个号码就是进程标识符（Process Identife PID）。</p><p>除了 PID 之外，Linux 内核还引入了线程组的概念。一个线程组中的所有线程都使用和该线程组中主线程相同的 PID，即该线程组中第一个线程的 PID，它会被存入 task_stuct 数据结构的 tgid 成员中。这与 POSIX 1003.1c 标准里的规定有关，一个多线程应用程序中的所有线程都必须有相同的 PID，这样就可以通过 PID 把信号发送给线程组里所有的线程。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getpid() <span class="comment">// 会返回当前进程的 TGID</span></span><br><span class="line">gettid() <span class="comment">// 会返回线程的 PID</span></span><br></pre></td></tr></tbody></table></figure><h1 id="进程间的家族关系">进程间的家族关系</h1><p>Linux 内核维护了进程之间的家族关系，比如：</p><ul><li>Linux 内核在启动时会有一个 init_task 进程，它是系统中所有进程的“鼻祖”，称为进程 0 或 idle 进程。当系统没有进程需要调度时，调度器就会执行 idle 进程。idle 进程在内核启动（start_kernel() 函数）时静态创建，所有的核心数据结构都预先静态赋值</li><li>系统初始化快完成时会创建一个 init 进程，也就是常说的进程 1，它是所有用户进程的祖先，从这个进程开始，所有的进程都将参与调度</li><li>如果进程 A 创建了进程 B，那么进程 A 称为父进程，进程 B 称为子进程。如果进程 B 创建了进程 C，那么进程 A 和进程 C 之间的关系就是祖孙关系</li><li>如果进程 A 创建了 Bi（1 &lt; i&lt; n）个进程，那么这些进程之间为兄弟关系</li></ul><h1 id="linux-进程调度">Linux 进程调度</h1><h2 id="进程的分类">进程的分类</h2><p>进程可以分成两类：一类是 CPU 消耗型（CPU-Bound），另外一类是 I/O 消耗型（I/O-Bound）。</p><ul><li>CPU 消耗型的进程会把大部分时间用在执行代码上，也就是一直占用 CPU</li><li>I/O 消耗型的进程大部分时间在提交 I/O 请求或者等待 I/O 请求，比如需要键盘输入的进程或者等待网络 I/O 的进程</li></ul><h2 id="进程的优先级和权重">进程的优先级和权重</h2><p>操作系统中最经典的进程调度算法是基于优先级调度。调度器总是从就绪队列中选择优先级高的进程进行调度，而且优先级高的进程分配的时间片也会比优先级低的进程多。</p><p>Linux 系统最早采用 nice 值来调整进程的优先级。范围是-20~+19，默认值是 0。</p><p>内核使用 0 ~ 139 的数值表示进程的优先级 (normal_prio)，数值越低优先级越高。优先级在 Linux 中的划分方式如下。</p><ul><li>普通进程的优先级：100~139(120 + nice)</li><li>实时进程的优先级：0~99 (99 - rt_prio)</li><li>deadline 进程的优先级：-1</li></ul><p>task struct 数据结构中有 4 个成员，用来描述进程的优先级。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    <span class="type">int</span> prio;</span><br><span class="line">    <span class="type">int</span> static_prio;</span><br><span class="line">    <span class="type">int</span> normal_prio;</span><br><span class="line">    unsignea <span class="type">int</span> rt_priority;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RT_PRIO100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __normal_prio(<span class="keyword">struct</span> task_struct *p)</span><br><span class="line">{</span><br><span class="line">   <span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">normal_prio</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> prio;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">   prio = MAX_DL_PRIO<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">   prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   prio = __normal_prio(p);</span><br><span class="line">   <span class="keyword">return</span> prio;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>static_prio 是静态优先级，在进程启动时分配 [120+nice]</li><li>normal_prio 是基于 static_prio 和调度策略计算出来的优先级，在创建进程时会继承父进程的 normal_prio。对于普通进程来说，normal_prio 等同于 static_prio；对于实时进程，会根据 rt_priority 重新计算 normal_prio[99 - rt_priority]</li><li>prio 保存着进程的动态优先级，也是调度类考虑使用的优先级。有些情况下需要暂时提高进程的优先级，例如实时互斥量等</li><li>rt_priority 是实时进程的优先级</li></ul><p>在 Linux 内核中，除了使用优先级来表示进程的轻重缓急之外，在实际的调度器中也使用权重的概念来表示进程的优先级，详细的权重含义将在 CFS 调度器一节中介绍，这里不做过多介绍了。</p><p>推荐阅读 <span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50L3Byb2Nlc3MtcHJpb3JpdHkuaHRtbA==">Linux 调度器：进程优先级<i class="fa fa-external-link-alt"></i></span> 更详细。</p><h2 id="调度策略">调度策略</h2><p>进程调度依赖于调度策略（schedule policy），Linux 内核把相同的调度策略抽象成了调度类（schedule class）。不同类型的进程采用不同的调度策略，目前 Linux 内核中默认实现了 5 个调度类，分别是 stop、 deadline、realtime、CFS 和 idle，它们分别使用 sched_class 来定义，并且通过 next 指针串联在一起，如图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/sched_list.png"></p><ul><li>stop：<ul><li>最高优先级，比 deadline 进程的优先级高</li><li>可以抢占任何进程</li><li>在每个 CPU 上实现一个名为“migration/N”的内核线程，N 表示 CPU 的编号。该内核线程的优先级最高，可以抢占任何进程的执行，一般用来执行特殊的功能</li><li>用于负载均衡机制中的进程迁移、softlockup 检测、CPU 热插拔、RCU 等</li></ul></li><li>deadline(SCHED_DEADLINE )：<ul><li>最高优先级的实时进程，优先级为-1</li><li>用于调度有严格时间要求的实时进程，如视频编解码等</li></ul></li><li>realtime(SCHED_FIFO、SCHED_RR)：<ul><li>普通实时进程，优先级为 0~99</li><li>用于普通的实时进程，比如 IRQ 线程化</li></ul></li><li>CFS(SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE)：<ul><li>普通进程，优先级为 100~139，由 CFS 来调度</li></ul></li><li>idle：<ul><li>最低优先级的进程</li><li>当就绪队列中没有其他进程时进入 idle 调度类，idle 调度类会让 CPU 进入低功耗模式</li></ul></li></ul><blockquote><p>进程调度的入口是 schedule() 函数，他会调用 pick_next_task() 函数，pick_next_task() 会以优先级为序，从高到低，依次检查每一个调度类，并从最高优先级的调度类中选择最高优先级的进程运行。</p></blockquote><p>用户空间程序可以使用调度策略 API 函数，比如 sched_setscheduler() 来设定用户进程的调度策略。其中，SCHED_NORMAL、SCHED_BATCH 以及 SCHED_IDLE 使用完全公平调度器（CFS），SCHED_FIFO 和 SCHED_RR 使用 realtime 调度器，SCHED_DEADLINE 专用 deadline 调度器。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_NORMAL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_BATCH    3</span></span><br><span class="line"><span class="comment">/* SCHED_ISO: reserved but not implemented yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_IDLE    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DEADLINE6</span></span><br></pre></td></tr></tbody></table></figure><ul><li>SCHED_RR（循环）调度策略表示优先级相同的进程以循环分享时间的方式执行。进程每次使用 CPU 的时间为一个固定长度的时间片。进程会保持占有 CPU，直到下面的某个条件得到满足：<ul><li>时间片用完</li><li>自愿放弃 CPU</li><li>进程终止</li><li>被高优先级进程抢占</li></ul></li><li>SCHED_FIFO（先进先出）调度策略与 SCHED_RR 调度策略类似，只不过没有时间片的概念。一旦进程获取了 CPU 控制权，就会一直执行下去，直到下面的某个条件得到满足：<ul><li>自愿放弃 CPU</li><li>进程终止</li><li>被更高优先级进程抢占</li></ul></li><li><p>SCHED_BATCH（批处理）调度策略是普通进程调度策略。这种调度策略会让调度器认为进程是 CPU 密集型的。因此，调度器对这类进程的唤醒惩罚（wakeup penalty）比较小。在 Linux 内核里，此类调度策略使用完全公平调度器：</p></li><li><p>SCHED_NORMAL（以前称为 SCHED_OTHER）分时调度策略是非实时进程的默度策略。所有普通类型的进程的静态优先级都为 0，因此，任何使用 SCHED_FIFO、SCHED_RR 调度策略的就绪进程都会抢占它们。Linux 内核没有实现这类调度策略。</p></li><li><p>SCHED_IDLE 空闲调度策略用于运行低优先级的任务。</p></li></ul><blockquote><p>其中实时进程一旦执行就会一直执行下去，需要进程自己主动放弃 CPU 使用权，只要有实时进程在运行其他普通进程就无法得到执行，因此实时进程的设计需要格外小心，需要主动放弃 CPU 使用权。</p></blockquote><h2 id="时间片">时间片</h2><p>时间片（time slice）表示进程被调度进与被调度出去之间所能持续运行的时间长度。通常操作系统都会规定默认的时间片，但是很难确定多长的时间片是合适的。I/O 消耗型的进程不需要很长的时间片，而 CPU 消耗型的进程则希望时间片越长越好。</p><p>早期的 Linux 中的调度器采用的是固定时间片，但是现在的 CFS 已经抛弃固定时间片的做法，而是采用进程权重占比的方法来公平地划分 CPU 时间，这样进程获得的 CPU 时间就与进程的权重以及 CPU 上的总权重有了关系。权重和优先级相关，优先级高的进程权重也高，有机会占用更多的 CPU 时间；而优先级低的进程权重也低，那么理应占用较少的 CPU 时间。</p><h1 id="抢占">抢占</h1><ul><li>抢占内核：更高优先级的进程会打断当前进程的执行，得到优先执行。</li><li>不可抢占内核：更高优先级的进程需要等到当前进程主动放弃 CPU 使用权才可以得到 CPU 使用权。</li></ul><p>用户抢占时机：</p><ul><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ul><p>内核抢占时机：</p><ul><li>中断处理程序正在执行，返回内核空间之前</li><li>内核代码再一次具有可抢占性的时候</li><li>内核显式调用 schedule()</li><li>内核中的任务 sleep 的时候会调用 schedule()</li></ul><h1 id="上下文切换">上下文切换</h1><ul><li><p>CPU 上下文切换： CPU 上下文包括 CPU 寄存器和程序计数器，CPU 上下文切换就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。系统调用时会发生 CPU 上下文切换，但是没有切换进程，始终在同一个进程里运行。</p></li><li><p>进程上下文切换： 进程上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p></li><li><p>中断上下文切换： 中断上下文包括 CPU 寄存器、内核堆栈、硬件中断参数等。中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。只保存 CPU 寄存器、内核堆栈、硬件中断参数等中断服务程序执行所必需的状态。</p></li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50LzE5Lmh0bWw=">http://www.wowotech.net/process_management/19.html<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》<br>《Linux 内核设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM64 架构基础</title>
      <link href="/next/2021/Program/ARM64Struct/"/>
      <url>/next/2021/Program/ARM64Struct/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/ARM64Struct.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1OTNjNzU2NTNiYjA3MWU2ZTllYjE=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="arm64-架构介绍">ARM64 架构介绍</h1><h2 id="armv8-a-架构介绍">ARMv8-A 架构介绍</h2><p>ARMv8-A 是 ARM 公司发布的第一代支持 64 位处理器的指令集和架构。ARMv8-A 架构除了提高了处理能力外，还引入了很多吸引人的新特性。</p><ul><li>具有 64 位宽的虚拟地址空间。</li><li>提供 31 个 64 位宽的通用寄存器，可以减少对栈的访问，从而提高性能。</li><li>提供 16KB 和 64KB 的 page，有助于降低 TLB 的未命中率（miss rate）。</li><li>具有全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度。</li><li>具有全新的加载-获取、存储-释放指令（load-acquire，store-release instruction），专为 C++11 以及 Java 内存模型而设计。</li></ul><h2 id="arm64-的基本概念">ARM64 的基本概念</h2><p>ARM 处理器实现的是精简指令集计算机（Reduced Instruction Set Computer，RISC）架构。本节介绍 ARMv8-A 架构中的一些基本概念。</p><ul><li><p>处理单元： ARM 公司的官方技术手册中提到了一个概念，可以把处理器处理事务的过程抽象为处理单元（Processing Element，（PE）</p></li><li>执行状态： 执行状态（execution state）是处理器运行时的环境，包括寄存器的位宽、支持的指令集异常模型、内存管理以及编程模型等。ARMv8 架构定义了两种执行模式<ul><li>AArch64:64 位的执行状态。提供 31 个 64 位的通用寄存器、提供 64 位的程序计数（PC）寄存器、栈指针（SP）寄存器以及异常链接寄存器（ELR）。提供 A64 指令集、定义 ARMv8 异常模型，支持 4 个异常等级 ELO~EL3</li><li>AArch32:32 位的执行状态。提供 13 个 32 位的通用寄存器，再加上 PC 寄存器、SP 寄存器、链接寄存器（LR）。支持两套指令集，分别是 A32 和 T32 指令集（Thumb 指令集）</li></ul></li><li>ARMv8 指令集：<ul><li>A64 指令集：运行在 AArch64 状态，提供 64 位指令集支持</li><li>A32 指令集：运行在 AArch32 状态，提供 32 位指令集支持</li><li>T32 指令集：运行在 AArch32 状态，提供 16 和 32 位指令集支持</li></ul></li><li><p>系统寄存器命名： 在 AArch64 状态下，很多系统寄存器会根据不同的异常等级提供不同的变种寄存器</p><p><register_name>_ELx, where x is 0,1, 2, or 3</register_name></p></li></ul><p>比如，SP_ELO 表示 ELO 下的栈指针寄存器，SP_EL1 表示 EL1 下的栈指针寄存器。</p><h2 id="armv8-处理器的运行状态">ARMv8 处理器的运行状态</h2><p>ARMv8 处理器支持两种运行状态--AArch64 状态和 AArch32 状态。AArch64 架构的异常等级（exception level）确定了处理器当前运行的特权级别，类似于 ARMv7 架构中的特权等级。</p><ul><li>EL0：用户特权，用于运行普通用户程序。</li><li>EL1：系统特权，通常用于运行操作系统。</li><li>EL2：运行虚拟化扩展的虚拟监控程序（hypervisor）。</li><li>EL3：运行安全世界中的安全监控器（secure monitor）。</li></ul><p>在 ARMv8 架构里允许切换应用程序的运行模式。比如，在运行 64 位操作系统的 ARMv8 处理器中，我们可以同时运行 A64 指令集的应用程序和 A32 指令集的应用程序。当需要执行 A32 指令集的应用程序时，需要通过管理员调用（Supervisor Call, SVC）指令切换到 EL1 操作系统会执行任务的切换并且返回到 AArch32 的 ELO，这时候系统便为这个应用程序备好了 AArch32 的运行环境。</p><h2 id="不对齐访问">不对齐访问</h2><p>对齐访问有两种情况。一种是指令对齐，另一种是数据对齐。</p><ul><li>A64 指令集要求指令存放的位置必须以字（word，32 位宽）为单位对齐。访问存储位置不是以字为单位对齐的指令会导致 PC 对齐异常（PCaligment fault）。</li><li>对于数据访问，需要区分不同的内存类型。<ul><li>对内存类型是设备内存的不对齐访问会触发对齐异常（alignment fault）</li><li>对于访问普通内存，除了使用独占、加载/独占-存储（load-exclusive/store-exclusive）指令或加载-获取/存储-释放（load-acquire/store-release）指令外，还可使用其他的用于加载或存储单个或多个寄存器的所有指令。如果访问地址和要访问的数据元素大小不对齐，那么可以根据以下两种情况进行处理：<ul><li>若对应的异常等级中的 SCTLR_ELx 寄存器的 A 域设置为 1，则说明打开了地址对齐检查功能，因而会触发对齐异常</li><li>若对应的异常等级中的 SCTLRELx 寄存器的 A 域设置为 0，则说明处理器支持不对齐访问</li></ul></li></ul></li></ul><p>当然，处理器支持的不对齐访问也有一些限制。</p><ul><li>不能保证单次访问原子地完成，有可能复制多次。</li><li>不对齐访问比对齐访问需要更多的处理时间。</li><li>不对齐的地址访问可能会引发中止（abort）。</li></ul><h1 id="armv8-寄存器">ARMv8 寄存器</h1><h2 id="通用寄存器">通用寄存器</h2><p>AArch64 运行状态支持 31 个 64 位的通用寄存器，分别是 x0~x30 寄存器，而 AArch32 运行状态支持 16 个 32 位的通用寄存器。通用寄存器除了用于数据运算和存储之外，还可以在函数调用过程中起到特殊作用，ARM64 架构的函数调用标准和规范对此有所约定。</p><ul><li>传递参数和结果：x0 - x7。</li><li>间接结果寄存器：x8。</li><li>临时寄存器（调用的函数需要保存）: x8 - x15。</li><li>平台寄存器：x16(IP0) x17(IP1) x18(PR)。</li><li>被调用函数需要保存：x19 - x28。</li><li>栈帧寄存器：x29(FP)。</li><li>链接寄存器：x30(LR)。</li></ul><p>在 AArch64 运行状态下，使用 X 来表示 64 位通用寄存器，比如 X0、X30 等。另外，还可以使用 W 来表示低 32 位的寄存器，比如 W0 表示 X0 寄存器的低 32 位数据。</p><h2 id="特殊寄存器">特殊寄存器</h2><p>ARMv8 架构除了支持 31 个通用寄存器之外，还提供各个特殊的寄存器，如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/arm64_register.png"></p><h3 id="零寄存器">零寄存器</h3><p>ARMv8 架构提供两个零寄存器（zero register），这两个零寄存器的内容全是 0，可以用作源寄存器，也可以当作目标寄存器。WZR 是 32 位的零寄存器，XZR 是 64 位的零寄存器。</p><h3 id="栈指针寄存器">栈指针寄存器</h3><p>ARMv8 架构支持 4 个异常等级，每一个异常等级都有专门的 SP_ELn 寄存器，比如当处理器运行在 EL1 时就选择 SP_EL1 寄存器作为栈指针（Stack Pointer，SP）寄仔器。</p><ul><li>SP EL0：EL0 下的栈指针寄存器。</li><li>SP EL1：EL1 下的栈指针寄存器。</li><li>SP EL2：EL2 下的栈指针寄存器。</li><li>SP EL3：EL3 下的栈指针寄存器。</li></ul><p>当处理器运行在比 EL0 高的异常等级时：</p><ul><li>处理器可以访问当前异常等级对应的栈指针寄存器 SP_ELn。</li><li>EL0 对应的栈指针寄存器 SP_ELO 可以当作临时寄存器，比如 Linux 内核就使用这种临时寄存器存放进程的 task struct 数据结构的指针。</li><li>当运行在 ELO 时，处理器只能访问 SP_EL0 寄存器，而不能访问其他高等级的 SP 寄存器。</li></ul><h3 id="pc-寄存器">PC 寄存器</h3><p>PC （Program Counter）寄存器通常用来指向当前运行指令的下一条指令的地址，用于控制程序中指令的执行顺序，但是编程人员不能通过指令来直接访问。</p><h3 id="异常链接寄存器">异常链接寄存器</h3><p>异常链接寄存器（Exception Link Register，ELR）用来存放异常返回地址。</p><h3 id="保存处理状态寄存器">保存处理状态寄存器</h3><p>当我们进行异常处理时，处理器的处理状态会保存到保存处理状态寄存器（SavedProcess Status Register，（SPSR）里，这种寄存器非常类似于 ARMv7 架构中的 CPSR。当异常将要发生时，处理器会把处理状态寄存器（PSTATE）的值暂时保存到 SPSR 里；当异常处理完成并返回时，再把 SPSR 中的值恢复到处理器状态寄存器。SPSR 的布局如图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/pstate_64.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/pstate_32.png"></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/pstate_top.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/pstate_bottom.png"></p><ul><li>CurrentEL 寄存器： PSTATE 寄存器中的 EL 字段保存了当前异常等级。使用 MRS 指令可以读取当前异等级。<ul><li>0：表示 ELO</li><li>1：表示 EL1</li><li>2：表示 EL2</li><li>3：表示 EL3</li></ul></li><li>DAIF 寄存器： 表示 PSTATE 寄存器中的{D，A，I，F}字段<ul><li>D Debug exceptions mask</li><li>A SError interrupt Process state mask, for example, asynchronous external abort</li><li>I IRQ interrupt Process state mask</li><li>F FIQ interrupt Process state mask</li></ul></li><li>SPSel 寄存器： 表示 PSTATE 寄存器中的 SP 字段，用来在 SP_EL0 和 SP_ELn 中选择栈指针寄存器</li></ul><h2 id="系统寄存器">系统寄存器</h2><p>除了上面介绍的通用寄存器和特殊寄存器之外，ARMv8 架构还定义了很多系统寄存器，可通过访问和设置这些系统寄存器来完成对处理器不同功能的配置。在 ARMv7 架构里，我们需要通过访问 CP15 协处理器来间接访问这些系统寄存器：而在 ARMv8 架构中没有协处理器，可直接访问系统寄存器。ARMv8 架构支持如下 7 大类的系统寄存器：</p><ul><li>通用系统控制寄存器</li><li>调试寄存器</li><li>性能监控寄存器</li><li>活动监控寄存器</li><li>统计扩展寄存器</li><li>RAS 寄存器</li><li>通用定时器寄存器</li></ul><p>系统寄存器支持不同异常等级下的访问，通常系统寄存器可使用“Reg_ELn”的方式来表示，示例如下。</p><ul><li>Reg_EL1：处理器处于 EL1、EL2 以及 EL3 时可以访问该寄存器。</li><li>Reg_EL2：处理器处于 EL2 和 EL3 时可以访问该寄存器。</li></ul><p>当处于 EL0 时，大部分系统寄存器不支持处理器访问，但也有一些例外，比如 CTR_ELO。可以通过 MSR 和 MRS 指令来访问系统寄存器，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrs x0, TTBRO_EL1 //把 TTBR0_EL1 的值复制到 x0 寄存器</span><br><span class="line">msr TTBROEL1, xO //把 x0 寄存器的值复制到 TTBR0_EL1</span><br></pre></td></tr></tbody></table></figure><h1 id="a64-指令集">A64 指令集</h1><p>指令集架构（ISA）是处理器架构设计的重点之一。ARM 公司定义和实现的指令集架构一直在不断变化和发展。ARMv8 架构最大的改变是增加了一种新的 64 位的指令集，这是对早前 ARM 指令集的有益补充和增强，称为 A64 指令集。这种指令集可以处理 64 位宽的寄存器，并且使用 64 位的指针来访问内存，运行在 AArch64 状态下。ARMv8 兼容老的 32 位指令集，又称为 A32 指令集，运行在 AArch32 状态下。 A64 指令集和 A32 指令集是不兼容的，它们是两套完全不一样的指令集架构，它们的指令编码也不一样。需要注意的是，A64 指令集的指令为 32 位宽，而不是 64 位宽</p><h2 id="aarch64-架构图">aarch64 架构图</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/arm64_alu.png"></p><h2 id="指令集概览">指令集概览：</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/a64_1.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/a64_2.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/a64_3.png"></p><p>详细可以查看原文 <span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2VzLmNzLndhc2hpbmd0b24uZWR1L2NvdXJzZXMvY3NlNDY5LzE5d2kvYXJtNjQucGRm">点击<i class="fa fa-external-link-alt"></i></span></p><h1 id="arm64-异常处理">ARM64 异常处理</h1><p>在 arm64 架构里，中断属于异常的一种。中断是外部设备通知处理器的一种方式，他会打断处理器正在执行的指令流。在前面的描述中断的文章中已经介绍了关于异常的处理，这里不再细说。</p><h1 id="arm64-内存管理">ARM64 内存管理</h1><p>如图所示，ARM 处理器的内存管理单元（Memory Management Unit，MMU）包括 TLB 和页表遍历单元（Table Walk Unit）两个部件。TLB 是一块高速缓存，用于缓存页表转换结果，从而减少页表查询的时间。完整的页表翻译和查找的过程叫作页表查询（TranslatonTable Walk），页表查询的过程由硬件自动完成，但是页表的维护需要由软件完成。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/mmu.png"></p><p>对于多任务操作系统，每个进程都拥有独立的进程地址空间。这些进程地址空间在虚地址范围内是相互隔离的，但是在物理地址空间内有可能映射到同一个物理页面，那么这些进程地址空间是如何和物理地址空间发生映射关系的呢？这就需要处理器的内存管理单元提供页表映射和管理的功能。</p><h2 id="页表">页表</h2><p>AArch64 架构中的 MMU 不仅支持单一阶段的地址页表转换，还支持虚拟化扩展中的两阶段页表转换</p><ul><li>单一阶段页表：虚拟地址（VA）被翻译成物理地址（PA）</li><li>两阶段页表（虚拟化扩展） 阶段 1 虚拟地址被翻译成中间物理地址（Intermediate Physical Adress，IPA） 阶段 2 中间物理地址被翻译成最终物理地址</li></ul><h2 id="页表映射">页表映射</h2><p>在 AArch64 架构中，因为地址总线位宽最多支持 48 位，所以虚拟地址被划分为两个空间，每个空间最多支持 256TB。</p><ul><li>低位的虚拟地址空间位于 0x00000000000000~0x0000FFFFFFFFF。如果虚拟地址的最高位等于 0，那就使用这个虚拟地址空间，并且使用 TTBRO_ELx （TranslationTable Base Register）来存放页表的基地址。</li><li>高位的虚拟地址空间介于 0xFFFF00000000000~0xFFFFFFFFFFFFF。如果虚拟地址的最高位等于 1，那就使用这个虚拟地址空间，并且使用 TTBR1_ELx 来存放页表的基地址。</li></ul><p>AArch64 架构中的页表支持如下特性。</p><ul><li>最多可以支持 4 级页表。</li><li>输入地址的最大有效位宽为 48 位。</li><li>输出地址的最大有效位宽为 48 位。</li><li>翻译的页面粒度可以是 4KB、16KB 或 64KB。</li></ul><p>当 TLB 未命中时，处理器查询页表的过程如下。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/mmu_table.png"></p><ul><li>处理器根据 TTBRx 和虚拟地址来判断使用哪个页表基地址寄存器，是使用 TTBR0 还是 TTBR1。当虚拟地址的第 63 位（简称 VA[63]）为 1 时选择 TTBR1 当 VA[63] 为 0 时选择 TTBR0。页表基地址寄存器中存放着一级页表的基地址。</li><li>处理器将虚拟地址的 VA[47:39] 作为 L0 索引，在一级页表（L0 页表）中找到页表项，一级页表一共有 512 个页表项。</li><li>一级页表的页表项中存放有二级页表（L1 页表）的物理基地址。处理器将虚拟地址的 VA[38:30] 作为 L1 索引，在二级页表中找到相应的页表项，二级页表有 512 个页表项。</li><li>二级页表的页表项中存放有三级页表（L2 页表）的物理基地址。处理器将虚拟地址的 VA[29:21] 作为 L2 索引，在三级页表（L2 页表）中找到相应的页表项，三级页表有 512 个页表项。</li><li>三级页表的页表项中存放有四级页表（L3 页表）的物理基地址。处理器将虚拟地址的 VA[20:12] 作为 L3 索引，在四级页表（L3 页表）中找到相应的页表项，四级页表有 512 个页表项。</li><li>四级页表的页表项里存放有 4KB 页的物理基地址，然后加上虚拟地址的 VA[11：0] 就构成了新的物理地址，于是处理器就完成了页表的查询和翻译工作。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS91XzE1Mjc4MjE4LzI5MzA5NjM=">https://blog.51cto.com/u_15278218/2930963<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2VzLmNzLndhc2hpbmd0b24uZWR1L2NvdXJzZXMvY3NlNDY5LzE5d2kvYXJtNjQucGRm">https://courses.cs.washington.edu/courses/cse469/19wi/arm64.pdf<i class="fa fa-external-link-alt"></i></span><br>《ARM-Architecture Reference Manual，for ARMv8-A Architecture Profile，v8.4》<br>《奔跑吧 Linux 内核-入门篇》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> ARM64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（七）WorkQueue</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptWorkQueue/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptWorkQueue/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQWorkQueue.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1OTA4ZTA3OTEyOTA2ZjUwODBjYjM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="概述">概述</h1><p>工作队列不完全是中断处理程序的下半部。内核的很多模块需要异步执行函数，这些模块也可以创建一个内核线程来异步执行函数。但是，如果每个模块都创建自己的内核线程，会造成内核线程的数量过多，内存消耗比较大，影响系统性能。所以，最好的方法是提供一种通用机制，让这些模块把需要异步执行的函数交给工作队列执行，共享内核线程，节省资源。</p><hr><h1 id="实现扩展">实现（扩展🙈）</h1><p>首先介绍一下工作队列使用的术语。</p><ul><li>work：工作，也称为工作项。</li><li>work_queue：工作队列，就是工作的集合，work_queue 和 work 是一对多的关系。</li><li>worker：工人，一个工人对应一个内核线程，我们把工人对应的内核线程称为工人线程。</li><li>worker_pool：工人池，就是工人的集合，工人池和工人是一对多的关系。</li><li>pool_workqueue：中介，负责建立工作队列和工人池之间的关系。工作队列和 pool_workqueue 是一对多的关系，pool_workqueue 和工人池是一对一的关系。</li></ul><h2 id="数据结构">数据结构</h2><p>工作队列分为两种。</p><ul><li>绑定处理器的工作队列：默认创建绑定处理器的工作队列，每个工人线程绑定到一个处理器</li><li>不绑定处理器的工作队列：创建工作队列的时候需要指定标志位 WO_UNBOUND，工人线程不绑定到某个处理器，可以在处理器之间迁移</li></ul><p>绑定处理器的工作队列的数据结构如下图所示，工作队列在每个处理器上有一个 pool_workqueue 实例，一个 pool_workqueue 实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。向工作队列中添加工作项的时候，选择当前处理器的 pool_workqueue 实例、工人池和工人线程。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/workqueue_bind.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE0ZWNkMTM1NjUzYmIyZWE2ZTIzOTUw">原图<i class="fa fa-external-link-alt"></i></span></p><p>不绑定处理器的工作队列的数据结构如下图所示，工作队列在每个内存节点上有一个 pool_workqueue 实例，一个 pool_workqueue 实例对应一个工人池，一个工人池有一条工人链表，每个工人对应一个内核线程。向工作队列中添加工作项的时候，选择当前处理器所属的内存节点的 pool_workqueue 实例、工人池和工人线程。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/workqueue_unbind.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE0ZWNjZDE2Mzc2ODk0ODFiNjYxMzI0">原图<i class="fa fa-external-link-alt"></i></span></p><p>不绑定处理器的工作队列还有一个默认的 pool_workaueue 实例（workqueue_struct.dfl_pwq），当某个处理器下线的时候，使用默认的 pool_workqueue 实例。</p><h2 id="添加工作项">添加工作项</h2><p>函数 queue_work() 用来向工作队列中添加一个工作项，把主要工作委托给函数 queue_work_on()，把第一个参数“int cpu”设置为 WORK_CPU_UNBOUND，意思是不绑定到任何处理器，优先选择当前处理器。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/workqueue.h&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数 queue_work_on 的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {</span><br><span class="line">__queue_work(cpu, wq, work);</span><br><span class="line">ret = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果工作项没有添加过，那么给工作项设置标志位 WORK_STRUCT_PENDING_BIT 然后把主要工作委托给函数__queue_work()。函数 queue_work 的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line"> <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> work_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">lockdep_assert_irqs_disabled();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/* 1. 从工作队列中选择 pool_workqueue 实例。如果是绑定处理器的工作队列，</span></span><br><span class="line"><span class="comment">     *    那么选择当前处理器的 pool_workqueue 实例如果是不绑定处理器的工作队列</span></span><br><span class="line"><span class="comment">     *    那么选择当前处理器所属的内存节点的 pool_workqueue 实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) {</span><br><span class="line"><span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">cpu = raw_smp_processor_id();</span><br><span class="line">pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 如果@work 之前在其他 pool_workaueue 中，它可能仍在那里运行，在这种情况下，</span></span><br><span class="line"><span class="comment">     *    工作需要在该池上排队以保证不可重入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">last_pool = get_work_pool(work);</span><br><span class="line"><span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">raw_spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) {</span><br><span class="line">pwq = worker-&gt;current_pwq;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">raw_spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">raw_spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">raw_spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 如果 pool_workqueue 实例的未处理工作数量小于限制，那么把工作添加到 pool_workqueue 实例</span></span><br><span class="line"><span class="comment">     *    对应的工人池的链表 worklist 中；如果 pool_workqueue 实例的未处理工作数量达到限制，那么给</span></span><br><span class="line"><span class="comment">     *    工作设置标志位 WORK_STRUCT_DELAYED，并把工作添加到 pool_workqueue 实例的链表 delayed_works 中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) {</span><br><span class="line"><span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) {</span><br><span class="line">raw_spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">cpu_relax();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* oops */</span></span><br><span class="line">WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">  wq-&gt;name, cpu);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pwq determined, queue */</span></span><br><span class="line">trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) {</span><br><span class="line">trace_workqueue_activate_work(work);</span><br><span class="line">pwq-&gt;nr_active++;</span><br><span class="line">worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line"><span class="keyword">if</span> (list_empty(worklist))</span><br><span class="line">pwq-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">debug_work_activate(work);</span><br><span class="line">    <span class="comment">/* 4. 把工作添加到注释 3 中描述的链表中 */</span></span><br><span class="line">insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="工人处理工作">工人处理工作</h2><p>每个工人对应一个内核线程，一个工人池对应一个或多个工人。多个工人从工人池的未处理工作链表（worker_pool.worklist）中取工作并处理。工人线程的处理函数是 worker_thread()，调用函数 process_one_work() 处理一个工作项。函数 worker_thread() 的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up:</span><br><span class="line">raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 如果工人太多，想要减少工人的数量，那么当前工人线程退出 */</span></span><br><span class="line"><span class="comment">/* am I supposed to die? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) {</span><br><span class="line">raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">set_pf_worker(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">worker_detach_from_pool(worker);</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 工人退出空闲状态 */</span></span><br><span class="line">worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">    <span class="comment">/* 3. 如果不需要本工人执行工作，那么本工人进入空闲状态 */</span></span><br><span class="line"><span class="comment">/* no more worker necessary? */</span></span><br><span class="line"><span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line"><span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 如果工人池中没有空闲的工人，那么创建一些工人使用*/</span></span><br><span class="line"><span class="comment">/* do we need to manage? */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line"><span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment"> * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment"> * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 5. 完成准备阶段。 我们保证至少有一名闲置工人或其他人已经担任管理角色。</span></span><br><span class="line"><span class="comment">     *    这是@worker 开始参与并发管理（如果适用）并在反弹后恢复并发管理的地方。</span></span><br><span class="line"><span class="comment">     *    有关详细信息，请参阅 rebind_workers()。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 6. 从工人池的链表 worklist 中取一个工作 */</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line"> <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 7. 如果是正常工作，那么调用函数 process_one_work() 执行正常工作，</span></span><br><span class="line"><span class="comment">         *    然后执行工人的链表 scheduled 中的特殊工作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) {</span><br><span class="line"><span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">process_one_work(worker, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/* 8. 如果是特殊工作，那么首先把工作添加到工人的链表 scheduled 的尾部，</span></span><br><span class="line"><span class="comment">             *    然后执行工人的链表 scheduled 中的特殊工作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">process_scheduled_works(worker);</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (keep_working(pool)); <span class="comment">//如果有工作需要处理，并且处于运行状态的工人数量不超过 1，那么本工人继续执行工作</span></span><br><span class="line"></span><br><span class="line">worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep: <span class="comment">//工人进入空闲状态，睡眠</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment"> * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment"> * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment"> * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment"> * event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">worker_enter_idle(worker);</span><br><span class="line">__set_current_state(TASK_IDLE);</span><br><span class="line">raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">goto</span> woke_up;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面解释一下正常工作和特殊工作。 向工作队列中添加正常工作，是直接添加到工人池的链表 worklist 中。 调用函数 flush_work(t) 等待工作 t 执行完，实现方法是添加一个特殊工作：屏障工作，执行这个屏障工作的时候就可以确定工作 t 执行完。如果工作 t 正在被工人 p 执行，那么把屏障工作直接添加到工人 p 的链表 scheduled 中；如果工作 t 没有执行，那么把屏障工作添加到工人池的链表 worklist 中，并且给屏障工作设置标志位 WORK_STRUCT_LINKED。函数 process_one_work() 负责处理一个工作，其代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/workqueue.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_one_work</span><span class="params">(<span class="keyword">struct</span> worker *worker, <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span> get_work_pwq(work);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"><span class="type">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line"><span class="type">int</span> work_color;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 1. 一个工作不应该被多个工人并发执行。如果一个工作正在被工人的其他工人执行，</span></span><br><span class="line"><span class="comment">      *    那么把这个工作添加到这个工人的链表 scheduled 中延后执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment"> * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment"> * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment"> * currently executing one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">collision = find_worker_executing_work(pool, work);</span><br><span class="line"><span class="keyword">if</span> (unlikely(collision)) {</span><br><span class="line">move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 把工人添加到工人池的散列表 busy_hash 中。工人的成员 current_work 指向当前工作，</span></span><br><span class="line"><span class="comment">     *    成员 current_func 指向当前工作的处理函数，成员 current_pwq 指向当前 pool_workqueue 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">debug_work_deactivate(work);</span><br><span class="line">hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="type">unsigned</span> <span class="type">long</span>)work);</span><br><span class="line">worker-&gt;current_work = work;</span><br><span class="line">worker-&gt;current_func = work-&gt;func;</span><br><span class="line">worker-&gt;current_pwq = pwq;</span><br><span class="line">work_color = get_work_color(work);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record wq name for cmdline and debug reporting, may get</span></span><br><span class="line"><span class="comment"> * overridden through set_worker_desc().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">strscpy(worker-&gt;desc, pwq-&gt;wq-&gt;name, WORKER_DESC_LEN);</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 如果工作队列是处理器密集型的，那么给工人设置标志位 WORKER_CPU_INTENSIVE，</span></span><br><span class="line"><span class="comment">     *    工人不再被工人池动态调度。这使@worker 脱离了并发管理，下一个代码块将链接</span></span><br><span class="line"><span class="comment">     *    执行待处理的工作项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment"> * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment"> * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment"> * execution of the pending work items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 对于不绑定处理器或处理器密集型的工作队列，唤醒更多空闲的工人处理工作 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment"> * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment"> * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment"> * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment"> * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. 记录最后一个池并清除 PENDING，这应该是对@work 的最后一次更新。 此外，</span></span><br><span class="line"><span class="comment">     *    在@pool-&gt;lock 中执行此操作，以便在禁用 IRQ 时同时发生 PENDING 和排队状态更改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment"> * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment"> * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment"> * disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">lock_map_acquire(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">lock_map_acquire(&amp;lockdep_map);</span><br><span class="line"></span><br><span class="line">lockdep_invariant_state(<span class="literal">true</span>);</span><br><span class="line">trace_workqueue_execute_start(work);</span><br><span class="line">    <span class="comment">/* 6. 执行工作的处理函数 */</span></span><br><span class="line">worker-&gt;current_func(work);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment"> * point will only record its address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_workqueue_execute_end(work, worker-&gt;current_func);</span><br><span class="line">lock_map_release(&amp;lockdep_map);</span><br><span class="line">lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) {</span><br><span class="line">pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">       <span class="string">"     last function: %ps\n"</span>,</span><br><span class="line">       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">       worker-&gt;current_func);</span><br><span class="line">debug_show_held_locks(current);</span><br><span class="line">dump_stack();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following prevents a kworker from hogging CPU on !PREEMPTION</span></span><br><span class="line"><span class="comment"> * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment"> * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment"> * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment"> * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment"> * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cond_resched();</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear cpu intensive status */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tag the worker for identification in schedule() */</span></span><br><span class="line">worker-&gt;last_func = worker-&gt;current_func;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we're done with it, release */</span></span><br><span class="line">hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="工人池动态管理工人">工人池动态管理工人</h2><p>工人池可以动态增加和删除工人，算法如下：</p><ul><li>工人有 3 种状态：空闲（idle）、运行（running）和挂起（suspend）。空闲是指没有执行工作，运行是指正在执行工作，挂起是指在执行工作的过程中睡眠。</li><li>如果工人池中有工作需要处理，至少保持一个处在运行状态的工人来处理。</li><li>如果处在运行状态的工人在执行工作的过程中进入挂起状态，为了保证其他工作的执行，需要唤醒空闲的工人处理工作。</li><li>如果有工作需要执行，并且处在运行状态的工人数量大于 1，会让多余的工人进入空闲状态。</li><li>如果没有工作需要执行，会让所有工人进入空闲状态。</li><li>如果创建的工人过多，工人池把空闲时间超过 300 秒（IDLE_WORKER_TIMEOUT）的工人删除。</li></ul><p>工人池的调度思想是如果有工作需要处理，保持一个处在运行状态的工人来处理，不多也不少。 这种做法有个问题：如果工作是处理器密集型的，虽然工人没有进入挂起状态，但是会长时间占用处理器，让后续的工作阻塞太长时间。 为了解决这个问题，可以在创建工作队列的时候设置标志位 WQ_CPUINTENSIVE，声明工作队列是处理器密集的。当一个工人执行工作的时候，让这个工人不受工人池动态调度，像是进入了挂起状态，工人池创建新的工人来执行后续的工作。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MTEwNjg0NA==">https://zhuanlan.zhihu.com/p/91106844<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NDU2MTYzMQ==">https://zhuanlan.zhihu.com/p/94561631<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYXJub2xkbHUvcC84NjU5OTg4Lmh0bWw=">https://www.cnblogs.com/arnoldlu/p/8659988.html<i class="fa fa-external-link-alt"></i></span></p><p>《Linux 内核深度解析》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（六）Tasklet</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptTasklet/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptTasklet/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQTasklet.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1OGVlMzA3OTEyOTA2ZjUwODA4YWM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="为什么有-tasklet">为什么有 tasklet</h1><p>linux kernel 已经把中断处理分成了 top half 和 bottom half，看起来已经不错了，那为何还要提供 softirq、tasklet 和 workqueue 这些 bottom half 机制。</p><p>workqueue 和 softirq、tasklet 有本质的区别：</p><ul><li>workqueue 运行在 process context，而 softirq 和 tasklet 运行在 interrupt context。因此，出现 workqueue 是不奇怪的，在有 sleep 需求的场景中需要。</li><li>softirq 更倾向于性能。软中断的种类是编译时静态定义的，在运行时不能添加或删除，同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区。</li><li>tasklet 更倾向于易用性。Tasklet 可以在运行时添加或删除，一个 Tasklet 同一时刻只能在一个处理器上执行，不要求处理函数是可以重入的。</li></ul><h1 id="数据结构">数据结构</h1><p>Tasklet 的数据结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line"><span class="type">atomic_t</span> count;</span><br><span class="line"><span class="type">bool</span> use_callback;</span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line"><span class="type">void</span> (*callback)(<span class="keyword">struct</span> tasklet_struct *t);</span><br><span class="line">};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>成员 next 用来把 Tasklet 添加到单向链表中。 成员 state 是 Tasklet 的状态，取值如下：</p><ul><li>0： Tasklet 没有被调度</li><li>(1 &lt;&lt; TASKLET_STATE_SCHED)： Tasklet 被调度，即将被执行</li><li>(1&lt;&lt; TASKLET_STATE_RUN)：只在多处理器系统中使用，表示 Tasklet 正在执行</li></ul><p>成员 count 是计数，0 表示允许 Tasklet 被执行，非零值表示禁止 Tasklet 被执行成员 func 是处理函数，成员 data 是传给处理函数的参数。 每个处理器有两条单向链表：低优先级 Tasklet 链表和高优先级 Tasklet 链表。</p><h2 id="section"><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br></pre></td></tr></tbody></table></figure></h2><h1 id="实现扩展">实现（扩展🙈）</h1><p>Tasklet 是基于软中断实现的，根据优先级分为两种，低优先级 Tasklet 和高优先级 Tasklet。软中断 HI_SOFTIRO 执行高优先级 Tasklet，软中断 TASKLET_SOFTIRQ 执行低优先级 Tasklet。</p><h2 id="调度-tasklet">调度 Tasklet</h2><p>函数 tasklet_schedule() 用来调度低优先级 Tasklet，函数 tasklet_hi_schedule() 用来调度高优先级 Tasklet。以函数 tasklet_schedule() 为例说明，其代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h、kernel/softirq.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">__tasklet_schedule(t);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">{</span><br><span class="line">__tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">  TASKLET_SOFTIRQ);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __tasklet_schedule_common(<span class="keyword">struct</span> tasklet_struct *t,</span><br><span class="line">      <span class="keyword">struct</span> tasklet_head __percpu *headp,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">head = this_cpu_ptr(headp);</span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*head-&gt;tail = t;</span><br><span class="line">head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">raise_softirq_irqoff(softirq_nr);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 Tasklet 没有被调度过，那么首先设置调度标志位，然后把 Tasklet 添加到当前处理器的低优先级 Tasklet 链表的尾部，最后触发软中断 TASKLET_SOFTIRQ。</p><h2 id="执行-tasklet">执行 Tasklet</h2><p>初始化的时候，把软中断 TASKLET_SOFTIRQ 的处理函数注册为函数 tasklet_action，把软中断 HI_SOFTIRQ 的处理函数注册为函数 tasklet_hi_action()。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) {</span><br><span class="line">per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以函数 tasklet_action() 为例说明，其代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">static</span> __latent_entropy <span class="type">void</span> <span class="title function_">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">{</span><br><span class="line">tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_vec), TASKLET_SOFTIRQ);</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_action_common</span><span class="params">(<span class="keyword">struct</span> softirq_action *a,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> tasklet_head *tl_head,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="built_in">list</span> = tl_head-&gt;head;</span><br><span class="line">tl_head-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 把当前处理器的低优先级 Tasklet 链表中的所有 Tasklet 移到临时链表 list 中 */</span></span><br><span class="line">tl_head-&gt;tail = &amp;tl_head-&gt;head;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 遍历临时链表 list，依次处理每个 Tasklet */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. ，尝试锁住 Tasklet，确保一个 Tasklet 同一时刻只在一个处理器上执行 */</span></span><br><span class="line"><span class="keyword">if</span> (tasklet_trylock(t)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 4. 如果 Tasklet 的计数为 0，表示允许 Tasklet 被执行 */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 5. 清除 Tasklet 的调度标志位，其他处理器可以调度这个 Tasklet，但是不能执行这个 Tasklet */</span></span><br><span class="line"><span class="keyword">if</span> (tasklet_clear_sched(t)) {</span><br><span class="line"><span class="keyword">if</span> (t-&gt;use_callback)</span><br><span class="line">                        <span class="comment">/* 6. 执行 Tasklet 的处理函数 */</span></span><br><span class="line">t-&gt;callback(t);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">                        <span class="comment">/* 6. 执行 Tasklet 的处理函数 */</span></span><br><span class="line">t-&gt;func(t-&gt;data);</span><br><span class="line">}</span><br><span class="line">tasklet_unlock(t);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 7. 释放 Tasklet 的锁，其他处理器就可以执行这个 Tasklet 了 */</span></span><br><span class="line">tasklet_unlock(t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8. 如果尝试锁住 Tasklet 失败（表示 Tasklet 正在其他处理器上执行），或者禁止 Tasklet 被执行，那么把 Tasklet 重新添加到当前处理器的低优先级 Tasklet 链表的尾部，然后触发软中断 TASKLET_SOFTIRQ */</span></span><br><span class="line">local_irq_disable();</span><br><span class="line">t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">*tl_head-&gt;tail = t;</span><br><span class="line">tl_head-&gt;tail = &amp;t-&gt;next;</span><br><span class="line">__raise_softirq_irqoff(softirq_nr);</span><br><span class="line">local_irq_enable();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的注释 4 如果 Tasklet 的计数为 0，表示允许 Tasklet 被执行 ，tasklet 就是通过这个来保证只在一个 cpu 上执行。如果该 tasklet 已经在别的 cpu 上执行了，那么我们将其挂入该 cpu 的 tasklet 链表的尾部，这样，在下一个 tasklet 执行时机到来的时候，kernel 会再次尝试执行该 tasklet，在这个时间点，也许其他 cpu 上的该 tasklet 已经执行完毕了。通过这样代码逻辑，保证了特定的 tasklet 只会在一个 cpu 上执行，不会在多个 cpu 上并发。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvaXJxX3N1YnN5c3RlbS9zb2Z0LWlycS5odG1s">http://www.wowotech.net/irq_subsystem/soft-irq.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvaXJxX3N1YnN5c3RlbS90YXNrbGV0Lmh0bWw=">http://www.wowotech.net/irq_subsystem/tasklet.html<i class="fa fa-external-link-alt"></i></span></p><p>《Linux 内核深度解析》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（五）SoftIRQ</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptSoftIRQ/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptSoftIRQ/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQSoftIRQ.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1OGNkN2U0MDFmZDA3MGJiMGNkYmI=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="软中断的定义">软中断的定义</h1><p>软中断（softirq）是中断处理程序在开启中断的情况下执行的部分，可以被硬中断抢占内核定义了一张软中断向量表，每种软中断有一个唯一的编号，对应一个 softirq_actior 实例，softirq_action 实例的成员 action 是处理函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">TIMER_SOFTIRQ,</span><br><span class="line">NET_TX_SOFTIRQ,</span><br><span class="line">NET_RX_SOFTIRQ,</span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">IRQ_POLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ,</span><br><span class="line">SCHED_SOFTIRQ,</span><br><span class="line">HRTIMER_SOFTIRQ,</span><br><span class="line">RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">void</span>(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>softirq_action 该结构体非常简单就是一个函数指针，用于指向具体定义的函数。</p><p>中断的来源很多，所以 softirq 的种类也不少。内核的限制是不能超过 32 个， 目前内核定义了 10 种软中断，各种软中断的编号如下：</p><ul><li>HI_SOFTIRQ：高优先级的小任务</li><li>TIMER_SOFTIRQ：定时器软中断</li><li>NET_TX_SOFTIRQ：网络栈发送报文的软中断</li><li>NET_RX_SOFTIRQ：网络栈接收报文的软中断</li><li>BLOCK_SOFTIRO：块设备软中断</li><li>IRQ_POLL_SOFTIRQ：支持 I/O 轮询的块设备软中断</li><li>TASKLET SOFTIRQ：低优先级的小任务</li><li>SCHED_SOFTIRQ：调度软中断，用于在处理器之间负载均衡</li><li>HRTIMER SOFTIRQ：高精度定时器，这种软中断已经被废弃，目前在中断处理程序的上半部处理高精度定时器</li><li>RCU_SOFTIRO：RCU 软中断</li></ul><p>软中断的编号形成了优先级顺序，编号小的软中断优先级高。</p><h1 id="软中断的实现">软中断的实现</h1><h2 id="注册软中断的处理函数">注册软中断的处理函数</h2><p>函数 open_softirq() 用来注册软中断的处理函数，在软中断向量表中为指定的软中断编号设置处理函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tips 同一种软中断的处理函数可以在多个处理器上同时执行，处理函数必须是可以重入的，需要使用锁保护临界区。</p></blockquote><h2 id="触发软中断">触发软中断</h2><p>在中断的 top half 处理完后，就会通过 raise_softirq() 设置 softirq 的 pending 位图，这个 pending 位图由一个名为"__softirq_pending"的 per-CPU 形式的变量表示。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span> <span class="comment">//nr 参数是软中断编号</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">raise_softirq_irqoff(nr);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该函数调用 raise_softirq_irqoff(),raise_softirq_irqoff() 是在已经禁止中断的情况下调用函数来触发软中断。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">{</span><br><span class="line">__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we're in an interrupt or softirq, we're done</span></span><br><span class="line"><span class="comment"> * (this also catches softirq-disabled code). We will</span></span><br><span class="line"><span class="comment"> * actually run the softirq once we return from</span></span><br><span class="line"><span class="comment"> * the irq or softirq.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise we wake up ksoftirqd to make sure we</span></span><br><span class="line"><span class="comment"> * schedule the softirq soon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!in_interrupt() &amp;&amp; should_wake_ksoftirqd())</span><br><span class="line">wakeup_softirqd();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用__raise_softirq_irqoff 函数，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __raise_softirq_irqoff(<span class="type">unsigned</span> <span class="type">int</span> nr)</span><br><span class="line">{</span><br><span class="line">lockdep_assert_irqs_disabled();</span><br><span class="line">trace_softirq_raise(nr);</span><br><span class="line">or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把宏 or_softirq_pending 展开以后是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irq_stat[smp <span class="title function_">processor_id</span><span class="params">()</span>].softirq_pending |= (<span class="number">1UL</span> &lt;&lt; nr);</span><br></pre></td></tr></tbody></table></figure><ul><li>__raise_softirq_irqoff 函数设定本 CPU 上的__softirq_pending 的某个 bit 等于 1，具体的 bit 是由 soft irq number（nr 参数）指定的。</li><li>如果在中断上下文，我们只要 set __softirq_pending 的某个 bit 就 OK 了，在中断返回的时候自然会进行软中断的处理。但是，如果在 context 上下文调用这个函数的时候，我们必须要调用 wakeup_softirqd 函数用来唤醒本 CPU 上的 softirqd 这个内核线程。</li></ul><p>这样 softirq 就相当于准备好了，在合适的时机将会调用 softirq 的处理函数。</p><h2 id="执行软中断">执行软中断</h2><p>内核执行软中断的地方如下。</p><ul><li>在中断处理程序的后半部分执行软中断，对执行时间有限制：不能超过 2 毫秒，并且最多执行 10 次。</li><li>每个处理器有一个软中断线程，调度策略是 SCHED_NORMAL，优先级是 120。</li><li>开启软中断的函数 local_bh_enable()。</li></ul><p>如果开启了强制中断线程化的配置宏 CONFIG_IRO_FORCED_THREADING，并且在引导内核的时候指定内核参数“threadirqs”，那么所有软中断由软中断线程执行</p><h3 id="中断处理程序执行软中断">中断处理程序执行软中断</h3><p>在中断处理程序的后半部分，调用函数 irq_exit() 以退出中断上下文，处理软中断，其代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">__irq_exit_rcu();</span><br><span class="line">rcu_irq_exit();</span><br><span class="line"> <span class="comment">/* must be last! */</span></span><br><span class="line">lockdep_hardirq_exit();</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __irq_exit_rcu(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARCH_IRQ_EXIT_IRQS_DISABLED</span></span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">lockdep_assert_irqs_disabled();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">account_hardirq_exit(current);</span><br><span class="line">preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line"><span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">invoke_softirq();</span><br><span class="line"></span><br><span class="line">tick_irq_exit();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 in_interrupt() 为真，表示在不可屏蔽中断、硬中断或软中断上下文，或者禁止软中断。如果正在处理的硬中断没有抢占正在执行的软中断，没有禁止软中断，并且当前处理器的待处理软中断位图不是空的，那么调用函数 invoke_softirq() 来处理软中断。</p><p>函数 invoke_softirq 的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">invoke_softirq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 1. 如果软中断线程处于就绪状态或运行状态，那么让软中断线程执行软中断 */</span></span><br><span class="line"><span class="keyword">if</span> (ksoftirqd_running(local_softirq_pending()))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 如果没有强制中断线程化，那么调用函数_do_softirq() 执行软中断 */</span></span><br><span class="line"><span class="keyword">if</span> (!force_irqthreads || !__this_cpu_read(ksoftirqd)) {</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can safely execute softirq on the current stack if</span></span><br><span class="line"><span class="comment"> * it is the irq stack, because it should be near empty</span></span><br><span class="line"><span class="comment"> * at this stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__do_softirq();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Otherwise, irq_exit() is called on the task stack that can</span></span><br><span class="line"><span class="comment"> * be potentially deep already. So call softirq in its own stack</span></span><br><span class="line"><span class="comment"> * to prevent from any overrun.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_softirq_own_stack();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* 3. 如果强制中断线程化，那么唤醒软中断线程执行软中断*/</span></span><br><span class="line">wakeup_softirqd();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数_do_softirq 是执行软中断的核心函数，其主要代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line">asmlinkage __visible <span class="type">void</span> __softirq_entry __do_softirq(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> end = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> old_flags = current-&gt;flags;</span><br><span class="line"><span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line"><span class="type">bool</span> in_hardirq;</span><br><span class="line">__u32 pending;</span><br><span class="line"><span class="type">int</span> softirq_bit;</span><br><span class="line"></span><br><span class="line">current-&gt;flags &amp;= ~PF_MEMALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 把局部变量 pending 设置为当前处理器的待处理软中断位图 */</span></span><br><span class="line">pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. softirq_handle_begin 调用__local_bh_disable_ip 把抢占计数器的软中断计数加 1 */</span></span><br><span class="line">softirq_handle_begin();</span><br><span class="line">in_hardirq = lockdep_softirq_start();</span><br><span class="line">account_softirq_enter(current);</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line"><span class="comment">/* 3. 把当前处理器的待处理软中断位图重新设置为 0 */</span></span><br><span class="line">set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 开启硬中断 */</span></span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">h = softirq_vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. 从低位向高位扫描待处理软中断位图，针对每个设置了对应位的转中断编号，执行软中断的处理函数*/</span></span><br><span class="line"><span class="keyword">while</span> ((softirq_bit = ffs(pending))) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vec_nr;</span><br><span class="line"><span class="type">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">vec_nr = h - softirq_vec;</span><br><span class="line">prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">trace_softirq_entry(vec_nr);</span><br><span class="line">        <span class="comment">/* 调用 action */</span></span><br><span class="line">h-&gt;action(h);</span><br><span class="line">trace_softirq_exit(vec_nr);</span><br><span class="line"><span class="keyword">if</span> (unlikely(prev_count != preempt_count())) {</span><br><span class="line">pr_err(<span class="string">"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n"</span>,</span><br><span class="line">       vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">       prev_count, preempt_count());</span><br><span class="line">preempt_count_set(prev_count);</span><br><span class="line">}</span><br><span class="line">h++;</span><br><span class="line">pending &gt;&gt;= softirq_bit;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_RT) &amp;&amp;</span><br><span class="line">    __this_cpu_read(ksoftirqd) == current)</span><br><span class="line">rcu_softirq_qs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 6. 禁止硬中断 */</span></span><br><span class="line">local_irq_disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 7. 如果软中断的处理函数又触发软中断，处理如下 */</span></span><br><span class="line">pending = local_softirq_pending();</span><br><span class="line"><span class="keyword">if</span> (pending) {</span><br><span class="line">        <span class="comment">/* 8. 如果软中断的执行时间小于 2 毫秒，不需要重新调度进程，并口且软中断的执行次数没超过 10，那么跳转到 restart 继续执行软中断 */</span></span><br><span class="line"><span class="keyword">if</span> (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">    --max_restart)</span><br><span class="line"><span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 9. 唤醒软中断线程执行软中断 */</span></span><br><span class="line">wakeup_softirqd();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">account_softirq_exit(current);</span><br><span class="line">lockdep_softirq_end(in_hardirq);</span><br><span class="line">    <span class="comment">/* 10. 把抢占计数器的软中断计数减 1 */</span></span><br><span class="line">softirq_handle_end();</span><br><span class="line">current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面就是软中断的调用流程。__do_softirq() 是紧接着"hardirq"执行的，它也是运行在中断上下文，如果非要和“hardirq 上下文”有所区分的话，可以认为这是“softirq 上下文”，在 softirq 上下文中，也是不能睡眠的。</p><h3 id="软中断线程">软中断线程</h3><p>每个处理器有一个软中断线程，名称是“ksofirqd/”后面跟着处理器编号，调度策略 SCHED_NORMAL，优先级是 120。软中断线程的核心函数是 run_ksoftirqd()，其代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_ksoftirqd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">{</span><br><span class="line">ksoftirqd_run_begin();</span><br><span class="line"><span class="keyword">if</span> (local_softirq_pending()) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment"> * in the task stack here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__do_softirq();</span><br><span class="line">ksoftirqd_run_end();</span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">ksoftirqd_run_end();</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> =</span> {</span><br><span class="line">.store= &amp;ksoftirqd,</span><br><span class="line">.thread_should_run= ksoftirqd_should_run,</span><br><span class="line">.thread_fn= run_ksoftirqd,</span><br><span class="line">.thread_comm= <span class="string">"ksoftirqd/%u"</span>,</span><br><span class="line">};</span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">spawn_ksoftirqd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">cpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, <span class="string">"softirq:dead"</span>, <span class="literal">NULL</span>,</span><br><span class="line">  takeover_tasklets);</span><br><span class="line">BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __smpboot_create_thread(<span class="keyword">struct</span> smp_hotplug_thread *ht, <span class="type">unsigned</span> <span class="type">int</span> cpu)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> *per_cpu_ptr(ht-&gt;store, cpu);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">smpboot_thread_data</span> *<span class="title">td</span>;</span></span><br><span class="line">    ...</span><br><span class="line">tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu,</span><br><span class="line">    ht-&gt;thread_comm);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tsk)) {</span><br><span class="line">kfree(td);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tsk);</span><br><span class="line">}</span><br><span class="line">kthread_set_per_cpu(tsk, cpu);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里创建一个线程，然后线程中执行 run_ksoftirqd 函数，run_ksoftirqd 函数里执行__do_softirq() 函数。</p><h1 id="抢占计数器">抢占计数器</h1><p>每个进程的 thread_info 结构体有一个抢占计数器：int preempt_count，它用来表示当前进程能不能被抢占。</p><p>抢占是指当进程在内核模式下运行的时候可以被其他进程抢占，如果优先级更高的进程处于就绪状态，强行剥夺当前进程的处理器使用权。</p><p>但是有时候进程可能在执行一些关键操作，不能被抢占，所以内核设计了抢占计数器。如果抢占计数器为 0，表示可以被抢占；如果抢占计数器不为 0，表示不能被抢占。</p><p>当中断处理程序返回的时候，如果进程在被打断的时候正在内核模式下执行，就会检查抢占计数器是否为 0。如果抢占计数器是 0，可以让优先级更高的进程抢占当前进程虽然抢占计数器不为 0 意味着禁止抢占，但是内核进一步按照各种场景对抢占计数器的位进行了划分， <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/preempt_count.png"></p><p>其中第 0 ~ 7 位是抢占计数，第 8 ~ 15 位是软中断计数，第 16 ~ 19 位是硬中断计数第 20 位是不可屏蔽中断（Non Maskable Interrupt，NMI）计数。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PREEMPT_MASK(__IRQ_MASK(PREEMPT_BITS) &lt;&lt; PREEMPT_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTIRQ_MASK(__IRQ_MASK(SOFTIRQ_BITS) &lt;&lt; SOFTIRQ_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDIRQ_MASK(__IRQ_MASK(HARDIRQ_BITS) &lt;&lt; HARDIRQ_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NMI_MASK(__IRQ_MASK(NMI_BITS)     &lt;&lt; NMI_SHIFT)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREEMPT_BITS8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTIRQ_BITS8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDIRQ_BITS4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NMI_BITS    4</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>各种场景分别利用各自的位禁止或开启抢占。</p><ul><li>普通场景（PREEMPT_MASK）：对应函数 preempt_disable() 和 preempt_enable()</li><li>软中断场景（SOFTIRO_MASK）：对应函数 local_bh_disable() 和 local_bh_enabe()</li><li>硬中断场景（HARDIRQ_MASK）：对应函数 _irq_enter() 和_irq_exit()</li><li>不可屏蔽中断场景（NMI MASK）：对应函数 nmi_enter() 和 nmi_exit()</li></ul><p>反过来，我们可以通过抢占计数器的值判断当前处在什么场景：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/preempt.h&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macros to retrieve the current execution context:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * in_nmi()- We're in NMI context</span></span><br><span class="line"><span class="comment"> * in_hardirq()- We're in hard IRQ context</span></span><br><span class="line"><span class="comment"> * in_serving_softirq()- We're in softirq context</span></span><br><span class="line"><span class="comment"> * in_task()- We're in task context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_nmi()(nmi_count())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_hardirq()(hardirq_count())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_serving_softirq()(softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_task()(!(in_nmi() | in_hardirq() | in_serving_softirq()))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following macros are deprecated and should not be used in new code:</span></span><br><span class="line"><span class="comment"> * in_irq()       - Obsolete version of in_hardirq()</span></span><br><span class="line"><span class="comment"> * in_softirq()   - We have BH disabled, or are processing softirqs</span></span><br><span class="line"><span class="comment"> * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_irq()(hardirq_count())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_softirq()(softirq_count())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_interrupt()(irq_count())</span></span><br></pre></td></tr></tbody></table></figure><ul><li>in_irq() 表示硬中断场景，也就是正在执行硬中断</li><li>in_softirq() 表示软中断场景，包括禁止软中断和正在执行软中断</li><li>in_interrupt() 表示正在执行不可屏蔽中断、硬中断或软中断，或者禁止软中断</li><li>in_serving_softirq() 表示正在执行软中断</li><li>in_nmi() 表示不可屏蔽中断场景</li><li>in_task() 表示普通场景，也就是进程上下文</li></ul><h1 id="禁止开启软中断">禁止/开启软中断</h1><p>如果进程和软中断可能访问同一个对象，那么进程和软中断需要互斥，进程需要禁止软中断。禁止软中断的函数是 local_bh_disable()，注意：这个函数只能禁止本处理器的软中断，不能禁止其他处理器的软中断。该函数把抢占计数器的软中断计数加 2，其代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">local_bh_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">__local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTIRQ_DISABLE_OFFSET(2 * SOFTIRQ_OFFSET)</span></span><br></pre></td></tr></tbody></table></figure><p>调用__local_bh_disable_ip 函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __local_bh_disable_ip(<span class="type">unsigned</span> <span class="type">long</span> ip, <span class="type">unsigned</span> <span class="type">int</span> cnt)</span><br><span class="line">{</span><br><span class="line">preempt_count_add(cnt);</span><br><span class="line">barrier();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>开启软中断的函数是 local_bh_enable()，该函数把抢占计数器的软中断计数减 2。为什么禁止软中断的函数 local_bh_disable() 把抢占计数器的软中断计数加 2，而不是加 1 呢？目的是区分禁止软中断和正在执行软中断这两种情况。执行软中断的函数__do_sofir() 把抢占计数器的软中断计数加 1。如果软中断计数是奇数，可以确定正在执行软中断。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvaXJxX3N1YnN5c3RlbS9zb2Z0LWlycS5odG1s">http://www.wowotech.net/irq_subsystem/soft-irq.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDM3MTc0NQ==">https://zhuanlan.zhihu.com/p/80371745<i class="fa fa-external-link-alt"></i></span></p><p>《Linux 内核深度解析》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（四）中断驱动实现</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptFramework/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptFramework/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQLinuxImpl.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1ODljMjYzNzY4OTA3MTA1ODk3YjM=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="数据结构">数据结构</h1><p>理解一个软件架构最重要的是要理清楚里面的数据结构的内容以及数据结构之间的关系，在本文中列出数据结构之前先来说明几个问题。首先是中断控制器 irq controller 这个在 arm 上一般是 gic，有可能会出现 irq controller 集联的情况，但是一般情况下是一个 controller，一个 controller 上有很多中断线，irq line 一般就是连接到 gpio 控制器上的，在一个中断线上可能有多个设备（共享中断）action，那么就涉及到这几种数据结构，描述中断控制器的数据结构可以组成链表，描述中断线 irq line 的数据结构可以组成链表，挂在中断线上的中断设备可以组成链表关系。&nbsp;除此之外硬件中断号于 linux 中断号之间有一个映射关系，也需要抽象出数据结构来描述。下面看下 linux 内核下对中断的抽象出的数据结构，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQ_Struct.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9kaWFncmFtaW5nLzYxNDg3ODJiMDc5MTI5NDNjMDVhYzg4MA==">原图<i class="fa fa-external-link-alt"></i></span></p><ul><li><p>irq_desc（描述中断线连接中断设备和中断控制器）<br>irq_desc 是中断描述符也就是用于描述硬件中断线的数据结构。他一方面通过 irq_data 连接中断控制器，一边连接中断设备，中断设备的操作需要通过该结构体找到 irq_data，进而找到中断控制器，毕竟中断使能等操作都是中断控制器提供的接口。该结构体功能包括该硬件 irq line 中断触发时，执行的对应操作，以及使用该 irq 的外设注册的操作接口（当一个硬件 irq line 是共享中断时，可注册多个操作接口）等信息</p></li><li><p>irq_domain（描述中断域）<br>用于描述 irq 域，该数据结构主要用于存储硬件 irq line 与 linux 中断号的映射关系，并提供 irq_domain_ops，实现该 irq 域下硬件 irq line 的 top handler 的设置等操作</p></li><li><p>irq_chip（描述中断控制器）<br>irq_chip 结构体是用于描述 irq controller 的，主要就是提供具体的中断控制器操作接口，中断控制器内部主要分为两部分，一个是分发器，一个是 cpu 接口，而这两部分是完成对中断的控制的，包括中断优先级设置，屏蔽和使能等操作，以及中断与 cpu 之间的绑定等操作</p></li><li><p>irqaction（描述中断处理方法）<br>irqaction 主要就是描述中断线上的设备以及处理方法了，提供了中断上下文处理 handle 以及线程化处理的 handle</p></li><li><p>irq_data<br>这个数据结构是一个桥梁用于连接 irq_desc 和 irq_chip 以及 irq_domain。</p></li></ul><p>下面以 irq_desc 通过数组的方式组织为例，列出上述数据结构之间的组织关系： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQ_List.png"> <span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzYxNDhhYzU4MWUwODUzMTVkYzRkY2JlZC5wbmc=">原图<i class="fa fa-external-link-alt"></i></span></p><p>通过上图我们可以了解到的是，内核驱动中关于中断相关数据结构的组织方式，也就清楚了内核中关于中断的驱动框架了。</p><hr><h1 id="实现扩展">实现（扩展🙈）</h1><p>设备驱动开发人员常用的接口是 request_irq()/request_threaded_irq，其定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">}</span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">     <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以看到 request_irq 其实就是调用 request_threaded_irq 实现的，只是没有提供 thread_fn 成员，也就是没有提供中断下半部的实现函数。</p><p>这里第一个参数是 irq 也就是 linux 中断号，这个中断号驱动开发人员该如何获得呢，其实就是在设备树里指定的，其中 device 结构体里有 device_node 结构体里就有设备树相关信息，可以通过函数 platform_get_irq 获得中断号。有了这些信息接下来就是注册一个中断了，下面将会详细分析一下 request_threaded_irq 函数的实现方式。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"> <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line"><span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 检查 irqflags，如果是 IRQF_SHARED 则必须提供 dev_id */</span></span><br><span class="line"><span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">    ((irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_NO_AUTOEN)) ||</span><br><span class="line">    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 通过中断号获得 irq_desc 结构体 */</span></span><br><span class="line">desc = irq_to_desc(irq);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handler) {</span><br><span class="line"><span class="keyword">if</span> (!thread_fn)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handler = irq_default_primary_handler;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 分配并设置 irqaction 结构体 */</span></span><br><span class="line">action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!action)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">action-&gt;handler = handler;</span><br><span class="line">action-&gt;thread_fn = thread_fn;</span><br><span class="line">action-&gt;flags = irqflags;</span><br><span class="line">action-&gt;name = devname;</span><br><span class="line">action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) {</span><br><span class="line">kfree(action);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 于完成中断的相关设置，包括中断线程化的处理*/</span></span><br><span class="line">retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval) {</span><br><span class="line">irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">kfree(action-&gt;secondary);</span><br><span class="line">kfree(action);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(request_threaded_irq);</span><br></pre></td></tr></tbody></table></figure><p>此调用分配中断资源并启用中断线和 IRQ 处理。如果你想为你的设备设置一个线程中断处理程序，那么你需要提供@handler 和@thread_fn。 <span class="citation" data-cites="handler">@handler</span> 仍然在硬中断上下文中被调用，并且必须检查中断是否来自设备，如果是，则需要禁用设备上的中断并返回 IRQ_WAKE_THREAD，这将唤醒处理程序线程并运行 <span class="citation" data-cites="thread_fn">@thread_fn</span>。 这种拆分处理程序设计对于支持共享中断是必要的。</p><p>dev_id 必须是全局唯一的。 通常设备数据结构的地址用作 cookie。如果中断是共享的，则必须传递一个非空的 dev_id，因为这是释放中断时所必需的字段。</p><p>该函数会调用__setup_irq 函数，内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__setup_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *new)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">old</span>, **<span class="title">old_ptr</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags, thread_mask = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret, nested, shared = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip == &amp;no_irq_chip)</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(desc-&gt;owner))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">new-&gt;irq = irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 如果没有提供 flags，则使用默认 flags */</span></span><br><span class="line"><span class="keyword">if</span> (!(new-&gt;flags &amp; IRQF_TRIGGER_MASK))</span><br><span class="line">new-&gt;flags |= irqd_get_trigger_type(&amp;desc-&gt;irq_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 检查中断是否嵌套到另一个中断线程中 */</span></span><br><span class="line">nested = irq_settings_is_nested_thread(desc);</span><br><span class="line"><span class="keyword">if</span> (nested) {</span><br><span class="line"><span class="keyword">if</span> (!new-&gt;thread_fn) {</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">}</span><br><span class="line">        <span class="comment">/* 3. 将驱动程序为非嵌套中断处理提供的主处理程序替换为在调用时发出警告的虚拟函数。*/</span></span><br><span class="line">new-&gt;handler = irq_nested_primary_handler;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">if</span> (irq_settings_can_thread(desc)) {</span><br><span class="line">            <span class="comment">/* 4. 强制线程化 */</span></span><br><span class="line">ret = irq_setup_forced_threading(new);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. 当提供了线程函数并且中断没有嵌套到另一个中断线程中时，创建一个处理程序线程。*/</span></span><br><span class="line"><span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) {</span><br><span class="line">ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_mput;</span><br><span class="line"><span class="keyword">if</span> (new-&gt;secondary) {</span><br><span class="line">ret = setup_irq_thread(new-&gt;secondary, irq, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_thread;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)</span><br><span class="line">new-&gt;flags &amp;= ~IRQF_ONESHOT;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;desc-&gt;request_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 6. 获取总线锁，因为下面的 irq_request_resources() 回调可能依赖于序列化*/</span></span><br><span class="line">chip_bus_lock(desc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 第一个安装的动作请求资源 */</span></span><br><span class="line"><span class="keyword">if</span> (!desc-&gt;action) {</span><br><span class="line">ret = irq_request_resources(desc);</span><br><span class="line"><span class="keyword">if</span> (ret) {</span><br><span class="line">pr_err(<span class="string">"Failed to request resources for %s (irq %d) on irqchip %s\n"</span>,</span><br><span class="line">       new-&gt;name, irq, desc-&gt;irq_data.chip-&gt;name);</span><br><span class="line"><span class="keyword">goto</span> out_bus_unlock;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8. 下代码块必须以原子方式执行，以防止并发中断和任何其他未通过 desc-&gt;request_mutex 或可选总线锁序列化的管理调用。*/</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</span><br><span class="line">old_ptr = &amp;desc-&gt;action;</span><br><span class="line">old = *old_ptr;</span><br><span class="line"><span class="keyword">if</span> (old) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> oldtype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_NMI) {</span><br><span class="line">pr_err(<span class="string">"Invalid attempt to share NMI for %s (irq %d) on irqchip %s.\n"</span>,</span><br><span class="line">new-&gt;name, irq, desc-&gt;irq_data.chip-&gt;name);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 9. 如果之前没有人设置过，则继承请求者提供的配置*/</span></span><br><span class="line"><span class="keyword">if</span> (irqd_trigger_type_was_set(&amp;desc-&gt;irq_data)) {</span><br><span class="line">oldtype = irqd_get_trigger_type(&amp;desc-&gt;irq_data);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">oldtype = new-&gt;flags &amp; IRQF_TRIGGER_MASK;</span><br><span class="line">irqd_set_trigger_type(&amp;desc-&gt;irq_data, oldtype);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!((old-&gt;flags &amp; new-&gt;flags) &amp; IRQF_SHARED) ||</span><br><span class="line">    (oldtype != (new-&gt;flags &amp; IRQF_TRIGGER_MASK)) ||</span><br><span class="line">    ((old-&gt;flags ^ new-&gt;flags) &amp; IRQF_ONESHOT))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All handlers must agree on per-cpuness */</span></span><br><span class="line"><span class="keyword">if</span> ((old-&gt;flags &amp; IRQF_PERCPU) !=</span><br><span class="line">    (new-&gt;flags &amp; IRQF_PERCPU))</span><br><span class="line"><span class="keyword">goto</span> mismatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* add new interrupt at end of irq queue */</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">/* 10. 所有现有的 action-&gt;thread_mask 位，这样我们就可以找到这个新动作的下一个空位*/</span></span><br><span class="line">thread_mask |= old-&gt;thread_mask;</span><br><span class="line">old_ptr = &amp;old-&gt;next;</span><br><span class="line">old = *old_ptr;</span><br><span class="line">} <span class="keyword">while</span> (old);</span><br><span class="line">shared = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 11. 为 ONESHOT 设置此 irqaction 的线程掩码*/</span></span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_ONESHOT) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unlikely to have 32 resp 64 irqs sharing one line,</span></span><br><span class="line"><span class="comment"> * but who knows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (thread_mask == ~<span class="number">0UL</span>) {</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line">new-&gt;thread_mask = <span class="number">1UL</span> &lt;&lt; ffz(thread_mask);</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (new-&gt;handler == irq_default_primary_handler &amp;&amp;</span><br><span class="line">   !(desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)) {</span><br><span class="line">pr_err(<span class="string">"Threaded irq requested with handler=NULL and !ONESHOT for %s (irq %d)\n"</span>,</span><br><span class="line">       new-&gt;name, irq);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shared) {</span><br><span class="line">init_waitqueue_head(&amp;desc-&gt;wait_for_threads);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup the type (level, edge polarity) if configured: */</span></span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_TRIGGER_MASK) {</span><br><span class="line">ret = __irq_set_trigger(desc,</span><br><span class="line">new-&gt;flags &amp; IRQF_TRIGGER_MASK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 12. 激活中断，该激活必须独立于 IRQ_NOAUTOEN 发生*/</span></span><br><span class="line">ret = irq_activate(desc);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \</span><br><span class="line">  IRQS_ONESHOT | IRQS_WAITING);</span><br><span class="line">irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_PERCPU) {</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_PER_CPU);</span><br><span class="line">irq_settings_set_per_cpu(desc);</span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_NO_DEBUG)</span><br><span class="line">irq_settings_set_no_debug(desc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (noirqdebug)</span><br><span class="line">irq_settings_set_no_debug(desc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_ONESHOT)</span><br><span class="line">desc-&gt;istate |= IRQS_ONESHOT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exclude IRQ from balancing if requested */</span></span><br><span class="line"><span class="keyword">if</span> (new-&gt;flags &amp; IRQF_NOBALANCING) {</span><br><span class="line">irq_settings_set_no_balancing(desc);</span><br><span class="line">irqd_set(&amp;desc-&gt;irq_data, IRQD_NO_BALANCING);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(new-&gt;flags &amp; IRQF_NO_AUTOEN) &amp;&amp;</span><br><span class="line">    irq_settings_can_autoenable(desc)) {</span><br><span class="line">irq_startup(desc, IRQ_RESEND, IRQ_START_COND);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">WARN_ON_ONCE(new-&gt;flags &amp; IRQF_SHARED);</span><br><span class="line"><span class="comment">/* Undo nested disables: */</span></span><br><span class="line">desc-&gt;depth = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (new-&gt;flags &amp; IRQF_TRIGGER_MASK) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nmsk = new-&gt;flags &amp; IRQF_TRIGGER_MASK;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> omsk = irqd_get_trigger_type(&amp;desc-&gt;irq_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nmsk != omsk)</span><br><span class="line"><span class="comment">/* hope the handler works with current  trigger mode */</span></span><br><span class="line">pr_warn(<span class="string">"irq %d uses trigger mode %u; requested %u\n"</span>,</span><br><span class="line">irq, omsk, nmsk);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">*old_ptr = new;</span><br><span class="line"></span><br><span class="line">irq_pm_install_action(desc, new);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset broken irq detection when installing new handler */</span></span><br><span class="line">desc-&gt;irq_count = <span class="number">0</span>;</span><br><span class="line">desc-&gt;irqs_unhandled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 13. 检查我们之前是否禁用了 irq，重新启用它*/</span></span><br><span class="line"><span class="keyword">if</span> (shared &amp;&amp; (desc-&gt;istate &amp; IRQS_SPURIOUS_DISABLED)) {</span><br><span class="line">desc-&gt;istate &amp;= ~IRQS_SPURIOUS_DISABLED;</span><br><span class="line">__enable_irq(desc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</span><br><span class="line">chip_bus_sync_unlock(desc);</span><br><span class="line">mutex_unlock(&amp;desc-&gt;request_mutex);</span><br><span class="line"></span><br><span class="line">irq_setup_timings(desc, new);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new-&gt;thread)</span><br><span class="line">wake_up_process(new-&gt;thread);</span><br><span class="line"><span class="keyword">if</span> (new-&gt;secondary)</span><br><span class="line">wake_up_process(new-&gt;secondary-&gt;thread);</span><br><span class="line"></span><br><span class="line">register_irq_proc(irq, desc);</span><br><span class="line">new-&gt;dir = <span class="literal">NULL</span>;</span><br><span class="line">register_handler_proc(irq, new);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里中断注册就完成了，下面以一张图来梳理函数调用关系，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Request_IRQ.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9kaWFncmFtaW5nLzYxNDk0NWM2NTY1M2JiMzUyNTMwOTg1Nw==">原图<i class="fa fa-external-link-alt"></i></span></p><h1 id="总结">总结</h1><p>在上面的介绍中我们可以得到以下结论，中断注册就是构建上面的数据结构，将新的中断挂在相应的数据结构上，当中断发生时会通过前面介绍的中断向量表开始执行相应的函数，获得中断号，根据中断号找到 irq_desc 然后调用 irqaction 上的函数。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTI5OTY4MTIuaHRtbA==">https://www.cnblogs.com/LoyenWang/p/12996812.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTMwNTI2NzcuaHRtbA==">https://www.cnblogs.com/LoyenWang/p/13052677.html<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》<br>《Linux 内核深度解析》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（三）Linux 中断处理过程</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptLinuxDealWith/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptLinuxDealWith/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQLinuxDealWith.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1ODFjZDU2NTNiYjA3MWU2ZTZkYmU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="中断控制器">中断控制器</h1><p>ARM 公司提供了一种标准的中断控制器，称为通用中断控制器（Generic IntermurController，GIC）。目前 GIC 架构规范有 4 个版本：v1~v4。GICv2 最多支持 8 个处理器。GIC v3 最多支持 128 个处理器，GICv3 和 GICv4 只支持 ARM64 处理器。</p><h2 id="gicv2-控制器的两个主要功能">GICv2 控制器的两个主要功能</h2><ul><li>分发器（Distributor）：系统中所有的中断源连接到分发器，分发器的寄存器用来控制单个中断的属性：优先级、状态、安全、转发信息（可以被发送到哪些处理器）和使能状态。分发器决定哪个中断应该通过处理器接口转发到哪个处理器</li><li>处理器接口（CPU Interface）：处理器通过处理器接口接收中断。处理器接口提供的寄存器用来屏蔽和识别中断，控制中断的状态。每个处理器有一个单独的处理器接口。软件通过中断号识别中断，每个中断号唯一对应一个中断源</li></ul><h2 id="中断有以下-4-种类型">中断有以下 4 种类型</h2><ul><li>软件生成的中断（Software Generated Interrupt，SGI）：中断号 0~15，通常用来实现处理器间中断（Inter-Processor Iterrupt，IPI）。这种中断是由软件写分发器的软件生成中断寄存器（GICD_SGIR）生成的</li><li>私有外设中断（Private Peripheral Iterrupt，PPI）：中断号 16~31。处理器私有的中断源，不同处理器的相同中断源没有关系，比如每个处理器的定时器</li><li>共享外设中断（Shared Peripheral Iterrupt，SPI）：中断号 32~1020。这种中断可以被中断控制器转发到多个处理器</li><li>局部特定外设中断（Locality-specific Peripheral Interrunt，LPI），基于消息的中断 GIC， v1 和 GIC v2 不支持 LPI</li></ul><h2 id="中断有以下-4-种状态">中断有以下 4 种状态</h2><ul><li>Inactive：中断源没有发送中断</li><li>Pending：中断源已经发送中断，等待处理器外理</li><li>Active：处理器已经确认中断，正在处理</li><li>Active and pending：处理器正在处理中断，相同的中断源又发送了一个中断</li></ul><h1 id="中断域">中断域</h1><p>一个大型系统可能有多个中断控制器，这些中断控制器可以级联，一个中断控制器作为中断源连接到另一个中断控制器，但只有一个中断控制器作为根控制器直接连接到处理器。如下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/HW_IRQ.png"></p><p>为了把每个中断控制器本地的硬件中断号映射到全局唯一的 Linux 中断号（虚拟中断号），内核定义了中断域 irq_domain，每个中断控制器有自己的中断域。</p><h2 id="创建中断域">创建中断域</h2><p>中断控制器的驱动程序使用分配函数 irq_domain_add_*() 创建和注册中断域。每种映射方法提供不同的分配函数，调用者必须给分配函数提供 irq_domain_ops 结构体，分配函在执行成功的时候返回 irq_domain 的指针。</p><h4 id="中断域支持以下映射方法">中断域支持以下映射方法</h4><ul><li>线性映射（linear map）</li></ul><p>线性映射维护一个固定大小的表，索引是硬件中断号。如果硬件中断号的最大数量固定的，并且比较小（小于 256），那么线性映射是好的选择。对于线性映射，分配中断的函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">irq_domain_add_linear</span><span class="params">(<span class="keyword">struct</span> device_node *of_node,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> irq_domain_ops *ops,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *host_data)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>树映射（tree map）</li></ul><p>树映射使用基数树（radix tree）保存硬件中断号到 Linux 中断号的映射。如果硬件中断号可能非常大，那么树映射是好的选择，因为不需要根据最大硬件中断号分配一个很大的表。对于树映射，分配中断域的函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">irq_domain_add_tree</span><span class="params">(<span class="keyword">struct</span> device_node *of_node,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> irq_domain_ops *ops,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *host_data)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>不映射（no map）</li></ul><p>有些中断控制器很强，硬件中断号是可以配置的，例如 PowerPC 架构使用的 MPIC（Muti-PossorIterrupt Controller）。我们直接把 Linux 中断号写到硬件，硬件中断号就是 Linux 中断号，不需要映射。对于不映射，分配中断域的函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> irq_domain *<span class="title function_">irq_domain_add_nomap</span><span class="params">(<span class="keyword">struct</span> device_node *of_node,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> max_irq,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> irq_domain_ops *ops,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *host_data)</span></span><br></pre></td></tr></tbody></table></figure><p>分配函数把主要工作委托给函数__irq_domain_add()。函数__irq_domain_add() 的执行过是、分配一个 irq_domain 结构体，初始化成员，然后把中断域添加到全局链表 irq_domain_list 中。</p><h2 id="创建映射">创建映射</h2><p>创建中断域以后，需要向中断域添加硬件中断号到 Linux 中断号的映射，内核提供了函数 irq_create_mapping：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_create_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *host,</span></span><br><span class="line"><span class="params">      <span class="type">irq_hw_number_t</span> hwirq)</span></span><br></pre></td></tr></tbody></table></figure><p>输入参数是中断域和硬件中断号，返回 Linux 中断号，该函数首先分配 Linux 中断号然后把硬件中断号到 Linux 中断号的映射添加到中断域。</p><h2 id="查找映射">查找映射</h2><p>中断处理程序需要根据硬件中断号查找 Linux 中断号，内核提供了函数 irq_find_mapping 函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * irq_find_mapping() - Find a linux irq from a hw irq number.</span></span><br><span class="line"><span class="comment"> * @domain: domain owning this hardware interrupt</span></span><br><span class="line"><span class="comment"> * @hwirq: hardware irq number in that domain space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_find_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">    <span class="type">irq_hw_number_t</span> hwirq)</span></span><br></pre></td></tr></tbody></table></figure><p>输入参数是中断域和硬件中断号，返回 Linux 中断号。</p><h1 id="linux-中断处理">Linux 中断处理</h1><p>对于中断控制器的每个中断源，向中断域添加硬件中断号到 Linux 中断号的映射时内核分配一个 Linux 中断号和一个中断描述符 irq_desc，中断描述符有两个层次的中断处理函数。</p><ul><li>第一层处理函数是中断描述符的成员 handle_irq()。</li><li>第二层处理函数是设备驱动程序注册的处理函数。中断描述符有一个中断处理链表（irq_desc.action），每个中断处理描述符（irq_action）保存设备驱动程序注册的处理函数。因为多个设备可以共享同一个硬件中断号，所以中断处理链表可能挂载多个中断处理描述符。</li></ul><p>怎么存储 Linux 中断号到中断描述符的映射关系？有两种实现方式。</p><ul><li>如果中断编号是稀疏的（即不连续），那么使用基数树（radix tree）存储。需要开启配置宏 CONFIG_SPARSE_IRQ。</li><li>如果中断编号是连续的，那么使用数组存储。</li></ul><p>设备驱动程序可以使用函数 request_irq() 注册中断处理函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request_irq - Add a handler for an interrupt line</span></span><br><span class="line"><span class="comment"> * @irq:The interrupt line to allocate</span></span><br><span class="line"><span class="comment"> * @handler:Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment"> *Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment"> *If NULL, the default primary handler is installed</span></span><br><span class="line"><span class="comment"> * @flags:Handling flags</span></span><br><span class="line"><span class="comment"> * @name:Name of the device generating this interrupt</span></span><br><span class="line"><span class="comment"> * @dev:A cookie passed to the handler function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call allocates an interrupt and establishes a handler; see</span></span><br><span class="line"><span class="comment"> * the documentation for request_threaded_irq() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>参数 irq 是 Linux 中断号。</li><li>参数 handler 是处理函数。</li><li><p>参数 flags 是标志位，可以是 0 或者以下标志位的组合。</p><p>IRQF_SHARED：允许多个设备共享同一个中断号 IRQF_TIMER：定时器中断 IRQF_PERCPU：中断是每个处理器私有的 IRQF_NOBALANCING：不允许该中断在处理器之间负载均衡。 IRQF_NO_THREAD：中断不能线程化</p></li><li>参数 name 是设备名称。</li><li><p>参数 dev 是传给处理函数（由参数 handler 指定）的参数。</p></li></ul><p>在上一节我们分析了 ARM64 架构下的异常处理流程，当异常发生时会跳转到异常向量表中执行异常处理函数，中断是异常的一种，因此当中断发生时也会跳转到异常向量表中执行中断处理函数，ARM64 对应有不同的异常级别，其中内核运行在 EL1 级别，对于这种情况，根据我们上一节的分析中断会跳转到 el1h_64_irq 标号处运行程序，该标号处的处理在不同的异常下都是类似的，不同的是跳转的处理函数不同，对于 el1h_64_irq 标号会跳转到 el1h_64_irq_handle 函数处处理，下面我们详细看下该函数的具体处理工作是怎样的吧：</p><p>同样由于函数调用层次较多，这里采用流程图的方式展现，当然这必然会忽略掉很多细节，详细的读者可以自己追踪源码查看。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQ_RUN.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9kaWFncmFtaW5nLzYxNDc1NjExZTQwMWZkNzg2MWE3MWFkYw==">原图<i class="fa fa-external-link-alt"></i></span></p><p>通过上图我们大概就了解了中断处理的整体流程。当中断发生时跳转到异常向量表，然后跳转到对应的标号处执行，然后执行中断控制器的处理函数，再调用外部中断注册的中断处理函数。</p><h1 id="中断控制器驱动初始化">中断控制器驱动初始化</h1><p>以一张图来整理这些函数之间的调用关系，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/irq_init1.png"> <span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzYxNDkzNzU0MWUwODUzMTVkYzRkZTZjOC5wbmc=">原图<i class="fa fa-external-link-alt"></i></span></p><h1 id="参考文献">参考文献</h1><p>《Linux 内核深度解析》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress搭建博客</title>
      <link href="/next/2021/Tools/WordpressUsage/"/>
      <url>/next/2021/Tools/WordpressUsage/</url>
      
        <content type="html"><![CDATA[<h1 id="准备-lamp-环境">准备 LAMP 环境</h1><h2 id="安装wordpress">安装wordpress</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://cn.wordpress.org/latest-zh_CN.zip</span><br><span class="line">unzip latest-zh_CN.zip</span><br></pre></td></tr></tbody></table></figure><h2 id="安装mysql">安装Mysql</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server -y</span><br><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="修改密码权限">修改密码权限</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/mysql/debian.cnf</span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = ROmgNW5hP8tsSwrB</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = ROmgNW5hP8tsSwrB</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">mysql -udebian-sys-maint -p</span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'xxxx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为wordpress创建数据库</span></span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> user,host from user;</span><br><span class="line">CREATE DATABASE wordpress;</span><br><span class="line">CREATE USER wordpressuser;</span><br><span class="line">SET PASSWORD FOR wordpressuser=PASSWORD(<span class="string">"password123"</span>);</span><br><span class="line">ALTER USER <span class="string">'wordpressuser'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'136140@Techliu'</span>;</span><br><span class="line"></span><br><span class="line">grant all on wordpress.* to <span class="string">'wordpressuser'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="安装apache2">安装apache2</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2</span><br><span class="line">sudo systemctl status apache2</span><br><span class="line">sudo ufw allow <span class="string">'Apache Full'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="安装php">安装php</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php -y</span><br><span class="line">sudo apt install libapache2-mod-php -y</span><br><span class="line">sudo apt install php-mysql -y</span><br><span class="line">sudo apt install php-curl -y</span><br><span class="line">sudo apt install php-gd -y</span><br><span class="line">sudo apt install php-xml -y</span><br><span class="line">sudo apt install php-mbstring -y</span><br><span class="line">sudo apt install php-xmlrpc -y</span><br><span class="line">sudo apt install php-zip -y</span><br><span class="line">sudo apt install php-soap -y</span><br><span class="line">sudo apt install php-intl -y</span><br></pre></td></tr></tbody></table></figure><h1 id="配置wordpress">配置wordpress</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /var/www/html</span><br><span class="line">sudo <span class="built_in">mv</span> wordpress/* /var/www/html/</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var/www/html/</span><br><span class="line"></span><br><span class="line">sudo mysql_secure_installation</span><br><span class="line">sudo apt-get install phpmyadmin -y</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/phpmyadmin /var/www/html/phpmyadmin</span><br><span class="line">sudo service mysql restart</span><br><span class="line">sudo systemctl restart apache2.service</span><br></pre></td></tr></tbody></table></figure><h1 id="解决安装插件需要ftp问题">解决安装插件需要FTP问题</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /var/www/html/wp-config.php</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line"></span><br><span class="line">define(<span class="string">"FS_METHOD"</span>, <span class="string">"direct"</span>);  </span><br><span class="line">define(<span class="string">"FS_CHMOD_DIR"</span>, 0777);  </span><br><span class="line">define(<span class="string">"FS_CHMOD_FILE"</span>, 0777); </span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 -R /var/www/html/wp-content/</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（二）ARM64 的异常处理过程</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptARMExcept/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptARMExcept/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/IRQExceptProcess.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1Nzk2NjA3OTEyOTA2ZjUwN2QxMDg=">原图<i class="fa fa-external-link-alt"></i></span></p><h1 id="异常级别">异常级别</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/ARM64_ELEVEL.png"></p><p>通常 ARM64 的进程执行在 EL0 级别，内核执行在 EL1 级别。</p><p>虚拟机是现在流行的虚拟化技术，在计算机上创建一个虚拟机，虚拟机里可以运行一个操作系统。常用的开源虚拟机管理软件是 QEMU，QEMU 支持基于内核的虚拟机 KVM，KVM 的特点是直接在处理器上执行客户机的操作系统，所以虚拟机的执行速度很快。</p><p>ARM64 架构的安全扩展定义了两种安全状态，正常世界和安全世界，两个世界只能通过异常级别 3 的安全监视器切换。</p><span id="more"></span><h1 id="异常类型">异常类型</h1><h2 id="中断">中断</h2><p>在 ARM 处理器中，FIQ（Fast Interruptre Quest）的优先级要高于 IRQ（Interrupt ReQuest）。在芯片内部，分别由 IRQ 和 FIQ 两根中断线连接到中断控制器再连接到处理器内部，发送中断信号给处理器。</p><h3 id="中止">中止</h3><p>中止（abort）主要有指令中止（instruction abort）和数据中止（data abort）两种，通常是因为访问外部存储单元时发生了错误，处理器内部的 MMU（Memory Management Unit）能捕获这些错误并且报告给处理器。指令中止是指当处理器尝试执行某条指令时发生了错误，而数据中止是指使用加载或存储指令读写外部存储单元时发生了错误。</p><h2 id="复位">复位</h2><p>复位（reset）操作是优先级最高的一种异常处理，复位操作包括上电复位和手动复位两种。</p><h2 id="软件产生的异常">软件产生的异常</h2><p>ARMv8 加构提供了 3 种软件产生的异常。发生这些异常通常是因为软件想尝试进入高的异常等级。</p><ul><li>SVC 指令：允许用户模式下的程序请求操作系统服务</li><li>HVC 指令：允许客户机（guestOS）请求主机服务</li><li>SMC 指令：允许普通世界（normal world）中的程序请求安全监控服务</li></ul><h1 id="同步异常和异步异常">同步异常和异步异常</h1><p>ARMv8 架构把异常分成同步异常和异步异常两种。同步异常是指处理器需要等待异常处理的结果，然后再继续执行后面的指令，比如数据中止发生时我们知道发生数据异常的地址，因而可以在异常处理函数中修复这个地址。常见的同步异常如下。</p><ul><li>尝试访问异常等级不恰当的寄存器</li><li>尝试执行没有定义（UNDEFINED）的指令</li><li>使用没有对齐的 SP 或执行没有对齐的 PC 指令</li><li>软件产生的异常，比如执行系统调用（SVC）、HVC 或 SMC 指令</li><li>因地址翻译或权限等导致的数据异常或指令异常</li><li>调试导致的异常，比如断点异常、观察点异常、软件单步异常等</li></ul><p>中断发生时，处理器正在处理的指令和中断是完全没有关系的，它们之间没有依赖关系因此，指令异常和数据异常称为同步异常，而中断称为异步异常。常见的异步异常包括物理中断和虚拟中断。</p><ul><li>物理中断分为系统错误、IRQ、FIQ。</li><li>虚拟中断分为 vSError、 vIRQ、vFIQ。</li></ul><h1 id="异常的发生和退出">异常的发生和退出</h1><p>当异常发生时，CPU 会自动做如下一些事情。</p><ul><li>将处理器状态寄存器 PSTATE 保存到对应目标异常等级的 SPSR_ELx 中</li><li>将返回地址保存在对应目标异常等级的 ELRELx 中</li><li>把 PSTATE 寄存器里的 DAIF 域都设置为 1，这相当于把调试异常、系统错误 （SError）、IRQ 以及 FIQ 都关闭了。具体异常原因需要查看 ESR_ELx</li><li>设置栈指针，指向对应目标异常等级下的栈，自动切换 SP 到 SP_ELx</li><li>CPU 处理器会从异常发生现场的异常等级切换到对应目标异常等级，然后跳转到异常向量表并执行</li></ul><p>上述是 ARMv8 处理器检测到异常发生后自动做的事情。操作系统需要做的事情是从中断向量表开始，根据异常发生的类型，跳转到合适的异常向量表。异常向量表中的每项会保存一个异常处理的跳转函数，然后跳转到恰当的异常处理函数并处理异常。</p><p>当操作系统的异常处理完成后，执行一条 eret 指令即可从异常返回。这条指令会自动完成如下工作</p><ul><li>从 ELR_ELx 中恢复 PC 指针</li><li>从 SPSR_ELx 恢复处理器的状态</li></ul><h1 id="异常向量表">异常向量表</h1><p>ARMv7 架构的异常向量表比较简单，每个表项占用 4 字节，并且每个表项里存放了一条跳转指令。但是 ARMv8 架构的异常向量表发生了变化。每一个表项需要 128 字节，这样可以存放 32 条指令。注意，ARMv8 指令集支持 64 位指令集，但是每一条指令的位宽是 32 位宽而不是 64 位宽。</p><p>在下表中，异常向量表存放的基地址可以通过 VBAR （Vector Base Address Register）来设置。VBAR 是异常向量表的基地址寄存器。见《ARM Architecture Reference Manual，ARMv8，for ARMv8-A architecture profile v8.4》的 D.1.10 节。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/armv8_vector.png"></p><hr><h1 id="异常向量表在-linux-中的实现扩展">异常向量表在 Linux 中的实现（扩展）</h1><h2 id="汇编宏定义">汇编宏定义</h2><p>要理解下面这段代码需要先简单了解一下一些汇编语法，下面做简单介绍： 首先是。macro 命令 .macro 和 .endm 之间允许您定义生成汇编输出的宏。例如，如下这段宏定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.macro  sum from=0, to=5</span><br><span class="line">.long   \from</span><br><span class="line">.if     \to-\from</span><br><span class="line">sum     "(\from+1)",\to</span><br><span class="line">.endif</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><p>根据该定义，“SUM 0,5”等效于以下程序集输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.long   0</span><br><span class="line">.long   1</span><br><span class="line">.long   2</span><br><span class="line">.long   3</span><br><span class="line">.long   4</span><br><span class="line">.long   5</span><br></pre></td></tr></tbody></table></figure><p>.macro comm 开始定义一个名为 comm 的宏，它不带参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.macro plus1 p, p1</span><br><span class="line">.macro plus1 p p1</span><br></pre></td></tr></tbody></table></figure><p>任一语句都开始定义一个名为 plus1 的宏，它带有两个参数；在宏定义中，写“”或“1”来计算参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro reserve_str p1=0 p2</span><br></pre></td></tr></tbody></table></figure><p>以两个参数开始一个名为 reserve_str 的宏的定义。 第一个参数有一个默认值，但第二个没有。 定义完成后，您可以将宏调用为 'reserve_str a,b'（'1' 计算为 a，'2' 计算为 b），或为 'reserve_str ,b'（使用 '1 ' 计算为默认值，在本例中为 '0'，'2' 计算为 b)。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro m p1:req, p2=0, p3:vararg</span><br></pre></td></tr></tbody></table></figure><p>以至少三个参数开始一个名为 m 的宏的定义。 第一个参数必须始终指定一个值，但第二个参数不是，而是具有默认值。 第三个形式将被分配在调用时指定的所有剩余参数。</p><p>调用宏时，可以按位置或关键字指定参数值。 例如，“sum 9,17”等价于“sum to=17, from=9”。</p><p>请注意，由于每个 macargs 都可以是与目标架构允许的任何其他标识符完全相同的标识符，因此如果目标在某些字符出现在特殊位置时对其制作了特殊含义，则可能会偶尔出现问题。 例如，如果冒号 (:) 通常被允许作为符号名称的一部分，但架构特定代码在作为符号的最后一个字符（以表示标签）出现时将其特殊化，则宏参数替换 代码将无法知道这一点并将整个构造（包括冒号）视为标识符，并仅检查此标识符是否受参数替换。 例如这个宏定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro label l</span><br><span class="line">\l:</span><br><span class="line">.endm</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可能无法按预期工作。 调用“label foo”可能不会创建一个名为“foo”的标签，而只是将文本“:”插入到汇编源代码中，可能会产生关于无法识别的标识符的错误。</p><p>类似的问题可能会出现在操作码名称（以及标识符名称）中通常允许使用的句点字符 (‘.’) 中。 因此，例如构造一个宏以根据基本名称和长度说明符构建操作码，如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro opcode base length</span><br><span class="line">       \base.\length</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><p>并将其作为“opcode store l”调用不会创建“store.l”指令，而是在汇编器尝试解释文本“.”时产生某种错误。 有几种可能的方法可以解决这个问题：</p><ul><li>Insert white space</li></ul><p>如果可以使用空格字符，那么这是最简单的解决方案。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro label l</span><br><span class="line">\l :</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><ul><li>Use ‘()’</li></ul><p>字符串“()”可用于将宏参数的结尾与以下文本分开。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.macro opcode base length</span><br><span class="line">        \base\().\length</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><ul><li>Use the alternate macro syntax mode</li></ul><p>在替代宏语法模式中，与号字符 (‘&amp;’) 可用作分隔符。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro label l</span><br><span class="line">l&amp;:</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><p>正确识别伪操作的字符串参数的这个问题也适用于 .irp 和 .irpc 中使用的标识符。</p><p>.endm 标记宏定义的结尾。</p><h2 id="源码">源码</h2><p>下面看下 Linux 中 arm64 的异常向量表，在 arch/arm64/kernel/entry.S 文件中有：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Exception vectors.</span><br><span class="line"> */</span><br><span class="line">.pushsection ".entry.text", "ax"</span><br><span class="line"></span><br><span class="line">.align11</span><br><span class="line">SYM_CODE_START(vectors)</span><br><span class="line">    # 使用 SP0 寄存器的当前的异常类型的异常向量表</span><br><span class="line">kernel_ventry1, t, 64, sync// Synchronous EL1t</span><br><span class="line">kernel_ventry1, t, 64, irq// IRQ EL1t</span><br><span class="line">kernel_ventry1, t, 64, fiq// FIQ EL1h</span><br><span class="line">kernel_ventry1, t, 64, error// Error EL1t</span><br><span class="line"></span><br><span class="line">    # 使用 SPx 寄存器的当前异常类型的异常向量表</span><br><span class="line">kernel_ventry1, h, 64, sync// Synchronous EL1h</span><br><span class="line">kernel_ventry1, h, 64, irq// IRQ EL1h</span><br><span class="line">kernel_ventry1, h, 64, fiq// FIQ EL1h</span><br><span class="line">kernel_ventry1, h, 64, error// Error EL1h</span><br><span class="line"></span><br><span class="line">    # AArch64 下低异常等级的异常向量表</span><br><span class="line">kernel_ventry0, t, 64, sync// Synchronous 64-bit EL0</span><br><span class="line">kernel_ventry0, t, 64, irq// IRQ 64-bit EL0</span><br><span class="line">kernel_ventry0, t, 64, fiq// FIQ 64-bit EL0</span><br><span class="line">kernel_ventry0, t, 64, error// Error 64-bit EL0</span><br><span class="line"></span><br><span class="line">    # AArch32 下低异常等级的异常向量表</span><br><span class="line">kernel_ventry0, t, 32, sync// Synchronous 32-bit EL0</span><br><span class="line">kernel_ventry0, t, 32, irq// IRQ 32-bit EL0</span><br><span class="line">kernel_ventry0, t, 32, fiq// FIQ 32-bit EL0</span><br><span class="line">kernel_ventry0, t, 32, error// Error 32-bit EL0</span><br><span class="line">SYM_CODE_END(vectors)</span><br></pre></td></tr></tbody></table></figure><p>上述异常向量表的定义和前面那张图是一致的，其中 kernel_ventry 是一个宏，他的实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.macro kernel_ventry, el:req, ht:req, regsize:req, label:req</span><br><span class="line">.align 7</span><br><span class="line">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span><br><span class="line">.if\el == 0</span><br><span class="line">alternative_if ARM64_UNMAP_KERNEL_AT_EL0</span><br><span class="line">.if\regsize == 64</span><br><span class="line">mrsx30, tpidrro_el0</span><br><span class="line">msrtpidrro_el0, xzr</span><br><span class="line">.else</span><br><span class="line">movx30, xzr</span><br><span class="line">.endif</span><br><span class="line">alternative_else_nop_endif</span><br><span class="line">.endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">subsp, sp, #PT_REGS_SIZE</span><br><span class="line">#ifdef CONFIG_VMAP_STACK</span><br><span class="line">/*</span><br><span class="line"> * Test whether the SP has overflowed, without corrupting a GPR.</span><br><span class="line"> * Task and IRQ stacks are aligned so that SP &amp; (1 &lt;&lt; THREAD_SHIFT)</span><br><span class="line"> * should always be zero.</span><br><span class="line"> */</span><br><span class="line">addsp, sp, x0// sp' = sp + x0</span><br><span class="line">subx0, sp, x0// x0' = sp' - x0 = (sp + x0) - x0 = sp</span><br><span class="line">tbnzx0, #THREAD_SHIFT, 0f</span><br><span class="line">subx0, sp, x0// x0'' = sp' - x0' = (sp + x0) - sp = x0</span><br><span class="line">subsp, sp, x0// sp'' = sp' - x0 = (sp + x0) - x0 = sp</span><br><span class="line">bel\el\ht\()_\regsize\()_\label</span><br><span class="line"></span><br><span class="line">0:</span><br><span class="line">/*</span><br><span class="line"> * Either we've just detected an overflow, or we've taken an exception</span><br><span class="line"> * while on the overflow stack. Either way, we won't return to</span><br><span class="line"> * userspace, and can clobber EL0 registers to free up GPRs.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* Stash the original SP (minus PT_REGS_SIZE) in tpidr_el0. */</span><br><span class="line">msrtpidr_el0, x0</span><br><span class="line"></span><br><span class="line">/* Recover the original x0 value and stash it in tpidrro_el0 */</span><br><span class="line">subx0, sp, x0</span><br><span class="line">msrtpidrro_el0, x0</span><br><span class="line"></span><br><span class="line">/* Switch to the overflow stack */</span><br><span class="line">adr_this_cpu sp, overflow_stack + OVERFLOW_STACK_SIZE, x0</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Check whether we were already on the overflow stack. This may happen</span><br><span class="line"> * after panic() re-enables interrupts.</span><br><span class="line"> */</span><br><span class="line">mrsx0, tpidr_el0// sp of interrupted context</span><br><span class="line">subx0, sp, x0// delta with top of overflow stack</span><br><span class="line">tstx0, #~(OVERFLOW_STACK_SIZE - 1)// within range?</span><br><span class="line">b.ne__bad_stack// no? -&gt; bad stack pointer</span><br><span class="line"></span><br><span class="line">/* We were already on the overflow stack. Restore sp/x0 and carry on. */</span><br><span class="line">subsp, sp, x0</span><br><span class="line">mrsx0, tpidrro_el0</span><br><span class="line">#endif</span><br><span class="line">bel\el\ht\()_\regsize\()_\label</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><p>.macro kernel_ventry, el:req, ht:req, regsize:req, label:req 定义 kernel_ventry 宏有 4 个参数，其中：req 代表这个参数必须提供。撇开各种宏定义我们看下里面其实主要就是如下三行代码，我们一一分析：</p><ul><li>.align 7</li></ul><p>表示把一条指令的地址对其到 2 的 7 次方，即 128 字节。</p><ul><li>sub sp, sp, #PT_REGS_SIZE</li></ul><p>sp 指针减去 PT_REGS_SIZE，PT_REGS_SIZE 的定义在 arch/arm64/kernel/asm_offset.c 文件中，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE(PT_REGS_SIZE,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs));</span><br></pre></td></tr></tbody></table></figure><p>pt_regs 定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_pt_regs</span> <span class="title">user_regs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">u64 regs[<span class="number">31</span>];</span><br><span class="line">u64 sp;</span><br><span class="line">u64 pc;</span><br><span class="line">u64 pstate;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line">u64 orig_x0;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AARCH64EB__</span></span><br><span class="line">u32 unused2;</span><br><span class="line">s32 syscallno;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">s32 syscallno;</span><br><span class="line">u32 unused2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">u64 sdei_ttbr1;</span><br><span class="line"><span class="comment">/* Only valid when ARM64_HAS_IRQ_PRIO_MASKING is enabled. */</span></span><br><span class="line">u64 pmr_save;</span><br><span class="line">u64 stackframe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only valid for some EL1 exceptions. */</span></span><br><span class="line">u64 lockdep_hardirqs;</span><br><span class="line">u64 exit_rcu;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>该结构定义了异常期间寄存器在堆栈上的存储方式。 请注意 sizeof(struct pt_regs) 必须是 16 的倍数（用于堆栈对齐）。</p><ul><li>b el()<em>()</em></li></ul><p>以 kernel_ventry 1, t, 64, sync 为例将宏展开得到：el1t_64_sync, 下面我们去看看该标号的实现，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.macro entry_handler el:req, ht:req, regsize:req, label:req</span><br><span class="line">SYM_CODE_START_LOCAL(el\el\ht\()_\regsize\()_\label)</span><br><span class="line">kernel_entry \el, \regsize</span><br><span class="line">movx0, sp</span><br><span class="line">blel\el\ht\()_\regsize\()_\label\()_handler</span><br><span class="line">.if \el == 0</span><br><span class="line">bret_to_user</span><br><span class="line">.else</span><br><span class="line">bret_to_kernel</span><br><span class="line">.endif</span><br><span class="line">SYM_CODE_END(el\el\ht\()_\regsize\()_\label)</span><br><span class="line">.endm</span><br><span class="line">/*</span><br><span class="line"> * Early exception handlers</span><br><span class="line"> */</span><br><span class="line">entry_handler1, t, 64, sync</span><br><span class="line">entry_handler1, t, 64, irq</span><br><span class="line">entry_handler1, t, 64, fiq</span><br><span class="line">entry_handler1, t, 64, error</span><br><span class="line"></span><br><span class="line">entry_handler1, h, 64, sync</span><br><span class="line">entry_handler1, h, 64, irq</span><br><span class="line">entry_handler1, h, 64, fiq</span><br><span class="line">entry_handler1, h, 64, error</span><br><span class="line"></span><br><span class="line">entry_handler0, t, 64, sync</span><br><span class="line">entry_handler0, t, 64, irq</span><br><span class="line">entry_handler0, t, 64, fiq</span><br><span class="line">entry_handler0, t, 64, error</span><br><span class="line"></span><br><span class="line">entry_handler0, t, 32, sync</span><br><span class="line">entry_handler0, t, 32, irq</span><br><span class="line">entry_handler0, t, 32, fiq</span><br><span class="line">entry_handler0, t, 32, error</span><br></pre></td></tr></tbody></table></figure><p>将 entry_handler 1, t, 64, sync 宏展开，得到如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el1t_64_sync:</span><br><span class="line">  kernel_entry \el, \regsize</span><br><span class="line">movx0, sp</span><br><span class="line">blel\el\ht\()_\regsize\()_\label\()_handler</span><br><span class="line">.if \el == 0</span><br><span class="line">bret_to_user</span><br><span class="line">.else</span><br><span class="line">bret_to_kernel</span><br><span class="line">.endif</span><br></pre></td></tr></tbody></table></figure><p>kernel_entry 宏定义如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">.macrokernel_entry, el, regsize = 64</span><br><span class="line">.if\regsize == 32</span><br><span class="line">movw0, w0// zero upper 32 bits of x0</span><br><span class="line">.endif</span><br><span class="line">stpx0, x1, [sp, #16 * 0]</span><br><span class="line">stpx2, x3, [sp, #16 * 1]</span><br><span class="line">stpx4, x5, [sp, #16 * 2]</span><br><span class="line">stpx6, x7, [sp, #16 * 3]</span><br><span class="line">stpx8, x9, [sp, #16 * 4]</span><br><span class="line">stpx10, x11, [sp, #16 * 5]</span><br><span class="line">stpx12, x13, [sp, #16 * 6]</span><br><span class="line">stpx14, x15, [sp, #16 * 7]</span><br><span class="line">stpx16, x17, [sp, #16 * 8]</span><br><span class="line">stpx18, x19, [sp, #16 * 9]</span><br><span class="line">stpx20, x21, [sp, #16 * 10]</span><br><span class="line">stpx22, x23, [sp, #16 * 11]</span><br><span class="line">stpx24, x25, [sp, #16 * 12]</span><br><span class="line">stpx26, x27, [sp, #16 * 13]</span><br><span class="line">stpx28, x29, [sp, #16 * 14]</span><br><span class="line"></span><br><span class="line">.if\el == 0</span><br><span class="line">clear_gp_regs</span><br><span class="line">mrsx21, sp_el0</span><br><span class="line">ldr_this_cputsk, __entry_task, x20</span><br><span class="line">msrsp_el0, tsk</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Ensure MDSCR_EL1.SS is clear, since we can unmask debug exceptions</span><br><span class="line"> * when scheduling.</span><br><span class="line"> */</span><br><span class="line">ldrx19, [tsk, #TSK_TI_FLAGS]</span><br><span class="line">disable_step_tsk x19, x20</span><br><span class="line"></span><br><span class="line">/* Check for asynchronous tag check faults in user space */</span><br><span class="line">check_mte_async_tcf x22, x23</span><br><span class="line">apply_ssbd 1, x22, x23</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_PTR_AUTH</span><br><span class="line">alternative_if ARM64_HAS_ADDRESS_AUTH</span><br><span class="line">/*</span><br><span class="line"> * Enable IA for in-kernel PAC if the task had it disabled. Although</span><br><span class="line"> * this could be implemented with an unconditional MRS which would avoid</span><br><span class="line"> * a load, this was measured to be slower on Cortex-A75 and Cortex-A76.</span><br><span class="line"> *</span><br><span class="line"> * Install the kernel IA key only if IA was enabled in the task. If IA</span><br><span class="line"> * was disabled on kernel exit then we would have left the kernel IA</span><br><span class="line"> * installed so there is no need to install it again.</span><br><span class="line"> */</span><br><span class="line">ldrx0, [tsk, THREAD_SCTLR_USER]</span><br><span class="line">tbzx0, SCTLR_ELx_ENIA_SHIFT, 1f</span><br><span class="line">__ptrauth_keys_install_kernel_nosync tsk, x20, x22, x23</span><br><span class="line">b2f</span><br><span class="line">1:</span><br><span class="line">mrsx0, sctlr_el1</span><br><span class="line">orrx0, x0, SCTLR_ELx_ENIA</span><br><span class="line">msrsctlr_el1, x0</span><br><span class="line">2:</span><br><span class="line">isb</span><br><span class="line">alternative_else_nop_endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">mte_set_kernel_gcr x22, x23</span><br><span class="line"></span><br><span class="line">scs_load tsk</span><br><span class="line">.else</span><br><span class="line">addx21, sp, #PT_REGS_SIZE</span><br><span class="line">get_current_task tsk</span><br><span class="line">.endif /* \el == 0 */</span><br><span class="line">mrsx22, elr_el1</span><br><span class="line">mrsx23, spsr_el1</span><br><span class="line">stplr, x21, [sp, #S_LR]</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * For exceptions from EL0, create a final frame record.</span><br><span class="line"> * For exceptions from EL1, create a synthetic frame record so the</span><br><span class="line"> * interrupted code shows up in the backtrace.</span><br><span class="line"> */</span><br><span class="line">.if \el == 0</span><br><span class="line">stpxzr, xzr, [sp, #S_STACKFRAME]</span><br><span class="line">.else</span><br><span class="line">stpx29, x22, [sp, #S_STACKFRAME]</span><br><span class="line">.endif</span><br><span class="line">addx29, sp, #S_STACKFRAME</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span><br><span class="line">alternative_if_not ARM64_HAS_PAN</span><br><span class="line">bl__swpan_entry_el\el</span><br><span class="line">alternative_else_nop_endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">stpx22, x23, [sp, #S_PC]</span><br><span class="line"></span><br><span class="line">/* Not in a syscall by default (el0_svc overwrites for real syscall) */</span><br><span class="line">.if\el == 0</span><br><span class="line">movw21, #NO_SYSCALL</span><br><span class="line">strw21, [sp, #S_SYSCALLNO]</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">/* Save pmr */</span><br><span class="line">alternative_if ARM64_HAS_IRQ_PRIO_MASKING</span><br><span class="line">mrs_sx20, SYS_ICC_PMR_EL1</span><br><span class="line">strx20, [sp, #S_PMR_SAVE]</span><br><span class="line">movx20, #GIC_PRIO_IRQON | GIC_PRIO_PSR_I_SET</span><br><span class="line">msr_sSYS_ICC_PMR_EL1, x20</span><br><span class="line">alternative_else_nop_endif</span><br><span class="line"></span><br><span class="line">/* Re-enable tag checking (TCO set on exception entry) */</span><br><span class="line">#ifdef CONFIG_ARM64_MTE</span><br><span class="line">alternative_if ARM64_MTE</span><br><span class="line">SET_PSTATE_TCO(0)</span><br><span class="line">alternative_else_nop_endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Registers that may be useful after this macro is invoked:</span><br><span class="line"> *</span><br><span class="line"> * x20 - ICC_PMR_EL1</span><br><span class="line"> * x21 - aborted SP</span><br><span class="line"> * x22 - aborted PC</span><br><span class="line"> * x23 - aborted PSTATE</span><br><span class="line">*/</span><br><span class="line">.endm</span><br></pre></td></tr></tbody></table></figure><p>这里不做详细分析了，除了对一些寄存器做基础处理，保存基本和特殊寄存器值外最重要的就是 bl el()<em>()</em>()_handler，同样以上面第一个宏定义为例，展开为 el1t_64_sync_handler，这些函数的定义和实现在 linux/arch/arm64/include/asm/exception.h 和 linux/arch/arm64/kernel/entry-common.c 中。</p><p>在上面的一系列函数中，其实就是一个中断向量表，及其里面的函数实现，当外部中断发生时，跳转到具体标处运行代码。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2V3YXJlLm9yZy9iaW51dGlscy9kb2NzL2FzL01hY3JvLmh0bWwjTWFjcm8=">https://sourceware.org/binutils/docs/as/Macro.html#Macro<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2V3YXJlLm9yZy9iaW51dGlscy9kb2NzL2FzLw==">https://sourceware.org/binutils/docs/as/<i class="fa fa-external-link-alt"></i></span><br>《奔跑吧 Linux 内核》<br>《Linux 内核深度解析》<br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中断子系统（一）综述</title>
      <link href="/next/2021/LinuxKernel/LinuxKernelInterruptSummery/"/>
      <url>/next/2021/LinuxKernel/LinuxKernelInterruptSummery/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/KernelInterruptSummery.png"> <span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjM1NzIyNWYzNDZmYjA3MjVmNTU0YjU=">原图<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="硬件链接相关描述">硬件链接相关描述</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/HW_IRQ.png"></p><p>在上图中主要分为三部分，产生中断的外部设备（中断源）、用于管理中断的中断控制器以及处理中断信号的 cpu。</p><h1 id="中断处理流程">中断处理流程</h1><p>在 ARM 处理器上会有一个中断向量的连续地址，一般是零地址开始，之后地址每增加 1 的地址上存放一条跳转指令，用于处理不同的中断信号，当有不同的中断发生时就到对应的地址执行跳转指令，而具体不同的中断信号就在不同中断标号位置进行处理。</p><p>保存现场（当前线程环境）— 跳转执行中断服务程序 — 返回恢复现场。</p><h1 id="linux-系统对中断处理的方式">Linux 系统对中断处理的方式</h1><p>首先需要先明确几个问题：</p><ul><li>中断处理过程中是关全局中断的，也就是中断程序处理期间不能响应新的中断。</li><li>基于第一点，Linux 内核不允许中断嵌套，其实第一点就已经决定了中断不能嵌套。</li></ul><p>基于以上两点，当 Linux 系统的中断任务比较多的时候系统响应就会有很大延迟，为此 Linux 系统将中断设计为上半部和下半部，上半部处理紧急的必须要处理的任务而耗时的不紧急的任务放到中断下半部来处理，中断下半部就是普通的软件程序（但是有一点区别就是 softirq 和 tasklet 运行在中断上下文，而 workqueue 和 threaded irq 运行在进程上下文），中断仍然是开启的，在中断的下半部仍然可以响应中断。</p><p>中断上半部应该主要处理如下任务：</p><ul><li>对实时性要求强的任务。</li><li>和硬件相关的操作，像清中断标志位，如果是共享中断则获取硬件中断号。</li><li>不能休眠，休眠会引发系统任务调度，而在中断状态下任务调度是关闭的，这个一定不能休眠。</li></ul><p>中断下半部内核提供了多种处理机制，下面挨个介绍中断下半部处理方式</p><h2 id="softirq性能好">softirq（性能好）</h2><p>在普通的驱动中一般是不会用到 softirq，softirq 不能动态分配，都是静态定义的。内核已经定义了若干种 softirq number，例如网络数据的收发、block 设备的数据访问（数据量大，通信带宽高），timer 的 deferable task（时间方面要求高）。softirq 的一些特性：</p><ul><li>softirq 是在编译期间静态分配的。</li><li>产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不会抢占另外一个软中断，唯一可以抢占软中断的是中断处理程序（硬中断处理完成会打开全局中断）。</li><li>可以并发运行在多个 CPU 上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个 CPU 同时操作）， 因此也需要使用自旋锁来保护其数据结构。</li><li>软中断可能运行在中断上下文，软中断处理函数中不能睡眠，从硬中断返回的时候调用 do_softirq()。</li><li>在 Linux 内核中，用 softirq_action 结构体表征一个软中断，这个结构体包含软中断处理函数指针和传递给该函数的指针的参数。使用 open_softirq() 函数可以注册软中断对应的处理函数，而 raise_softirq() 函数可以触发一个软中断。</li></ul><h2 id="tasklet易用">Tasklet（易用）</h2><p>内核把普通优先级和高优先级的 tasklet 维护在两个不同的链表中。tasklet_schedule 将 tasklet 添加到普通优先级链表中，用 TASKLET_SOFTIRQ 来标志调度相关的 softirq。tasklet_hi_schedule 将 tasklet 添加到高优先级链表中，用 HI_SOFTIRQ 来标志调度相关的 softirq。下面是 tasklet 的一些特点：</p><ul><li>一个 Tasklet 同一时刻只能在一个处理器上执行，不要求处理函数是可重入的（易用性的体现），不同的 Tasklet 可以同时运行在不同的 cpu 上。</li><li>Tasklet 可以在运行时添加或删除（易用）。</li><li>在已经被调度但还未开始执行的 tasklet 上调用 tasklet_schedule 将不会执行任何操作，该 tasklet 最终也只执行一次。</li><li>可以在 tasklet 中调用 tasklet_schedule，意味着 tasklet 可以调度自己。</li><li>高优先级的 tasklet 总是在普通优先级的 tasklet 之前执行，滥用高优先级的 tasklet 会导致系统延时增加。</li></ul><p>调用 tasklet_kill 可以停止 tasklet（等待当前执行完毕后再杀掉）。</p><p>x 与软中断和 tasklet 不同，他们运行在中断上下文，不可抢占，而 workqueue 运行在进程上下文中，可以抢占，可以调度当然最直接的就是可以睡眠。这里的睡眠是指可以执行导致线程睡眠的操作，比如持有互斥锁，调用 usleep 等操作。 工作队列是构建在内核线程之上的，内核有两种方法处理工作队列。</p><ul><li>一种是默认的共享工作队列，由一组内核线程处理，每个内核线程运行在一个 cpu 上。一旦有工作任务需要调度，就让该工作到全局工作队列中排队，他将在合适的时候执行。</li><li>另一种是专用内核线程内运行工作队列。这意味着无论何时需要执行工作队列处理程序，都会唤醒专用内核线程来处理它，而不是默认的预定义内核线程。</li></ul><h2 id="threaded-irq">threaded irq</h2><p>线程化中断的主要目标是将中断禁用时间减少到最低限度。使用线程化中断，注册中断处理程序的方式将得到简化。甚至不必自己调度下半部，线程化核心会完成。下半部在专用内核线程中执行。这里使用 request_threaded_irq() 来替代 request_irq();</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"> <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></tbody></table></figure><p>request_threaded_irq() 函数在其参数中接收两个函数。</p><ul><li><p><span class="citation" data-cites="handler">@handler</span> 函数：这与使用 request_irq() 注册时使用的函数一样。它表示上半部函数，在中断上下文（或原子上下文）中运行。如果它能更快地处理中断，就可以根本不用下半部，它应该返回 IRQ_HANDLED。但是，如果中断处理需要 100us 以上，如前所述，则应该使用下半部。在这种情况下，它应该返回 IRQ_WAKE_THREAD，从而导致调度 thread_fn 函数（必须提供）。</p></li><li><p><span class="citation" data-cites="thread_fn">@thread_fn</span> 函数：这代表下半部，由上半部调度。当硬中断处理程序（handler 函数）返回 IRQ_WAKE_THREAD 时，将调度与该下半部相关联的内核线程，在内核线程运行时调用 thread_fn 函数。thread_fn 函数完成时必须返回 IRQ_HANDLED。执行后，再重新触发该中断，并且在硬中断返回 IRQWAKE_THREAD 之前，内核线程不会被再次调度。</p></li></ul><p>在任何能够使用工作队列调度下半部的地方，都可以使用线程化中断。真正的线程化中断必须定义 handler 和 thread_fn。如果 handler 为 NULL，而 thread_fn 不为 NULL，则内核将安装默认的硬中断处理程序，它将简单地返回 IRQ_WAKE_THREAD 来调度下半部。handler 总是在中断上下文中调用，无论是开发人员定义还是由内核默认提供。</p><h1 id="qa">QA</h1><h2 id="softirq-为什么不能休眠">SoftIRQ 为什么不能休眠</h2><p>SoftIRQ 可能运行在中断上下文中，中断上下文中是不能 sleep 的，因为 sleep 会触发调度。这里软中断是通过 do_softirq() 函数执行的，而执行该函数的时机是</p><ul><li>从硬中断处理函数返回时（硬中断返回时调用 irq_exit()-&gt;invoke_softirq()-&gt;do_doftirq(), 这个时候还在中断上下文）。</li><li>在 ksoftirq 内核线程中（进程上下文）。</li><li>在显示调用软中断中，比如网络子系统中的 NET_TX_SOFTIRQ 和 NET_RX_SOFTIRQ（进程上下文）。</li></ul><h2 id="isr-里为什么不能-sleep">ISR 里为什么不能 sleep</h2><p>sleep 会导致 call scheduler 以选择另一个进程来运行，内核代码里有大量的 critical section （临界区），critical section 本质上是一段会访问或操作共享资源的代码，在 critical section 里，是不能 call scheduler 的。因为已经有一个进程持有锁了，如果这时切换到另一个进程，最好的情况下是等待一段无法预测的时间后前一个进程会将锁释放出来，最坏的情况是死锁。硬件中断是随时可能发生的，即便内核执行的路径正处于 critical section 中。如果想在 ISR 里支持 sleep，也就是支持 call scheduler 的话，那么所有的 critical section 都必须得禁用中断，否则硬件中断一旦来临系统就会出现 race condition，接下来大概率是死锁。</p><p>硬件中断是超级宝贵的资源，想在中断里睡眠的话就得在大量的 critical section 中关闭中断才能避免 race condition，而关闭硬件中断将会大大地增加中断响应的延迟，降低系统的反应速度，这是操作系统的用户所无法接受的，因此内核开发者采用的设计是在中断里不允许睡眠，并且 ISR 应尽快执行并返回以便系统里的进程继续运行。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvaXJxX3N1YnN5c3RlbS9pbnRlcnJ1cHRfc3Vic3lzdGVtX2FyY2hpdGVjdHVyZS5odG1s">http://www.wowotech.net/irq_subsystem/interrupt_subsystem_architecture.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MDMyNzY1NTI=">https://zhuanlan.zhihu.com/p/403276552<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1ZG9uZ2d1b2EvYXJ0aWNsZS9kZXRhaWxzLzEyMTIyNjQ4NA==">https://blog.csdn.net/ludongguoa/article/details/121226484<i class="fa fa-external-link-alt"></i></span></p><p>《linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Interrupt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具推荐</title>
      <link href="/next/2021/Tools/Toolsrecommand/"/>
      <url>/next/2021/Tools/Toolsrecommand/</url>
      
        <content type="html"><![CDATA[<h1 id="效率类">效率类</h1><h2 id="notion">Notion</h2><p>Notion 是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。<span class="exturl" data-url="aHR0cHM6Ly93d3cubm90aW9uLnNvLzJiMmU4NDYxOWE2YjQwN2Q5MWExYzUzZjI4ZmQxOTE1">Notion<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h2 id="page">Page</h2><p>Notion 的 Page（Page 无处不在）可以创建各种 Block，可以创建链接到其他文章，可以创建链接到 Database，因此 Page 可以用于管理一切想要管理的东西。实际上 Page 是 Notion 的页面基本组成元素与层级关系，作为文件夹，作为文章皆可。</p><h2 id="block">Block</h2><p>notion 中最基本的数据单位被称为“块”（block），所有的数据都是一个又一个的块结构，可以对这些块结构进行任意的排列组合，按照自己的工作需要进行设计布局，并且可以同步到所有的设备端。notion 提供了超过 40 种块数据类型以供选择，从最基本的文字，到图片、文件、视频、网页、等媒体 ，更有表格、数据库、任务追踪等复杂结构等等。 下面是一些基本的 Block 介绍：</p><ul><li><p>列表 notion 提供了几种基本的列表可以进行使用，包括 Bulleted list（无序列表）、Numbered List（有序列表）、to-do list（待办列表）以及 toggle list（可折叠内容列表）。</p></li><li><p>强调与引用 Notion 提供了一些帮助整理和编辑文字的文字块修饰效果，比如用于 tips 提示的 callout 命令，记录代码片段的 code 命令，引用某些文章段落的 quote 命令。</p></li><li><p>媒体 图片、音视频、网页、文件统统可以引用进来。可以引用在线资源，也可以本地上传。</p></li></ul><h2 id="database">Database</h2><p>Notion 不得不提的一项功能是 Database，这个是我选择 Notion 最重要的原因之一，下面详细介绍一下 Notion 的 Database 功能： Database 总共有 5 种视图：</p><ul><li>Table：表格视图。类似于常见的方格表，比较方便做数据统计。每一行都可以单独打开成为一个 Page，在其中添加更多的东西。</li><li>Board：看板视图。可以用来进行任务分配与分类。卡片中的选项可以完全自定义，看板的分组也可以用选项筛选来更改。</li><li>Gallery：画廊试图。可以查看多张卡片中的开头部分，同时添加一些简要内容。</li><li>List：列表视图。可以查看某些关键信息，比如说只显示名称和状态，来确保任务进度。</li><li>Calendar：日历视图。可以在日历上按时间顺序查看添加的内容。</li></ul><p>这是五种展示视图，意味着他们其实的内容其实是统一的只是表现形式不同，而不同的表现形式意味着他具有更丰富的应用场景，例如用于知识管理、项目管理、清单等。如果不同的视图显示的内容全部都一样只是展示形式不同那么其实他也就没那么灵活和有用了，在不同的视图下可以修改 Property 的顺序以及是否显示，这里有个 Filter 功能，Filter 就是根据 Property 名称和 Property 值来作为判断依据进行过滤，只展示符合条件的项目。例如可以将 Property 的 name 命名为优先级，然后值可以设为，紧急的，重要的等然后通过 Filter 功能快速展示紧急的工作项。</p><p>在你除了工作之外还有很多个人学习，项目活动的时候那么久可以通过 Database 的 Filter 功能将工作的、生活的、学习的 Database 链接到一个 Page 然后通过 Filter 过滤出截止日期是当天的列表项来实现每日清单的功能。</p><h2 id="总结">总结</h2><p>Notion 作为一款生产力软件，它就像的乐高拼块一样，它能做各种各样的事。当然 Notion 也有一些缺点，比如对于一个有强迫症的人来说不完全的 Markdown 语法，没有悬浮目录，丑陋的代码块以及奇奇怪怪的 Formula 语法都有些让人不爽，不过适应之后就也还可以接受。</p><h1 id="marginnote">MarginNote</h1><p>MarginNote 是一款功能强大且人性化的阅读和学习软件，适用于 Apple 系软件。</p><h2 id="文档模式">文档模式</h2><p>在 MarginNote 3 中，文件从外部导入将首先进入「文档模式」在这个模式下，MarginNote 3 是一个纯粹的 PDF 阅读器，你在这里可以进行简单的标记和批注，通过快速浏览文档来确定自己是否需要进行「精读」。或者你也可以把它当做你的文献「收件箱」和「中转站」，将自己需要阅读的文献放在一起，方便批量管理。</p><h2 id="学习模式">学习模式</h2><p>只需要点击右上角省略号里的「转到学习模式」，就能创建一个包含该文档的脑图笔记本，进入功能更为强大的「学习模式」。在这里你可以使用高亮、圈选、选中、手绘等工具对内容进行标注，而 MarginNote 3 则会将它们剪辑为卡片，按大纲排列于左侧，并生成思维导图。</p><blockquote><p>MarginNote 最灵魂的功能就在这了，阅读文献一定要整理出文章的整体结构，而 MarginNote 在学习模式下通过标注可以直接生成思维导图，这有助于帮你养成标注文章结构及流程的好习惯，而且在精读后想再次阅读时可以直接通过思维导图快速导航到文章具体章节。</p></blockquote><h2 id="复习模式">复习模式</h2><p>这个本人已经毕业不需要再考试了，也不常用这个功能。</p><h2 id="总结-1">总结</h2><p>阅读书籍文献的好工具，强烈推荐，不过这个只在 Apple 系下才有。</p><h1 id="chrome-浏览器">Chrome 浏览器</h1><p>这里推荐 Chrome 浏览器实际上是要推荐里面几个好用的插件。</p><h2 id="google-翻译">Google 翻译</h2><p>这个是网页翻译的神器，可以设置为在双击单词的时候翻译</p><h2 id="infinity">Infinity</h2><p>新标签页可以替代浏览器上的书签，最主要的是这个美观，毕竟颜值即正义，支持自定义网站图标圆角等。强推</p><h2 id="标签分组扩展">标签分组扩展</h2><p>Chrome 更新添加了标签分组的功能，懂得都懂，作为一名程序员一个 chrome 不打开个十几二十几个 table 也都不好意思说自己在工作，使用标签分组可以让你打开的标签页分类排布并且暂时不需要的可以折叠，其不同的标签颜色看起来特别舒服这个应该是最重要的了吧。</p><h2 id="lastpass">LastPass</h2><p>密码助手，不必多说了，现在各大网站都实名，各种登录 xxx。</p><h2 id="ads-killer-adblocker-plus">Ads Killer Adblocker Plus</h2><p>广告拦截 xxxooo。</p><h2 id="unsplash-for-chrome">Unsplash For Chrome</h2><p>Unsplash 免费精美的图片不多说了，没事常逛逛，身心愉悦。</p><h1 id="proceson">ProcesOn</h1><p>一款在线绘图工具，思维导图、UML 图等。强推</p><h1 id="surge">Surge</h1><p>科学上网最好的工具，没有之一。</p><h1 id="magnet">Magnet</h1><p>mac 下窗口排列的好工具，强推。</p><h1 id="text-scanner">Text Scanner</h1><p>方便的 OCR 软件。</p><h1 id="编程">编程</h1><h1 id="vscode">vscode</h1><p>vscode 的灵魂是其丰富的插件，下面是个人非常喜欢的插件。</p><h2 id="better-comments">Better Comments</h2><p>代码注释高亮，注释作为代码的一部分不能抛弃吧，用它， <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Share/better_comments.png"></p><h2 id="bracket-pair-colorizer">Bracket Pair Colorizer</h2><p>为代码中的括号添上一抹亮色。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Share/bracker_pair_colorizer.png"></p><h2 id="change-case">change-case</h2><p>速更改当前选择或当前单词的大小写</p><ul><li>extension.changeCase.commands：列出所有更改案例命令，如果只选择了一个单词，则预览。</li><li>extension.changeCase.camel：Change Case'amell'：转换为带有分隔符的字符串，表示下一个字母大写。</li><li>extension.changeCase.constant：Change Case'constant'：转换为大写，下划线分隔的字符串。</li><li>extension.changeCase.dot：Change Case'dot'：转换为小写，句点分隔的字符串。</li><li>extension.changeCase.kebab：Change Case'kebab'：转换为小写，破折号分隔的字符串（param case 的别名）。</li><li>extension.changeCase.lower：Change Case'lower'：转换为小写的字符串。</li><li>extension.changeCase.lowerFirst：更改大小写'lowerFirst'：转换为第一个字符更低的字符串。</li><li>extension.changeCase.no：转换字符串没有任何外壳（小写，空格分隔）。</li><li>extension.changeCase.param：Change Case'param'：转换为小写，短划线字符串。</li><li>extension.changeCase.pascal：Change Case'pascal'：转换为以与 camelCase 相同的方式表示的字符串，但第一个字母也大写。</li><li>extension.changeCase.path：Change Case'path'：转换为小写，斜杠分隔的字符串。</li><li>extension.changeCase.sentence：更改案例'句子'：转换为小写，空格分隔的字符串。</li><li>extension.changeCase.snake：更改案例'蛇'：转换为小写，下划线分隔字符串。</li><li>extension.changeCase.swap：更改大小写'swap'：转换为每个字符大小写颠倒的字符串。</li><li>extension.changeCase.title：更改大小写'标题'：转换为空格分隔的字符串，每个单词的第一个字符为大写字母。</li><li>extension.changeCase.upper：Change Case'upper'：以大写形式转换为字符串。</li><li>extension.changeCase.upperFirst：Change Case'upperFirst'：转换为第一个字符大写的字符串。</li></ul><h2 id="clang-format">Clang-Format</h2><ul><li>安装 clang-format。</li><li>打开首选项设置（ctrl + ,），搜索 format ，勾选 format on save 自动保存。</li><li>在项目目录下编写。clang-format 文件如下，这样每当修改文件保存时，就会依据。clang-format 中规定的格式自动格式化代码。</li></ul><h2 id="compareit">compareit</h2><p>使用快捷键 ctrl 选中两个文件右键将已选项比较。进行文件比较时可替代 beyond compare</p><h2 id="git-graph">Git Graph</h2><p>用过 GitLab 的都知道 GitLab 里的 git 提交可以以图形化方式显示 git 分支和提交记录，典型的用过就再回不去了，Git Graph 可以帮你在 vscode 里实现。</p><h2 id="gitlens">GitLens</h2><p>git 好帮手，做方便的在于可以在 vscode 里显示当前改动相较于上次提交的改动，其他操作其实在 Termel 里操作习惯了。</p><h2 id="indenticator">Indenticator</h2><p>会将同一级的深度用竖线对齐展示，这样很容易看出来块结构。</p><h2 id="vscode-icons">vscode-icons</h2><p>vscode-icons 插件可以实现对各种文件类型的文件前的图标进行优化显示，好看诶。</p><h2 id="korofileheader">koroFileHeader</h2><p>KoroFileHeader 是 VScode 中自动生成程序注释的一个插件。 <strong>配置：</strong></p><p>快捷键 shift+ctrl+p，打开快捷搜索配置，输入 setting，选择 Open User Settings，在 settings 中搜索 Fileheader.cursorMode，点击编辑 json，添加配置信息即可。</p><h2 id="latex-preview-和-latex-language-support">Latex Preview 和 LaTeX language support</h2><p>latex 公式编写利器。</p><h2 id="markdown-preview-enhanced">Markdown Preview Enhanced</h2><p>markdown 实时预览，配合 vscode 轻松编写 markdown 文档。</p><h2 id="one-dark-pro">One Dark Pro</h2><p>个人非常喜欢的一款主题。</p><h2 id="project-manager">Project Manager</h2><p>多目录，多工程管理必备工具，快速切换项目，强推。</p><h2 id="todo-tree">Todo Tree</h2><p>代办事项利器，强推。</p><h2 id="remote-ssh">Remote-SSH</h2><p>这个插件可谓是 Linux 程序员神器，在程序开发过程中程序一般要放到服务器中编译，本地机器通过 SSH 连接到服务器进行编译开发，但是浏览代码、编辑代码一般通过 Samba 服务器将服务器上的目录映射到本地然后进行编辑开发，但是这种方法存在一个问题就是在浏览大型代码的时候访问速度很慢，毕竟不是本地代码而是通过网络连接这导致浏览代码速度很慢。或者本地一份代码服务器一份代码，在本地修改然后再上传到服务器，但是这种方法不推荐容易出现本地与服务器代码不同步的问题。当然还有一种方式直接通过 SSH 用服务器本地的 VIM 浏览编辑代码，这是一种不错的方法。</p><p>本文提供一种新的方法用 vscode 配合 Remoter-SSH 插件来浏览编辑代码的方式，之所以把 Remote-SSH 作为最后一个插件介绍是因为安装这个插件后前面的插件可以再通过 Remote-SSH 安装一遍，不过是安装到服务器而不是本地，这样在浏览代码的时候就可以充分利用服务器的性能加速代码访问速度，尤其在代码跳转上可以极大加速代码跳转速度。</p><h1 id="windows-常用软件列表">Windows 常用软件列表</h1><h2 id="电路设计">电路设计</h2><ul><li><strong>Altium Desginer</strong></li><li><strong>Cadence allegro</strong></li><li><strong>KiCad</strong></li><li><strong>EAGLE</strong></li></ul><h2 id="软件设计">软件设计</h2><ul><li><strong>atlab</strong></li><li><strong>visual studio</strong></li><li><strong>VSCode</strong></li><li><strong>NotePad++</strong></li><li><strong>Xshell</strong></li><li><strong>QT</strong></li><li><strong>Keil</strong></li><li><strong>ST Cubemx</strong></li><li><strong>Beyond Compare</strong></li><li><strong>Everything</strong></li><li><strong>Docker</strong></li></ul><h2 id="d-绘图">3D 绘图</h2><ul><li><strong>Fusion360</strong></li></ul><h2 id="base">Base</h2><ul><li><strong>rufus</strong></li><li><strong>diskgenius</strong></li><li><strong>balenaEtcher</strong></li><li><strong>Pot Player</strong></li><li><strong>7zip</strong></li><li><strong>Wireshark</strong></li></ul><h2 id="video">Video</h2><ul><li><strong>YUV Player</strong></li><li><strong>MediaInfo</strong></li><li><strong>ImageJ</strong></li><li><strong>ElecardStreameye</strong></li><li><strong>EasyICE</strong></li></ul><h1 id="参考文章">参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC81Njc3Nw==">https://sspai.com/post/56777<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC81NzExMA==">https://sspai.com/post/57110<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NTAwODY0OQ==">https://zhuanlan.zhihu.com/p/95008649<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzk4MjU2NDU=">https://zhuanlan.zhihu.com/p/379825645<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODYwNDEzNTI=">https://zhuanlan.zhihu.com/p/386041352<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjY0Njc0L2FydGljbGUvZGV0YWlscy84MjQ5MjE3Ng==">https://blog.csdn.net/qq_41264674/article/details/82492176<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTYxNDMzOTY=">https://zhuanlan.zhihu.com/p/356143396<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yODgwNGJjZjZkM2Y=">https://www.jianshu.com/p/28804bcf6d3f<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种用于实时视频稳定的新型相机路径规划算法</title>
      <link href="/next/2021/Science/ANovelCameraPathPlanningAlgorithmForRealTimeVideoStabilization/"/>
      <url>/next/2021/Science/ANovelCameraPathPlanningAlgorithmForRealTimeVideoStabilization/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>视频稳定根据运动模型分为 2D 和 3D 方法。 第一种方法是 2D 视频稳定 [2]，它使用 2D 运动模型（例如简单的平移模型、2D 刚性模型和 2D 仿射模型 [3-12]）描述两个连续帧之间的关系。 如果相机在 3D 空间中沿 x 轴和 y 轴的旋转很小，则 2D 视频稳定可提供良好的性能 [13]。 然而，随着相机运动变得动态，二维运动模型无法描述连续帧之间的几何关系，性能非常有限。 lee 等 提出了一种无需明确估计相机运动即可直接稳定视频的方法 [14]。 该方法找到一组变换来平滑特征轨迹 [15, 16] 并稳定视频。</p><p>第二种方法是 Buehler 等人引入的 3D 视频稳定 [17]。早期的 3D 方法使用来自运动的结构 (SFM) 技术重建场景和相机运动的 3D 模型 [18]。然后在新的 3D 相机路径上渲染稳定的视图 [17, 19]。 3D 视频稳定提供比 2D 方法更好的性能。由于这些 3D 方法在处理缺乏视差的视频时经常失败，因此它们在许多情况下并不实用 [20]。 Liu 提出了结合 2D 和 3D 视频稳定优点的子空间视频稳定 [21]，然而，由于长特征轨迹的数量不足，这种方法对于包含动态运动的视频通常会失败 [20]。因此，Wang [20] 针对 3D 重建困难或长特征轨迹不可用的视频提出了视频稳定。Liu 等人 [22] 提出了一种运动模型 SteadyFlow，它是一种通过强制强空间相干性的特定光流。Grundmann 等人基于单应性混合模型 [23]，提出了免校准滚动快门去抖。 Dong 提出了使用基于帧间单应性估计的运动模型的实时应用视频稳定 [24]。Ringaby 等人提出了一种通过将相机旋转参数化为连续曲线来校正和稳定视频的方法 [25]。Karpendo 等人建议使用陀螺仪进行视频稳定和滚动快门校正 [26]。 Lee 提出了基于人类视觉系统的视频稳定 [27]。</p><span id="more"></span><h1 id="background">Background</h1><p>为便于解释，本文描述了在简单视频稳定下相机路径规划的建议算法，如图 1 所示。 不同的运动模型，如单应性。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc1.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc2.png"></p><p>手持相机拍摄的视频的原始相机路径通常是不稳定的，如图 2 所示。为了提供稳定的输出视频，有必要从原始相机路径预测平滑的相机路径。估计平滑相机路径的最简单方法是对原始相机路径应用低通滤波器，如下所示：</p><p><span class="math display">\[P_N(t) = \sum_{k} w(k)P_o(k)  \tag1\]</span></p><p>这里，<span class="math inline">\(P_O(t)\)</span> 和 <span class="math inline">\(P_N(t)\)</span> 分别表示原始和新的相机位置。 <span class="math inline">\(w(k)\)</span> 是低通滤波器的第 k 个系数。 由于上述理想滤波器需要无限多的信号，因此无法实现。 实际上，低通滤波器应该考虑有限数量的信号。具体来说，在实时应用中考虑依赖于过去和现在帧的相机位置的临时过滤器，如下所示。</p><p><span class="math display">\[P_N(t) = \sum_{k=0}{k=t} w(k)P_o(k) \tag2\]</span></p><p>图 2 显示了将临时低通滤波器应用于沿 x 方向的相机路径的结果，低通滤波器显着平滑了相机路径。 在这里，图 2 中原始和新相机路径之间的差异可以解释为图 1 中所示的裁剪窗口偏移量。如果偏移量是超过边距的宽度或高度，裁剪窗口将不适合原始框架。 宽度和高度余量（MW 和 MH）定义如下。</p><p><span class="math display">\[M_W = \frac{W_I - W_O}{2}, M_H = \frac{H_I - H_O}{2} \tag3\]</span></p><p>其中<span class="math inline">\(W_I、H_I\)</span>和<span class="math inline">\(W_O、H_O\)</span>分别是原始帧和输出帧的宽度和高度。 出界区域将不可见或需要运动修复 [10, 33]。 边界如图 3 所示。在图中，灰色区域说明了界外区域的示例。 对于实时应用，由于复杂性，运动修复不是一个可行的解决方案。 因此，应确定新的相机路径，以便裁剪窗口位于原始帧内。 然而，基于低通滤波器的方法中的裁剪窗口偏移量是不可控的，并且该方法不能保证裁剪窗口总是位于原始帧内。 因此，这种简单的方法不能应用于输出视频大小固定的实时视频稳定。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc3.png"></p><p>在后期处理视频稳定中，在规划新的相机路径之前给出整个原始相机路径。 因此，可以优化规划平滑的相机路径，从而不会出现越界区域。然而，由于实时视频稳定中后续帧的摄像机位置是未知的，因此有时难以正确确定当前帧的摄像机位置。图 4 举例说明了为实时视频稳定规划相机路径的困难。在图 4a 中，无法预测相机路径在后续帧中是上升还是下降。如果相机路径在后续帧中向下行进，则新的相机路径可以是直的，如图 4b 所示。如果相机路径在后续帧中向上移动，则新相机路径的方向应该改变，如图 4c 所示。这种突然的移动会降低稳定视频的视觉质量。另一方面，由于整个原始相机路径是在后处理视频稳定中给出的，因此可以如图 4d 所示规划新的相机路径。如本例所示，如果没有后续帧的摄像机位置，实时视频稳定是很困难的。摄像机路径规划在实时视频稳定方面的性能将不可避免地受到限制。因此，用于实时视频稳定的相机路径规划是一个具有挑战性的问题。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc4.png"></p><h1 id="methodcamera-path-planning">Method—camera path planning</h1><h2 id="framework-of-the-proposed-algorithm">Framework of the proposed algorithm</h2><p>在规划相机路径时要考虑的第一个属性是提供恒定的相机路径。恒定的相机路径表示一条斜率为零的线。下一个属性是线性相机路径，其中相机具有恒定速度。虽然线性相机路径的斜率不为零，但线性路径也是一条线。虽然这两个属性的物理含义在相机运动方面有所不同，但恒定和线性相机路径的形状基本上是一条线。因此，所提出的算法将线视为在相机路径中追求的基本特征。</p><p>所提出的算法首先在新的相机路径上找到通过最后一个相机位置的所有可能的候选线，如图 6 所示。由于新的相机路径应该是连续的，候选线应该从第（ n − 1) 帧，它是新相机路径上的最后一个相机位置。然后它们在第 (n + K) 帧的上下边界之间结束。所有可能的候选线在第 (n+K) 帧以相邻候选线之间的间隔为 1 的方式生成。图中，当前帧（或第 n 帧）的相机位置尚未确定，缓冲的帧范围从第 (n+1) 帧到第 (n+K) 帧。可以预先预测缓冲帧的相机运动，从而可以确定缓冲帧处的原始相机位置和边界。因此，候选线的端点简单地位于第 (n+K) 帧的两个边界之间。然后，所提出的算法使用将在下一小节中描述的所提出的成本函数检查搜索范围内所有可能的候选线，选择成本最低的候选线作为最佳线。最后，根据最佳线计算当前帧的相机位置，请注意，缓冲帧处的相机位置不属于新的相机路径。</p><p>如果候选线穿过界外区域，则不应将其选为最佳线。 图 7 描绘了不应选择的候选行的示例。 在图 7a 中，区域 R 中的候选线通过了界外区域。 因此，不应选择区域 R 中的任何候选线作为最佳线。 有时，搜索范围内的所有候选线都经过界外区域，如图 7b 所示。 在这种情况下，当找不到最佳行时，K 的值减 1，直到找到最佳行。</p><h2 id="cost-function">Cost function</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc6.png"></p><p>所提出的算法选择具有最小成本的候选线作为最佳线。 第 n 帧第 i 条候选线的代价函数定义如下。</p><p><span class="math display">\[C(n,i) = w_1C_s(n,i) + w_2C_L(n,i) + w_3C_M(n,i) \tag4\]</span></p><p>其中，w1、w2 和 w3 是权重因子。 CS(n, i) 定义如下。</p><p><span class="math display">\[C_S(n,i) = |S(n,i)| \tag5\]</span></p><p><span class="math inline">\(S(n, i)\)</span> 是第 i 条候选线在第 n 帧的斜率。 候选线的零斜率表示没有相机移动。 因此<span class="math inline">\(C_S(n, i)\)</span>可以解释为追求静态相机路径的术语，这是第一个属性。 如果候选线的斜率陡峭，则此项变大。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc7.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc8.png"></p><p><span class="math inline">\(C_L(n,i)\)</span>定义如下：</p><p><span class="math display">\[C_L(n,i) = |S(n,i) - S(n-1, i_{n-1}^{min})| \tag6\]</span></p><p>这里，<span class="math inline">\(i_{n-1}^{min}\)</span>是第 (n-1) 帧的最佳行的索引。 因此<span class="math inline">\(S(n − 1,i_{n-1}^{min})\)</span>表示在第 (n − 1) 帧的最佳线的斜率。 如果当前帧的候选线的斜率与前一帧的最佳线的斜率相同，则<span class="math inline">\(C_L(n, i)\)</span>将为零。 可以理解为，该术语旨在保持相机路径的线性，这是第二个属性。</p><p>如果相机路径规划方法利用上下边界作为简单的约束，虽然约束会阻止新的相机路径超过可用的图像边缘，但新的相机位置有时会非常接近下边界，例如新的相机位置 对于图 4a 中的当前帧。 在这种情况下，如果原来的相机路径向上行进（情况 a），由于向下方向没有图像边缘，新的相机路径应该突然改变方向为向上。 新相机路径上的这种突然移动会降低稳定视频的视觉质量。 为了避免这种情况，本文考虑了一个新的<span class="math inline">\(C_M(n, i)\)</span>项来保留上下方向的可用图像边距。</p><p><span class="math display">\[\begin{aligned}C_M(n,i) = \sum_{k=n}^{n+K} (F_{LO}(k,i) + F_{UP}(k,i)) \\&amp;F_{UP}(k,i) = \frac{1}{max(0.01,P_O(n) + M_{UP} - P_N^i(n))^2}  \\&amp;F_{LO}(k,i) = \frac{1}{max(0.01, P_N^i(n) - P_O(n) + M_{UP})^2}\end{aligned}  \tag7\]</span></p><p>其中<span class="math inline">\(P^i_N(n)\)</span>是第 i 条候选线上第 n 帧的相机位置。<span class="math inline">\(M_{LO}\)</span> 和<span class="math inline">\(M_{UP}\)</span> 分别是下边距和上边距的大小，这些边距通常设置为相同的值。<span class="math inline">\(P_O(n)+M_{UP}−P_N^i(n)（或 P_N^i(n)+ M_{LO}−P_O(n)）\)</span>是<span class="math inline">\(P_N^i(n)\)</span>与上边界（或下边界）之间的欧几里德距离，如图 8 所示。这里，0.01 被认为是为了防止被零除。如果<span class="math inline">\(P^i_N(n)\)</span>靠近上边界（或下边界），则<span class="math inline">\(F_{UP}(n, i)（或 F_{LO}(n, i)）\)</span>的值将变得非常大。如果<span class="math inline">\(P_N^i(n)\)</span>远离上边界（或下边界），则<span class="math inline">\(F_{UP}(n, i)（或 F_{LO}(n, i)）\)</span>的值将变得非常小。当<span class="math inline">\(P_N^i(n)\)</span>位于距离两个边界等距的位置时，<span class="math inline">\((F_{UP}(n, i)+F_{LO}(n, i))\)</span>将获得最小值。因此，<span class="math inline">\(F_{UP}(n, i)\)</span>和<span class="math inline">\(F_{LO}(n, i)\)</span>可以解释为从边界推动相机位置以保持图像边缘的力。<span class="math inline">\(C_M(n, i)\)</span>在第 i 条候选线上的相机位置处累积所有<span class="math inline">\(F_{UP}(n, i)\)</span>和<span class="math inline">\(F_{LO}(n, i)\)</span>。相机位置不能位于边界之外。如果 K 值减小<span class="math inline">\(C_M(n, i)\)</span>成为在实时视频稳定中实现高质量新相机路径的重要术语。实验结果在第 4 节中给出了详细信息。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anc9.png"></p><p>让我们简要地考虑一下所提出方法的计算过程。所提出算法的第一步是寻找候选线。这可以通过获取从第 (n - 1) 个摄像机位置连接到搜索范围内的点的线来简单地实现，如图 6 所示。下一步涉及排除包含在外的候选线边界区域，如图 7 所示。 如果第 i 条候选线（或 <span class="math inline">\(P^i_N(n)\)</span>）上的任何点不在<span class="math inline">\(P_O(n) − M_{LO}\)</span>到<span class="math inline">\(P_O(n) + M_{UP}\)</span>之间，则对应的候选线应为排除在外。在最后一步，该方法根据等式评估每个候选行 (4) 并找到成本最低的候选行。如上所示，所提出的算法需要多次算术运算和比较来规划当前帧新相机路径的新相机位置，与视频稳定的计算负担相比，其计算过程极低。</p><h1 id="参考文献">参考文献</h1><p>&lt; A novel camera path planning algorithm for real-time video stabilization &gt;</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于陀螺仪的视频稳定非线性滤波器</title>
      <link href="/next/2021/Science/GyroscopeBasedNonlinearFilterForVideoStabilization/"/>
      <url>/next/2021/Science/GyroscopeBasedNonlinearFilterForVideoStabilization/</url>
      
        <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1><p>我们提出了一种对移动设备上捕获的视频进行视频稳定和滚动快门校正的方法。该方法使用来自机载陀螺仪的数据来跟踪相机的角速度，并且可以在相机捕获期间内实时运行。我们消除了由于手抖动引起的小抖动和滚动快门失真，营造出在三脚架上拍摄的视频的效果。</p><span id="more"></span><h1 id="introduction">Introduction</h1><p>大多数中高端移动设备包含一个多核 CPU 复合体、一个图形处理单元 (GPU) 和一个带有 3 轴陀螺仪的惯性测量单元 (IMU)。 在本文中，我们解决了在此类设备上执行视频稳定的挑战，使用陀螺仪进行运动跟踪。 与大多数稳定方法不同，它们作为捕获视频的后处理步骤运行，我们的方法可以作为相机捕获的一部分实时运行。</p><h1 id="background-and-prior-work">Background and Prior Work</h1><p>视频稳定消除了视频中的抖动，它本质上是一个三阶段过程，包括运动估计阶段、平滑测量运动的滤波阶段和生成新视频序列的重新合成阶段。</p><p>当深度变化引起像素运动时，基于图像的跟踪方法会受到影响，视差，单应性不容易建模。此外，滚动快门成像传感器可以引入非刚性的帧到帧对应关系，不能简单地通过全局帧到帧运动模型进行建模。为了解决滚动快门问题，Baker 等人 [8] 使用低频光流的时间超分辨率估计和去除相机的高频抖动。Grundmann 等人 [3] 开发了一个基于混合单应性的模型，该模型跟踪帧内运动并生成具有校正滚动快门失真的稳定视频。 Liu 等人 [6] 采用基于网格的空间变化运动表示，结合自适应时空路径优化，可以处理视差并校正滚动快门效应。</p><p>Karpenko [1] 和 Hanning 等人 [11] 描述了使用内置陀螺仪跟踪相机方向的移动设备的视频稳定技术，将线性低通滤波器应用于陀螺仪输出。Karpenko 等人 [1] 使用高斯核，而 Hanning 等人 [11] 应用可变长度的 Hann 窗口来自适应地平滑相机路径。相比之下，我们引入了一种非线性滤波方法，该方法可以完全平坦化小运动，而不管频率如何，并在虚拟摄像机必须移动以将裁剪窗口保持在输入帧内时执行低通平滑。当相机几乎静止时，我们的虚拟相机被固定，消除所有抖动。移动时，我们的方法就像一个可变 IIR 滤波器，以平滑输出的方式将输入速度与虚拟相机速度混合，同时保证它跟踪输入，以便裁剪窗口永远不会离开输入帧。</p><h1 id="algorithm-description">Algorithm Description</h1><p>从概念上讲，可以通过创建一个裁剪矩形来实现视频稳定，该矩形在相机四处晃动时随场景内容逐帧移动。如图 1 所示 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anl1.png"></p><h2 id="camera-tracking-using-the-gyroscope">Camera Tracking Using the Gyroscope</h2><p>我们将相机运动建模为全局坐标系中的旋转。陀螺仪提供了一系列带有时间戳的离散角速度测量值，我们将其积分以生成描述相机方向的时间函数。 理论上，我们还可以通过使用设备的加速度计测量平移来更精确，但实际上这很困难且价值有限。如果相机距离平面场景 3 米，那么 1 厘米平移引起的图像运动相当于旋转 0.19 度。 此外，平移的使用需要了解场景中物体的深度。</p><p>为了修复卷帘快门失真，我们需要知道特定行曝光时相机的方向。 给定帧 <span class="math inline">\(t_0\)</span> 第一行的时间戳，第 r 行的时间戳为</p><p><span class="math display">\[t_r = t_0 + \frac{r}{f_l}f_t \tag1\]</span></p><p>其中 <span class="math inline">\(f_t\)</span> 是总帧时间（即两个连续帧开始之间经过的时间），<span class="math inline">\(f_l\)</span> 是图像行中的帧长度。 帧长是图像高度（以像素为单位）加上消隐行数的总和。 这两个值都取决于图像传感器和捕获模式，但我们假设它们在视频持续时间内是已知的并且是恒定的。如果这些值不是由传感器驱动提供的，也可以通过校准获得 [13, 14]。</p><p>我们可以通过计算其对应的行时间戳并从已知样本中插入相机方向来找到与图像中点 x 对应的设备方向。由于硬件和软件延迟，帧时间戳和陀螺仪时间戳之间存在小的偏移，我们假设这个偏移 <span class="math inline">\(t_d\)</span> 是已知的，并且在捕获期间是恒定的。 在实践中，我们按照第 3.5 节中的详细说明校准此偏移量。</p><p>我们使用具有焦距 f 和投影中心 (cx, cy) 的投影相机模型；这三个参数定义了相机固有矩阵 K。这些参数使用 OpenCV 库进行离线校准。在已知 K 矩阵的情况下，滚动快门传感器在旋转运动下捕获的两个不同帧上的对应点<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>之间的关系为 :</p><p><span class="math display">\[x_2 = KR_c(t_2)R_c^{-1}(t_1K^{-1})x_1 \tag2\]</span></p><p>其中旋转矩阵 <span class="math inline">\(R_c\)</span> 表示作为时间函数的相机坐标系中的相机方向，<span class="math inline">\(t_1\)</span> 和 <span class="math inline">\(t_2\)</span> 是点 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的行时间戳。 我们可以将关于陀螺仪坐标系和时间原点的方程 2 重写为：</p><p><span class="math display">\[x_2 = KTR_g(t_2 + t_d)R_g^{-1}(t_1 + t_d)T^{-1}K^{-1}x_1 \tag3\]</span></p><p>其中 <span class="math inline">\(R_g\)</span> 是从陀螺仪导出的方向，T 是相机和陀螺仪坐标系之间的转换，<span class="math inline">\(t_d\)</span> 是上述陀螺仪和相机数据流之间的时间偏移。由于大多数移动设备都将陀螺仪和摄像头固定安装在一起，轴彼此平行，因此 T 只是一个置换矩阵。</p><h2 id="motion-model-and-smoothing-algorithm">Motion Model and Smoothing Algorithm</h2><p>我们在每一帧用相机的方向和角速度参数化相机路径。我们用四元数<span class="math inline">\(p(k)\)</span>和<span class="math inline">\(v(k)\)</span>表示第 k 帧的物理和虚拟相机方向。 物理和虚拟角速度计算为从第 k 帧到第 k + 1 帧的离散角变化，并表示 <span class="math inline">\(p_∆(k)\)</span>和<span class="math inline">\(v_∆(k)\)</span>。由于帧速率是恒定的，因此这种速度表示中隐含了时间。对于每个新帧 k，我们的平滑算法使用来自最后一帧的虚拟参数以及来自最后一帧、当前帧和可选的未来小缓冲区的物理相机参数计算<span class="math inline">\(v(k)\)</span>和<span class="math inline">\(v_Δ(k)\)</span>帧（5 个或更少）。</p><p>我们的平滑算法创建了一个新的相机路径，当测量到的运动足够小以表明实际意图是保持相机静止时，该路径使虚拟相机保持静止，否则遵循测量运动的意图，角速度平滑变化 . 作为第一步，我们通过设置假设虚拟相机的新方向。 <span class="math display">\[\hat{v}^(k) = v(k − 1) · v_∆(k − 1) \tag4\]</span> 其中<span class="math inline">\(\cdot\)</span>表示四元数积。简单地说，这个方程是通过从上次已知方向旋转相机，同时保持其角速度来计算新的相机方向。给定这个假设的相机方向 <span class="math inline">\(\hat{v}^(k)\)</span>，我们使用等式 2 来计算生成的裁剪多边形的角坐标。在虚拟相机空间中，裁剪多边形是一个以图像中心为中心的固定矩形，但在物理相机空间中，它可能会发生倾斜或扭曲，并在帧内四处移动，如图 1 所示。裁剪多边形较小比输入大小，这在多边形边界和输入框架边缘之间留下了少量的 "padding"，如图 2 所示。我们将此填充分为两个同心区域，我们将其称为 "inner region"和 "outer region"。当假设的裁剪多边形位于图像的内部区域内时，我们断言假设 <span class="math inline">\(\hat{v}^(k)\)</span>是好的，并使其成为当前的相机方向。在实践中，我们发现让运动在这种情况下衰减为零，这会使虚拟相机在可能的情况下偏向于保持静止。因此，如果裁剪多边形完全保留在内部区域内，我们将角度变化减少衰减因子 d，并将新的虚拟相机配置设置为：</p><p><span class="math display">\[v_∆(k) = slerp(q_I; v_∆(k − 1); d) \tag5\]</span></p><p>and</p><p><span class="math display">\[v(k) = v(k − 1) · v_∆(k − 1) \tag6\]</span></p><p>这里<span class="math inline">\(q_I\)</span>代表恒等四元数，slerp 函数是两个四元数之间的球面线性插值 [17]。在我们的实现中，我们将混合权重设置为 d ≈ 0.95，这样每一帧的角度变化只会略微减少。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anl2.png"></p><p>如果假设裁剪多边形的任何部分位于内部区域之外，我们将更新虚拟摄像机的角速度以使其更接近物理摄像机的变化率：</p><p><span class="math display">\[v_∆(k) = slerp(p'_∆(k), v(k − 1), α) \tag7\]</span></p><p>这里 <span class="math inline">\(p'_∆\)</span> 是保持裁剪多边形从一帧到下一帧的相对位置的方向变化，计算为：</p><p><span class="math display">\[p'_∆(k) = p(k) · p^∗(k − 1) · v(k − 1) \tag8\]</span></p><p>其中<span class="math inline">\(p^∗\)</span>表示反转旋转的四元数共轭。 该方程计算虚拟摄像机参考坐标系中从前一帧到当前帧的物理摄像机运动。 α项是一个混合权重，它是根据裁剪多边形和框架边缘之间剩余的填充量来选择的，如图 2 的右侧所示。直观地，如果裁剪多边形仅稍微超出内部 区域，α 应该接近 1，为当前速度分配更高的权重。 相反，如果假设的裁剪多边形靠近边缘（甚至外部），则 α 应为 0，这样输入速度匹配，裁剪多边形保持在相对于输入帧的相同位置。 我们用</p><p><span class="math display">\[α = 1 − w^β \tag9\]</span> 其中 <span class="math inline">\(w \subseteq (0, 1]\)</span> 是裁剪多边形超出内部区域的最大突出量，而 β 是决定响应锐度的指数。在裁剪多边形的任何角落在输入之外的极端情况下 帧，w 取值为 1，强制 α 为 0，并使虚拟摄像机跟上物理摄像机。</p><p>该算法运行良好，但当裁剪矩形突然碰到边缘时，它有时必须快速改变速度。 如果帧在处理之前可以在相机流水线中缓存一小段时间，那么可以检查更大的陀螺仪数据时间窗口，并且可以抢先避免急剧变化。 在本节的其余部分，我们扩展了我们的算法以使用来自前瞻缓冲区的数据来计算更平滑的路径。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anl3.png"></p><p>我们可以通过将虚拟相机的方向及时向前投射并将其与“未来”时间的实际方向进行比较来跨越更大的帧窗口。让 a 是向前看的帧数，并假设：</p><p><span class="math display">\[v(k + a) = v(k − 1) · v_∆(k)^{a+1} \tag{10}\]</span></p><p>然后，我们可以计算<span class="math inline">\(v_∆(k+a)\)</span> 和 <span class="math inline">\(v(k+a)\)</span>，就像我们在无前瞻情况下描述的那样。 如果裁剪多边形 a 帧到未来的投影在内部区域之外，我们可以更新<span class="math inline">\(v_∆(k)\)</span> 为：</p><p><span class="math display">\[v_∆(k) = slerp(v_∆(k + a); v_∆(k); γ) \tag{11}\]</span></p><p>其中 γ 是一个混合因子，它定义了我们应该将多少前瞻角度变化与当前角度变化混合。 使用接近 1 的 γ 值提供了在正确方向上的先发制人的推动，而不是硬约束。 请注意，我们不会在没有前瞻的情况下更新我们计算的虚拟摄像机位置，我们只会更新我们将用于下一帧的虚拟摄像机速度</p><p>图 3 显示了一系列前瞻距离（以帧为单位）的路径比较。 较大的前瞻值会产生更平滑的路径，因为它们可以有效地“预测”较大的运动并轻轻地导致输出开始移动。但需要注意的是，我们的算法可以在没有前瞻的情况下工作并且仍然产生良好的结果。</p><h2 id="output-synthesis-and-rolling-shutter-correction">Output Synthesis and Rolling-Shutter Correction</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anl4.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/anl5.png"></p><p>一旦我们计算了虚拟摄像机的新方向，我们就可以通过将裁剪多边形从视频输入投影到虚拟摄像机来合成输出。我们的裁剪多边形本质上是一个裁剪矩形，在垂直边缘上有多个拐点，如图 4 所示。拐点允许我们对多边形的每个切片使用不同的变换并修复滚动快门失真。对于每个切片，我们根据等式 2 计算单应矩阵。 我们将旋转矩阵 <span class="math inline">\(R_c(t2)\)</span> 固定到虚拟输出相机的方向，并通过来自陀螺仪的数据计算 <span class="math inline">\(R_c(tk)\)</span>，输入相机在每个拐点处的方向。我们将裁剪多边形的坐标设置为 OpenGL 着色器程序的纹理坐标，该程序将裁剪多边形从输入帧投影映射到虚拟相机。请注意，为了有效校正滚动快门效应，陀螺仪采样率应高于帧读出时间。在我们的实现中，我们以 200 Hz 的频率对陀螺仪进行采样，总共使用 10 个切片，或每个垂直边缘 9 个拐点。</p><h2 id="parameter-selection">Parameter Selection</h2><p>最重要的参数是输出裁剪多边形的大小以及分配给内部和外部区域的填充量。裁剪大小是平滑和图像质量之间的权衡：较大的裁剪多边形保留更多的输入图像，但留下较少的填充来平滑运动。填充分配是完全去除运动和剩余运动的平滑度之间的权衡。 如图 5 所示，较大的内部区域（绿色）能够使较大的运动（例如步行）变平，但当裁剪窗口接近框架边缘时必须更突然地移动。</p><h2 id="gyroscope-and-camera-calibration">Gyroscope and Camera Calibration</h2><p>我们使用为此目的开发的校准程序来求解时间偏移 <span class="math inline">\(t_d\)</span>。 我们在相机前面放置了一个校准图案，它由一个不对称的圆网格组成，然后我们在剧烈旋转相机的同时录制视频和陀螺仪读数。 即使存在运动模糊和滚动快门效果，也可以轻松地跨帧跟踪圆圈。 我们使用每个圆的质心作为特征点，并根据公式 3 通过最小化重投影误差的总和来迭代求解 <span class="math inline">\(t_d\)</span>。通过在多个数据集上重复校准，我们确定偏移 <span class="math inline">\(t_d\)</span> 几乎是恒定的。 我们还考虑了通过在捕获每一帧时跟踪关键点来进行在线校准的可能性 [18]，但事实证明离线方法足以满足我们的目的。</p><p>陀螺仪测量中任何静态偏移的积分将导致估计的方向缓慢偏离地面实况。然而，我们的稳定算法不受这种漂移的影响，因为它平滑了方向的相对变化。 我们在一到五帧的窗口内测量方向变化，在如此短的时间跨度内，积分漂移可以忽略不计。</p><h1 id="results">Results</h1><p>我们的源视频、结果和补充材料视频可在 https://research.nvidia.com/publication/non-linearfilter-gyroscope-based-video-stabilization 获得。</p><h1 id="参考文献">参考文献</h1><p>&lt; A Non-Linear Filter for Gyroscope-Based Video Stabilization &gt;</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用陀螺仪的数字视频稳定和卷帘快门校正</title>
      <link href="/next/2021/Science/DigitalVideoStabilizationAndRollingShutterCorrectionUsingGyroscope/"/>
      <url>/next/2021/Science/DigitalVideoStabilizationAndRollingShutterCorrectionUsingGyroscope/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs1.png"></p><h1 id="abstract">Abstract</h1><p>在本文中，我们提出了一种基于商用陀螺仪的强大实时视频稳定和滚动快门校正技术。首先来对相机运动和卷帘快门扭曲进行建模，然后从单个视频捕获自动校准陀螺仪和相机输出。 这种校准使我们能够仅使用陀螺仪数据来有效校正卷帘快门扭曲并稳定视频。</p><span id="more"></span><h1 id="video-stabilization-and-rolling-shutter-correction">Video Stabilization and Rolling Shutter Correction</h1><p>我们系统中的相机运动仅根据旋转进行建模。 我们忽略平移运动，加速度计数据必须被积分两次才能获得位移，因此它们很难使用 IMU 准确测量。即使我们可以准确地测量平移，这也是不够的，因为在相机相同平移量的情况下不同深度的物体移动的量不同，我们将不得不依赖立体或基于特征的运动结构（SfM）算法来获取深度信息。这些方法并不健壮，而且目前在移动平台上实时运行计算成本太高。</p><p>Forsse ́n 和 Ringaby[2010] 试图在他们的系统中模拟相机位移，但发现结果比只考虑旋转的模型表现更差。 他们假设优化器在尝试从特征跟踪器重建位移时陷入局部最小值。他们的算法还假设相机正在对纯平面场景（即恒定深度）进行成像。 因此，由于视频中的未建模视差，平移重建有时会失败。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs2.png"></p><p>为了避免这些问题，我们没有将平移合并到我们的模型中。 幸运的是，相机抖动和卷帘快门扭曲主要来自旋转。之所以如此，是因为平移随着深度的增加而迅速衰减，并且物体通常离镜头足够远，平移相机抖动不会在图像中产生明显的运动。 这一结论得到了我们的稳定结果的支持。</p><h2 id="camera-model">Camera Model</h2><p>我们的旋转卷帘快门相机模型基于针孔相机模型。在针孔相机中，图像之间的关系在齐次坐标中的点 x 和对应点在 3D 世界坐标系中的 X（图 2）可以通过以下方式表示：</p><p><span class="math display">\[x=KX, X=\lambda K^{-1}x \tag1\]</span></p><p>其中<span class="math inline">\(\lambda\)</span>是未知比例因子，<span class="math inline">\(K\)</span>是相机内参矩阵，我们假定内参矩阵的逆如下：</p><p><span class="math display">\[K^{-1} = \begin{bmatrix} 1 &amp; 0 &amp; -o_x\\ 0 &amp; 1 &amp; -o_y\\ 0 &amp; 0 &amp; f \end{bmatrix} \tag2\]</span></p><p>其中，<span class="math inline">\((o_x, o_y)\)</span> 是图像平面中相机轴的原点坐标，f 是焦距。</p><h2 id="camera-motion">Camera Motion</h2><p>我们将世界原点设置在相机原点。然后可以用 R(t) 来描述相机在时间 t 时刻的运动。因此，对于任何世界坐标点点 X，对应的图像点 x 在时间 t 由下式给出：</p><p><span class="math display">\[x = KR(t)X \tag3\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs3.png"></p><p>旋转矩阵<span class="math inline">\(R(t) \in SO(3)\)</span>是通过相机旋转角度<span class="math inline">\(\Delta \theta (t)\)</span>计算得到的。然后对其使用 SLERP（球形四元数线性插值）来平滑的得到足够多的旋转矩阵。<span class="math inline">\(\Delta \theta (t)\)</span>可以通过陀螺仪的角速度获得：</p><p><span class="math display">\[\Delta \theta (t) = (w(t + t_d) + w_d) * dt \tag4\]</span></p><p>这里<span class="math inline">\(w_d\)</span>是陀螺仪漂移，<span class="math inline">\(t_d\)</span>是陀螺仪和相机时间戳的差，这些参数都是未知的需要进行校准获得。</p><h2 id="rolling-shutter-compensation">Rolling Shutter Compensation</h2><p>我们现在将卷帘快门的概念引入我们的相机模型中。在 RS 相机中，每个图像行的曝光时间略有不同，因此曝光期间相机的旋转将导致图像的扭曲。例如，如果相机在快门滚动时左右摇摆，则输出图像将扭曲，如图 2 所示。更正式地说，我们可以说 x 在时间 t(i, y) 期间成像：</p><p><span class="math display">\[t(i,y) = t_i + t_s * y / h; where  x = (x,y,1)^T \tag5\]</span></p><p>其中 y 是点 x 对应的图像行，h 是帧中的总行数，<span class="math inline">\(t_i\)</span>是第 i 帧的时间戳。 <span class="math inline">\(t_s\)</span>是一帧曝光所需时间，也就是从上到下逐行读出完整帧所需的时间。</p><h2 id="image-warping">Image Warping</h2><p>现在我们推导出一帧图像两个坐标点之间的旋转关系。对于场景点 X，在 i 帧和 j 帧的图像平面中的投影点<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>由下式给出：</p><p><span class="math display">\[x_i = KR(t(i,y_i))X, and x_j = KR(t(j,y_j))X \tag6\]</span></p><p>联立两式整理得到：</p><p><span class="math display">\[x_j = KR(t(j,y_j))R^{T}(t(i,y_i))K^{-1}x_i \tag7\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs4.png"></p><p>想在我们已经考虑了同一个视频中的两帧之间的关系，我们加入限制条件两帧图像的原点相同，将<span class="math inline">\(R(t)\)</span>映射到<span class="math inline">\(R'(t)\)</span>, 现在重新定义扭曲矩阵将一个点映射到另一个相机坐标系下：</p><p><span class="math display">\[W(t1,t2) = KR'(t1)R^T(t2)K^{-1} \tag8\]</span></p><p>我们可以得到如下：</p><p><span class="math display">\[x_j = W(t(j,y_j),t(i,y_i))x_i, R' = R \tag9\]</span></p><p>还要注意，W 分别取决于图像点<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>的图像行<span class="math inline">\(y_i\)</span>和<span class="math inline">\(y_j\)</span>。该变换矩阵可用于将帧 i 中的点与帧 j 中的对应点进行匹配，同时在两帧中都考虑卷帘快门的影响。给定这种变形矩阵的公式，滚动快门校正和视频稳定的算法就变得简单了。我们创建了一个具有平滑运动和全局快门的合成视频。该相机的运动是通过对输入相机的运动应用高斯低通滤波器来计算的，这会产生一组新的旋转矩阵 R0。我们将合成相机的滚动快门持续时间 ts 设置为 0（即全局快门），然后我们在当前帧 i 的每个图像行<span class="math inline">\(y_i\)</span>处计算<span class="math inline">\(W(t_i; t(i; y_i))\)</span>，并将扭曲应用于该行。 请注意 W 的第一项现在仅取决于帧时间<span class="math inline">\(t_i\)</span>。此操作将所有输入帧映射到我们的合成视频上；因此可以同时消除滚动快门扭曲和视频抖动。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs5.png"></p><p>实际上，我们不会为每个图像行<span class="math inline">\(y_i\)</span>计算<span class="math inline">\(W(t_i; t(i; y_i))\)</span>。相反我们细分输入图像（图 5a）并计算每个垂直细分的扭曲（图 5c 和 5d）。本质上，我们从输入图像创建一个扭曲的网格，它是非线性扭曲的分段线性近似。我们发现十个细分通常足以去除任何可见的 RS 拖影。Forssen 和 Ringaby [2010] 将这种采样方法称为´逆插值。他们还提出了两种额外的插值技术，他们凭经验证明在合成视频数据集上表现更好。然而，我们使用逆插值是因为使用顶点着色器很容易在 GPU 上实现一个高效的版本。GPU 的片段着色器负责使用双线性插值对网格扭曲图像进行重新采样。我们发现，由于双线性逆插值实际视频中的 RS 扭曲通常不足以产生混叠拖影，因此逆插值在实践中效果也很好。</p><h1 id="camera-and-gyroscope-calibration">Camera and Gyroscope Calibration</h1><p>我们现在展示用于找到未知的相机和陀螺仪参数。 这个校准步骤是必要的，它使我们能够直接从陀螺仪数据中计算 W。 我们模型中的未知参数是：相机的焦距 f、滚动快门的持续时间 <span class="math inline">\(t_s\)</span>、陀螺仪和帧样本时间戳之间的延迟 <span class="math inline">\(t_d\)</span> 以及陀螺仪漂移 <span class="math inline">\(w_d\)</span></p><p>请注意，制造商可能会给定其中一些参数，例如相机的焦距，也可以通过实验测量这些参数。 例如，Forssen 和 Ringaby [2010] 使用快速闪烁的显示器来测量滚动快门持续时间 <span class="math inline">\(t_s\)</span>。 然而这些技术往往不精确且容易出错；而且它们也太繁琐，普通用户无法执行。滚动快门的持续时间通常在毫秒范围内。因此，<span class="math inline">\(t_d\)</span> 或<span class="math inline">\(t_s\)</span>中的小偏差将导致卷帘门整流失败。</p><p>我们的方法是从单个视频和陀螺仪捕获中估计这些参数。用户被要求记录视频和陀螺仪轨迹，在那里他们站着不动并在指向建筑物时晃动相机。持续时间约为 10 秒的短片通常以估计所有未知数。 请注意，这只需为每个摄像头和陀螺仪设置完成一次。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs6.png"></p><p>在我们的方法中，我们使用 SIFT [Lowe 2004] 在连续视频帧中找到匹配点，并且我们使用 RANSAC [Fischler and Bolles 1981] 来丢弃异常值。 结果是捕获视频中所有相邻帧的一组点对应关系 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(x_j\)</span> （图 6）。鉴于这一基本事实，我们可以将校准表述为一个优化问题，我们希望最小化所有点对应的均方重投影误差：</p><p><span class="math display">\[J = \sum_{i,j} \left \| x_j - W(t(j,yj); t(i, yi))x_i \right \|^2 \tag{10}\]</span></p><p>请注意，这是一个非线性优化问题。许多非线性优化器可用于最小化我们的目标函数。 然而，我们发现通过直接目标函数评估的坐标下降可以快速收敛。每次我们在目标函数 J 不减小的情况下迈出一步，我们就反转步长方向并减小相应参数的步长。一旦所有参数的步长降到所需阈值以下（即，当我们达到目标精度时），算法就会终止。对于时长约 10 秒的校准视频，我们的 Matlab/C++ 实现通常会在 2 秒内收敛。</p><p>我们通过将焦距设置为相机具有 45° 的视野来初始化优化算法，并将所有其他参数设置为 0。我们发现在这些初始条件下，优化器收敛到我们数据集的正确解。 更一般地，我们可以通过重新启动我们的坐标下降算法以获取一系列合理参数并选择最佳解决方案来避免陷入局部最小值（例如，当陀螺仪和帧时间戳之间的延迟很大时）。正确恢复参数的平均重新投影误差通常约为 1 个像素。</p><p>我们模型中的另一个未知数是陀螺仪与相机的相对方向。 例如，绕陀螺仪 y 轴的旋转可以对应于绕相机 x 轴的旋转。为了发现陀螺仪的方向，我们排列了它的 3 个旋转轴并为每个排列运行我们的优化器，最小化目标的排列最好对应于相机的轴顺序。我们发现不正确排列的重投影误差要大得多。 因此，这种方法在实践中效果很好。</p><p>在我们的讨论中，我们假设相机具有垂直滚动快门。RS 模型可以很容易地修改为适用于图像列而不是行。 找到两种情况下的最小重投影误差将告诉我们相机是否具有水平或垂直滚动快门。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/dvs7.png"></p><p>最后，为了更好地了解校准所获得的结果，我们展示了校准前后视频和陀螺仪信号的可视化效果。 如果我们假设连续帧之间的旋转很小，那么图像中的平移可以通过旋转近似计算如下：</p><p><span class="math display">\[\dot{x} \approx f * \hat{\omega }(t+t_d), where \left\{\begin{matrix}\dot{x} = (\dot{x},\dot{y})^T\\\dot{y} = (w_y,w_x)^T\end{matrix}\right. \tag{11}\]</span></p><p>在这里，我们还假设滚动快门没有影响（即 <span class="math inline">\(t_s\)</span> = 0），并且我们忽略绕 z 轴的旋转（即 <span class="math inline">\(\omega_z\)</span>）。 我们让 <span class="math inline">\(\dot{x}\)</span> 是连续帧中所有点对应沿 x 和 y 的平均平移率。 如果我们的优化器收敛到正确的焦距 f 和陀螺延迟 <span class="math inline">\(t_d\)</span>，那么两个信号应该对齐。 图 7 绘制了对齐前后信号 <span class="math inline">\(\dot{x}\)</span> 和 <span class="math inline">\(f ∗ \hat{\omega }(t + t_d)\)</span> 的第一维。 请注意陀螺仪数据与图像运动的匹配程度。 MEMS 陀螺仪的这种惊人的精度使我们的方法能够在视频稳定和滚动快门校正任务上表现良好。</p><h1 id="参考文献">参考文献</h1><p>&lt; Digital Video Stabilization and Rolling Shutter Correction using Gyroscopes &gt;</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 IMU 传感器的视频稳定混合运动估计</title>
      <link href="/next/2021/Science/HybridMotionEstimationForVideoStabilizationBasedOnIMUSensor/"/>
      <url>/next/2021/Science/HybridMotionEstimationForVideoStabilizationBasedOnIMUSensor/</url>
      
        <content type="html"><![CDATA[<h2 id="abstract">Abstract</h2><p>在本文中，我们提出了一种混合方法来估计运动并通过切换函数稳定视频，该方法在 Kanade-Lucus-Tomasi (KLT) 跟踪器和 IMU 辅助运动估计器之间切换估计的运动。为了实现这一点，由于 KLT 跟踪器在较大运动期间的性能不佳，我们使用 KLT 跟踪器来校正低旋转的运动，并使用 IMU 辅助运动估计器来校正高旋转，此外，卡尔曼滤波器用于去除不需要的运动，从而平滑轨迹。</p><span id="more"></span><h1 id="introduction">Introduction</h1><p>在相机市场，光学图像稳定（OIS）系统安装在相机镜头或图像传感器上，价格相当昂贵 [3]。另一方面，数字稳定系统通过在相机移动时补偿捕获图像的移动来处理图像，它可以分为三个步骤，即运动估计、运动平滑和图像扭曲 [4,5]。</p><p>数字视频稳定中运动估计的常用技术是分别使用块匹配 [9]、KLT (Kanade-Lucus-Tomasi) 跟踪器 [10,11]、SIFT [12] 和 SURF [13]。最近，Dong et al. [14] and Lim 等人 [15] 使用 KLT 跟踪器以高帧率和低计算成本实时估计运动， KLT 跟踪器通过 Good Feature to Track 检测特征点，并使用 Lucas-Kanade 方法估计连续帧的光流。该跟踪器在评估小运动中的运动方面取得了成功，但在局部运动和全局运动发生显着变化时失败 [15]，然而，可以通过使用 IMU（惯性测量单元）数据来估计大运动。</p><p>我们提出了一种混合函数来切换运动估计算法，以确定两个连续帧之间的转换。 在低运动的情况下，我们应用 KLT 跟踪器来计算两个连续帧上运动物体的光流。 然而，在快速旋转的情况下，来自 IMU 传感器的旋转数据用于通过计算来自预定义运动点和参考点的运动来估计运动。</p><h1 id="related-work">Related Work</h1><p>Karpenko 等人 [3] 仅使用陀螺仪数据创建滚动快门以实现视频稳定。此外，一些研究分别包括 IMU 数据和特征跟踪，例如 Ryu 等人 [26] 提出了通过将旋转运动纳入 KLT 跟踪的运动估计，它使用来自 IMU 的位置来预测下一帧，从而证明速度和准确性。</p><h1 id="proposed-framework">Proposed Framework</h1><p>本文的挑战是如何估计连续帧在移动相机上的运动，例如，由于相机旋转引起的大旋转和基于场景中运动物体的局部运动。 根据我们的目标，我们应用了一种混合方法来近似确定估计移动相机运动的方法，如图 1 中的流程图所示。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm1.png"></p><p>为了使用混合方法估计运动，我们采用由 IMU 传感器 <span class="math inline">\(w^{imu}\)</span> 测量和相机<span class="math inline">\(w^{cam}\)</span>的旋转速度来确定估计方法。 但是，这两个设备是不同的位置，因此我们需要将<span class="math inline">\(w^{imu}\)</span>转换为具有相对方向 <span class="math inline">\(R^{ci}\)</span> 的 <span class="math inline">\(w^{cam}\)</span>。 因此，相机的旋转速度定义为：</p><p><span class="math display">\[w^{cam}(t+t_{off}) = R^{ci}(w^{imu}(t) + b^{imu}) \tag1\]</span></p><p>其中 <span class="math inline">\(b^{imu}\)</span> 是陀螺仪偏置，<span class="math inline">\(t_{off}\)</span> 表示来自 IMU 的时间戳与 Cam 时间戳的时间偏移。相机和 IMU 传感器校准如下：</p><ul><li>使用 OpenCV（开源计算机视觉）中的相机校准模块校准相机以找出焦距（f）。</li><li>校准陀螺仪以防止陀螺仪漂移问题与偏置偏移。我们可以通过测量陀螺仪长时间静止时的输出信号来评估偏置偏移，并通过卡尔曼滤波器降低噪声。</li><li>使用 Li 和 Ren [16] 提出的陀螺仪数据和光流之间的关系估计 <span class="math inline">\(R^{ci}\)</span>，使用 CC+LS13 方法。</li><li>确定陀螺仪和相机输入之间的 <span class="math inline">\(t_{off}\)</span> 时间偏差。然后，我们可以正确估计<span class="math inline">\(w^{cam}\)</span>。</li></ul><h1 id="motion-estimation">Motion Estimation</h1><p>为了挑战每个环境中的运动估计，我们开发了一种可靠且有效的方法，用于通过混合算法切换算法，以计算连续帧的运动流。 该方法分为两个功能，其中包括 KLT 跟踪器和 IMU 辅助运动估计器。</p><h2 id="a-klt-tracker">A KLT Tracker</h2><p>如果 <span class="math inline">\(w^{cam}\)</span> z 的绝对值小于 0.5 rad/s，则刚性变换由相应的特征点集估计。 我们使用 Good Feature to Track，这是一种实时计算光流的高效检测器。特征点由 Harris 角点检测器检测，该检测器使用强度差异对 (u, v) 在所有方向上的位移，定义如下：</p><p><span class="math display">\[\varepsilon (u,v) = \sum_{x,y}^{} w(x,y)[I(x+u,y+v) - I(x,y)]^2 \\\approx \begin{bmatrix} u &amp; v\end{bmatrix} M \begin{bmatrix} u\\ v \end{bmatrix} \tag2\]</span></p><p>其中 <span class="math inline">\(I(x, y)\)</span> 表示来自参考图像的图像像素，而 <span class="math inline">\(I(x + u, y + v)\)</span> 是下一张图像的图像像素。 <span class="math inline">\(w(x, y)\)</span> 是一个高斯函数，它为周围的像素分配权重，<span class="math inline">\(M\)</span> 是从特征点的指定邻域中函数的梯度导出的汇总矩阵。此外，由 Shi-Tomasi [29] 修改的 Harris 角点检测器得分函数是：</p><p><span class="math display">\[R = min(\lambda _1,\lambda _2) \tag3\]</span></p><p>其中 <span class="math inline">\(\lambda _1\)</span> 和 <span class="math inline">\(\lambda _2\)</span> 是 M 的特征值。 R 的结果可以分为三种情况：</p><ol type="1"><li>如果<span class="math inline">\(\lambda _1\)</span>和<span class="math inline">\(\lambda _2\)</span>都小，这意味着 R 也小，则该区域是平坦的；</li><li>如果<span class="math inline">\(\lambda _1\)</span>大于<span class="math inline">\(\lambda _2\)</span>，则 R 为负，则该区域为边；</li><li>如果<span class="math inline">\(\lambda _1\)</span>和<span class="math inline">\(\lambda _2\)</span>都大，则 R 大，区域为 corner。</li></ol><p>这种改进后的方法被称为 Good Feature to Track。</p><p>然而，为了实时运行算法，特征点和它们的匹配在计算时间内必须在两个连续的帧内。我们对拼接全景图进行了实验，以确认一定数量的特征点的效率，这对于单应矩阵来说是足够的。 图 2a 显示了拼接前的原始图像，图 2b、c 分别说明了使用 200 个特征点和 2000 个特征点的全景图像。 这些图像是相似的，但大特征点过度计算了拼接图像。因此，我们提出的方法使用少于 200 个特征点来允许对运动变换的合理估计。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm2.png"></p><p>两个连续帧之间的特征点匹配需要快速逼近，因此，我们使用光流来匹配检测到的角点。光流是图像对象在连续帧之间由于物体或相机的运动而产生的明显运动的模式。它表示角点在 dt 时间后从前一帧 <span class="math inline">\(I(x, y, t)\)</span> 移动到当前帧时 2D 矢量场 <span class="math inline">\((dx, dy)\)</span> 的位移。 光流假设亮度不变，则给出以下等式：</p><p><span class="math display">\[I(x,y,t) = I(x+d_x, y+d_y, t+d_t) \tag4\]</span></p><p>等式（4）可以通过去除公共项并在右手边采取泰勒级数近似后除以 dt 以简单的形式表述。 我们获得了图像梯度 <span class="math inline">\(f_x\)</span> 和 <span class="math inline">\(f_y\)</span> 以及沿时间 <span class="math inline">\(f_t\)</span> 的梯度以编写以下等式：</p><p><span class="math display">\[f_xu + f_yv + f_t = 0 \tag5\]</span></p><p><span class="math display">\[f_x = \frac{\partial f}{\partial x}; f_y = \frac{\partial f}{\partial y}; u = \frac{d_x}{d_t}; v = \frac{d_y}{d_t} \tag6\]</span></p><p>然而，式 (5) 在一个方程中有两个未知数 (u, v)。 一些研究人员提出了解决这个问题的方法，但我们使用了 Lucas-Kanade 方法，这是估计光流的标准方法。 Lucas-Kanade 通过在拐角点周围取 3 × 3 块的相邻像素解决了这个问题，假设所有 9 个点都具有相同的运动。 然后，可以使用最小二乘拟合方法求解具有正确方程的两个未知数，其定义如下：</p><p><span class="math display">\[\begin{bmatrix} u \\ v \end{bmatrix} =\begin{bmatrix} \sum_{i}^{}f_{x_i}^2   &amp; \sum_{i}^{}f_{x_i}f_{y_i}  \\ \sum_{i}^{}f_{x_i}f_{y_i}  &amp; \sum_{i}^{}f_{y_i}^2  \end{bmatrix}^{-1}\begin{bmatrix} -\sum_{i}^{}f_{x_i}f_{t_i} \\ -\sum_{i}^{}f_{y_i}f_{t_i} \end{bmatrix}  \tag7\]</span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm3.png"></p><p>例如，图 3a、b 分别显示了在正常运动和快速运动期间来自 KLT 特征跟踪器的光流。 后一种运动情况是无序的，导致对单应矩阵的估计效率低下。在大运动期间，KLT 特征跟踪器确实失败了。因此，我们在大运动的情况下使用 IMU 辅助的运动估计器方法来减少任何运动矢量误差。</p><p>总之，KLT 跟踪器已经根据前一帧中的特征点和当前帧中移动到新位置的特征点创建了运动向量。 这两组来自 KLT 跟踪器的特征点用于估计刚性变换的单应矩阵以稳定图像帧。</p><h2 id="an-imu-aided-motion-estimator">An IMU-Aided Motion Estimator</h2><p>在<span class="math inline">\(w_{𝑧}^{𝑐𝑎𝑚}\)</span> 的绝对值大于 0.5 rad/s 的情况下，IMU 传感器将估计运动。 首先，我们需要在第一张图像<span class="math inline">\(I_0(x_{ij}, y_{ij})\)</span>上创建参考点的集合为如图 4 所示，由 <span class="math inline">\((i, j)\)</span> 的对称分布点组成。 <span class="math inline">\((i, j)\)</span> 的大小由 $(2e + 1) x(2f + 1), e , f = 1, 2, ..., n $计算，其中 e 和 f 应在 5 到 30 之间，以准确地近似运动 分别在 x 和 y 方向上的计算负载。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm4.png"></p><p><span class="math inline">\(I_0(x_{ij}, y_{ij})\)</span> 的所有参考点都位于图像中心 <span class="math inline">\((x0, y0)\)</span> 的周围，由以下等式确定： <span class="math display">\[\left\{\begin{matrix}x_{ij} = x_0 - \frac{x_{sp}(2e-1)}{2} + ix_{sp} \\y_{ij} = y_0 - \frac{y_{sp}(2f-1)}{2} + jy_{sp}\end{matrix}\right. \tag8\]</span></p><p>其中 <span class="math inline">\(x_{sp}\)</span> 和 <span class="math inline">\(y_{sp}\)</span> 分别是 x 和 y 方向参考点之间的像素空间。下一帧上的运动点<span class="math inline">\(I_{imu}(p, q)\)</span>可以从 (1) 中 z 轴上的 <span class="math inline">\(w_{cam}\)</span> 计算得出：</p><p><span class="math display">\[\left\{\begin{matrix}p = (x_{ij} - \frac{H}{2} ) \cos \varphi + (y_{ij} - \frac{W}{2} ) \sin \varphi + \frac{H}{2}  \\Q = (x_{ij} - \frac{H}{2} ) \sin \varphi + (y_{ij} - \frac{W}{2} ) \cos \varphi + \frac{W}{2}\end{matrix}\right. \tag9\]</span></p><p>其中 j 等于<span class="math inline">\(w_{z}^{cam}\)</span> 除以输入视频的帧率，H 和 W 分别是图像的高度和宽度。然而，Li 和 Ren [16] 进行了 z 轴旋转运动具有抵消作用的运动点，表示如下：</p><p><span class="math display">\[\varphi =\left\{\begin{matrix}-\frac{8}{F_{fps}}, w_{z}^{cam} &lt; -6 \\-\frac{4}{F_{fps}}, -6 \le w_{z}^{cam}\le -2\\0,  0.5 \le \left | w_{z}^{cam} \right | \le 2 \\\frac{4}{F_{fps}}, 2 \le w_{z}^{cam}\le 6 \\\frac{8}{F_{fps}}, w_{z}^{cam} &gt; 6\end{matrix}\right. \tag{10}\]</span></p><ol start="9" type="1"><li>和 (10) 可以由来自 IMU 传感器的运动矢量合成。运动矢量的方向和大小取决于测量的旋转。 图 5 显示了从一组具有不同 φ 值的点计算的运动矢量，对于图 5a 中的低旋转速率，运动矢量在方向和大小方面相似。另外，快速旋转中运动矢量在不同的方向和大小上是有序的，如图 5b,c <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm5.png"></li></ol><p>来自 IMU 传感器的一组参考点和新位置点被应用于估计刚性变换的单应性矩阵。两种方法的运动流比较运动矢量如图 6 所示，KLT 跟踪器的光流为快速运动矢量如图 6 所示，同时组织从 IMU 数据估计运动。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm6.png"></p><p>上一步中参考图像（S0）和当前图像（Sn）的近似设定点用于定义运动模型。运动估计通过找到 2 × 2 矩阵 A 和 2 × 1 向量 t 来近似这些设定点之间的仿射变换 [A|t]，其公式如下所示：</p><p><span class="math display">\[[A^*|t^*] = arg min\sum_{i}^{} \begin{Vmatrix}S_0[i] - AS_n[i]^T - t\end{Vmatrix}^2 \tag{11}\]</span></p><p>为了求解（11）中的 <span class="math inline">\([A|t]\)</span>，匹配对最少需要三对才能生成仿射变换。 因此，运动估计被发现为仿射变换，应用于 <span class="math inline">\(I(x, y)\)</span>以映射变形图像<span class="math inline">\(I_{warp}(x', y')\)</span>。</p><p><span class="math display">\[\begin{bmatrix} x'\\ y'\\ 1 \end{bmatrix} =\begin{bmatrix} S \cos \theta   &amp; -S \sin \theta   &amp; t_x\\ S \sin \theta  &amp; S \cos \theta &amp; t_y\\ 0  &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix} x\\ y\\ 1 \end{bmatrix} \tag{12}\]</span></p><p>自由度 (12) 包括标度 (S)、旋转角度 (q) 以及 x 轴和 y 轴上的平移<span class="math inline">\(t_x\)</span> 和 <span class="math inline">\(t_y\)</span>。 因此，式 (12) 中的总自由度为 4，称为相似变换。 然而，在本文中，我们使用刚性变换来扭曲稳定的框架，使尺度等于 1，以减少用于计算尺度向量的存储区域</p><h1 id="motion-smoothing-and-image-warping">Motion Smoothing and Image Warping</h1><p>为了从估计的运动中去除噪声，我们使用卡尔曼滤波器来减少噪声并获得平滑的运动 [30]。 卡尔曼滤波器通过使用前一个状态 [31] 来近似下一个状态，这适合连续帧的动态系统。<span class="math inline">\(x_k\)</span>的预测状态由下式给出：</p><p><span class="math display">\[x_k = F_{x_{k-1}} + B_{u_k} + w_k \tag{13}\]</span></p><p>其中 F 矩阵是前一状态 <span class="math inline">\(x_{k−1}\)</span> 中的状态转移模型，B 矩阵是控制输入模型，<span class="math inline">\(u_k\)</span>是控制向量，<span class="math inline">\(w_k\)</span>是高斯分布中的过程噪声。 系统状态<span class="math inline">\(x_k\)</span>在时间 k 的状态<span class="math inline">\(z_k\)</span>由下式给出：</p><p><span class="math display">\[z_k = H_kx_k + v_k \tag{14}\]</span></p><p>其中 <span class="math inline">\(H_k\)</span> 和<span class="math inline">\(v_k\)</span>分别是观测矩阵和观测噪声。 来自卡尔曼滤波器的过滤运动以平滑的轨迹扭曲了稳定的框架。 因此，刚性变换的校正可以发现为：</p><p><span class="math display">\[\begin{bmatrix} x_{sta} \\ y_{sta} \\ 1 \end{bmatrix} = \begin{bmatrix}\cos (\theta - \hat{\theta} )  &amp; -\sin (\theta - \hat{\theta} ) &amp; t_x - \hat{t_x}\\\sin (\theta - \hat{\theta} )  &amp; \cos (\theta - \hat{\theta} ) &amp; t_y - \hat{t_y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} \tag{15}\]</span></p><p>其中 <span class="math inline">\((\hat{\theta},\hat{t_x},\hat{t_y})\)</span>是来自卡尔曼滤波器的滤波后的运动。 稳定的视频是用这种校正运动和平滑轨迹创建的。</p><h1 id="experimental-results-and-discussion">Experimental Results and Discussion</h1><p>假设 IMU 和 Camera 之间的延迟是常数 [32]。它可以通过应用围绕 z 轴移动相机以测量 <span class="math inline">\(w_z^{cam}\)</span> 所需的小正弦信号来识别偏移时间。然后，对光流和陀螺数据的平均幅度进行比较，如图 9 所示，光流是用图像插值算法 [33] 估计的，陀螺数据由等式（1）计算。 来自光流和陀螺仪数据的存档数据包含相同的相位，因此由<span class="math inline">\(t_{off}\)</span> 表示的两个测量数据之间的最大相位滞后等于 -0.035 s， <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/EIS/ahm10.png"></p><p>我们提出的方法与独立的 KTL 跟踪器和 IMU 辅助运动估计器进行了比较。 为了合理的评估稳定视频的性能，我们使用帧间变换保真度（ITF）[34] 通过总结峰值信噪比（PSNR）以单个值表示稳定视频的质量 ，由下式给出：</p><p><span class="math display">\[ITF = \frac{1}{N_{max}-1} \sum_{k=1}^{N_{max}-1}  PSNR \tag{16}\]</span></p><p>其中<span class="math inline">\(N_{max}\)</span>是帧数，PSNR 用于执行稳定方法的有效性，其定义为：</p><p><span class="math display">\[PSNR(I_n, I_{n+1}) = 10log\frac{I_{max}^2}{MSE(I_n,I_{i+1})}  \tag{17}\]</span></p><p>其中<span class="math inline">\(I_max\)</span>是视频帧的最大像素强度，MSE 是连续两个帧之间的均方误差，<span class="math inline">\(I_n\)</span>和<span class="math inline">\(I_{n+1}\)</span>，在稳定视频中连续帧的每个像素中计算，可以定义为：</p><p><span class="math display">\[MSE(I_n,I_{i+1}) = \frac{1}{MN}\sum_{j=1}^{N}\sum_{i=1}^{M}(I_n(i,j) - I_{n+1}(i,j))^2  \tag{18}\]</span></p><p>其中 N 和 M 是视频尺寸。 ITF 和 PSNR 的高代表稳定视频的质量。</p><h1 id="参考文献">参考文献</h1><p>&lt; A Hybrid Motion Estimation for Video Stabilization Based on an IMU Sensor &gt;</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EIS 电子防抖基本原理</title>
      <link href="/next/2021/Science/BasicPrinciplesOfEISElectronicImageStabilization/"/>
      <url>/next/2021/Science/BasicPrinciplesOfEISElectronicImageStabilization/</url>
      
        <content type="html"><![CDATA[<h1 id="投影">投影</h1><p>这里以小孔成像模型为例，全相模型是相同的流程只是投影模型不一样而已。在相机校准模型一文中已经介绍了将像素坐标系变换到相机坐标系中 <a href="https://carlyleliu.github.io/2021/Camera/CameraCalibrationModel/">相机校准模型</a> 如下：</p><p><span class="math display">\[\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \frac{1}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{1}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\&nbsp; y \\ 1 \end{bmatrix} = \frac{1}{z_c}\begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x_c\\&nbsp; y_c\\&nbsp; z_c \end{bmatrix}\]</span></p><p>这里我们取 <span class="math inline">\(z_c = 1\)</span> 再做一个变换得到：</p><p><span class="math display">\[\begin{bmatrix} x_c\\&nbsp; y_c\\&nbsp; z_c \end{bmatrix} =\begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} ^{-1} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix}\]</span></p><p>我们记 ：</p><p><span class="math display">\[K_{内参}^{-1} = \begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} ^{-1} \]</span></p><p>则将像素坐标系与该矩阵相乘就可以将像素坐标系转换到相机坐标系上，待后面使用。</p><h1 id="imu-数据处理">IMU 数据处理</h1><p>具体可以参考 <a href="https://carlyleliu.github.io/2020/Algorithm/imuAttitudeCalculation/">imu 姿态解算</a> 一文，我们需要对 IMU 数据做三件事情：</p><ul><li>IMU 坐标系对齐相机坐标系，这一步目的为了将 IMU 的正交三轴数据与 Camera 坐标系对齐。</li><li><p>卡尔曼滤波：为了消除 IMU 的系统误差以及如果要做重力矫正需要做姿态解算（重力对齐）。这里常用的就是卡尔曼滤波和 mahony 滤波，这一层滤波的目的就是为了得到更为准确的相机姿态和相机抖动状态，如下图所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/lpf.png"></p></li><li><p>平滑滤波：在我们得到相机的抖动状态就可以对相机的姿态做一个平滑滤波（可以采用四元数求平均，或者高斯滤波等算法），这个平滑滤波的目的是为了得到相机防抖后想要得到的状态。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ISP/anl5.png"></p></li></ul><p>我们将从 Large inner region 曲线或者 Small inner region 曲线到 Input 曲线的变换矩阵记为 <span class="math inline">\(M(\alpha, \beta, \gamma)\)</span> 为了简化模型这里面的数据是已经将 IMU 坐标系变化到相机坐标系下的变换矩阵。</p><p>到这里我们就得到了两条曲线和一个变换矩阵。</p><h1 id="求透视变换矩阵">求透视变换矩阵</h1><p>这里我们记旋转矩阵为：</p><p><span class="math display">\[\begin{aligned}M(\alpha, \beta, \gamma) &amp; =\left[\begin{array}{ccc}\cos \gamma &amp; -\sin \gamma &amp; 0 \\\sin \gamma &amp; \cos \gamma &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{ccc}\cos \beta &amp; 0 &amp; \sin \beta \\0 &amp; 1 &amp; 0 \\-\sin \beta &amp; 0 &amp; \cos \beta\end{array}\right]\left[\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \cos \alpha &amp; -\sin \alpha \\0 &amp; \sin \alpha &amp; \cos \alpha\end{array}\right] \\&amp; =\left[\begin{array}{ccc}\cos \gamma \cos \beta &amp; -\sin \gamma &amp; \cos \gamma \sin \beta \\\sin \gamma \cos \beta &amp; \cos \gamma &amp; \sin \gamma \sin \beta \\-\sin \beta &amp; 0 &amp; \cos \beta\end{array}\right]\left[\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \cos \alpha &amp; -\sin \alpha \\0 &amp; \sin \alpha &amp; \cos \alpha\end{array}\right] \\&amp; =\left[\begin{array}{ccc}\cos \gamma \cos \beta &amp; -\sin \gamma \cos \alpha+\cos \gamma \sin \beta \sin \alpha &amp; \sin \gamma \sin \alpha+\cos \gamma \sin \beta \cos \alpha \\\sin \gamma \cos \beta &amp; \cos \gamma \cos \alpha+\sin \gamma \sin \beta \sin \alpha &amp; -\cos \gamma \sin \alpha+\sin \gamma \sin \beta \cos \alpha \\-\sin \beta &amp; \cos \beta \sin \alpha &amp; \cos \beta \cos \alpha\end{array}\right]\end{aligned}\]</span></p><p>综合前面两节的内容我们可以通过如下公式得到投影变换矩阵 R：</p><p><span class="math display">\[R = K_{内参}^{-1} \ast M(\alpha ,\beta ,\gamma ) \ast K_{内参}\]</span></p><p>改写成完整的公式如下：</p><p><span class="math display">\[R = \begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix}^{-1} \ast \left[\begin{array}{ccc}\cos \gamma \cos \beta &amp; -\sin \gamma \cos \alpha+\cos \gamma \sin \beta \sin \alpha &amp; \sin \gamma \sin \alpha+\cos \gamma \sin \beta \cos \alpha \\\sin \gamma \cos \beta &amp; \cos \gamma \cos \alpha+\sin \gamma \sin \beta \sin \alpha &amp; -\cos \gamma \sin \alpha+\sin \gamma \sin \beta \cos \alpha \\-\sin \beta &amp; \cos \beta \sin \alpha &amp; \cos \beta \cos \alpha\end{array}\right] \ast \begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\]</span></p><p>该公式是通过相机的内参矩阵将像素坐标系变换到相机坐标系，然后通过 IMU 得到相机的姿态，将相机坐标系变换到世界坐标系下对相机的姿态进行稳定，得到稳定后的相机姿态，再将上述矩阵的逆乘起来变换回像素坐标系。这样就得到了透视变换的矩阵，将像素的坐标与该 R 矩阵相乘就得到了该像素防抖后的坐标值（就是 opencv 里的 remap）。</p><h1 id="特别注意">特别注意</h1><ul><li>在做 IMU 姿态解算的时候要给陀螺仪足够的置信度，不然可能很难得到较好的防抖效果。</li><li>要将视频帧的时间戳与 IMU 的时间戳对齐，不然一定不能得到较好的效果，笔者没有研究好这块算法手动试出来的，精度要在 1ms 内才行，另外有香港科技大学的 VIO 项目里面有相关论文和实现可以参考。</li><li>rollingshutter 需要矫正，其实算法上需要做的就是找到帧曝光开始和结束的时刻，然后将旋转矩阵按行进行插值得到每一行的矩阵然后分别对每一行进行应用 remap 就可以了。</li><li>这里没有考虑破图问题，实际工程中要考虑破图问题。</li><li>这里存在一个问题就是将原图乘透视变换矩阵得到的坐标值大概率是浮点值，但是像素坐标系下只有蒸熟点那么就会造成画质损失，如果想改善这个，可以通过将目标图像乘矩阵 R 的逆得到原图的坐标点，当然这里也会得到浮点坐标坐标值，但是对于原图我们可以通过双线性插值得到变换后的图像值（注意这里是操作图像值而不是坐标值了）。</li><li>实际使用中一般不会直接使用旋转矩阵，会改用四元数来处理，便于插值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机校准模型</title>
      <link href="/next/2021/Camera/CameraCalibrationModel/"/>
      <url>/next/2021/Camera/CameraCalibrationModel/</url>
      
        <content type="html"><![CDATA[<h1 id="小孔成像模型">小孔成像模型</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/CoordinateSystem1.png"></p><span id="more"></span><h1 id="各坐标系定义及相机的内参和外参">各坐标系定义及相机的内参和外参</h1><h2 id="像素坐标系">像素坐标系</h2><p>像素坐标就是像素在图像中的位置。一般像素坐标系的左上角的顶点就是原点，水平向右是 u，垂直向下是 v 轴。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/PixelCoordinateSystem.png"></p><h2 id="图像坐标系">图像坐标系</h2><p>在像素坐标系中，每个像素的坐标是用像素来表示的，然而，像素的表示方法却不能反应图像中物体的物理尺寸，因此，有必要将像素坐标转换为图像坐标。将像素坐标系的原点平移到图像的中心，就定为图像坐标系的原点，图像坐标系的 x 轴与像素坐标系的 u 轴平行，方向相同，而图像坐标系的 y 轴与像素坐标系的 v 轴平行，方向相同。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/ImageCoordinateSystem.png"></p><p>在图中，假设在像素坐标系下图像中心的像素坐标是（u0,v0），相机中感光器件每个像素的物理尺寸是 dx * dy，那么，图像坐标系的坐标（x,y）与像素坐标系的坐标（u,v）之间的关系可以表示为：</p><p><span class="math display">\[u = \frac{x}{d_x} + u_0 \\         v = \frac{y}{d_y} + v_0 \]</span></p><p>写成矩阵的形式就为：</p><p><span class="math display">\[\begin{bmatrix} u \\  v \end{bmatrix} = \begin{bmatrix} \frac{1}{d_x} &amp; 0 \\ 0 &amp; \frac{1}{d_y} \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} + \begin{bmatrix} u_0\\  v_0 \end{bmatrix}\]</span></p><p>改写为齐次坐标的形式：</p><p><span class="math display">\[\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \frac{1}{d_x}&amp; 0 &amp;0 \\ 0 &amp; \frac{1}{d_y} &amp; 0\\ 0 &amp; 0 &amp; 0 \end{bmatrix} \begin{bmatrix} x \\  y \\ 0 \end{bmatrix} + \begin{bmatrix} u_o \\  v_o \\ 1 \end{bmatrix} = \begin{bmatrix} \frac{1}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{1}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\  y \\ 1 \end{bmatrix}\]</span></p><h2 id="相机坐标系">相机坐标系</h2><p>相机坐标系是以相机的光轴作为 Z 轴，光线在相机光学系统的中心位置就是原点 Oc（实际上就是透镜的中心）, 相机坐标系的水平轴 Xc 与垂直轴 Yc 分别于图像坐标系的 X 轴和 Y 轴平行。在图中，相机坐标系的原点与图像坐标系的原点之间的距离 OcOi 之间的距离为 f（也就是焦距）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Camera1CoordinateSystem.png"></p><p>假设，三维空间中点 P, 其在相机坐标系下坐标为<span class="math inline">\(P_c = [x_c,y_c,z_c]^T\)</span>; 其像点 p，在图像坐标系中坐标为。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/Camera2CoordinateSystem.png"></p><p>由相似三角形原理，得到</p><p><span class="math display">\[\frac{f}{z_c} = \frac{x}{x_c} = \frac{y}{y_c} \\ x = f \frac{x_c}{z_c},  y = f \frac{y_c}{z_c} \]</span></p><p>用向量表示为：</p><p><span class="math display">\[\begin{bmatrix} x\\ y\\ 1 \end{bmatrix} = \frac{1}{z_c}\begin{bmatrix} f &amp;0&nbsp; &amp;0 \\&nbsp; 0 &amp; f &amp; 0\\&nbsp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x_c\\&nbsp; y_c\\&nbsp; z_c \end{bmatrix}\]</span></p><p>进一步可以写为：</p><p><span class="math display">\[\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \frac{1}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{1}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\&nbsp; y \\ 1 \end{bmatrix} = \frac{1}{z_c}\begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x_c\\&nbsp; y_c\\&nbsp; z_c \end{bmatrix}\]</span></p><p>到这里<span class="math inline">\(\begin{bmatrix} \frac{f}{d_x}&amp; 0 &amp;u_o \\ 0 &amp; \frac{f}{d_y}&amp; v_0\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span> <strong>就是相机的内参矩阵，跟相机的焦距和传感器的大小等参数有关</strong>。</p><h2 id="世界坐标系">世界坐标系</h2><p>界坐标系是图像与真实物体之间的一个映射关系。如果是单目视觉的话，主要就是真实物体尺寸与图像尺寸的映射关系。如果是多目视觉的话，那么就需要知道多个相机之间的关系，这个关系就需要在同一个坐标系下进行换算。在下图中，世界坐标系的原点是 Ow, 而 Xw,Yw,Zw 轴并不是与其他坐标系平行的，而是有一定的角度，并且有一定的平移。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/CoordinateSystem1.png"></p><p>对于世界坐标系到相机坐标系的转换是刚体变换，是旋转动作和平移动作的结果，如下：</p><p><span class="math display">\[\begin{bmatrix} x_c\\&nbsp; y_c\\&nbsp; z_c\\&nbsp; 1 \end{bmatrix} = \begin{bmatrix}R &amp; t\\ 0 &amp; 1 \end{bmatrix}\begin{bmatrix} x_w\\&nbsp; y_w\\&nbsp; z_w\\&nbsp; 1 \end{bmatrix}\]</span></p><p>这里<span class="math inline">\(\begin{bmatrix}R &amp; t\\ 0 &amp; 1 \end{bmatrix}\)</span>就是相机的外参矩阵，R 是相机相对世界坐标系的旋转关系，t 是相机相对于世界坐标系的平移关系，当相机位姿发生变化，该参数也相应的发生变化**。</p><h1 id="图像畸变及畸变矫正">图像畸变及畸变矫正</h1><h2 id="径向畸变">径向畸变</h2><p>径向畸变：是由于透镜形状的制造工艺导致，且越向透镜边缘移动径向畸变越严重，实际情况中我们常用 r=0 处的泰勒级数展开的前几项来近似描述径向畸变，矫正径向畸变前后的坐标关系为： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/RadialDistortion.png"></p><p>径向畸变的矫正公式如下：</p><p><span class="math display">\[\begin{aligned}&amp;x_{rad}=x(1+k_1r^2+k_2r^4+k_3r^6) \\&amp;y_{rad}=y(1+k_1r^2+k_2r^4+k_3r^6)\end{aligned}\]</span></p><h2 id="切向畸变">切向畸变</h2><p>切向畸变：是由于透镜和 CMOS 或者 CCD 的安装位置误差导致，切向畸变需要两个额外的畸变参数来描述，矫正前后的坐标关系为： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/TangentialDistortion.png"></p><p>切向畸变的矫正公式如下（这里不给出推导过程，直接使用）：</p><p><span class="math display">\[x_{tan}=x+2p_1xy+p_2(r^2+2x^2)\\y_{tan}=y+p_1(r^2+2y^2)+2p_2xy\]</span></p><h2 id="畸变矫正">畸变矫正</h2><p>综合以上两种畸变，得到相机的畸变模型（纠正后的图像像素坐标系的坐标）：</p><p><span class="math display">\[\begin{aligned}&amp;r^2=x^2+y^2  \\ &amp;x_{distorted}=x(1+k_1r^2+k_2r^4+k_3r^6)+2p_1xy+p_2(r^2+2x^2) \\ &amp;y_{distorted}=y(1+k_1r^2+k_2r^4+k_3r^6)+p_1(r^2+2y^2)+2p_2xy\end{aligned}\]</span></p><p>其中 x,y 是是去畸变后的图像坐标，它是归一化的坐标，以图像中心为原点。r 为半径。<span class="math inline">\(x_{distorted}y_{distorted}\)</span>是具有畸变得图像坐标。</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image </tag>
            
            <tag> Stabilization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 V4L2 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverV4L2/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverV4L2/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>V4L2 是专门为 linux 设备设计的一套视频框架，其主体框架在 linux 内核，可以理解为是整个 linux 系统上面的视频源捕获驱动框架。其广泛应用在嵌入式设备以及移动端、个人电脑设备上面，市面上的编码产品类如：SDV、手机、IPC、行车记录仪都会用到这个框架来进行视频采集。</p><h1 id="框架">框架</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/V4L2_Framework.jpeg"></p><p>该图描述了 v4l2 驱动框架的整体结构，v4l2 本质上也是一个字符设备驱动程序，图中芯片模块对应 Soc 的各个子模块，video_device 结构体主要用来控制 Soc 的 video 模块，v4l2_device 会包含多个 v4l2_subdev ，每个 v4l2_subdev 用来控制各自的子模块，某些驱动不需要 v4l2_subdev ，依靠 video 模块就能实现功能。</p><ul><li>video_device：一个字符设备，为用户空间提供设备节点（/dev/videoX），提供系统调用的相关操作，是采集设备的抽象接口。</li><li>vb2_queue：与 vb2_v4l2_buffer 一起用于数据流的实际逻辑和 DMA 操作。</li><li>v4l2_device：表示一个 v4l2 设备的实例。</li><li>v4l2_subdev：属于 v4l2 设备的子设备，一个 v4l2 设备可以拥有多个子设备。</li><li>videobuf：v4l2 驱动的缓存管理。</li></ul><span id="more"></span><h1 id="数据结构">数据结构</h1><p>整体数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE3NTE2MTU2Mzc2ODkxMmI1NjMzNGUw">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/V4L2_Struct.png"></p><ul><li><p>v4l2_device：<br>这个是整个输入设备的总结构体，是所有子设备的根节点，负责管理所有子设备。由该结构体引申出来 v4l2_subdev。用于视频输入设备整体的管理，有多少输入设备就有多少个 v4l2_device 抽象（比如一个 USB 摄像头整体就可以看作是一个 V4L2 device）。再往下分是输入子设备，对应的是例如 ISP、CSI、MIPI 等设备，它们是从属于一个 V4L2 device 之下的</p></li><li><p>media_device：<br>用于运行时数据流的管理，嵌入在 V4L2 device 内部，运行时的意思就是：一个 V4L2 device 下属可能有非常多同类型的子设备（两个或者多个 sensor、ISP 等），那么在设备运行的时候我怎么知道我的数据流需要用到哪一个类型的哪一个子设备呢。这个时候就轮到 media_device 出手了，它为这一坨的子设备建立一条虚拟的连线，建立起来一个运行时的 pipeline（管道），并且可以在运行时动态改变、管理接入的设备</p></li><li><p>v4l2_ctrl_handler：<br>控制模块，提供子设备（主要是 video 和 ISP 设备）在用户空间的特效操作接口，比如你想改变下输出图像的亮度、对比度、饱和度等等，都可以通过这个来完成</p></li><li><p>v4l2_ctrl：<br>control 的结构体抽象，一个 control 就用一个实例化的 v4l2_ctrl 变量来表示</p></li><li><p>v4l2_ctrl_ref：<br>一个实例化的 v4l2_ctrl 的引用，可以看到该结构体里面包含了一个 struct v4l2_ctrl * 类型的指针变量成员，该指针成员指向的就是与之一一对应的 v4l2_ctrl 实例化对象</p></li><li><p>vb2_queue：<br>供内核与用户空间的 buffer 流转接口，输入设备产生了一坨图像数据，在内核里面应该放在哪里呢？能放几个呢？是整段连续的还是还是分段连续的又或者是物理不连续的？用户怎么去取用呢？都是它在管理</p></li></ul><p>entity、link 和 pad 该怎么理解呢，这里在网上找到一张图挺形象的，这里贴出来，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/entity.png"></p><p>待续。..</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZXNpb24uY29tL2FydGljbGUvMjEwOTk5NTk5Lw==">https://www.freesion.com/article/210999599/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95ZWxsb3dtYXguYmxvZy5jc2RuLm5ldC9hcnRpY2xlL2RldGFpbHMvODA3MTg4MzE=">https://yellowmax.blog.csdn.net/article/details/80718831<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95ZWxsb3dtYXguYmxvZy5jc2RuLm5ldC9hcnRpY2xlL2RldGFpbHMvODMyNDI0NDY=">https://yellowmax.blog.csdn.net/article/details/83242446<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MDQyMjcvYXJ0aWNsZS9kZXRhaWxzLzgwODg5OTQ3">https://blog.csdn.net/u013904227/article/details/80889947<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 Regulator 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverRegulator/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverRegulator/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>该框架旨在提供标准内核接口来控制电压和电流 Regulator。其目的是允许系统动态控制 Regulator 功率输出，以节省功率并延长电池寿命。 这适用于电压 Regulator（电压输出可控）和电流 Regulator（电流限制可控）。</p><span id="more"></span><h2 id="命名法">命名法</h2><ul><li><p>Regulator:<br>为其他设备供电的电子设备。大多数稳压器可以启用和禁用其输出，而有些可以控制其输出电压和/或电流。输入电压 -&gt; 稳压器 -&gt; 输出电压</p></li><li><p>PMIC:<br>电源管理 IC。 包含多个稳压器且通常包含其他子系统的 IC</p></li><li><p>Consumer:<br>由稳压器供电的电子设备。 消费者可分为两类：</p><p>静态：消费者不会改变其电源电压或电流限制。 它只需要启用或禁用其电源。 其电源电压由硬件、引导加载程序、固件或内核板初始化代码设置 动态：消费者需要改变其电源电压或电流限制以满足操作需求</p></li><li><p>Power Domain:<br>由稳压器、开关或其他电源域的输出电源提供其输入电源的电子电路。电源 Regulator 可能位于一个或多个开关后面，例如：</p><pre><code>  Regulator -+-&gt; Switch-1 -+-&gt; Switch-2 --&gt; [Consumer A]             |             |             |             +-&gt; [Consumer B], [Consumer C]             |             +-&gt; [Consumer D], [Consumer E]</code></pre><p>这是一个稳压器和三个电源域：</p><pre><code>  Domain 1: Switch-1, Consumers D &amp; E.  Domain 2: Switch-2, Consumers B &amp; C.  Domain 3: Consumer A.</code></pre><p>这代表了一种"supplies"关系：</p><pre><code>  Domain-1 --&gt; Domain-2 --&gt; Domain-3.</code></pre></li><li><p>Constraints:<br>约束用于定义性能和硬件保护的功率级别。约束存在于三个层面： 1、稳压器级别：这由稳压器硬件操作参数定义，并在稳压器数据表中指定，例如：</p><pre><code>  电压输出范围为 800mV -&gt; 3500mV  稳压器电流输出限制为 20mA @ 5V，但为 10mA @ 10V</code></pre><p>2、功率域级别：这是由内核级板初始化代码在软件中定义的。 它用于将功率域限制在特定的功率范围内，例如：</p><pre><code>  Domain-1 电压为 3300mV  Domain-2 电压为 1400mV -&gt; 1600mV  Domain-3 电流限制为 0mA -&gt; 20mA</code></pre><p>3、Consumer 级别：这是由 Consumer 驱动程序动态设置电压或电流限制级别定义的。例如 消费类背光驱动器要求将电流从 5mA 增加到 10mA，以增加 LCD 亮度。 这将通过以下级别：</p><pre><code>  Consumer：需要增加 LCD 亮度。 在亮度表中查找并请求下一个当前 mA 值（Consumer 驱动程序可用于基于相同参考设备的多个不同个性）  电源域：是此域和系统状态（例如电池电源、USB 电源）的域操作限制内的新电流限制  稳压器域：是输入/输出电压的稳压器操作参数内的新电流限制。</code></pre><p>如果 Regulator 请求通过所有约束测试，则应用新的 Regulator 值</p></li></ul><h2 id="design">Design</h2><p>Regulator 框架专为基于 SoC 的设备而设计，但也可能与非 SoC 设备相关，并分为以下四个接口：</p><ul><li><p>Consumer driver interface:<br>这使用与内核时钟接口类似的 API，因为 Consumer 驱动程序可以获取和放置一个 Regulator（就像他们可以使用时钟 atm）并获取/设置电压、电流限制、启用和禁用。 这应该允许 Consumer 完全控制他们的电源电压和电流限制</p></li><li><p>Regulator driver interface:<br>这允许 Regulator 驱动程序注册其 Regulator 并向内核提供操作。 它还具有用于向客户端传播事件的通知程序调用链</p></li><li><p>Machine interface:<br>此接口用于机器特定代码，并允许为每个稳压器创建电压/电流域（带约束）。 它可以提供稳压器约束，以防止由于有缺陷的客户端驱动程序引起的过压或过流而损坏设备。 它还允许创建 regulators 树，其中一些 regulators 由其他 regulators 提供（类似于时钟树）</p></li><li><p>Userspace ABI:<br>该框架还通过 sysfs 将许多有用的电压/电流/操作模式数据导出到用户空间。 这可用于帮助监控设备功耗和状态</p></li></ul><h1 id="regulator-consumer-driver-interface">Regulator Consumer Driver Interface</h1><p>本节描述了消费类设备驱动程序的调节器接口。</p><h2 id="consumer-regulator-access-static-dynamic-drivers">Consumer Regulator Access (static &amp; dynamic drivers)</h2><p>消费者驱动程序可以通过调用 regulator_get 访问其供应调节器：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regulator = regulator_get(dev, <span class="string">"Vcc"</span>);</span><br></pre></td></tr></tbody></table></figure><p>消费者传入其结构设备指针和电源 ID。 然后内核通过查询特定于机器的查找表找到正确的调节器。 如果查找成功，则此调用将返回一个指向提供此使用者的结构调节器的指针。</p><p>要释放调节器，消费者驱动程序应调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regulator_put(regulator);</span><br></pre></td></tr></tbody></table></figure><p>消费者可以由多个调节器供电，例如 具有模拟和数字电源的编解码器消费者：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">digital = regulator_get(dev, <span class="string">"Vcc"</span>);  <span class="comment">/* digital core */</span></span><br><span class="line">analog = regulator_get(dev, <span class="string">"Avdd"</span>);  <span class="comment">/* analog */</span></span><br></pre></td></tr></tbody></table></figure><p>调节器访问函数 regulator_get() 和 regulator_put() 通常会分别在您的设备驱动程序 probe() 和 remove() 中调用。</p><h2 id="regulator-output-enable-disable-static-dynamic-drivers">Regulator Output Enable &amp; Disable (static &amp; dynamic drivers)</h2><p>消费者可以通过调用 regulator_enable 启用调节器：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_enable</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在调用 regulator_enabled() 之前，电源可能已经启用。 如果消费者共享调节器或调节器先前已由引导加载程序或内核板初始化代码启用，则可能会发生这种情况。</p></blockquote><p>消费者可以通过调用 regulator_is_enabled 判断是否启用了调节器：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_is_enabled</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><p>当调节器启用时，这将返回大于零。</p><p>消费者可以在不再需要时通过调用禁用其供应：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_disable</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果它与其他消费者共享，这可能不会禁用供应。 仅当启用的参考计数为零时，才会禁用调节器。</p></blockquote><p>最后，在紧急情况下可以强制禁用调节器：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_force_disable</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这将立即强制关闭稳压器输出。 所有消费者都将断电。</p></blockquote><h2 id="regulator-voltage-control-status-dynamic-drivers">Regulator Voltage Control &amp; Status (dynamic drivers)</h2><p>一些消费类驱动器需要能够动态改变其电源电压以匹配系统工作点。 例如 CPUfreq 驱动程序可以随频率调整电压以节省电量，SD 驱动程序可能需要选择正确的卡电压等。</p><p>消费者可以通过调用来控制他们的电源电压：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_set_voltage</span><span class="params">(regulator, min_uV, max_uV)</span>;</span><br></pre></td></tr></tbody></table></figure><p>其中 min_uV 和 max_uV 是以微伏为单位的最小和最大可接受电压。</p><blockquote><p>这可以在调节器启用或禁用时调用。如果在已启用 regulator 时调用，则电压会立即更改，否则电压配置会更改，并且在下一次启用稳压器时会物理设置电压。</p></blockquote><p>调节器配置的电压输出可以通过调用找到：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_get_voltage</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>无论调节器是启用还是禁用，get_voltage() 都将返回配置的输出电压，并且不应用于确定调节器输出状态。 然而，这可以与 is_enabled() 结合使用来确定稳压器物理输出电压。</p></blockquote><h2 id="regulator-current-limit-control-status-dynamic-drivers">Regulator Current Limit Control &amp; Status (dynamic drivers)</h2><p>一些消费类驱动程序需要能够动态更改其电源电流限制以匹配系统工作点。 例如 LCD 背光驱动程序可以更改电流限制以改变背光亮度，USB 驱动程序可能希望在供电时将限制设置为 500mA。</p><p>消费者可以通过调用来控制他们的电源电流限制：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_set_current_limit</span><span class="params">(regulator, min_uA, max_uA)</span>;</span><br></pre></td></tr></tbody></table></figure><p>其中 min_uA 和 max_uA 是以微安为单位的最小和最大可接受电流限制。</p><blockquote><p>这可以在调节器启用或禁用时调用。如果在已启用电流限制时调用，则电流限制会立即更改，否则电流限制配置会更改，并且在下一次启用调节器时会设置电流限制。</p></blockquote><p>通过调用可以找到调节器电流限制：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_get_current_limit</span><span class="params">(regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>无论调节器是启用还是禁用，get_current_limit() 都将返回电流限制，并且不应用于确定调节器电流负载。</p></blockquote><h2 id="regulator-operating-mode-control-status-dynamic-drivers">Regulator Operating Mode Control &amp; Status (dynamic drivers)</h2><p>一些消费者可以通过改变其电源调节器的工作模式来进一步节省系统功率，以便在消费者工作状态发生变化时提高效率。 例如 消费者驱动程序空闲，随后消耗较少的电流。调节器操作模式可以间接或直接改变。</p><ul><li><p>间接操作模式控制： 消费者驱动程序可以通过以下调用请求更改其电源调节器操作模式：</p><pre><code>  int regulator_set_load(struct regulator *regulator, int load_uA);</code></pre><p>这将导致 core 重新计算调节器上的总负载（基于其所有消费者）并更改操作模式（如果必要和允许）以最佳匹配当前操作负载。load_uA 值可以从消费者的数据表中确定。 例如 大多数数据表都有表格显示在某些情况下消耗的最大电流。大多数消费者将使用间接操作模式控制，因为他们不了解调节器或调节器是否与其他消费者共享</p></li><li><p>直接操作模式控制： 定制或紧密耦合的驱动器可能希望根据其工作点直接控制调节器的工作模式，这可以通过调用：</p><pre><code>  int regulator_set_mode(struct regulator *regulator, unsigned int mode);  unsigned int regulator_get_mode(struct regulator *regulator);</code></pre><p>直接模式将仅由<em>了解</em>有关调节器且不与其他消费者共享调节器的消费者使用</p></li></ul><h2 id="regulator-events">Regulator Events</h2><p>监管机构可以将外部事件通知消费者，在监管机构压力或故障条件下，消费者可能会收到事件。</p><p>消费者调用以下接口注册感兴趣的事件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_register_notifier</span><span class="params">(<span class="keyword">struct</span> regulator *regulator,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> notifier_block *nb)</span>;</span><br></pre></td></tr></tbody></table></figure><p>消费者调用以下接口反注册感兴趣的事件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_unregister_notifier</span><span class="params">(<span class="keyword">struct</span> regulator *regulator,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> notifier_block *nb)</span>;</span><br></pre></td></tr></tbody></table></figure><p>监管机构使用内核通知程序框架向感兴趣的消费者发送事件。</p><h2 id="regulator-direct-register-access">Regulator Direct Register Access</h2><p>某些类型的电源管理硬件或固件被设计为需要对调节器进行低级硬件访问，而无需内核参与，此类设备的示例有：</p><ul><li>带有压控振荡器和控制逻辑的时钟源，可通过 I2C 改变电源电压，以实现所需的输出时钟速率。</li><li>热管理固件，可发出任意 I2C 事务以在过热条件下执行系统断电。</li></ul><p>要设置这样的设备/固件，需要为其配置各种参数，例如调节器的 I2C 地址、各种调节器寄存器的地址等。 监管者框架提供了以下查询这些详细信息的帮助程序。</p><p>特定于总线的详细信息，例如 I2C 地址或传输速率，由 regmap 框架处理。 要获取监管机构的 regmap（如果支持），请使用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> regmap *<span class="title function_">regulator_get_regmap</span><span class="params">(<span class="keyword">struct</span> regulator *regulator)</span>;</span><br></pre></td></tr></tbody></table></figure><p>要获取稳压器电压选择器寄存器的硬件寄存器偏移量和位掩码，请使用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_get_hardware_vsel_register</span><span class="params">(<span class="keyword">struct</span> regulator *regulator,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> *vsel_reg,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> *vsel_mask)</span>;</span><br></pre></td></tr></tbody></table></figure><p>要将调节器框架电压选择器代码（由调节器列表电压使用）转换为可直接写入电压选择器寄存器的特定于硬件的电压选择器，请使用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_list_hardware_vsel</span><span class="params">(<span class="keyword">struct</span> regulator *regulator,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> selector)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="regulator-driver-interface">Regulator Driver Interface</h1><h2 id="registration">Registration</h2><p>驱动程序可以通过调用以下接口注册 Regulator：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> regulator_dev *<span class="title function_">regulator_register</span><span class="params">(<span class="keyword">struct</span> regulator_desc *regulator_desc,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> regulator_config *config)</span>;</span><br></pre></td></tr></tbody></table></figure><p>这会将 regulator 的能力和操作注册到 regulator 核心。</p><p>注销接口如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">regulator_unregister</span><span class="params">(<span class="keyword">struct</span> regulator_dev *rdev)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="regulator-events-1">Regulator Events</h2><p>调节器可以通过调用以下方式向消费者驱动程序发送事件（例如过热、欠压等）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regulator_notifier_call_chain</span><span class="params">(<span class="keyword">struct</span> regulator_dev *rdev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> event, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="regulator-api-design-notes">Regulator API design notes</h1><p>本节对影响调节器 API 设计的一些设计注意事项进行了简要的、部分结构化的概述。</p><h2 id="safety">Safety</h2><ul><li>调节器配置中的错误会对系统产生非常严重的后果，可能包括持久的硬件损坏。</li><li>无法自动确定系统的电源配置 - 同一芯片的软件等效变体可能具有不同的电源要求，并且并非所有具有电源要求的组件对软件都是可见的。</li></ul><blockquote><p>API 不应更改硬件状态，除非它知道在此特定系统上执行这些更改是安全的。</p></blockquote><h2 id="consumer-use-cases">Consumer use cases</h2><ul><li>系统中的绝大多数设备除了能够打开或关闭电源外，不需要对其电源进行任何运行时配置。</li><li>系统中的许多电源将在许多不同的消费者之间共享。</li></ul><blockquote><p>消费者 API 的结构应使这些用例非常易于处理，并且消费者无需任何额外工作即可使用共享的 supplies。</p></blockquote><h1 id="regulator-machine-driver-interface">Regulator Machine Driver Interface</h1><p>调节器机器驱动程序接口用于板/机器特定的初始化代码以配置调节器子系统。</p><pre><code>Regulator-1 -+-&gt; Regulator-2 --&gt; [Consumer A @ 1.8 - 2.0V]             |             +-&gt; [Consumer B @ 3.3V]</code></pre><p>消费者 A 和 B 的驱动器必须映射到正确的调节器，以控制它们的电源。 这种映射可以在机器初始化代码中通过为每个调节器创建一个结构体 regulator_consumer_supply 来实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator_consumer_supply</span> {</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">/* consumer dev_name() */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *supply;<span class="comment">/* consumer supply - e.g. "vcc" */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>对于上面的电源：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regulator_consumer_supply</span> <span class="title">regulator1_consumers</span>[] =</span> {</span><br><span class="line">REGULATOR_SUPPLY(<span class="string">"Vcc"</span>, <span class="string">"consumer B"</span>),</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regulator_consumer_supply</span> <span class="title">regulator2_consumers</span>[] =</span> {</span><br><span class="line">REGULATOR_SUPPLY(<span class="string">"Vcc"</span>, <span class="string">"consumer A"</span>),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这将 Regulator-1 映射到消费者 B 的“Vcc”电源，并将 Regulator-2 映射到消费者 A 的“Vcc”电源。</p><p>现在可以通过为每个稳压器电源域定义一个结构体 regulator_init_data 来注册。这种结构还将消费者映射到他们的 supply regulators：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regulator_init_data</span> <span class="title">regulator1_data</span> =</span> {</span><br><span class="line">.constraints = {</span><br><span class="line">.name = <span class="string">"Regulator-1"</span>,</span><br><span class="line">.min_uV = <span class="number">3300000</span>,</span><br><span class="line">.max_uV = <span class="number">3300000</span>,</span><br><span class="line">.valid_modes_mask = REGULATOR_MODE_NORMAL,</span><br><span class="line">},</span><br><span class="line">.num_consumer_supplies = ARRAY_SIZE(regulator1_consumers),</span><br><span class="line">.consumer_supplies = regulator1_consumers,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>名称字段应设置为对电路板有用的描述，以便为其他调节器配置电源以及用于日志记录和其他诊断输出。 通常，原理图中用于 supply rail 的名称是一个不错的选择。 如果未提供名称，则子系统将自动选择一个。</p><p>Regulator-1 为 Regulator-2 供电。 这种关系必须在核心中注册，以便在消费者 A 启用其供应 (Regulator-2) 时也启用 Regulator-1。 电源调节器由下面的 supply_regulator 字段设置：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regulator_init_data</span> <span class="title">regulator2_data</span> =</span> {</span><br><span class="line">.supply_regulator = <span class="string">"Regulator-1"</span>,</span><br><span class="line">.constraints = {</span><br><span class="line">.min_uV = <span class="number">1800000</span>,</span><br><span class="line">.max_uV = <span class="number">2000000</span>,</span><br><span class="line">.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,</span><br><span class="line">.valid_modes_mask = REGULATOR_MODE_NORMAL,</span><br><span class="line">},</span><br><span class="line">.num_consumer_supplies = ARRAY_SIZE(regulator2_consumers),</span><br><span class="line">.consumer_supplies = regulator2_consumers,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>最后，必须以通常的方式注册调节器设备：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">regulator_devices</span>[] =</span> {</span><br><span class="line">{</span><br><span class="line">.name = <span class="string">"regulator"</span>,</span><br><span class="line">.id = DCDC_1,</span><br><span class="line">.dev = {</span><br><span class="line">.platform_data = &amp;regulator1_data,</span><br><span class="line">},</span><br><span class="line">},</span><br><span class="line">{</span><br><span class="line">.name = <span class="string">"regulator"</span>,</span><br><span class="line">.id = DCDC_2,</span><br><span class="line">.dev = {</span><br><span class="line">.platform_data = &amp;regulator2_data,</span><br><span class="line">},</span><br><span class="line">},</span><br><span class="line">};</span><br><span class="line"><span class="comment">/* register regulator 1 device */</span></span><br><span class="line">platform_device_register(&amp;regulator_devices[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* register regulator 2 device */</span></span><br><span class="line">platform_device_register(&amp;regulator_devices[<span class="number">1</span>]);</span><br></pre></td></tr></tbody></table></figure><h1 id="数据结构">数据结构</h1><p>上文中已经将 Regulator、PMIC、Consumer、Power Domain 等概念进行了介绍，同时也将相关接口进行了介绍。在这一章中将介绍 regulator 的内部实现。整体的数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2ODNmYzg1NjUzYmIxMzM2ZGY2YmYx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Regulator_Struct.png"></p><ul><li><p>regulator_map:<br>组织一个系统内所有的 pmic 设备。将他们挂载到一个全局链表中</p></li><li><p>regulator_dev:<br>struct regulator_dev 是 regulator 设备的抽象，当 driver 以 struct regulator_desc、struct regulator_config 两个类型的参数，调用 regulator_register 将 regulator 注册到 kernel 之后，regulator 就会分配一个 struct regulator_dev 变量，后续所有的 regulator 操作，都将以该变量为对象</p></li><li><p>regulator_desc:<br>regulator_desc 用于描述一个调节器（dcdc、ldo 等）。 在注册 regulator 的时候，需要使用 struct regulator_desc 结构提供该 regulator 的静态描述。所谓的静态，是指这些描述不会在运行时改变，代表了设备的一种属性。regulator_desc 描述该 regulator device 的类型（电压、电流、电流和电压）、中断 id、支持的输出电压个数、操作类型（可改变电压等）、输出模式（fast、normal、idle、standby 等）；若该 regulator device 在注册的时候支持通过 regmap 进行配置（如该 regulator device 可通过 spi、iic 接口访问，则可以通过 spi/iic 对应的 regmap 接口访问该 regulator device 的寄存器，进行配置操作），则需要定义 enable_reg、enable_mask、apply_reg 等参数的信息，以便通过 regmap 进行配置</p></li><li><p>regulator_ops:<br>这个数据结构是描述调节器的操作函数集的数据结构。对于 pmic 里的每一个调节器都需要有自己的操作方法，该数据结构提供对调节器的操作函数集</p></li><li><p>regulator_config:<br>regulator_config 保存了 regulator 的动态信息，所谓的动态信息，是指那些会在 driver 运行过程中改变、或者 driver 运行后才会确定的信息</p></li><li><p>regulation_constraints:<br>该数据结构描述 regulator device 的约束信息，包括输出电压范围、输出电流范围、regulator device 支持的模式（fast、normal、idle、standby 等）、regulator device 支持的操作模式，包括 change volt、change current、change bypass mode 等、regulator device 支持的 suspend 状态下的输出控制（如在 suspend to disk 状态下的输出控制等）</p></li><li><p>regulator:<br>该数据结构表示一个 regulator device 的使用者，包括是否一直使能、是否使用 bypass 模式（bypass 模式指 regulator device 输入电压直接作为输出，不做限制）、电压范围、电流值、设备属性信息、该 regulator 对应的 supply 名称等</p></li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL3JlZ3VsYXRvcl9kcml2ZXIuaHRtbA==">http://www.wowotech.net/pm_subsystem/regulator_driver.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDcxMjg4MTg/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/107128818?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDcxMjg4NTc/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/107128857?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br>《Linux 内核文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 RTC</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverRTC/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverRTC/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>RTC 和系统时钟有不同的用途。前者是硬件时钟，以非易失方式维护绝对时间和日期，而后者是内核维护的软件时钟，用于实现 gettimeofday（2）和 time（2）系统调用，以及在文件上设置时间戳等。系统时钟报告从起点开始的秒和微秒，起点定义为 POSIX 纪元：1970-01-0100:00：00 +0000(UTC)。</p><span id="more"></span><h1 id="数据结构">数据结构</h1><p>rtc 数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDU5MTYwNzkxMjk1NzEwYjZiNjM0">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/RTC_Struct.png"></p><ul><li><p>rtc_device： 内核中使用 rtc_device 结构体来抽象一个 rtc 设备，rtc_device 结构体屏蔽了不同 RTC 硬件之间的差异，通过 rtc_class_ops 结构体为上层提供了访问硬件设备的统一接口</p></li><li><p>rtc_class_ops： 该结构体提供了对底层差异的抽象，rtc_device 用于描述一个 rtc 设备，而访问该设备的方法对于不同的设备是不同的，rtc_class_ops 用于抽象对 rtc 设备的访问，对上屏蔽了底层操作的差异。编写一个 rtc 设备驱动就是构造一个 rtc_device 结构体并注册进系统，rtc 的访问方法就是 rtc_class_ops 结构体</p></li><li><p>rtc_time： 这是一个描述时间的结构体</p></li><li><p>rtc_timer： 用于对 rtc 设备的管理</p></li></ul><h1 id="实现">实现</h1><p>rtc 实现的整体框架如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDYxNzMxZWZhZDQyNDNkNDc0MTA2">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/RTC_Framework.png"></p><ul><li>在 rtc 设备驱动模型的最上层，针对 procfs 文件、sysfs 属性文件、字符设备文件相关的处理接口，分别抽象出 rtc-dev 相关接口、rtc-sysfs 相关接口、rtc-procfs 相关接口，分别存储在 rtc-dev.c、rtc-sysfs.c、rtc-proc.c 这三个文件中。</li><li>在 rtc-dev.c、rtc-sysfs.c、rtc-proc.c 中定义了这三类文件的操作接口（open、read、write、close…）。</li><li>上述三类文件的操作接口（open、read、write、close…），会借助 rtc interface 接口，调用各设备的操作接口，rtc interface 接口可以理解为调用设备驱动的桥梁； 针对 rtc 设备驱动，均需要实现 rtc class ops 中的方法，以便被 rtc 上层接口调用，从而完成与 rtc 设备的通信操作。</li><li>应用程序通过系统调用接口、vfs 相关接口、设备文件系统的 inode 的操作接口、sysfs 文件系统的 inode 的操作接口、procfs 文件系统的 inode 的操作接口，方才进入 rtc 设备驱动模型的处理接口中。</li></ul><p>实现流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDZjYWExZWZhZDQyNDNkNDc0Zjdk">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/rtc_register.png"></p><p>devm_rtc_device_register 函数就是注册一个 rtc 设备的 api。注册流程如下：</p><ul><li>devm_rtc_allocate_device 分配并设置 rtc_device 结构体。</li><li>devm_rtc_register_device 注册 rtc_device 结构体。这里是/linux/drivers/rtc/dev.c 文件里提供的 cdev 的 file_operations 结构体，该结构体函数指针提供了对 interface 的访问。</li><li>在/linux/drivers/rtc/interface.c 文件里向上为/linux/drivers/rtc/dev.c 提供接口，向下提供访问 rtc_class_ops 的接口。</li><li>rtc_class_ops 由具体的 rtc 设备在注册的时候提供。</li></ul><h1 id="sysfs-接口">sysfs 接口</h1><p>在 Linux 系统上，从用户空间正确管理 RTC 需要关注两个内核选项。这两个选项是 CONFIG_RTC_HCTOSYS 和 CONFIG_RTC_HCTOSYS_DEVICE。 要使用 CONFIG_RTC_HCTOSYS 应在内核构建过程中包含代码文件 driversrtc/hctosys.c，它在启动和恢复时从 RTC 设置系统时间。一旦启用此选项，就将使用从指定 RTC 设备读取的值设置系统时间。RTC 设备应该在 CONFIG_RTC_HCTOSYSDEVICE 中指定：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_RTC_HCTOSYS=y</span><br><span class="line">CONFIG_RTC_HCTOSYS_DEVICE=<span class="string">"rtcO"</span></span><br></pre></td></tr></tbody></table></figure><p>负责在 sysfs 中实例化 RTC 属性的内核代码在内核源码树的 drivers/rtc/rtc_sysfs.c 中定义。一旦注册，RTC 设备就将在/sys/class/rtc 下创建 rtc<id> 目录，该目录包含一组只读属性，其中重要的属性如下。</id></p><ul><li><p>date: 该文件打印 RTC 接口的当前日期：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/class/rtc/rtc0/date</span><br><span class="line">2017-8-28</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>time: 打印此 RTC 的当前时间：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/class/rtc/rtc0/time</span><br><span class="line">14:54:20</span><br></pre></td></tr></tbody></table></figure><p></p></li><li>hctosys: 该属性指出 RTC 设备是否是 CONFIG_RTC_HCTOSYS_DEVICE 中指定的设备，也就是在启动和恢复时是否使用该 RTC 设置系统时间。其值为 1 表示真，0 表示假：<br><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/class/rtc/rtc0/hctosys</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure></li><li><p>dev: 此属性显示设备的主设备号和次设备号。数据格式为主设备号：次设备号：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/class/rtc/rtc0/dev</span><br><span class="line">251:0</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>since_epoch: 该属性将显示从 UNIX 纪元（自 1970 年 1 月 1 日起）以来的秒数：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/class/rtc/rtc0/since epoch</span><br><span class="line">1503931738</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h1 id="hwclock-工具">hwclock 工具</h1><p>硬件时钟（hwclock）工具用于访问 RTC 设备。man hwclock 命令可能比本节讨论的所有内容都更有意义。尽管如此，下面还是编写一些命令，以从系统时钟设置 hwclockRTC:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ntpd -q              <span class="comment">#确保系统时钟是从网络时间设置的</span></span><br><span class="line">$ sudo hwclock --systohc    <span class="comment">#从系统时钟设置 RTC</span></span><br><span class="line">$ sudo hwclock --show       <span class="comment">#设置 RTC</span></span><br><span class="line">Sat May 17 17:36:50 2017 -0.671045 seconds</span><br></pre></td></tr></tbody></table></figure><p>上面的例子假定主机具有网络连接，可以访问 NTP 服务器。也可以手动设置系统时间：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">date</span> -s <span class="string">'2017-08-28 17:14:00'</span>+s<span class="string">' #手动设置系统时钟</span></span><br><span class="line"><span class="string">$ sudo hwclock 一 systohc                #在系统时间上同步 RTC 芯片</span></span><br></pre></td></tr></tbody></table></figure><p>如果没有给出参数，hwclock 假定 RTC 设备文件是/dev/rtc，它实际上是真正 RTC 设备的符号链接：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /dev/rtc</span><br><span class="line">lrwxrwxrwx 1 root root 4 aout 27 17:50 /dev/rtc -&gt; rtc0</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vMDUzMTc5aHUvcC8xNDEzMDMwMC5odG1s">https://www.cnblogs.com/053179hu/p/14130300.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDM4NDE5NDE/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/103841941?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 CCF 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverCCF/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverCCF/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>CCF 主要用于系统 clock 的管理等操作。clk 的种类说明： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/clk_type.png"></p><p>如上图所示，时钟源大概可分为如下几种：</p><ul><li>提供基础时钟源的晶振（可分为有源晶振、无源晶振两种）</li><li>用于倍频的锁相环</li><li>用于分频的 divider</li><li>用于多路时钟源选择的 mux</li><li>用于时钟使能的与门电路等</li></ul><p>而在 CCF 子系统的抽象中，这五种均抽象为 clk，但是针对这 5 种类型的时钟也提供了单独的时钟注册函数（也就是对 clk_register 函数的封装，并针对不同的时钟类型定义了不同的结构体）。</p><p>在 CCF 子系统中，针对硬件时钟的操作接口，也抽象了对应的结构体 struct clk_ops，包含时钟的使能接口、时钟频率的修改接口等等。而针对上述所说的不同种类的时钟源，其并不需要实现所有 struct clk_ops 中定义的接口。针对“时钟使能的与门电路”而言，仅需要实现 enabel、disable、is_enable 接口即可；针对多路时钟源选择的 mux 而言，则需要实现父时钟源的设置及获取的接口 set_parent、get_parent 等；对于倍频、分频而言，则需要实现时钟频率相关的接口 set_rate、recalc_rate 等。</p><span id="more"></span><h1 id="apiconsumer">API（consumer）</h1><h2 id="clock-获取有关的-api">clock 获取有关的 API</h2><ul><li>以 device 指针或者 id 字符串（可以看作 name）为参数，查找 clock。devm_clk_get 使用了 device resource management，可以自动释放</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *id)</span>;</span><br><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">devm_clk_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *id)</span>;</span><br></pre></td></tr></tbody></table></figure><pre><code>dev 和 id 的任意一个可以为空。如果 id 为空，则必须有 device tree 的支持才能获得 device 对应的 clk；根据具体的平台实现，id 可以是一个简单的名称，也可以 是一个预先定义的、唯一的标识（一般在平台提供的头文件中定义，如 mach/clk.h）；不可以在中断上下文调用</code></pre><ul><li>get 的反向操作，一般和对应的 get API 成对调用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clk_put</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">devm_clk_put</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> clk *clk)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 device 的 name 查找 clock</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_get_sys</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dev_id, <span class="type">const</span> <span class="type">char</span> *con_id)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>device tree 相关的接口，直接从相应的 DTS node 中，以 index、name 等为索引，获取 clk</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">of_clk_get</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">of_clk_get_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">of_clk_get_from_provider</span><span class="params">(<span class="keyword">struct</span> of_phandle_args *clkspec)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="clock-控制有关的-api">clock 控制有关的 API</h2><ul><li>启动/停止 clock。不会睡眠</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clk_enable</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clk_disable</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>启动 clock 前的准备工作/停止 clock 后的善后工作</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">clk_prepare</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">clk_unprepare</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>clock 频率的获取和设置，其中 clk_set_rate 可能会不成功（例如没有对应的分频比），此时会返回错误。如果要确保设置成功，则需要先调用 clk_round_rate 接口，得到和需要设置的 rate 比较接近的那个值</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">clk_get_rate</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clk_set_rate</span><span class="params">(<span class="keyword">struct</span> clk *clk, <span class="type">unsigned</span> <span class="type">long</span> rate)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">clk_round_rate</span><span class="params">(<span class="keyword">struct</span> clk *clk, <span class="type">unsigned</span> <span class="type">long</span> rate)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>获取/选择 clock 的 parent clock</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_get_parent</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clk_set_parent</span><span class="params">(<span class="keyword">struct</span> clk *clk, <span class="keyword">struct</span> clk *parent)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>将 clk_prepare 和 clk_enable 组合起来，一起调用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clk_prepare_enable</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>将 clk_disable 和 clk_unprepare 组合起来，一起调用</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clk_disable_unprepare</span><span class="params">(<span class="keyword">struct</span> clk *clk)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>prepare/unprepare，enable/disable 的说明</strong></p><p>这两套 API 的本质，是把 clock 的启动/停止分为 atomic 和 non-atomic 两个阶段，以方便实现和调用。因此上面所说的“不会睡眠/可能会睡眠”，有两个角度的含义：一是告诉底层的 clock driver，请把可能引起睡眠的操作，放到 prepare/unprepare 中实现，一定不能放到 enable/disable 中；二是提醒上层使用 clock 的 driver，调用 prepare/unprepare 接口时可能会睡眠哦，千万不能在 atomic 上下文（例如中断处理中）调用哦，而调用 enable/disable 接口则可放心。</p><p>另外，clock 的开关为什么需要睡眠呢？这里举个例子，例如 enable PLL clk，在启动 PLL 后，需要等待它稳定。而 PLL 的稳定时间是很长的，这段时间要把 CPU 交出（进程睡眠），不然就会浪费 CPU。</p><p>最后，为什么会有合在一起的 clk_prepare_enable/clk_disable_unprepare 接口呢？如果调用者能确保是在 non-atomic 上下文中调用，就可以顺序调用 prepare/enable、disable/unprepared，为了简单，framework 就帮忙封装了这两个接口。</p><h2 id="其它接口">其它接口</h2><ul><li>注册/注销 clock rate 改变的通知。例如某个 driver 关心某个 clock，期望这个 clock 的 rate 改变时，通知到自己，就可以注册一个 notify <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clk_notifier_register</span><span class="params">(<span class="keyword">struct</span> clk *clk, <span class="keyword">struct</span> notifier_block *nb)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clk_notifier_unregister</span><span class="params">(<span class="keyword">struct</span> clk *clk, <span class="keyword">struct</span> notifier_block *nb)</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="通用-api-的使用说明">通用 API 的使用说明</h2><ul><li><p>首先，在 DTS（device tree source）中，指定 device 需要使用的 clock，如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* DTS */</span><br><span class="line">device {</span><br><span class="line">    clocks = &lt;&amp;osc 1&gt;, &lt;&amp;ref 0&gt;;</span><br><span class="line">    clock-names = "baud", "register";</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>该 DTS 的含义是：</p><p>device 需要使用两个 clock，“baud”和“regitser”，由 clock-names 关键字指定；</p><p>baud 取自“osc”的输出 1，register 取自“ref”的输出 0，由 clocks 关键字指定。</p></li><li><p>系统启动后，device tree 会解析 clock 有关的关键字，并将解析后的信息放在 platform_device 相关的字段中</p></li><li><p>具体的 driver 可以在 probe 时，以 clock 的名称（不提供也行）为参数，调用 clk get 接口，获取 clock 的句柄，然后利用该句柄，可直接进行 enable、set rate 等操作，如下：</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* driver */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">baud_clk</span>;</span></span><br><span class="line">    <span class="type">int</span> ret; </span><br><span class="line"></span><br><span class="line">    baud_clk = devm_clk_get(&amp;pdev-&gt;dev, “baud”);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(clk)) {</span><br><span class="line">            …</span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    ret = clk_prepare_enable(baud_clk);</span><br><span class="line">    <span class="keyword">if</span> (ret) {</span><br><span class="line">            …</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="数据结构provider">数据结构（provider）</h1><p>CCF 实现的数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDEyYzgwNzkxMjk1NzEwYjY2NzQ4">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/CCF_Struct.png"></p><ul><li><p>clk_hw： 为硬件时钟源的逻辑抽象可以理解为 clk provider</p></li><li><p>clk_core： 可以理解为 clk provider 的 driver，包含了 clk provider 的访问方法、时钟频率设定、支持的时钟频率、父时钟源的个数以及父时钟源的名称等内容</p></li><li><p>clk： 可以理解 clk consumer，包含了指向 clk provider 的指针、使用者的设备名称、使用者所定义的时钟别名（con_id）</p></li><li><p>clk_ops： 主要是 clk provider 的操作接口，包含 prepare 与 unprepare 操作接口（这两个接口执行时允许 sleep，主要是用的互斥锁）、enable 与 disable 接口（这两个接口执行时不允许 sleep，里面使用了自旋锁），也包含了速率设置接口、重新计算速率接口、parent 设置与获取接口等等，通过这些接口可实现时钟频率的修改、父时钟源的选择、时钟的使能与否等功能</p></li><li><p>clk_init_data： 描述该 clock 的静态数据，clock provider 负责把系统中每个 clock 的静态数据准备好，然后交给 clock framework 的核心逻辑，剩下的事情，clock provider 就不用操心了。这个过程，就是 clock driver 的编写过程</p></li></ul><p>ccf 的驱动框架也是与设备驱动模型类似的结构，clk_core 用于抽象设备树驱动的方法类似于 device_driver 而 clk 则更像是一个 device，在 soc 内部有很多控制器，这些控制器都挂载在时钟树下面，这些控制器就是 consumer，他们会用到 clk 数据结构用于使能失能时钟，以及设置时钟频率等操作。而 clk_core 结构体则抽象了时钟树中的每一个节点组织成树状结构来描述整个时钟树。下面看下 clk_core 在内核中的组织关系结构图，如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDI0NjYxZTA4NTMzYTAzMDJmZWRh">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/CLK_Core_List.png"></p><h1 id="实现">实现</h1><h2 id="clock-分类及-register">clock 分类及 register</h2><p>根据 clock 的特点，clock framework 将 clock 分为 fixed rate、gate、devider、mux、fixed factor、composite 六类，每一类 clock 都有相似的功能、相似的控制方式，因而可以使用相同的逻辑 s，统一处理，这充分体现了面向对象的思想。</p><ul><li>fixed rate cloc： 这一类 clock 具有固定的频率，不能开关、不能调整频率、不能选择 parent、不需要提供任何的 clk_ops 回调函数，是最简单的一类 clock。 可以直接通过 DTS 配置的方式支持，clock framework core 能直接从 DTS 中解出 clock 信息，并自动注册到 kernel，不需要任何 driver 支持。 clock framework 使用 struct clk_fixed_rate 结构抽象这一类 clock，另外提供了一个接口，可以直接注册 fixed rate clock，如下：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_fixed_rate</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">clk_hw</span> <span class="title">hw</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fixed_rate;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fixed_accuracy;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_register_fixed_rate</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *parent_name, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> fixed_rate)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>gate clock<br>这一类 clock 只可开关（会提供。enable/.disable 回调），可使用下面接口注册：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_register_gate</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *parent_name, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">void</span> __iomem *reg, u8 bit_idx,</span></span><br><span class="line"><span class="params">u8 clk_gate_flags, <span class="type">spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>divider clock<br>这一类 clock 可以设置分频值（因而会提供。recalc_rate/.set_rate/.round_rate 回调），可通过下面两个接口注册：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> clk_register_divider(dev, name, parent_name, flags, reg, shift, width, \</span></span><br><span class="line"><span class="meta">     clk_divider_flags, lock)       \</span></span><br><span class="line"><span class="meta">clk_register_divider_table((dev), (name), (parent_name), (flags),      \</span></span><br><span class="line"><span class="meta">   (reg), (shift), (width),       \</span></span><br><span class="line"><span class="meta">   (clk_divider_flags), NULL, (lock))</span></span><br></pre></td></tr></tbody></table></figure><ul><li>mux clock<br>这一类 clock 可以选择多个 parent，因为会实现。get_parent/.set_parent/.recalc_rate 回调，可通过下面两个接口注册：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> clk_register_mux(dev, name, parent_names, num_parents, flags, reg,    \</span></span><br><span class="line"><span class="meta"> shift, width, clk_mux_flags, lock)      \</span></span><br><span class="line"><span class="meta">clk_register_mux_table((dev), (name), (parent_names), (num_parents),  \</span></span><br><span class="line"><span class="meta">       (flags), (reg), (shift), BIT((width)) - 1,     \</span></span><br><span class="line"><span class="meta">       (clk_mux_flags), NULL, (lock))</span></span><br></pre></td></tr></tbody></table></figure><ul><li>fixed factor clock<br>这一类 clock 具有固定的 factor（即 multiplier 和 divider），clock 的频率是由 parent clock 的频率，乘以 mul，除以 div，多用于一些具有固定分频系数的 clock。由于 parent clock 的频率可以改变，因而 fix factor clock 也可该改变频率，因此也会提供。recalc_rate/.set_rate/.round_rate 等回调。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_register_fixed_factor</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *parent_name, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> mult, <span class="type">unsigned</span> <span class="type">int</span> div)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>composite clock<br>顾名思义，就是 mux、divider、gate 等 clock 的组合，可通过下面接口注册：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> clk *<span class="title function_">clk_register_composite</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> *parent_names, <span class="type">int</span> num_parents,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> clk_hw *mux_hw, <span class="type">const</span> <span class="keyword">struct</span> clk_ops *mux_ops,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> clk_hw *rate_hw, <span class="type">const</span> <span class="keyword">struct</span> clk_ops *rate_ops,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> clk_hw *gate_hw, <span class="type">const</span> <span class="keyword">struct</span> clk_ops *gate_ops,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="上面这些注册接口的实现逻辑">上面这些注册接口的实现逻辑</h2><p>clk 注册流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDNiNWE1NjUzYmI2NzkxZTRhZWZh">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/clk_register.png"></p><p>驱动针对不同类型的 clock 节点提供了几种不同的注册函数，驱动开发人员一般不需要自己编写对应的驱动而是尽可能调用系统提供的接口，而对于系统而言也是尽可能的复用函数，这些注册函数都是通过调用 clk_hw_register 函数来实现自己的功能。</p><p>这里有一个 map 映射没有涉及，ccf 子系统提供了 clk provider 的 map，这种 map 机制可以理解为定义了 clk consumer 与 clk_provider 的映射关系，即该 clk provider 可以给哪些 clk consumer 提供时钟（如针对非设备树模式，则定义了 clk consumer 的设备名称、clk consumer 的时钟使用名称）。</p><h2 id="系统启动阶段对设备树的处理">系统启动阶段对设备树的处理</h2><p>clk 初始化流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1ZDQwYmZlNDAxZmQ2YmUwN2YyZGRl">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/clk_init.png"></p><p>上面介绍了 clk 的注册流程，在上图中展示了系统启动过程中，解析设备树按照默认配置来设置系统时钟树的流程，下面给出详细说明：</p><ul><li>通常在 Clock 驱动中会有一个 CLK_OF_DECLARE 宏，该宏用于声明一个 struct of_device_id 数据结构，并且最终在链接的时候会将数据结构链接在一个叫做__of_clk_table 的段中，这个段的定义位于 vmlinux.lds.h 文件中。</li><li>在内核启动过程中，最终会调用到 of_clk_init 函数，在该函数中会去访问__of_clk_table 段中的内容，由于此时内核已经调用了 unflatten_device_tree() 接口，完成了 Device Tree 的解析过程，在 of_clk_init 函数中，会根据 struct of_device_id 中的内容去匹配 Device Node。</li><li>最终调用__of_clk_table 中匹配上的 struct of_device_id 中的函数，也就是 Clock 驱动的入口函数了，此时顺着这个入口函数，可以完成一系列的操作，比如 clk_ops 中的函数实现，注册进 CCF 框架等。</li><li>当驱动完成注册之后，Consumer Driver 的 Device Node 和 Clock Provider 建立了联系，Consumer Driver 便可通过 CCF 接口来操作时钟了。</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2Nsa19vdmVydmlldy5odG1s">http://www.wowotech.net/pm_subsystem/clk_overview.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2Nsb2NrX3Byb3ZpZGVyLmh0bWw=">http://www.wowotech.net/pm_subsystem/clock_provider.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcG1fc3Vic3lzdGVtL2Nsb2NrX2ZyYW1ld29ya19jb3JlLmh0bWw=">http://www.wowotech.net/pm_subsystem/clock_framework_core.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDc3MjkxNTY/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/107729156?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucXRlci5vcmcvcG9ydGFsLnBocD9tb2Q9dmlldyZhaWQ9Nzc3NA==">https://www.qter.org/portal.php?mod=view&amp;aid=7774<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 Input 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverInput/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverInput/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同。为此 input 子系统分为 input 驱动层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点，input 子系统框架如图 所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/input.png"></p><ul><li>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。</li><li>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。</li><li>事件层：主要和用户空间进行交互。</li></ul><span id="more"></span><h1 id="数据结构">数据结构</h1><p>Input 子系统实现的数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE1NWY2ZTVlMGIzNGQwOTEyMzViN2U1">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Input_Struct.png"></p><ul><li><p>input_dev:<br>input_dev 结构体用于描述一个 input 设备，例如按键、鼠标、键盘等，我们编写设备驱动主要就是构造这个结构体。该结构体包含设备类型，消息类型，事件 code 等信息。该数据结构在内核里会挂载到一个全局链表 input_dev_list，所有注册的 input 设备都会挂载到该链表中</p></li><li><p>input_handler:<br>input_handler 用于表示一个 input 事件，用于上报 input 事件，系统中所有注册的 input_handler 也会挂载到一个全局链表 input_handler_list 中。input_handler 可以类比设备驱动模型中 driver 方法，用于驱动 device，这里 input_handler 用于处理 input_dev 设备产生的事件。input_dev 和 input_handler 之间也是通过一种匹配规则来进行匹配建立联系，当 input_dev 注册的时候会遍历 input_handler_list 链表，通过 id_table 或 input_handler 的 match 方法进行匹配，匹配成功后两者之间会建立联系。同样对于 input_handler 的注册也是一样，当一个 input_handler 注册时会遍历 input_dev_list 链表，当两个结构体满足匹配关系时则建立联系</p></li><li><p>input_handle:<br>在上面的介绍中当 input_handler 和 input_dev 匹配成功后会建立联系，这个联系就是通过该结构体来建立的。当 input_dev 和 input_handler 匹配成功后会创建一个 evdev 结构体，evdev 结构体下有一个 input_handle 结构体，input_handle 结构体会指向匹配成功的 input_dev 和 input_handler，而且将自己挂载到 input_dev 和 input_handler 结构体中</p></li><li><p>evdev_client:<br>evdev_client 结构体表示一个 input 客户，也就是 app 用户会使用 input_dev，那么这个 app 用户就用 evdev_client 结构体来描述，可以看到，该结构体挂载在 evdev 结构体下，且是以链表的形式组织，也就说明一个 input 设备可以被多个 client 打开使用</p></li><li><p>evdev:<br>通过对 input_handler 和 evdev_client 的介绍其实也就已经将 evdev 介绍完了，evdev_client 使用设备，那么需要知道使用的是哪个设备 input_dev 以及如何驱动这个设备 input_handler，这都是通过 input_handler 结构体完成的。evdev 是将 input 设备，input 设备的驱动方法和用户 client 联系起来的一个结构体</p></li></ul><p>通过对 input 结构体的介绍，其实我们就已经大致了解了驱动的整体框架。其实跟设备模型中 device 和 device_driver 之间的关系很像，device 和 driver 之间有一个匹配规则，当匹配成功后，两者之间建立联系，完成驱动设备的功能。但是为什么这里不直接使用设备驱动模型呢，不理解。</p><h1 id="实现">实现</h1><p>input 驱动的实现无非就是 input_dev、input_handler 的注册等流程，下面一个个看下具体相关流程吧：</p><h2 id="input_dev-注册流程">input_dev 注册流程</h2><p>input_register_device 函数用于注册一个 input_dev 设备：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></tbody></table></figure><p>该函数主要完成以下工作：</p><pre><code>1、为 input_dev 创建 struct device 类型的变量，并设置其所属的 class 为 input_class，并调用 device_add 完成 device 类型变量的注册，至此完成 strcut device 类型变量注册至 input_class 中，且完成了 input_dev 对应的 sysfs 属性文件的创建。 2、将该 input_device 注册至 input_dev_list。3、遍历 input_handler_list 链表，针对 input_handler_list 上每一个 input_handler，均与注册的 input_device 进行匹配检测，若匹配检测成功，则调用  input_handler-&gt;connect 接口，进行 input_handler 与 input_device 的绑定（通过调用 input_register_handle 实现，也可以理解为在 input_handler、input_device 上 完成 input_handler、input_device 的事件消息的订阅操作）。因 input_handler 和 input_device 可实现多对多的绑定，因此，会遍历 input_handler_list 链表上所有已注册的 input_handler，而不是检测到一个 input_handler 的匹配即返回。</code></pre><h2 id="input_handler-的注册流程">input_handler 的注册流程</h2><p>input_handler 的注册函数是 input_register_handler：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_handler</span><span class="params">(<span class="keyword">struct</span> input_handler *handler)</span></span><br></pre></td></tr></tbody></table></figure><p>该函数主要完成以下工作：</p><pre><code>1、将该 input_device 注册至 input_handler_list      2、遍历 input_dev_list 链表，针对 input_dev_list 上每一个 input_dev，均与注册的 input_device 进行匹配检测，若匹配检测成功，则调用 input_handler-&gt;connect 接口，进行 input_handler 与 input_device 的绑定（通过调用 input_register_handle 实现，也可以理解为在 input_handler、input_device 上完成 input_handler、input_device 的事件消息的订阅操作）。因 input_handler 和 input_device 可实现多对多的绑定，因此，会遍历 input_dev_list 链表上所有已注册的 input_dev，而不是检测到一个 input_dev 的匹配即返回</code></pre><h2 id="input_handle-的注册流程">input_handle 的注册流程</h2><p>input_handle 的注册函数是 input_register_handle：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_handle</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br></pre></td></tr></tbody></table></figure><p>该函数主要完成以下工作：</p><pre><code>1、 完成 input_handle 与 input_handler 的关联2、完成 input_handle 与 input_dev 的关联</code></pre><h1 id="一个完整的事件上报流程">一个完整的事件上报流程</h1><h2 id="应用打开并读设备">应用打开并读设备</h2><p>当应用打开一个 input 设备时会通过 vfs 调用到驱动程序的 file_operations, 对于 input 设备就是 evdev.c 下的：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> {</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read= evdev_read,</span><br><span class="line">.write= evdev_write,</span><br><span class="line">.poll= evdev_poll,</span><br><span class="line">.open= evdev_open,</span><br><span class="line">.release= evdev_release,</span><br><span class="line">.unlocked_ioctl= evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_ioctl= evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.fasync= evdev_fasync,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个就是 input_dev 注册的时候会向系统注册的字符设备，该字符设备的注册时机是什么时候呢，先来看下 input_handle 的初始化。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> {</span><br><span class="line">.event= evdev_event,</span><br><span class="line">.events= evdev_events,</span><br><span class="line">.connect= evdev_connect,</span><br><span class="line">.disconnect= evdev_disconnect,</span><br><span class="line">.legacy_minors= <span class="literal">true</span>,</span><br><span class="line">.minor= EVDEV_MINOR_BASE,</span><br><span class="line">.name= <span class="string">"evdev"</span>,</span><br><span class="line">.id_table= evdev_ids,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">evdev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>evdev_handler 里面的成员 connect 的指针指向 evdev_connect，当 input_dev 和 input_handler 匹配成功后就会调用 connect，函数，而 evdev_connect 里面会调用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line"></span><br><span class="line">cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>evdev_fops 就是上面那个 file_operations。然后应用调用 open 就会调用驱动的 evdev_open 函数，应用调用 read 就会调用驱动的 evdev_read 函数，下面说明下 open 和 read 函数主要的工作： evdev_open 的工作：</p><pre><code>1、 创建并分配一个 evdev_client 结构体   2、 将 evdev_client 放入 evdev 的链表中   </code></pre><p>evdev_read 的工作：</p><pre><code>如果没有数据等待休眠，调用 wait_event_interruptible 函数，将当前工作挂载在 evdev_client 的 wait 等待队列中</code></pre><h2 id="事件产生上报数据">事件产生上报数据</h2><p>一般采用中断方式处理外部事件，当按键或其他输入事件发生时，产生中断，执行中断服务程序，中断服务程序一般主要就是干两件事，读取数据和上报数据，对于读取数据没什么好说的，下面看下上报数据流程：上报数据通过 input core 层提供的 input_event 函数完成，函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) {</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">input_handle_event(dev, type, code, value);</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数调用流程如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_event()</span><br><span class="line">    --&gt;input_handle_event()</span><br><span class="line">        --&gt;input_pass_values()</span><br><span class="line">            --&gt;input_to_handler()</span><br></pre></td></tr></tbody></table></figure><p>input_to_handler 函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">input_to_handler</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> =</span> vals;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1、 使用 filter 过滤事件 */</span></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;filter) {</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++) {</span><br><span class="line"><span class="keyword">if</span> (handler-&gt;filter(handle, v-&gt;type, v-&gt;code, v-&gt;value))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (end != v)</span><br><span class="line">*end = *v;</span><br><span class="line">end++;</span><br><span class="line">}</span><br><span class="line">count = end - vals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2、调用 handler 的 events 处理多个事件或者调用 event 一个一个处理事件 */</span></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">handler-&gt;events(handle, vals, count);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++)</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以 evdev 为例，在上面的 evdev_handler 中提供了 events 函数 evdev_handler，该函数调用流程如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evdev_events()</span><br><span class="line">    --&gt;evdev_pass_values()</span><br><span class="line">        --&gt;__pass_event()</span><br><span class="line">        --&gt;wake_up_interruptible_poll(&amp;client-&gt;wait,</span><br><span class="line">EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM);</span><br></pre></td></tr></tbody></table></figure><p>__pass_event 函数将读取的事件传递给 client 结构体，wake_up_interruptible_poll 将应用程序唤醒（前面提到读取数据的时候如果没有数据就休眠）。</p><h1 id="input-tools">Input Tools</h1><h2 id="getevent-命令">getevent 命令</h2><p>getevent 指令用于获取 input 输入事件，比如获取按键上报信息、获取触摸屏上报信息等。 getevent -h：查看 getevent 帮助信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@rk3288:/ <span class="comment"># getevent -h</span></span><br><span class="line">getevent -h</span><br><span class="line">Usage: getevent [-t] [-n] [-s switchmask] [-S] [-v [mask]] [-d] [-p] [-i] [-l] [-q] [-c count] [-r] [device]</span><br><span class="line">    -t: show time stamps</span><br><span class="line">    -n: don<span class="string">'t print newlines</span></span><br><span class="line"><span class="string">    -s: print switch states for given bits</span></span><br><span class="line"><span class="string">    -S: print all switch states</span></span><br><span class="line"><span class="string">    -v: verbosity mask (errs=1, dev=2, name=4, info=8, vers=16, pos. events=32, props=64)</span></span><br><span class="line"><span class="string">    -d: show HID descriptor, if available</span></span><br><span class="line"><span class="string">    -p: show possible events (errs, dev, name, pos. events)</span></span><br><span class="line"><span class="string">    -i: show all device info and possible events</span></span><br><span class="line"><span class="string">    -l: label event types and names in plain text</span></span><br><span class="line"><span class="string">    -q: quiet (clear verbosity mask)</span></span><br><span class="line"><span class="string">    -c: print given number of events then exit</span></span><br><span class="line"><span class="string">    -r: print rate events are received</span></span><br></pre></td></tr></tbody></table></figure><ul><li>-t：显示时间戳</li><li>-n：不换行打印</li><li>-s：显示指定位的开关状态</li><li>-v：根据 mask 值显示相关信息，执行后会一直显示上报数据</li><li>-d：如果设备可用，显示设备隐藏的描述信息</li><li>-p：显示设备支持的事件类型和编码方式</li><li>-i：显示设备的所有信息和支持的事件，比 -p 显示更多信息</li><li>-l：以文本形式输出事件类型和名称，比 -t 更清楚直观</li><li>-c：打印固定数量的事件并退出</li><li>-r：显示事件上报速率</li></ul><p>参数可以组合使用，一次性查看需要的触摸屏信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@rk3288:/ <span class="comment"># getevent -tlr /dev/input/event3</span></span><br><span class="line">getevent -tlr /dev/input/event3</span><br><span class="line">[    2514.550104] EV_ABS       ABS_MT_TRACKING_ID   0000001c</span><br><span class="line">[    2514.550104] EV_ABS       ABS_MT_POSITION_X    00002dac</span><br><span class="line">[    2514.550104] EV_ABS       ABS_MT_POSITION_Y    000018ca</span><br><span class="line">[    2514.550104] EV_KEY       BTN_TOUCH            DOWN</span><br><span class="line">[    2514.550104] EV_ABS       ABS_X                00002dac</span><br><span class="line">[    2514.550104] EV_ABS       ABS_Y                000018ca</span><br><span class="line">[    2514.550104] EV_SYN       SYN_REPORT           00000000             rate 0</span><br><span class="line">[    2514.638845] EV_ABS       ABS_MT_TRACKING_ID   ffffffff</span><br><span class="line">[    2514.638845] EV_KEY       BTN_TOUCH            UP</span><br><span class="line">[    2514.638845] EV_SYN       SYN_REPORT           00000000             rate 11</span><br></pre></td></tr></tbody></table></figure><h2 id="tslib-调试工具">tslib 调试工具</h2><h3 id="配置-tslib">配置 tslib</h3><p>配置文件/etc/ts.conf。触摸模块从上到下加载。每一行指定一个模块及其参数，模块按顺序处理。在顶部使用一个 module_raw，访问您的设备，然后是过滤器模块的任意组合。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Uncomment if you wish to use the one-wire linux input layer S70/A70...</span></span><br><span class="line"><span class="comment"># module_raw one_wire_ts_input</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you wish to use the linux input layer event interface</span></span><br><span class="line">module_raw input</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using a Sharp Zaurus SL-5500/SL-5000d</span></span><br><span class="line"><span class="comment"># module_raw collie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using a Sharp Zaurus SL-C700/C750/C760/C860</span></span><br><span class="line"><span class="comment"># module_raw corgi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using a device with a UCB1200/1300/1400 TS interface</span></span><br><span class="line"><span class="comment"># module_raw ucb1x00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using an HP iPaq h3600 or similar</span></span><br><span class="line"><span class="comment"># module_raw h3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using a Hitachi Webpad</span></span><br><span class="line"><span class="comment"># module_raw mk712</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you're using an IBM Arctic II</span></span><br><span class="line"><span class="comment"># module_raw arctic2</span></span><br><span class="line"></span><br><span class="line">module pthres pmin=1</span><br><span class="line">module variance delta=30</span><br><span class="line">module dejitter delta=100</span><br><span class="line">module linea</span><br></pre></td></tr></tbody></table></figure><h3 id="插件">插件</h3><ul><li>pthres 压力阈值过滤器</li><li>variance 方差过滤器。尽最大努力滤除来自触摸屏 ADC 的随机噪声</li><li>dejitter 消除 X 和 Y 坐标上的抖动</li><li>debounce 简单的去抖动机制，在触摸手势停止后的指定时间内丢弃输入事件</li><li>skip nhead 按下后跳过样品，ntail 释放前跳过样品</li><li>lowpass 简单的低通指数平均滤波模块</li><li>linear 线性缩放 - 校准 - 模块，主要用于将触摸屏坐标转换为屏幕坐标</li><li>invert 围绕给定值在 X /Y 方向反转值</li><li>median 中值滤波器减少样本坐标值中的噪声。它能够过滤信号中不需要的单个大跳跃</li><li>iir 无限脉冲响应滤波器</li><li>tslib 从触摸屏驱动采样到的设备坐标进行处理再提供给应用端的过程大体如下</li></ul><p>raw device --&gt; variance --&gt; dejitter --&gt; linear --&gt; application</p><h3 id="ts_calibrate-触摸屏校准工具">ts_calibrate 触摸屏校准工具</h3><p>校准由 linear 插件完成，它使用自己的配置文件 /etc/pointercal。不要手动编辑此文件。它是由 ts_calibrate 程序创建的 ：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxTS1.png"></p><p>测试过滤后的输入行为。</p><p>您可以使用以下命令快速测试由配置的过滤器产生的触摸行为 ts_test_mt： ts_test_mt： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxTS2.png"></p><h1 id="总结">总结</h1><ul><li>应用 open 一个 input 设备，通过 vfs 调用到驱动字符设备的 open 函数，该函数创建构造一个 evdev_client 结构体并将该结构体放入打开的 input 设备的 evdev 结构体链表中<br></li><li>应用 read 读取一个 input 设备，通过 vfs 调用到驱动的字符设备 read 函数，如果没有数据就休眠<br></li><li>事件发生产生中断，在中断函数里读取数据并上报事件，上报事件流程是通过 input_dev 结构体找到驱动该结构体的 input_handler 结构体，然后调用 input_handler 结构体的 events 函数，在 events 函数里，主要干两件事，一是将外部事件传递给 evdev_client 结构体，二是将应用程序唤醒</li></ul><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9sZDI0Ni5jb20vYXJ0aWNsZS8xNTk4MDkzMjM3MjM1">https://ld246.com/article/1598093237235<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGVuZy10YW8vcC82MDk0MDQ5Lmh0bWw=">https://www.cnblogs.com/deng-tao/p/6094049.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDY0NDkxMDQ/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/106449104?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br>《韦东山老师相关课程和文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 Regmap 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverRegmap/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverRegmap/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>内核版本 3.1 中引入了 Regmap API，用于统一内核开发人员访问 SPI/IIC 设备的方式，无论是 SPI 设备还是 IIC 设备，只需要初始化，配置 Regmap 就可以通过 Regmap 读写设备。Regmap 子系统主要提供如下两种功能：</p><ul><li>第一是为 IIC/SPI/MMIO 等提供统一的访问接口，linux 中大量的 iic 和 spi 设备就可以通过统一的接口进行访问尤其对于那些同时支持 iic 和 spi 接口的设备。</li><li>第二是提供缓存访问机制用于加速设备访问设备，对于支持缓存的设备这将大大加快设备的当问速度。</li></ul><p>下面看一下 Regmapz 子系统在驱动中的位置，如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTVhMzg1NjUzYmI2NDkzMGMxYzAz">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Regmap.png"></p><span id="more"></span><h1 id="数据结构">数据结构</h1><p>regmap 子系统的实现比较简单，数据结构也是很简单的，整体结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU5YjUwZTNlNzQwNmUyMDI0Njhi">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Regmap_Struct.png"></p><ul><li><p>regmap_bus:<br>regmap_bus 数据结构用于对具体的 bus 进行封装，例如对 IIC 或 SPI 总线进行封装，这些 bus 下可以挂载很多设备，他们都从属于一个总线那么就有很多共性操作，对这个结构的封装就用 regmap_bus 结构。该结构主要提供同步读写、异步读写、格式化数据等操作接口</p></li><li><p>regmap:<br>在上面的结构中讲到 regmap_bus 用于封装具体的 bus，这些 bus 下会挂载各种不同的设备，这些设备的操作有很多不一样的，针对每一个设备进行封装就使用 regmap 结构体。该结构主要提供的功能有：缓存区和缓存操作、异步读写链表和队列操作、读写权限管理（哪些地址的寄存器是可读的、哪些地址范围是可写的以及哪些地址范围是可读写的）、读写页的支持及访问操作以及对寄存器和值的格式化操作等</p></li><li><p>regmap_config:<br>regmap_config 结构是最接近用户的，因此上图中也对该结构做了最详细的注释，该结构主要用于用户通过该结构来初始化 regmap 结构体</p></li><li><p>regmap_range_cfg:<br>regmap_range_cfg 数据结构用于描述页范围和页选择</p></li><li><p>regmap_format:<br>regmap_format 数据结构就是上面提到的用户格式化数据的结构，对于某些寄存器是 12bit 或其他非常规位数的寄存器进行格式化数据的结构</p></li><li><p>regmap_access_table:<br>regmap_access_table 数据结构用于描述对寄存器访问权限的控制，yes_ranges 是可访问地址范围而 no_range 是不可访问地址访问</p></li><li><p>regcache_ops:<br>regcache_ops 结构提供缓存操作相关接口描述</p></li></ul><h1 id="实现">实现</h1><h2 id="regmap_bus-的实现">regmap_bus 的实现</h2><p>这里以 spi 总线的 regmap_bus 为例，iic 等其他总线是相同的逻辑，regmap_spi 的实现如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_bus</span> <span class="title">regmap_spi</span> =</span> {</span><br><span class="line">.write = regmap_spi_write,</span><br><span class="line">.gather_write = regmap_spi_gather_write,</span><br><span class="line">.async_write = regmap_spi_async_write,</span><br><span class="line">.async_alloc = regmap_spi_async_alloc,</span><br><span class="line">.read = regmap_spi_read,</span><br><span class="line">.read_flag_mask = <span class="number">0x80</span>,</span><br><span class="line">.reg_format_endian_default = REGMAP_ENDIAN_BIG,</span><br><span class="line">.val_format_endian_default = REGMAP_ENDIAN_BIG,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *__<span class="title">regmap_init_spi</span>(<span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="keyword">struct</span> <span class="title">regmap_config</span> *<span class="title">config</span>,</span></span><br><span class="line"><span class="class"> <span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">lock_key</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">return</span> __regmap_init(&amp;spi-&gt;dev, &amp;regmap_spi, &amp;spi-&gt;dev, config,</span><br><span class="line">     lock_key, lock_name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到其实实现很简单就是构造一个 regmap_bus 数据结构 regmap_spi，并提供 spi 的相关操作，这里以 write 为例看下里面的实现，其他类似：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">regmap_spi_write</span><span class="params">(<span class="type">void</span> *context, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> count)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> context;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> spi_write(spi, data, count);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实就是标准的 spi 接口的调用，这也证明了 regmap 其实就是对一些底层 bus 进行进一步封装并对外提供统一的接口，同时还提供页操作缓存等非常好用的接口。</p><h2 id="regmap-的实现">regmap 的实现</h2><p>在上面介绍的__regmap_init_spi 函数就会返回一个 regmap 结构体也就是 regmap 结构体的创建过程 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__devm_regmap_init</span><br><span class="line">    __regmap_init</span><br></pre></td></tr></tbody></table></figure> __regmap_init 函数的流程比较繁琐这里就不贴代码了，大致的流程是初始化需要两个重要的数据结构 regmap_bus 和 regmap_config。每一个 regmap 都需要一个 regmap_bus 数据结构，regmap 的初始化就是设置其结构体的成员，而设置的依据就是根据 regmap_config 结构体的内容来设置。<p></p><p>其实到这里 regmap 的主体结构和实现就大概清楚了，至于其具体的实现细节像页的访问操作，缓存的操作权限的管理感兴趣的可以去 driver/base/regmap/目录下去看源码，我也没去详细了解具体的实现过程，只是梳理了一下 regmap 的大致实现过程。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDc1OTUzNzM/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/107595373?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDc1OTUzNDA/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/107595340?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 Pinctrl 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverPinctrl/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverPinctrl/</url>
      
        <content type="html"><![CDATA[<h1 id="pinctrl-概述">Pinctrl 概述</h1><p>关于 pinctrl 主要可以归结为两类设置，其中一类是功能选择，即一组 gpio 是用于 iic 还是 uart 还是就作为普通 gpio 来用，另一类是 gpio 的特性配置，即上拉、下拉、驱动能力和速率的配置。而 pinctrl 主要负责这两类配置的管理工作。总结起来 pinctrl 主要完成以下三种功能：</p><ul><li>引脚枚举与命名 (Enumerating and naming)</li><li>引脚复用 (Multiplexing)：比如用作 GPIO、I2C 或其他功能</li><li>引脚配置 (Configuration)：比如上拉、下来、open drain、驱动强度等</li></ul><span id="more"></span><h1 id="dts-配置">dts 配置</h1><p>以全志平台的写法如下（虚构的）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uart0_pins: uart0-pins {</span><br><span class="line">    pins = "PA4", "PA5";</span><br><span class="line">    function = "uart0";</span><br><span class="line">};</span><br><span class="line">uart0_sleep_pins: uart0-pins {</span><br><span class="line">    pins = "PA4", "PA5";</span><br><span class="line">    function = "gpio";</span><br><span class="line">};</span><br><span class="line">...</span><br><span class="line">&amp;uart0 {</span><br><span class="line">    pinctrl-names = "default","sleep";</span><br><span class="line">    pinctrl-0 = &lt;&amp;uart0_pins&gt;;</span><br><span class="line">    pinctrl-1 = &lt;&amp;uart0_sleep_pins&gt;;</span><br><span class="line">    status = "okay";</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>pinctrl-0 对应的 pinctrl-names 的第 0 个名称 default，默认配置，也就是 uart0 在使用 pinctrl 的时候的默认配置，pinctrl-1 对应的是 pinctrl-names 的第一个名称 sleep，在系统进入休眠的时候会通过 pinctrl 将 uart0 的 pin 配置成 gpio 功能。</p><h1 id="pinctrl-重要概念">Pinctrl 重要概念</h1><p>在软件上将他们分为 pin controller 和 client device 两个设备，但是 pinctrl 一般是没有具体硬件的控制器的，就是 gpio 里的一些 config 和 data 寄存器，control 是软件抽象的概念。</p><h2 id="pin-controller">Pin Controller</h2><p>pin controller 和 GPIO Controller 不是一回事，前者控制的引脚可用于 GPIO 功能、I2C 功能；后者只是把引脚配置为输入、输出等简单的功能。即先用 pin controller 把引脚配置为 GPIO，再用 GPIO Controler 把引脚配置为输入或输出。</p><ul><li><p>Pin State<br>对于一个“client device”来说，比如对于一个 UART 设备，它有多个“状态”：default、sleep 等，那对应的引脚也有这些状态。比如默认状态下，UART 设备是工作的，那么所用的引脚就要复用为 UART 功能。在休眠状态下，为了省电，可以把这些引脚复用为 GPIO 功能；或者直接把它们配置输出高电平</p></li><li><p>Groups 和 Function<br>一个设备会用到一个或多个引脚，这些引脚就可以归为一组 (group)。这些引脚可以复用为某个功能：function</p></li><li><p>Multiplexing node 和 Configuration node<br>可以用来描述复用信息：哪组 (group) 引脚复用为哪个功能 (function) 可以用来描述配置信息：哪组 (group) 引脚配置为哪个设置功能 (setting)，比如上拉、下拉等</p></li></ul><h2 id="client-device">Client Device</h2><p>具体到每个控制器一般都是要通过 pin 脚与外部连接的，这就需要使用 soc 的 pin 脚，那么这个控制器就是 pinctrl 的 client device，具体的 client device 会通过 pinctrl 来将 pin 设置为相应的功能及配置。</p><h1 id="数据结构">数据结构</h1><p>pinctrl 的数据结构是比较复杂的，整体数据结构之间的关系如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjEzYjdiMzlmMzQ2ZmIwNzBiOThkYjdi">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PinCtrlStruct.png"></p><p>上图是数据结构的整体结构图，主要分为三部分，下面我将分别介绍每一部分：</p><ul><li><p>pin controller:<br>pin controller 主要是描述该 soc 的所有引脚信息以及一系列操作函数集。该结构通过 pinctrl_dev 数据结构来描述，该结构体主要提供的功能是：将此引脚控制器的每个引脚描述符保存在 radix_tree 树中，通过 struct pin_desc 来描述该引脚控制器，pin_desc 里有控制器的每个引脚配置信息以及访问及设置该引脚控制器的方法，也就是 pctlops、pmxops 和 confops，分别是访问控制器下的 pin 和 group 的方法、设置复用功能和设置配置引脚的操作方法，这个一般由 soc 原厂来提供驱动</p></li><li><p>pinctrl_maps:<br>pinctrl_maps 主要是描述板级配置信息，对于一块单板会使用的 soc 的不同控制器及不同配置，对于同一 soc 的 iic0 控制器在不同单板上可以接在不同的 pin group 上，这就是 pin 的管脚复用功能。在 dts 中如下：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;uart0 {</span><br><span class="line">    pinctrl-names = <span class="string">"default"</span>,<span class="string">"sleep"</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;uart0_pins&gt;;</span><br><span class="line">    pinctrl<span class="number">-1</span> = &lt;&amp;uart0_sleep_pins&gt;;</span><br><span class="line">    status = <span class="string">"okay"</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>pinctrl-0 和 pinctrl-1 等会被解析成一个个的 pinctrl_maps 然后通过 pinctrl_register_mappings 函数将每一个控制器用到的引脚信息这册到内核，实际上就是通过一个链表组织整个单板上控制器的引脚状态信息</p></li><li><p>pinctrl:<br>pinctrl 主要是描述 client 设备管脚的状态和使用情况。例如对于 uart、iic、spi 等设备都需要通过 pin 与其他设备进行通信，那么就需要配置 pin 连接到对应的具体控制器以及配置 pin 的一些电器特性，例如上下拉，驱动能力速率等信息。该数据结构既然是 client 端的数据那么就需要挂入到设备驱动模型结构中，在上图可以看到该结构先是挂入到 dev_pin_info 结构，然后 dev_pin_info 又是 struct device 结构的成员，这是该结构的上半部分；下半部分是状态信息的描述了首先是挂接所有的状态例如 default、sleep 状态。然后每个状态下就是配置信息，这些配置信息来自上面介绍的 pinctrl_maps 结构体中的数据</p></li></ul><h1 id="实现">实现</h1><h2 id="pin-controller-的注册">Pin Controller 的注册</h2><p>pin controller 的注册主要调用吧如下函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span></span><br></pre></td></tr></tbody></table></figure><p>该函数需要提供一个 pinctrl_desc 结构体，并返回一个 pinctrl_dev 结构体。由于函数调用关系比较简单这里就不画流程图了。这里最关键的是 pinctrl_desc 结构体：该结构体用于描述一个 soc pin controller 的信息，包含所支持的 pin 引脚的描述（每一个引脚的名称与 index）、pin 复用操作的接口（主要是 struct pinmux_ops 类型的变量，包含引脚的申请与释放、gpio 引脚复用配置以及方向设置接口等）、pin 引脚或 group 相关的引脚配置接口（包含引脚配置接口、引脚当前配置参数获取接口、group 相关引脚的配置接口、debug 接口等）、group 相关的操作接口（获取 group 的个数、获取 group 的名称、获取 group 对应的引脚内容、从设备树设备节点中解析 board pin 描述信息并进行 pinctrl map 注册的接口 dt_node_to_map）。然后 pinctrl_register 函数就是创建一个 pinctrl_dev 结构体然后设置相关成员变量并对 pinctrl_desc 结构体中提供的一些函数操作做检查（必须提供函数实现），再将 pinctrl_dev 链入 pinctrldev_list 全局链表中即可。</p><p>devm_pinctrl_register 是 pinctrl_register 的资源管理版本，也是调用 pinctrl_register 实现的：</p><h2 id="pinctrl-map-注册">Pinctrl Map 注册</h2><p>pinctrl map 的注册函数是 pinctrl_register_mappings，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_register_mappings</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *maps,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> num_maps)</span></span><br></pre></td></tr></tbody></table></figure><p>该函数也比较简单，需要提供一个需要注册到内核的 pinctrl_map 结构体，然后 pinctrl_register_mappings 函数就对该结构体进行 check，然后将其挂在 pinctrl_maps 链表上。</p><h2 id="bing-过程">Bing 过程</h2><p>在前面提到了 client 里会通过设备树获得一个个的 pinctrl_maps 结构，而该结构是要根 pin controller 里的 pin 之间建立联系的，因为不同的 soc pin 脚的设计都是不一样的，其配置方法也不一样，而在控制器初始化阶段需要解析出该控制器所使用的 pin 脚然后与 controller 提供的 pin 脚建立联系通过 controller 的 pin 或 group 操作函数集来操作具体的 pin 配置为想要的功能。</p><p>在前面介绍设备驱动模型的时候有一张 device 注册过程的流程图，其中有一个细节就是在 driver_probe_device 的时候会调用 really_probe 函数，而 really_probe 函数又会调用 pinctrl_bind_pins 函数用来处理 pinctrl 信息，如下：<span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzYxMTY4ODc1N2Q5YzA4MDZlNGFlZmUzOS5wbmc=">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/DeviceRegister.png"></p><p>下面我们将其中的 pinctrl 处理过程补充完，pinctrl_bind_pins 函数如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU4ZTExZTA4NTMwNmQ3NDFhNjE3">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PinCtrlBingPin.png"></p><p>该函数主要完成以下工作：</p><ul><li>解析设备树，解析 client 设备的 pinctrl 状态信息，并创建相关结构</li><li>通过设备树中的 pinctrl 的 phandle 找到 controller 配置中的 pin，并将设备树中的每一个状态转换为 map 结构，这里由于不同的 soc 关于 pinctrl 的设备树写法不一致因此这里通过 controller 提供的回调函数 dt_node_to_map 转换为 map 结构（具体的 soc 有自己的实现自然知道转换方法）并将一系列的 map 转换为一系列的与 map 对应的 setting 结构</li><li>对每一个 map 结构进行 pinmux 和 pinconf 的设置，同样设置函数也是由具体的 controller 提供实现，然后通过函数指针调用具体的实现</li></ul><h1 id="与-gpio-的关系">与 gpio 的关系</h1><p>原则上 gpio 子系统是 pinctrl 的 client 用户，gpio 和 iic、spi 这些一样会通过 pinctrl 来配置，但是实际上 gpio 和 pinctrl 之间有更为紧密的联系，如果通过 soc 的 datasheet 我们也可以了解到实际的 soc 中并没有具体的 pin controller 硬件，这个一般都在 gpio 的章节中介绍，与 gpio 的寄存器之间是密不可分的。这里关于 gpio 和 pinctrl 之间的关系可以参考 <span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvZ3Bpb19zdWJzeXN0ZW0vcGluY3RybC1hbmQtZ3Bpby5odG1s">窝窝科技<i class="fa fa-external-link-alt"></i></span> 的文章。</p><h2 id="pinctrl-和-gpio-之间的强耦合实现">pinctrl 和 gpio 之间的强耦合实现</h2><p>首先还是看下相关数据结构，如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU5MWIwZTNlNzQwNmUyMDI0NjIz">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/GPIO2Pinctrl.png"></p><p>gpio 和 pinctrl 通过 gpio_pin_range 建立映射关系，将 gpio 中的 pin 描述转换到 pinctrl 中的 pin 描述空间，从而将两者建立关联，这样 gpio 就可以不通过 pinctrl 提供的标准接口来设置 pin 的复用和配置了。gpio_pin_range 这个描述关系通过 dts 文件来描述，这样就可以不通过代码将他们建立联系，写法如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qe_pio_e: gpio-controller@<span class="number">1460</span> {</span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    compatible = <span class="string">"fsl,qe-pario-bank-e"</span>, <span class="string">"fsl,qe-pario-bank"</span>;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl1 <span class="number">0</span> <span class="number">20</span> <span class="number">10</span>&gt;, &lt;&amp;pinctrl2 <span class="number">10</span> <span class="number">50</span> <span class="number">20</span>&gt;;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>上面 dts 节点中的 gpio-ranges 关键字指定了两个 gpio range：gpio controller(qe_pio_e) 中的 gpio0 ~ 9 和 pinctrl1 中的 pin20 ~ 29 对应；gpio controller(qe_pio_e) 中的 gpio10 ~ 29 和 pinctrl2 中的 pin50 ~ 69 对应。 而 dts 文件的解析过程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU5M2NlNDAxZmQzYzI0OWUyZjQx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/gpiochip_add_data.png"></p><p>以上过程将生成 pinctrl_dev 下由 gpio_ranges 组织成的链表。</p><p>下面以 gpiod_get 函数为例看一下 gpio 中具体是如何使用 pinctrl 中的接口的，gpiod_get 函数流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU5NTZlNDAxZmQzYzI0OWUyZjVk">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/gpiod_get.png"></p><p>该函数就是将 gpio 中的 pin 描述转换到 pinctrl 中的描述，进而找到该管脚在 pinctrl 中的描述然后调用 pin controller 提供的函数来设置引脚复用功能和配置引脚。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDY2Nzc3ODE=">https://blog.csdn.net/lickylin/article/details/106677781<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpY2t5bGluL2FydGljbGUvZGV0YWlscy8xMDY2Nzc4NTE/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">https://blog.csdn.net/lickylin/article/details/106677851?spm=1001.2014.3001.5501<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvc29ydC9ncGlvX3N1YnN5c3RlbQ==">窝窝科技 gpio 子系统相关文章<i class="fa fa-external-link-alt"></i></span><br>《韦东山老师的书籍和课程》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 GPIO 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverGPIO/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverGPIO/</url>
      
        <content type="html"><![CDATA[<h1 id="gpio-概述">GPIO 概述</h1><p>以前学习 stm32 的时候看到手册里有关于 gpio 的电路图，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/gpio.png"></p><ul><li><p>保护二极体：<br>IO 引脚上下两边两个二极体用于防止引脚外部过高、过低的电压输入。当引脚电压高于 VDD 时，上方的二极体导通；当引脚电压低于 VSS 时，下方的二极体导通，防止不正常电压引入晶片导致晶片烧毁</p></li><li><p>P-MOS 管和 N-MOS 管：<br>由 P-MOS 管和 N-MOS 管组成的单元电路使得 GPIO 具有“推挽输出”和“开漏输出”的模式</p></li><li><p>TTL 肖特基触发器：<br>信号经过触发器后，模拟信号转化为 0 和 1 的数字信号。但是，当 GPIO 引脚作为 ADC 采集电压的输入通道时，用其“模拟输入”功能，此时信号不再经过触发器进行 TTL 电平转换。ADC 外设要采集到的原始的模拟信号</p></li></ul><span id="more"></span><p>STM32 的 GPIO 支持 4 种输入模式（浮空输入、上拉输入、下拉输入、模拟输入）和 4 种输出模式（开漏输出、开漏复用输出、推挽输出、推挽复用输出）</p><ul><li><p>浮空输入模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/floatin.png"></p></li><li><p>上拉输入模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/pullupin.png"></p></li><li><p>下拉输入模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/pulldownin.png"></p></li><li><p>模拟输入模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/ain.png"></p></li><li><p>开漏输出模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/openout.png"></p></li></ul><p>开漏输出模式下，通过设定位设定/清除寄存器或者输出寄存器的值，途经 N-MOS 管，最终输出到 I/O 口。这里要注意 N-MOS 管，当设定输出的值为高电平的时候，N-MOS 管处于关闭状态，此时 I/O 口的电平就不会由输出的高低电平决定，而是由 I/O 口外部的上拉或者下拉决定；当设定输出的值为低电平的时候，N-MOS 管处于开启状态，此时 I/O 口的电平就是低电平。同时，I/O 口的电平也可以通过输入电路进行读取；注意，I/O 口的电平不一定是输出的电平。</p><ul><li>开漏复用输出模式： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/openflexout.png"></li></ul><h1 id="gpio-驱动中几个概念">GPIO 驱动中几个概念</h1><ul><li><p>Active-High and Active-Low<br>以 LED 为例，需要设置 GPIO 电平。但是有些电路可能是高电平点亮 LED，有些是低电平点亮 LED。</p><p>可以使用如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpiod_set_value(gpio, <span class="number">1</span>);  <span class="comment">// 输出高电平点亮 LED</span></span><br><span class="line">gpiod_set_value(gpio, <span class="number">0</span>);  <span class="comment">// 输出低电平点亮 LED</span></span><br></pre></td></tr></tbody></table></figure><p>对应同一个目标：点亮 LED，对于不同的 LED，就需要不同的代码，原因在于上面的代码中 1、0 表示的是"物理值"。</p><p>如果能使用"逻辑值"，同样的逻辑值在不同的配置下输出对应的物理值，就可以保持代码一致，比如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpiod_set_value(gpio, <span class="number">1</span>);  <span class="comment">// 输出逻辑 1</span></span><br><span class="line">                           <span class="comment">// 在 Active-High 的情况下它会输出高电平</span></span><br><span class="line">                           <span class="comment">// 在 Active-Low 的情况下它会输出低电平</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Open Drain and Open Source: 有多个 GPIO 同时驱动一个电路时，就需要设置 Open Drain 或 Open Source</p><ul><li>Open Drain：引脚被设置为低电平时才会驱动电路，典型场景是 I2C 接口。</li><li>Open Source：引脚被设置为高电平时才会驱动电路。</li></ul></li></ul><h1 id="gpio-数据结构">GPIO 数据结构</h1><p>要理解一个驱动框架的设计就一定要理清楚该框架下的数据结构组织关系，首先列出 gpio 子系统的数据结构关系图如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU2OGI1NjUzYmI2NDkzMGMxOTFj">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/GPIO_Struct.png"></p><ul><li><p>gpio_chip: gpio_chip 这个数据结构用于描述一组 gpio，soc 里的 gpio 一般都是分为几组，同一组内的 gpio 具有相同的操作方式</p></li><li><p>gpio_device: gpio_device 是具体的 device 它管理一个 gpio_chip 和该组下的所有 pin。gpio_device 通过链表连接起来就是 soc 内的多组 gpio</p></li><li><p>gpio_desc: gpio_desc 这个结构用于描述一个 pin，一组 gpio 里面有 32 个 pin 或者多个 pin，每一个 pin 由 gpio_desc 描述，同一组的 pin 挂载在 gpio_device 下</p></li></ul><h1 id="gpio-子系统的层次和接口">GPIO 子系统的层次和接口</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/gpio_system_level.png"></p><p>硬件层之上是 soc 原厂提供的 gpio controller 驱动这部分提供了具体 soc 的 pin 脚的描述和控制接口，在这之上是 gpiolib 层为其他驱动程序提供统一的接口来配置和控制 gpio，再往上就是其他驱动程序使用 gpio 的接口完成他们想要的工作。当然在 gpiolib 之下还会使用 pinctrl 子系统来管理 pin 的功能复用与配置，这个在 pinctrl 一篇文章里再详细说明。</p><h1 id="实现">实现</h1><p>gpio_chip 是描述一个 gpio 控制器的数据结构，将一个 gpio 控制器添加到系统中的流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU2Y2YwNzkxMjkwNmIyYTQ0ZGEx">原图<i class="fa fa-external-link-alt"></i></span><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/GPIO_CHIP_ADD.png"></p><p>对于 gpio 驱动一般由原厂写好，其他驱动工程师不需要编写具体驱动，需要的时候直接在 dts 里配置就可以直接使用。其中 gpio_chip 结构体的注册如上图所示，每个 gpio_chip 都需要一个 gpio_device 结构，要先分配一个 gpio_device 结构体，然后就是处理该组下的 pin，以及各种中断信息。</p><h1 id="sysfs-接口">sysfs 接口</h1><p><code>/sys/bus/gpio/devices</code>目录下，列出了所有的 GPIO 控制器 <code>/sys/class/gpio/gpiochipXXX</code>下有每个 GPIO 控制器的详细信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/sys/class/gpio/gpiochip508]# </span><span class="language-bash"><span class="built_in">ls</span> -1</span></span><br><span class="line">base     // 这个 GPIO 控制器的 GPIO 编号</span><br><span class="line">device</span><br><span class="line">label    // 名字</span><br><span class="line">ngpio    // 引脚个数</span><br><span class="line">power</span><br><span class="line">subsystem</span><br><span class="line">uevent</span><br></pre></td></tr></tbody></table></figure><p>查看 gpio 使用情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/gpio</span><br></pre></td></tr></tbody></table></figure><p>导出/设置方向/读写值：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">echo 509 &gt; /sys/class/gpio/export</span><br><span class="line">echo out &gt; /sys/class/gpio/gpio509/direction</span><br><span class="line">echo 1 &gt; /sys/class/gpio/gpio509/value</span><br><span class="line">echo 509 &gt; /sys/class/gpio/unexport</span><br><span class="line"></span><br><span class="line">echo 509 &gt; /sys/class/gpio/export</span><br><span class="line">echo in &gt; /sys/class/gpio/gpio509/direction</span><br><span class="line">cat /sys/class/gpio/gpio509/value</span><br><span class="line">echo 509 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly9pdGVyMDEuY29tLzUzOTA0MS5odG1s">https://iter01.com/539041.html<i class="fa fa-external-link-alt"></i></span><br>《韦东山老师的书籍和课程》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 SPI 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverSPI/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverSPI/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-spi-驱动框架">Linux SPI 驱动框架</h1><p>对于 SPI 的驱动框架与 I2C 是大致一致的，也分为两层，控制器驱动程序层叫 spi_controller ，主要提供 transfer 函数，进行 spi 协议的收发。</p><p>另一层是设备驱动层，基于 spi_bus_type，在 driver 里则使用 spi_read、spi_writer 等函数，最终也会调用到 controller-&gt;transfer 函数进行发送接收。</p><span id="more"></span><h1 id="数据结构">数据结构</h1><p>整体数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTU0NzQ2Mzc2ODkyMWZhMjUwYTJk">原图<i class="fa fa-external-link-alt"></i></span><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/SPI_Struct.png"></p><ul><li>spi_controller 结构体用于描述一个 spi 控制器，可以类比 iic 的 i2c_adapt。</li><li>spi_device 结构体用于描述一个 spi 设备，可以类比于 i2c_client 结构体。</li></ul><p>spi_device 结构里有个 mode 很重要下面是其详细描述，SPI 模式主要有两个特征：</p><ul><li>CPOL：这是时钟极性：<ul><li>0：初始时钟状态为低电平，第一个时钟边沿是上升沿<br></li><li>1：初始时钟状态为高电平，第一个时钟边沿是下降沿</li></ul></li><li>CPHA：这是时钟相位，选择在哪个边沿采样数据：<ul><li>0：数据在下降沿锁存，输出在上升沿改变<br></li><li>1：数据在上升沿锁存，并在下降沿输出</li></ul></li></ul><p>这有四种 SPI 模式，如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/spi4mode.png"></p><ul><li>spi_driver 用于驱动 spi 设备，可以类比 i2c_driver 结构体。</li><li>spi_message 用于描述 spi 传输的消息，由多个 spi_transfer 段组成，可以类比 i2c_message 结构体。</li><li>spi_transfer 代表一个读写缓冲对，包含接收缓冲区及发送缓冲区，其实，spi_transfer 的发送是通过构建 spi_message 实现，通过将 spi_transfer 中的链 transfer_list 链接到 spi_message 中的 transfers，再以 spi_message 形势向底层发送数据。</li></ul><h2 id="实现">实现</h2><p>关于 spi 的实现其实也是分为 controller 和设备及设备驱动这三部分，controller 一般由 soc 厂商编写好了驱动通过 spi_register_controller 向内核注册一个 controller 设备并挂载在 spi_bus 总线下，而 device 和 device_driver 的实现根 platform 或 iic 的实现也是大同小异，这里不做详细的分析了，感兴趣的可以查看内核源码。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLWNuLyVFNSVCQSU4RiVFNSU4OCU5NyVFNSU5MSVBOCVFOSU4MiU4QSVFNCVCQiU4QiVFOSU5RCVBMg==">https://www.wikiwand.com/zh-cn/%E5%BA%8F%E5%88%97%E5%91%A8%E9%82%8A%E4%BB%8B%E9%9D%A2<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpenVvYmluMi9hcnRpY2xlL2RldGFpbHMvNTE3MzU5NjM=">https://blog.csdn.net/lizuobin2/article/details/51735963<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3V0YW9wb3dlci9hcnRpY2xlL2RldGFpbHMvOTk4NjY3NzM=">https://blog.csdn.net/zhoutaopower/article/details/99866773<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 PWM</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverPWM/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverPWM/</url>
      
        <content type="html"><![CDATA[<h1 id="pwm-概述">PWM 概述</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PWM.png"></p><ul><li>Ton：信号高电平持续时间</li><li>Toff：信号底电平持续时间</li><li>Period： 完整 pwm 周期</li><li>Duty cycle：pwm 信号周期内保持为 ON 的时间百分比</li></ul><span id="more"></span><h1 id="linux-下-pwm-驱动">Linux 下 PWM 驱动</h1><h2 id="数据结构">数据结构</h2><p>pwm 的数据结构如下图所示：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTUyODYwZTNlNzQwNmUyMDI0MTMx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PWM_Struct.png"></p><ul><li>pwm_chip 结构体用于抽象 soc 的 pwm 控制器</li><li>pwm_device 用来抽象设备</li><li>pwm_state 表示 pwm 设备的周期、占空比、极性等信息</li><li>pwm ops 结构体提供一系列回调函数。这些回调函数的操作对象是具体的 pwm device</li></ul><h2 id="实现">实现</h2><p>pwm 驱动分为 consumer 和 provider。其中 consumer 提供接口如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pwm_config</span><span class="params">(<span class="keyword">struct</span> pwm_device *pwm, <span class="type">int</span> duty_ns, <span class="type">int</span> period_ns)</span> <span class="comment">//配置 pwm device 的频率、占空比。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pwm_enable</span><span class="params">(<span class="keyword">struct</span> pwm_device *pwm)</span>                            <span class="comment">//使能/禁止 pwm 信号输出</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pwm_disable</span><span class="params">(<span class="keyword">struct</span> pwm_device *pwm)</span></span><br></pre></td></tr></tbody></table></figure><p>这些接口实现对 pwm 设备的配置，使能等（这些接口最终会调用到 pwm_ops 结构体提供的函数），操作 struct pwm_device 结构体，代表了具体的 pwm 设备。这些 struct pwm_device 结构体指针由以下函数获得：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pwm_device *<span class="title function_">pwm_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *con_id)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm_put</span><span class="params">(<span class="keyword">struct</span> pwm_device *pwm)</span></span><br><span class="line"><span class="keyword">struct</span> pwm_device *<span class="title function_">devm_pwm_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *con_id)</span></span><br></pre></td></tr></tbody></table></figure><p>其中 pwm_get 接口流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTUyYTUwNzkxMjkwNmIyYTQ0YTI5">原图<i class="fa fa-external-link-alt"></i></span><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PWM_Get.png"></p><p>pwm_get/devm_pwm_get，从指定设备（dev）的 DTS 节点中，获得对应的 PWM 句柄。可以通过 con_id 指定一个名称，或者会获取和该设备绑定的第一个 PWM 句柄。</p><p>provider 提供以下接口：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwmchip_add</span><span class="params">(<span class="keyword">struct</span> pwm_chip *chip)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pwmchip_remove</span><span class="params">(<span class="keyword">struct</span> pwm_chip *chip)</span></span><br></pre></td></tr></tbody></table></figure><p>将一个 pwm_chip 注册到内核添加到 pwm_chips 链表中去。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvY29tbS9wd21fb3ZlcnZpZXcuaHRtbA==">http://www.wowotech.net/comm/pwm_overview.html<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之 IIC 子系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverIIC/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverIIC/</url>
      
        <content type="html"><![CDATA[<h1 id="iic-协议">IIC 协议</h1><h2 id="写操作">写操作</h2><p>流程如下：</p><ul><li>主芯片要发出一个 start 信号</li><li>然后发出一个设备地址（用来确定是往哪一个芯片写数据），方向（读/写，0 表示写，1 表示读）</li><li>从设备回应（用来确定这个设备是否存在），然后就可以传输数据</li><li>主设备发送一个字节数据给从设备，并等待回应</li><li>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成），然后再传输下一个数据</li><li>数据发送完之后，主芯片就会发送一个停止信号</li></ul><p>下图：白色背景表示"主→从"，灰色背景表示"从→主" <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/007_i2c_write.png"></p><span id="more"></span><h2 id="读操作">读操作</h2><p>流程如下：</p><ul><li>主芯片要发出一个 start 信号</li><li>然后发出一个设备地址（用来确定是往哪一个芯片写数据），方向（读/写，0 表示写，1 表示读）</li><li>从设备回应（用来确定这个设备是否存在），然后就可以传输数据</li><li>从设备发送一个字节数据给主设备，并等待回应</li><li>每传输一字节数据，接收方要有一个回应信号（确定数据是否接受完成），然后再传输下一个数据</li><li>数据发送完之后，主芯片就会发送一个停止信号</li></ul><p>下图：白色背景表示"主→从"，灰色背景表示"从→主" <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/008_i2c_read.png"></p><h2 id="iic-信号">IIC 信号</h2><p>IIC 协议中数据传输的单位是字节，也就是 8 位。但是要用到 9 个时钟：前面 8 个时钟用来传输 8 数据，第 9 个时钟用来传输回应信号。传输时，先传输最高位 (MSB)。</p><ul><li>开始信号（S）：SCL 为高电平时，SDA 从高电平向低电平跳变，开始传送数据</li><li>结束信号（P）：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据</li><li>响应信号 (ACK)：接收器在接收到 8 位数据后，在第 9 个时钟周期，拉低 SDA</li><li>SDA 上传输的数据必须在 SCL 为高电平期间保持稳定，SDA 上的数据只能在 SCL 为低电平期间变化</li></ul><p>IIC 协议信号如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/009_i2c_signal.png"></p><h2 id="硬件实现">硬件实现</h2><p>scl 和 sda 管脚都采用开漏输出的驱动方式，需要外接上拉电阻来输出高电平。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/010_i2c_signal_internal.png"></p><p>真值表如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/011_true_value_table.png"></p><p>从真值表和电路图我们可以知道：</p><ul><li>当某一个芯片不想影响 SDA 线时，那就不驱动这个三极管</li><li>想让 SDA 输出高电平，双方都不驱动三极管 (SDA 通过上拉电阻变为高电平）</li><li>想让 SDA 输出低电平，就驱动三极管</li></ul><h2 id="硬件拓扑">硬件拓扑</h2><p>soc 中的 iic 控制器与挂载在 iic 总线上的设备的拓扑图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/001_i2c_hardware_block.png"></p><h2 id="smbus-协议">SMBus 协议</h2><p>SMBus 是基于 IIC 协议的，SMBus 要求更严格，SMBus 是 IIC 协议的子集，做了相关限制，例如 VDD 的极限值不一样、地址回应 (Address Acknowledge)、时钟频率等都有相关限制，这里不做过多说明。</p><h1 id="数据结构">数据结构</h1><p>首先通过一张图来展示这些数据结构之间的关系，如下图：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTRjOTQ2Mzc2ODkyMWZhMjUwMWMx">原图<i class="fa fa-external-link-alt"></i></span><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/IIC_Struct.png"></p><ul><li><p>bus_type:<br>iic 是一个总线设备，linux 启动阶段会创建一个 iic 总线 i2c_bus_type，该总线用于管理 i2c_client 设备和 i2c_driver 驱动。该结构跟 linux 驱动之设备模型里的总线相同，这里实现了它自己的 match 和 probe 函数</p></li><li><p>i2c_adapter:<br>每个 soc 内部都有自己的多个 iic 控制器，i2c_adapter 结构体就是用于描述 iic 控制器的结构体（就是 iic controler），结构体里的 nr 用于表述该控制器是第几个控制器例如 iic-0，iic-1 等。这里面有一个最重要的结构就是 i2c_algorithm，该结构是具体 controler 实际 iic 传输的实现，由具体的平台实现自己的 i2c_algorithm</p></li><li><p>i2c_client:<br>一个 iic 下会挂载一个或多个设备，每个设备的信息由 i2c_client 结构体描述，例如设备地址等信息。该结构体还有一个指针指向 i2c_adapter，表示该设备挂载在哪个 iic controler 下以便在 iic 通信的时候通过 i2c_adapter 提供的 i2c_algorithm 提供的接口完成实际的数据传输</p></li><li><p>i2c_driver:<br>iic 下挂载的设备例如 tp、温湿度传感器等设备的驱动由该数据结构来描述，这个是我们实际编写驱动中最常用的，通过 iic 驱动具体的挂载在 iic 总线上的设备。i2c_driver 跟 i2c_client 匹配成功后，就调用 i2c_driver.probe 函数</p></li><li><p>i2c_msg:<br>有了 iic 设备和 iic 驱动了，iic 是通信总线，那就是要用来传输消息的，还有一个描述具体消息的结构体就是 i2c_msg，该结构体描述了消息方向，传输地址，消息长度以及消息本身内容</p></li></ul><p>可以看到我们的 iic 驱动也是使用之前描述的设备驱动模型，bus 下挂载链条结构一个挂载设备一个挂载驱动通过总线提供的 match 函数进行匹配实现 device 找到 device_driver 或则 device_driver 找到要驱动的 device，然后在 match 成功后通过总线的 probe 函数调用到驱动的 probe 函数，实际驱动开发人员只需要填充 i2c_driver 结构体并将其注册到总线就可以了。区别在于 iic 总线是一个具体实实在在的总线，soc 内部有 iic 控制器，通过 i2c_adapter 描述提供统一的接口，i2c_driver 通过 i2c_adapter 提供的 iic 传输函数来操作 i2c_client 设备，这就是 iic 总线驱动的整体框架了。</p><h1 id="流程分析">流程分析</h1><p>i2c_register_adapter 函数流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTRjYjY2Mzc2ODkyMWZhMjUwMWUz">原图<i class="fa fa-external-link-alt"></i></span><br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/IIC_RegisterAdapt.png"></p><p>这里面有一个函数 i2c_detect 需要注意，该函数会遍历总线下的每一个 i2c_driver 并调用 i2c_driver 的 detect 函数，具体的 i2c_driver 的 detect 函数由具体的驱动实现。</p><p>i2c_register_driver 函数流程如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTRjZDM2Mzc2ODkyMWZhMjUwMjA0">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/IIC_RegisterDriver.png"></p><p>i2c_driver 同 adapt 的注册有一些相同的流程，其中 detect 函数就是其中之一，注册 i2c_driver 的时候也会遍历 bus 下的 i2c_driver 并调用相应的 detect 函数。</p><h1 id="i2c-tools">I2C tools</h1><h2 id="选择工具-i2c_tools">选择工具 i2c_tools</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Utilities--&gt;</span><br><span class="line">i2c-tools--&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="用法">用法</h2><ul><li><p>i2cdetect:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]</span><br><span class="line">       i2cdetect -F I2CBUS</span><br><span class="line">       i2cdetect -l</span><br><span class="line">  I2CBUS is an <span class="built_in">integer</span> or an I2C bus name</span><br><span class="line">  If provided, FIRST and LAST <span class="built_in">limit</span> the probing range.</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>i2cdump:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cdump [-f] [-y] [-r first-last] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]</span><br><span class="line">  I2CBUS is an <span class="built_in">integer</span> or an I2C bus name</span><br><span class="line">  ADDRESS is an <span class="built_in">integer</span> (0x03 - 0x77)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    b (byte, default)</span><br><span class="line">    w (word)</span><br><span class="line">    W (word on even register addresses)</span><br><span class="line">    s (SMBus block)</span><br><span class="line">    i (I2C block)</span><br><span class="line">    c (consecutive byte)</span><br><span class="line">    Append p <span class="keyword">for</span> SMBus PEC</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>i2cget：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cget [-f] [-y] I2CBUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]</span><br><span class="line">  I2CBUS is an <span class="built_in">integer</span> or an I2C bus name</span><br><span class="line">  ADDRESS is an <span class="built_in">integer</span> (0x03 - 0x77)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    b (<span class="built_in">read</span> byte data, default)</span><br><span class="line">    w (<span class="built_in">read</span> word data)</span><br><span class="line">    c (write byte/read byte)</span><br><span class="line">    Append p <span class="keyword">for</span> SMBus PEC</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>i2cset：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: i2cset [-f] [-y] [-m MASK] [-r] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]</span><br><span class="line">  I2CBUS is an <span class="built_in">integer</span> or an I2C bus name</span><br><span class="line">  ADDRESS is an <span class="built_in">integer</span> (0x03 - 0x77)</span><br><span class="line">  MODE is one of:</span><br><span class="line">    c (byte, no value)</span><br><span class="line">    b (byte data, default)</span><br><span class="line">    w (word data)</span><br><span class="line">    i (I2C block data)</span><br><span class="line">    s (SMBus block data)</span><br><span class="line">    Append p <span class="keyword">for</span> SMBus PEC</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h1 id="参考文献">参考文献：</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvc29ydC9jb21t">http://www.wowotech.net/sort/comm<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGtubGZ5L3AvMzI2NTEwOC5odG1s">https://www.cnblogs.com/lknlfy/p/3265108.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3h5YmIuY29tL2FydGljbGUvcm9ja3JvY2t3dS83NDM1ODE3">https://www.cxybb.com/article/rockrockwu/7435817<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之设备树</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverDeviceTree/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverDeviceTree/</url>
      
        <content type="html"><![CDATA[<h1 id="dtb-数据解析">dtb 数据解析</h1><h2 id="内核启动阶段获得-dtb-位置指针">内核启动阶段获得 dtb 位置指针</h2><p>以 arm64 为例，内核启动如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_EFI</span><br><span class="line">addx13, x18, #0x16</span><br><span class="line">bstext</span><br><span class="line">#else</span><br><span class="line">bstext// branch to kernel start, magic</span><br><span class="line">.long0// reserved</span><br><span class="line">#endif</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在开启 UEFI 支持时，add x13, x18, #0x16 这个 code 实际上是为了满足 EFI 格式的”MZ”头。如果使用 UEFI 来启动 kernel, 会识别出来并走 UEFI 启动的流程，如果是普通的启动过程如使用 uboot 的 booti 进行引导，那么第一条指令就是一条 dummy 指令，第二条就跳转到 stext 运行了。</p><span id="more"></span><p>x0 寄存器保存的是 dtb 里 blob 块的物理地址，x0 寄存器内容由 uboot 设置，uboot 将 dtb 地址传递给内核，跳转到 stext，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">blpreserve_boot_args</span><br><span class="line">blel2_setup// Drop to EL1, w0=cpu_boot_mode</span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line">andx23, x23, MIN_KIMG_ALIGN - 1// KASLR offset, defaults to 0</span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables</span><br><span class="line">bl__cpu_setup// initialise processor</span><br><span class="line">b__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br><span class="line">...</span><br><span class="line">preserve_boot_args:</span><br><span class="line">movx21, x0// x21=FDT</span><br><span class="line"></span><br><span class="line">adr_lx0, boot_args// record the contents of</span><br><span class="line">stpx21, x1, [x0]// x0 .. x3 at kernel entry</span><br><span class="line">stpx2, x3, [x0, #16]</span><br><span class="line"></span><br><span class="line">dmbsy// needed before dc ivac with</span><br><span class="line">// MMU off</span><br><span class="line"></span><br><span class="line">addx1, x0, #0x20// 4 x 8 bytes</span><br><span class="line">b__inval_cache_range// tail call</span><br><span class="line">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></tbody></table></figure><p>arm64 linux 寄存器规定如下：</p><pre><code>x0 = physical address of device tree blob (dtb) in system RAM.x1 = 0 (reserved for future use)x2 = 0 (reserved for future use)x3 = 0 (reserved for future use)</code></pre><p>将 dtb 的物理地址保存在 x21 寄存器中。 __inval_cache_range 这个函数用来 invalidate 指定区域的 cache。如果指定内存区域有跨越 cacheline, 那么对两边跨越了 cacheline 的地址使用的 clean + invalidate, 对于中间区域可以直接 invalidate 不用写回内存，从而加快 invalidate 速度。</p><p>调用__primary_switch 如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line"></span><br><span class="line">bl__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br><span class="line">...</span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></tbody></table></figure><p>调用__primary_switched 函数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__primary_switched:</span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line">msrsp_el0, x4// Save thread_info</span><br><span class="line"></span><br><span class="line">adr_lx8, vectors// load VBAR_EL1 with virtual</span><br><span class="line">msrvbar_el1, x8// vector table address</span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">stpxzr, x30, [sp, #-16]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line">str_lx21, __fdt_pointer, x5// Save FDT pointer</span><br><span class="line">...</span><br><span class="line">bstart_kernel</span><br><span class="line">ENDPROC(__primary_switched)</span><br></pre></td></tr></tbody></table></figure><p>通过 str_l x21, __fdt_pointer, x5 这句将 dtb 的地址保存在__fdt_pointer 指针里，以便后续内核可以找到 dtb 并解析设备树文件。</p><p>关于 linux 启动过程可以参考下图：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjEyOWYxZDhlMGIzNGQzNTUwZjBiNjFi">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/StartKernel.png"></p><h2 id="dtb-解析过程">dtb 解析过程</h2><p>start_kernel 阶段会处理 dtb 文件生成 device_node 结构体以及他们之间的组织关系。整体的调用逻辑如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTQ4ZjA2Mzc2ODkyMWZhMjRmY2Vl">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/fdt.png"></p><p>下面以一个简单的设备树为例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/ {</span><br><span class="line">    leds {</span><br><span class="line">        act {</span><br><span class="line">            gpios = &lt;&amp;gpio <span class="number">42</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        pwr {</span><br><span class="line">            label = <span class="string">"PWR"</span>;</span><br><span class="line">            gpios = &lt;&amp;expgpio <span class="number">2</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">            <span class="keyword">default</span>-state = <span class="string">"keep"</span>;</span><br><span class="line">            linux,<span class="keyword">default</span>-trigger = <span class="string">"default-on"</span>;</span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    wifi_pwrseq: wifi-pwrseq {</span><br><span class="line">        compatible = <span class="string">"mmc-pwrseq-simple"</span>;</span><br><span class="line">        reset-gpios = &lt;&amp;expgpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>该设备树经过 populate_node() 解析处理后，结构体关系如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- /节点：</span><br><span class="line">    - parent：NULL</span><br><span class="line">    - sibling：NULL</span><br><span class="line">    - child：wifi_pwrseq</span><br><span class="line">- led 节点：</span><br><span class="line">    - parent：/</span><br><span class="line">    - sibling：NULL</span><br><span class="line">    - child：pwr</span><br><span class="line">- act 节点：</span><br><span class="line">    - parent：led</span><br><span class="line">    - sibling：NULL</span><br><span class="line">    - child：NULL</span><br><span class="line">- pwr 节点：</span><br><span class="line">    - parent：led</span><br><span class="line">    - sibling：act</span><br><span class="line">    - child：NULL</span><br><span class="line">- wifi_pwrseq 节点：</span><br><span class="line">    - parent：/</span><br><span class="line">    - sibling：led</span><br><span class="line">    - child：NULL</span><br></pre></td></tr></tbody></table></figure><h2 id="device_node-与-device-绑定">device_node 与 device 绑定</h2><p>kernel 会为设备树 root 节点下所有带'compatible' 属性的节点都分配并注册一个 platform_device；另外，如果某节点的'compatible' 符合某些 matches 条件，则会为该节点下所有带'compatible' 属性的子节点（child）也分配并注册一个 platform_device。 整体调用流程如下图所示：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTQ5MmI2Mzc2ODkyMWZhMjRmZDQx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/FDT_BindDevice.png"></p><p>至此，为所有设备树中所有符合条件的 node 都创建了 platform_device 结构体，node 下描述的资源也解析到了 platform_device 中，并通过 dev 成员将该 node 描述的设备加入了统一设备模型。</p><blockquote><p>&nbsp;补充：标签是标记节点的方法，可以用唯一的名称来标识节点，在 dt 编译器编译过程中，dt 编译器将该名称转换为唯一的 32 位值，之后可以使用标签引用节点，因为标签对于节点是唯一的。phandle 是与节点相关联的 32 位值，用于唯一标识该节点，以便可以从另一个节点属性引用该节点。为了在查找节点时不遍历整个树，引入别名的概念，在 dt 中，别名可以看作是节点的快速查找表，即一个节点的索引</p></blockquote><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDE2MjMzNzA=">https://zhuanlan.zhihu.com/p/141623370<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDMwOTI4Njg=">https://zhuanlan.zhihu.com/p/143092868<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2duZ3Nobi5naXRodWIuaW8v">http://gngshn.github.io/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvc29ydC9kZXZpY2VfbW9kZWw=">http://www.wowotech.net/sort/device_model<i class="fa fa-external-link-alt"></i></span><br>《Linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之文件系统</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverFileSystem/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverFileSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="seq_file">seq_file</h1><h2 id="概述">概述</h2><p>seq_file 只是在普通文件 read 中加入了内核缓冲的功能，从而实现顺序多次遍历读取大数据量的简单接口，seq_file 一般只提供只读接口。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> {</span></span><br><span class="line"><span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line"><span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line"><span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line"><span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="核心功能">核心功能</h2><p>seq_file 接口可通过 &lt;linux/seq_file.h&gt; 获得。 seq_file 包含三个方面：</p><ul><li>An iterator interface which lets a virtual file implementation step through the objects it is presenting</li><li>Some utility functions for formatting objects for output without needing to worry about things like output buffers</li><li>A set of canned file_operations which implement most operations on the virtual file</li></ul><p>实现文件在 fs/seq_file.c 和 include/linux/seq_file.h 中。</p><h2 id="总结">总结</h2><p>seq_file 是为 proc 文件系统设计的，但不只是 proc，在需要创建一个由一系列数据顺序组合而成的虚拟文件或一个较大的虚拟文件时，推荐使用 seq_file 接口。这正是符合 bin_attribute 的场景。用户空间通过 open、read 等函数操作文件时通过系统的 VFS 调用到内核层，其中 file 结构体的 private 指针指向 seq_file 结构体，然后调用该结构体里的 op 指针指向的相应函数。</p><h1 id="kernfs">kernfs</h1><h2 id="概述-1">概述</h2><p>在 Linux 内核中，kernfs 提供内核子系统内部虚拟文件系统所需的功能，源于拆分 sysfs 使用的部分内部逻辑，它通过将有关硬件设备和相关设备驱动程序的信息从内核的设备模型导出到用户空间，提供一组虚拟文件，从而实现独立且可重用的功能。 其他内核子系统可以更容易，更一致地实现自己的文件系统。</p><h2 id="数据结构">数据结构</h2><p>先整体看下数据结构，如下图：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2YTQyOTllMGIzNGQ3YzdkYjU1MjU1">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/KernFS.png"></p><p>该图展示了各个数据结构之间的关系以及实现方式，kernfs 是 fs 抽象出来公共的属性操作，sysfs 基本就是调用该结构的方法来实现，同时 kobject 的目录和属性文件在用户空间的文件组织也是通过该数据结构实现的。</p><h2 id="实现">实现</h2><p>所有文件系统的实现都是通过 file_operations 结构体实现具体的操作的，kernfs 也是，它同样实现了 file_operations 结构体相关操作，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kernfs_file_fops</span> =</span> {</span><br><span class="line">.read= kernfs_fop_read,</span><br><span class="line">.write= kernfs_fop_write,</span><br><span class="line">.llseek= generic_file_llseek,</span><br><span class="line">.mmap= kernfs_fop_mmap,</span><br><span class="line">.open= kernfs_fop_open,</span><br><span class="line">.release= kernfs_fop_release,</span><br><span class="line">.poll= kernfs_fop_poll,</span><br><span class="line">.fsync= noop_fsync,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这个可以关注下 open 成员的实现函数 kernfs_fop_open，</p><ul><li><p>((struct seq_file *)file-&gt;private_data)-&gt;private = of: <strong>可以看到 kernfs_open_file 结构体是挂在 seq_file 结构体的 private 指针下的，现在可以梳理下这三者之间的关系，file 结构体的 private_data 指向 seq_file，seq_file 的 private 指向 kernfs_open_file，这样他们就都联系起来的，当然这里是分析特定文件系统下的实现，在其他情况下可以指向其他数据结构</strong></p></li><li><p>seq_open(file, &amp;kernfs_seq_ops): seq_file 的实现就使用了 kernfs 结构，kernfs 实现了 seq_file 的 file_operations 结构成员，如下：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">kernfs_seq_ops</span> =</span> {</span><br><span class="line">.start = kernfs_seq_start,</span><br><span class="line">.next = kernfs_seq_next,</span><br><span class="line">.stop = kernfs_seq_stop,</span><br><span class="line">.show = kernfs_seq_show,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后通过调用 seq_open 将该数据结构连入 seq_file 结构体的 op 成员中。</p></li></ul><h1 id="sysfs">sysfs</h1><h2 id="概述-2">概述</h2><p>sysfs 是非持久性虚拟文件系统，它提供系统的全局视图，并通过它们的 kobiect 显示内核对象的层次结构（拓扑）。每个 kobiect 显示为目录和目录中的文件，目录代表相关 kobject 导出的内核变量。这些文件称为属性，可以读取或写入。</p><p>对系统上的每个块设备，block 都包含一个目录，目录下包含设备上分区的子目录。bus 包含系统上注册的总线。dev 以原始方式（无层次结构）包含已注册的设备节点，每个节点都是/sys/devices 目录中真实设备的符号链接。devices 给出系统内设备的拓扑结构视图。firmware 显示系统相关的低层子系统树，如 ACPI、EFI、OF （DT）。fs 列出系统上实际使用的文件系统。kernel 保存内核配置选项和状态信息。module 是加载的模块列表。</p><pre><code>kernel_kobj：对应于/sys/kernelpower_kobj：对应于/sys/powerfirmware_kobi ：对应于/sys/firmware，导出在 drivers/baselirmware.c 源文件中hvpervisor_kobj：对应于/sys/hypervisor，导出在 drivers/base hypervisor.c 中fs_kobj：对应于/sys/fs，导出在 fs/namespace.c 文件中</code></pre><p>然而，class/、dev/、devices/是在启动期间由内核源代码内 drivers_base/core.c 中的 devices_init 函数创建的，block/在 block/genhd.c 中创建，bus/ 在 drivers/base/bus.c 中被创建为 kset。</p><p>kobject 目录被添加到 sysfs（使用 kobject_add）时，其添加位置取决于 kobject 的父项。如果其父指针已设置，则它将被添加为父目录内的子目录。如果父指针为 NULL，则将其添加为 kset-&gt;kobj 内的子目录。如果其父和 kset 字段都未设置，它将映射到 sysfs 内的根目录（/sys）。</p><h2 id="挂载-sysfs">挂载 sysfs</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t sysfs sysfs /sys</span><br></pre></td></tr></tbody></table></figure><h2 id="属性文件使用">属性文件使用</h2><h4 id="属性文件定义">属性文件定义</h4><p>裸属性不包含读取或写入属性值的方法。 鼓励子系统定义自己的属性结构和包装函数，以便为特定对象类型添加和删除属性。 例如驱动模型定义 struct device_attribute 如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span><span class="title">attr</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line"><span class="type">char</span> *buf);</span><br><span class="line"><span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>它还定义了用于定义设备属性的 helper 程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br></pre></td></tr></tbody></table></figure><p>例如做如下声明：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(foo, S_IWUSR | S_IRUGO, show_foo, store_foo)</span>;</span><br></pre></td></tr></tbody></table></figure><p>相当于定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> <span class="title">dev_attr_foo</span> =</span> {</span><br><span class="line">.attr = {</span><br><span class="line">.name = <span class="string">"foo"</span>,</span><br><span class="line">.mode = S_IWUSR | S_IRUGO,</span><br><span class="line">},</span><br><span class="line">.show = show_foo,</span><br><span class="line">.store = store_foo,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="子系统定义回调">子系统定义回调</h4><p>当子系统定义新的属性类型时，它必须实现一组 sysfs 操作，以将读取和写入调用转发到属性所有者的 show 和 store 方法。读取或写入文件时，sysfs 会调用该类型的适当方法。 然后该方法将通用 struct kobject 和 struct attribute 指针转换为适当的指针类型，并调用关联的方法。</p><p>阐明：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> to_dev(obj) container_of(obj, struct device, kobj)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span><br><span class="line"><span class="params">                             <span class="type">char</span> *buf)</span></span><br><span class="line">{</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attr</span> =</span> to_dev_attr(attr);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> to_dev(kobj);</span><br><span class="line">        <span class="type">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dev_attr-&gt;show)</span><br><span class="line">                ret = dev_attr-&gt;show(dev, dev_attr, buf);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= (<span class="type">ssize_t</span>)PAGE_SIZE) {</span><br><span class="line">                print_symbol(<span class="string">"dev_attr_show: %s returned bad count\n"</span>,</span><br><span class="line">                                (<span class="type">unsigned</span> <span class="type">long</span>)dev_attr-&gt;show);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里通过 to_dev_attr 宏定义（container_of 方法）通过 kobject 结构体找到子系统或自定义的数据结构指针，这里以 device_attribute 为例，该数据结构要实现自己的 show 和 store 方法。得到 device_attribute 数据地址后调用该数据的 show/store 方法。</p><blockquote><p>可以看到 kobject 实际上实现了一套机制，该机制帮组用户方便的创建文件和删除文件并提供访问文件的方法，而它本身并未实现具体的操作。</p></blockquote><p>一个简单的例子，来看看具体的使用方法：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">                         <span class="type">char</span> *buf)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> scnprintf(buf, PAGE_SIZE, <span class="string">"%s\n"</span>, dev-&gt;name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">store_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">{</span><br><span class="line">        <span class="built_in">snprintf</span>(dev-&gt;name, <span class="keyword">sizeof</span>(dev-&gt;name), <span class="string">"%.*s"</span>,</span><br><span class="line">                 (<span class="type">int</span>)min(count, <span class="keyword">sizeof</span>(dev-&gt;name) - <span class="number">1</span>), buf);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, show_name, store_name)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvc29ydC9kZXZpY2VfbW9kZWw=">窝窝科技相-设备驱动模型<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW55aW5nMTI2L2FydGljbGUvZGV0YWlscy83ODA3OTk0Mg==">https://blog.csdn.net/chenying126/article/details/78079942<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvc2VxX2ZpbGUuaHRtbA==">https://www.kernel.org/doc/html/latest/filesystems/seq_file.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzIyMzU5Lw==">https://lwn.net/Articles/22359/<i class="fa fa-external-link-alt"></i></span><br>《linux 设备驱动开发》<br>《linux 内核文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
            <tag> FileSystem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动之设备驱动模型</title>
      <link href="/next/2020/LinuxDriver/LinuxDriverDeviceModule/"/>
      <url>/next/2020/LinuxDriver/LinuxDriverDeviceModule/</url>
      
        <content type="html"><![CDATA[<h1 id="kobject">kobject</h1><h2 id="概述">概述</h2><ul><li>Kobjects 有一个 name 和一个引用计数，还具有父指针（允许将对象排列成层次结构）</li><li>ktype 是嵌入在 kobject 结构体中的对象。 每个 kobject 结构都需要一个相应的 ktype。 ktype 控制 kobject 在创建和销毁时的行为</li><li>kset 是一组 kobjects(kset 本身包含一个 kobject), 这些 kobject 可以拥有相同的 ktype，kset 也是 sysfs 中的一个子目录。Ksets 可以支持 kobjects 的“热插拔”（uevent 事件）</li></ul><span id="more"></span><h2 id="kobject-的数据结构和实现">kobject 的数据结构和实现</h2><p>下图展示了 kobject、ktype 和 kset 三者数据结构之间的关系：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWE2ZmU3ZDljMDg2NjUxM2U5ZDA4">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Kobject_Struct.png"></p><ul><li><p>sysfs_ops: show 是回调函数，在读取具有该 kobj_type 的所有属性时调用他。缓冲区长度始终是 PAGE_SIZE，在成功时返回写入缓冲区的数据大小，失败返回错误码。写入的时候调用 store 函数，其参数 buf 最大为 PAGE_SIZE，成功返回写入数据大小，失败返回错误码</p></li><li><p>uevent_ops: 是此 kset 的 uevent 操作集</p></li><li><p>attribute: 是由 kobject 导出到用户空间 sysfs 文件，attribute 表示可以从用户空间读取、写入或同时具有这两者的对象属性，属性将内核数据映射到 sysfs 中的文件</p></li></ul><p>用于从文件系统添加/删除属性的函数如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __must_check <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> attribute *attr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="keyword">struct</span> attribute *attr)</span>;</span><br></pre></td></tr></tbody></table></figure><p>除此之外还有一个数据结构 attribute_group 很常用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="type">umode_t</span>(*is_visible)(<span class="keyword">struct</span> kobject *,</span><br><span class="line">      <span class="keyword">struct</span> attribute *, <span class="type">int</span>);</span><br><span class="line"><span class="type">umode_t</span>(*is_bin_visible)(<span class="keyword">struct</span> kobject *,</span><br><span class="line">  <span class="keyword">struct</span> bin_attribute *, <span class="type">int</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>**<span class="title">attrs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span>**<span class="title">bin_attrs</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>attrs 字段是一个指针，他指向以 NULL 结尾的属性列表，每个属性组必须赋予一个指向 struct attribute 元素列表/数组的指针，该 group 只是一个 helper 包装器，以便管理多个属性。 在实际使用中可以定义多个属性文件然后嵌入在 struct attribute_group 结构体中，之后调用如下函数可以一次将多个属性添加/删除到系统。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __must_check <span class="title function_">sysfs_create_group</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> attribute_group *grp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_group</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> attribute_group *grp)</span>;</span><br></pre></td></tr></tbody></table></figure><p>下图展示了 kset 和 kobject 通常的组织关系，形成层级关系，当其他结构需要构建层级关系或需要引用计数的时候都可以将这个数据结构嵌入进去：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWE3NTIxZWZhZDQxZDgyNWM3Zjc5">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/Kobject_List.png"></p><h2 id="用法api">用法（API）</h2><ol type="1"><li>创建 kobjec 的代码必须初始化该对象：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kobject_init</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype)</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>正确创建 kobject 需要 ktype，因为每个 kobject 都必须有一个关联的 kobj_type。 调用 kobject_init() 后，要向 sysfs 注册 kobject，必须调用函数 kobject_add()：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_add</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobject *parent, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果 kobject 要与特定的 kset 相关联，kobj-&gt;kset 必须在调用 kobject_add() 之前赋值。 如果 kset 是与 kobject 相关联的，那么 kobject 的父级可以在调用 kobject_add() 时设置为 NULL，然后 kobject 的父级将是 kset 本身。</p><ol start="3" type="1"><li>由于 kobject 的名称是在添加到内核时设置的，因此不应直接操作 kobject 的名称。 如果必须更改 kobject 的名称，请调用 kobject_rename()：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_rename</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="type">const</span> <span class="type">char</span> *new_name)</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>有一个辅助函数可以初始化 kobject 并将其添加到内核同时调用 kobject_init_and_add()：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_init_and_add</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> kobject *parent, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="5" type="1"><li>在 kobject 注册到 kobject 核心后，您需要通知它已被创造。 这可以通过调用 kobject_uevent() 来完成：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_uevent</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span>;</span><br></pre></td></tr></tbody></table></figure><p>当 kobject 从内核中删除时， KOBJ_REMOVE 的 uevent 将由 kobject 核心自动调用，因此调用者不必担心手动执行此操作。</p><ol start="6" type="1"><li>kobject 的关键功能之一是用作嵌入它的对象的引用计数器，用于操作 kobject 引用计数的函数是：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kobject *<span class="title function_">kobject_get</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kobject_put</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span>;</span><br></pre></td></tr></tbody></table></figure><p>当引用被释放时，对 kobject_put() 的调用将减少引用计数，并可能释放对象。</p><ol start="7" type="1"><li>每个注册的 kset 对应 sysfs 目录，可以使用 kset_create_and_add() 函数创建和添加 kset，使用 kset_unregister() 函数将其删除</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kset * __must_check <span class="title function_">kset_create_and_add</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> kset_uevent_ops *u,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> kobject *parent_kobj)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kset_unregister</span><span class="params">(<span class="keyword">struct</span> kset *kset)</span></span><br></pre></td></tr></tbody></table></figure><p>因为 kobject 是动态的，所以它们不能静态声明或在堆栈上声明，而是始终动态分配。 内核的未来版本将包含对静态创建的 kobjects 的运行时检查，并将警告开发人员这种不正确的使用。</p><h2 id="example">example</h2><p>参考 samples/kobject/kobject-example.c</p><h1 id="busdevice-和-driver">bus、device 和 driver</h1><h2 id="数据结构">数据结构</h2><p>要理解 linux 驱动的设计，首先要理清楚 linux 驱动最重要的几个数据结构，struct device, struct device_driver, struct bus 这些数据结构是理解 Linux 驱动的关键，下面先从整体上看一下这几个数据结构之间的关系，如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWE3YTFlNDAxZmQzYzI0OWRjZmVj">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/BusStruct.png"></p><ul><li><p>bus: bus 结构体用于抽象系统中总线的数据结构，这个可以是实际的总线，例如 iic、spi 总线，也可以是虚拟总线 platform 总线。struct bus 结构体管理挂载在该 bus 下的 struct device 和 struct device_driver, 负责 device 和 device_driver 的匹配，调用 probe 等工作。其中管理 struct device 和 struct device_driver 的功能独立出来成为一个子系统叫 subsys_private，该数据结构除了管理该 bus 下的设备和驱动外还用于处理 bus，device 和 device_driver 的一些默认属性（公共属性），uevent 事件等。可以看到 subsys_private 数据结构下有两个链表一个用于挂载 device 另一个用于挂载 device_driver, 从而实现 bus 对 device 和 device_driver 管理</p></li><li><p>device: device 结构体用于抽象驱动设备，系统下挂载的设备都是通过 struct device 结构体来描述，其中 dts 里定义的很多节点都会转换为 struct device 结构体，用于描述一个设备信息，管理设备用到的资源等。device 结构体下一个重要结构是 device_private，该结构体成员 knode_bus 就是用于挂载到上面提到的 bus 下的 subsys_private 结构体中的 klist_devices</p></li><li><p>device_driver: device_driver 结构体用于描述对 struct device 结构体描述的设备的驱动方法，比如对于通信协议的实现，对控制器的操作等。这样设备和设备的驱动实现分离单独管理，而设备和驱动分离后两者的匹配工作就是 bus 完成的，device_driver 是用户需要编写的具体操作设备的方法和流程。同样 struct device_driver 结构体下的 driver_private 的 knode_bus 用于链接到 struct bus 下 subsys_private 结构体中的 klist_drivers</p></li></ul><p>三者数据结构实际使用中的连接关系可能如下：<span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzVlZjMxMWI3MWUwODUzMjYzNzQxNDc3Ny5wbmc=">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/BusList.png"></p><p>bus 和 device 以及 device_driver 下都有一个 private 或 subsys 结构用来处理一些共性的工作，是一种很好的抽象结构。</p><h2 id="实现">实现</h2><p>好了到现在我们已经清楚最重要的三个数据结构之间的关系了，接下来是关于 device 和 device_driver 是如何匹配上的，device 和 device_driver 一个描述了设备一个是拥有驱动设备的方法，但是 linux 下设备非常多，每个设备都要有一个对应的驱动程序来驱动，下面详细看下 device 和 device_driver 的关联过程。</p><h3 id="device-的注册过程">device 的注册过程</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">device_register</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">{</span><br><span class="line">device_initialize(dev);</span><br><span class="line"><span class="keyword">return</span> device_add(dev);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(device_register);</span><br></pre></td></tr></tbody></table></figure><p>初始化设备并将其添加到系统中。其中 device_initialize 初始化 device 结构体，主要是 kobject_init 初始化 kobj 结构体，其他就是初始化一些锁、链表指针之类的，重点是 device_add 这个函数，这个函数主要完成以下工作：</p><pre><code> 1. 初始化 device_private 结构体 2. 使用 bus-&gt;dev_name + dev-&gt;id 为 dev-&gt;init_name 自动命名 3. 增加 device 引用次数 4. 如果没有 class，则子系统为设备指定默认的 root 路径 (bus-&gt;dev_root) 5. kobject 名称在此函数中设置并添加到 kobject 层次结构中 6. 通知新设备加入 7. 为 device 创建 sysfs 文件 8. 将 device 添加到 bus（将 dev-&gt;p-&gt;knode_bus 加入到 us-&gt;p-&gt;klist_devices) 9. 创建 dev 目录 10. 通知客户端有新设备添加 11. 调用最重要的函数为 device_probe_driver</code></pre><p>下面主要介绍 bus_probe_device 这个函数，由于函数调用层级较多，这里不打算将函数一一列出，而是梳理出调用关系，如下：<span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzYxMTY4ODc1N2Q5YzA4MDZlNGFlZmUzOS5wbmc=">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/DeviceRegister.png"></p><p>这里需要注意的是 match 函数的实现是具体的 bus 实现的函数，例如 platform bus 会实现自己的 match 函数，后续会有文章进行介绍，关于 probe 函数，一般 bus 也会实现自己的 probe 函数，然后 bus 下的 probe 函数会调用 driver 数据结构的 probe 函数。</p><h3 id="driver-的注册过程">driver 的注册过程</h3><p>driver 的注册是通过 driver_register 该函数完成的，感兴趣的读者可以去阅读源码。同样关于 driver 的注册这里也贴一张图：<span class="exturl" data-url="aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzYxMTdjMmMzMGUzZTc0MDdkM2EwZjNhNy5wbmc=">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/DriverRegister.png"></p><p>driver 和 device 的注册类似，都会在自己挂载的 bus 上去遍历对方的所有设备或驱动然后进行遍历匹配，当匹配上了将两个数据结构关联然后调用 driver 的 probe 函数。而 driver 的 probe 函数也就是驱动程序的入口，用户需要实现的操作都在这个函数里实现。</p><h3 id="bus-的注册过程">bus 的注册过程</h3><p>上面已经将 device 和 driver 介绍完了，device 和 driver 都将注册到 bus，然后 bus 管理两个链表一个 device 链表一个 driver 链表，现在我们再看看 bus 数据本身的一注册过程。 bus_register 函数完成 bus 的注册，该函数主要完成以下工作：</p><pre><code> 1. 为 subsys_private 分配内存空间 2. 初始化 subsys_private 结构体，并将 bus-&gt;p 指向这块内存 3. 设置 priv-&gt;subsys.kobj 的 name 为 bus-&gt;name 4. 初始化 subsys_private 的 kobj、kset，ktype 结构体 5. 注册 kset，会在 sysfs 文件系统下创建目录 6. 向 bus 目录下添加一个 uevent attribute 7. 分别向内核添加 devices 和 device_drivers kset，会体现在 sysfs 中 8. 初始化 subsys_private 里的 mutex、klist_devices 和 klist_drivers 等变量 9. 在 bus 下添加 drivers_probe 和 drivers_autoprobe 两个 attribute，如/sys/bus/spi/drivers_probe 和/sys/bus/spi/drivers_autoprobe），其中 drivers_probe 允许用户空间程序主动出发指定 bus 下的 device_driver 的 probe 动作，而 drivers_autoprobe 控制是否在 device 或 device_driver 添加到内核时，自动执行 probe 10. 调用 bus_add_attrs，添加由 bus_attrs 指针定义的 bus 的默认 attribute，这些 attributes 最终会体现在/sys/bus/xxx 目录下</code></pre><p>bus 的注册基本上是对自己内部的数据初始化以便于具体的 bus 结构体使用，例如 platform 总线进行使用。</p><h1 id="class">class</h1><p>class 数据结构是一种抽象结构，class 是将一些共性的属性或操作提取出来单独成为一个数据结构以提高代码复用率减少重复代码。官方文档的描述是：</p><pre><code>A device class describes a type of device, like an audio or network device.</code></pre><p>下面是 class 数据结构内容：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name; <span class="comment">// class 的名称</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span>*<span class="title">class_attrs</span>;</span> <span class="comment">// class 的默认属性</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>**<span class="title">dev_groups</span>;</span> <span class="comment">// 属于该 class 的 device 的默认属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>*<span class="title">dev_kobj</span>;</span> <span class="comment">// 代表该 class 的层级关系</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*dev_uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env); <span class="comment">// 当有设备添加到 class 或从 class 移除时调用</span></span><br><span class="line"><span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> device *dev, <span class="type">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*class_release)(<span class="keyword">struct</span> class *class); <span class="comment">//class 销毁时调用</span></span><br><span class="line"><span class="type">void</span> (*dev_release)(<span class="keyword">struct</span> device *dev); <span class="comment">//release 一个 device</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state); <span class="comment">//休眠时调用</span></span><br><span class="line"><span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev); <span class="comment">//唤醒时调用</span></span><br><span class="line"><span class="type">int</span> (*shutdown)(<span class="keyword">struct</span> device *dev); <span class="comment">//关机时调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *<span class="title">ns_type</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *(*namespace)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span> <span class="comment">//属于该 class 的 device 的默认电源管理操作</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span> <span class="comment">//子系统，跟 bus 下的相同含义</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>其实这里 class 就是一个多设备容器，这个容器就是方便管理设备的（当然 bus 也是管理设备的数据结构，bus 是管理同一总线上的设备和设备驱动的），class 将设备进行分类管理（另一个维度，区别于 bus）并提供 api 方便驱动开发人员进行管理设备。</p><h1 id="uevent">Uevent</h1><p>Uevent 是 Kobject 的一部分，用于在 Kobject 状态发生改变时，例如增加、移除等，通知用户空间程序。用户空间程序收到这样的事件后，会做相应的处理。该机制通常是用来支持热拔插设备的，从而动态的支持该设备。</p><h2 id="实现-1">实现</h2><p>uevent 相关数据结构如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWIwMjIwNzkxMjkwNmIyYTNmNDMx">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/uevent.png"></p><p>主要的实现函数就是 kobject_uevent 函数，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kobject_uevent</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> kobject_uevent_env(kobj, action, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用 kobject_uevent_env 函数：该函数主要完成以下工作：</p><pre><code> 1. 查找 kobj 本身或者其 parent 是否从属于某个 kset 2. 该 kobject 不属于某个 kset，返回报错。如果一个 kobject 没有加入 kset，是不允许上报 uevent 的 3. 查看 kobj-&gt;uevent_suppress 是否设置，如果设置，则忽略所有的 uevent 上报并返回。可以通过 Kobject 的 uevent_suppress 标志，管控 Kobject 的 uevent 的上报 4. 如果所属的 kset 有 uevent_ops-&gt;filter 函数，则调用该函数，过滤此次上报，kset 可以通过 filter 接口过滤不希望上报的 event，从而达到整体的管理效果 5. 判断所属的 kset 是否有合法的名称（称作 subsystem，和前期的内核版本有区别），否则不允许上报 uevent 6. 分配一个用于此次上报的、存储环境变量的 buffer（结果保存在 env 指针中），并获得该 Kobject 在 sysfs 中路径信息（用户空间软件需要依据该路径信息在 sysfs 中访问它） 7. 获取 kobject 完整路径 8. 调用 add_uevent_var 接口，将 Action、路径信息、subsystem 等信息，添加到 env 指针中 9. 如果传入的 envp_ext 不空，则解析传入的环境变量中，同样调用 add_uevent_var 接口，添加到 env 指针中 10. 如果所属的 kset 存在 uevent_ops-&gt;uevent 接口，调用该接口，添加 kset 统一的环境变量到 env 指针 11. 在对象中标记“添加”和“删除”事件，以确保在自动清理期间向用户空间发送适当的事件。如果对象确实发送了“添加”事件，则核心将自动生成“删除”，如果调用者尚未完成 12. 用 add_uevent_var 接口，添加格式为"SEQNUM=%llu”的序列号 13. 如果定义了"CONFIG_NET”，则使用 netlink 发送该 uevent 13. 以 uevent_helper、subsystem 以及添加了标准环境变量（HOME=/，PATH=/sbin:/bin:/usr/sbin:/usr/bin）的 env 指针为参数 14. 调用 kmod 模块提供的 call_usermodehelper 函数，上报 uevent。其中 uevent_helper 的内容是由内核配置项 CONFIG_UEVENT_HELPER_PATH（位于。/drivers/base/Kconfig) 决定的（可参考 lib/kobject_uevent.c, line 32)，该配置项指定了一个用户空间程序（或者脚本），用于解析上报的 uevent，例如"/sbin/hotplug”。call_usermodehelper 的作用，就是 fork 一个进程，以 uevent 为参数，执行 uevent_helper</code></pre><p>在系统启动后，大部分的设备已经 ready，可以根据需要，重新指定一个 uevent helper，以便检测系统运行过程中的热拔插事件。这可以通过把 helper 的路径写入到"/sys/kernel/uevent_helper”文件中实现。实际上，内核通过 sysfs 文件系统的形式，将 uevent_helper 数组开放到用户空间，供用户空间程序修改访问，具体可参考"./kernel/sysfs.c”中相应的代码，这里不再详细描述。</p><h1 id="platfor-总线">platfor 总线</h1><h2 id="platform-数据结构">platform 数据结构</h2><p>platform 数据结构同样是对 device、device_driver、bus 数据结构的再封装，我将 platform 的数据结构列出来如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWIwOWE3ZDljMDg2NjUxM2VhMjgz">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/PlatformStruct.png"></p><h2 id="platform-总线实现">platform 总线实现</h2><p>首先还是将数据结构之间的关系列出来，如下：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNjE2OWIwYzNmMzQ2ZmIwNmE5ZjEzMjI1">原图<i class="fa fa-external-link-alt"></i></span> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/Driver/PlatformStruct.png"></p><p>上图将 platform 总线的实现概要列举出来，下面详细看看 platform 总线的几个重要函数：</p><ul><li><p>platform_probe: 在上面介绍 device_driver 的时候介绍 register 的时候讲到 probe 函数的调用时机，在 device_driver 注册的时候会执行总线的 probe 函数，对于 platform 总线就是由 platform 总线再调用 device_driver 的 probe 函数</p></li><li><p>platform_match: 这个函数提供了 4 种匹配规则，具体如下：</p><ul><li>driver_override 匹配：这个是最优先的匹配将 device 的 driver_override 和 device_driver 的 name 进行匹配</li><li>of_driver_match_device 匹配：这个把 device_driver 的 of_match_table 和 device 里的 of_node 进行匹配，of_node 由 dts 里的 compatible 字符串进行比较匹配</li><li>acpi_driver_match_device 匹配：acpi 匹配规则进行匹配，这个没详细看</li><li>platform_match_id 匹配：通过 platform_driver-&gt;id_table-&gt;name 和 platform_device-&gt;name 进行匹配</li></ul></li><li><p>platform_pm_suspend: 在我们编写驱动的时候休眠唤醒是一个非常关键的操作，那么 platform 总线实现的休眠函数就是 platform_pm_suspend，platform 总线的 suspend 的实现就是调用 device_driver 的 suspend 函数，跟 probe 函数类似</p></li></ul><h2 id="总结">总结</h2><p>这里也说明了 platform 总线并没有操作具体实际的硬件，总线的实现就是调用驱动的具体函数。有了这些总线我们在实际编写驱动的时候就非常方便，我们只需要实现 device_driver 结构体里的具体函数然后将这个结构体注册到 platform 总线就完事了，具体函数的调用时机由总线负责，不需要驱动编写人员编写。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvc29ydC9kZXZpY2VfbW9kZWw=">窝窝科技-设备驱动模型<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvZGV2aWNlX21vZGVsL3VldmVudC5odG1s">窝窝科技-Linux 设备模型 (3)_Uevent<i class="fa fa-external-link-alt"></i></span><br>《linux 内核文档》<br>《linux 设备驱动开发》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Linux </category>
          
          <category> Driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foc 相关算法</title>
      <link href="/next/2020/Algorithm/focRelatedAlgorithms/"/>
      <url>/next/2020/Algorithm/focRelatedAlgorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="mtpa">MTPA</h1><h2 id="为什么要用-mtpa">为什么要用 MTPA</h2><p>当电机采用 id=0 的控制策略，这种控制方法忽略了磁阻转矩的作用，电磁转钜方程如下：</p><p><span class="math display">\[\tau _e = \frac{3}{2}p[k_e \cdot i_q + (L_d - L_q)\cdot i_d \cdot i_q]\]</span></p><p>转矩分为永磁转矩 Tr 和磁阻转矩 Tm，而 id=0 只剩下 Tr。这会导致电流的利用率不高，系统的效率降低。所以 id=0 的控制比较适用于隐极式电机（Ld=Lq），而对于凸极式电机并不最优，所以需要重新考虑控制策略。</p><span id="more"></span><h2 id="推导过程">推导过程</h2><p>电动机电压方程：</p><p><span class="math display">\[\begin{aligned}U_d = rI_d - L_qI_q\omega_e \\U_q = rI_q + k_E\omega_e + L_dI_d\omega_e\end{aligned}\]</span></p><p>那么电动机消耗对有功功率为：</p><p><span class="math display">\[P = \frac{3}{2}(U_dI_d + U_qI_q)\]</span></p><p>将电动机方程代入功率方程得：</p><p><span class="math display">\[P = \frac{3}{2} r (I_d^2 + I_q^2) + [k_EI_q + (L_d - L_q)I_dI_q]\omega_e\]</span></p><p>电动机的有功功率一部分消耗在绕阻电阻上发热，另一部分用于输出机械功率： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/mtpa.png"></p><p>电动机的机械功率为：</p><p><span class="math display">\[P_{mech} = \tau_e \omega_{mech}\]</span></p><p>机械转速与电频率之间的关系为：</p><p><span class="math display">\[\omega_e = p \omega_{mech}\]</span></p><p>所以：</p><p><span class="math display">\[\tau_e \omega_{mech} = \frac{3}{2} r (I_d^2 + I_q^2) + [k_EI_q + (L_d - L_q)I_dI_q] p \omega_{mech}\]</span></p><p>得到电磁转钜公式：</p><p><span class="math display">\[\tau _e = \frac{3}{2}p[k_e \cdot i_q + (L_d - L_q)\cdot i_d \cdot i_q]\]</span></p><p>如果绕阻中电流峰值是 I_s</p><p><span class="math display">\[I_s^2 = I_d^2 + I_q^2\]</span></p><p>当输出电磁转钜一定时：</p><p><span class="math display">\[I_q = \frac{\tau_e}{\frac{3}{2}p[(k_E) + (L_d - L_q)I_d]}\]</span></p><p>联立上两式得：</p><p><span class="math display">\[I_s^2 = I_d^2 + \left ( \frac{\tau_e}{\frac{3}{2}p[(k_E) + (L_d - L_q)I_d]} \right )^2\]</span></p><p>上式可以看作是一个关于<span class="math inline">\(I_d\)</span>的函数，上式有最小值，当电磁转钜一定时，有一个最小峰值电流<span class="math inline">\(I_s\)</span>，取<span class="math inline">\(I_s\)</span>最小时有：</p><p><span class="math display">\[\begin{aligned}\frac{\partial I_s^2}{\partial I_d} &amp;= 2I_d + 2I_q \frac{\tau_e}{\frac{3}{2}p} \frac{-(L_d - L_q)}{[k_E + (L_d - L_q)I_d]^2} \\&amp; = 2I_d + 2I_q \frac{\tau_e}{\frac{3}{2}p[k_E + (L_d - L_q)I_d]} \frac{-(L_d - L_q)}{[k_E + (L_d - L_q)I_d]} \\&amp; = 2I_d + 2I_q^2\frac{-(L_d - L_q)}{[k_E + (L_d - L_q)I_d]} = 0\end{aligned}\]</span></p><p>整理得：</p><p><span class="math display">\[(L_d - L_q)I_d^2 + k_EI_d - (L_d - L_q)I_q^2 = 0\]</span></p><p>求解<span class="math inline">\(I_d\)</span>得到：</p><p><span class="math display">\[I_d = - \frac{k_E}{2(L_d - L_q)} \pm \sqrt{\left ( \frac{k_E}{2(L_d - L_q)} \right )^2 + I_q^2}\]</span></p><p>如果<span class="math inline">\(L_d &lt; L_q\)</span>时当电磁转钜一定时电流峰值<span class="math inline">\(I_s\)</span>最小：</p><p><span class="math display">\[I_d = - \frac{k_E}{2(L_d - L_q)} - \sqrt{\left ( \frac{k_E}{2(L_d - L_q)} \right )^2 + I_q^2}\]</span></p><h1 id="弱磁控制">弱磁控制</h1><h2 id="简介">简介</h2><p>弱磁控制的这个思想源还是来自他励直流电动机的调磁控制。当他励直流电动机端电压达到最大电压时，只能通过调节电机的励磁电流，进而改变励磁磁通，在保证输出电压最大值不变的条件下，使电机能恒功率运行于更高的转速。也就是说，他励直流电动机可以通过降低励磁电流达到弱磁扩速的目的。对于 PMSM 而言，励磁磁动势因永磁体产生而无法调节，只能通过调节定子电流，即增加定子直轴去磁电流分量来维持高速运行时电压的平衡。达到弱磁扩速的目的。</p><h2 id="推导">推导</h2><p>很多应用需要马达工作在高于额定速度的范围内，这里就需要弱磁控制来实现，电流的电压约束条件如下：</p><p><span class="math display">\[(L_qI_q)^2 + (k_E + L_dI_d)^2 \leqslant \frac{U_{1-limit}^2}{\omega_e^2}\]</span></p><p>电流幅值约束条件：</p><p><span class="math display">\[I_d^2 + I_q^2 \leqslant I_{s-limit}^2\]</span></p><p>MTPA 下有<span class="math inline">\(I_d\)</span>：</p><p><span class="math display">\[MTPA: I_d = \left\{\begin{matrix}- \frac{k_E}{2(L_d - L_q)} + sign(L_d - L_q) \sqrt{\left ( \frac{k_E}{2(L_d - L_q)} \right )^2 + I_q^2}, L_d \neq L_q\\ 0, L_d = L_q\end{matrix}\right.\]</span></p><p>其中：</p><p><span class="math display">\[sign(x) = \left\{\begin{matrix}1, x &gt; 0\\ 0, x = 0\\ -1, x &lt; 0\end{matrix}\right.\]</span></p><p>弱磁情况下有<span class="math inline">\(I_d\)</span>:</p><p><span class="math display">\[I_d = \left\{\begin{matrix}-\frac{k_E}{L_d}+ \frac{\sqrt{(\frac{U_{1-limit}}{\omega_e})^2 - (L_qI_q)^2}}{L_d}, \frac{U_{1-limit}}{\omega_e} \geq L_qI_q\\ n/a, \frac{U_{1-limit}}{\omega_e} &lt; L_qI_q\end{matrix}\right.\]</span></p><h1 id="电流前馈">电流前馈</h1><h2 id="前馈理论">前馈理论</h2><p>前馈控制是按照扰动量进行补偿都开环控制，当系统出现扰动时，按照扰动量当大小直接产生矫正作用。 前馈控制结构图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/foc-pre-feedback.png"></p><p>图中<span class="math inline">\(G_n(s)\)</span>是被控对象扰动通道的传递函数，<span class="math inline">\(D_n(s)\)</span>是前馈控制器的传递函数，<span class="math inline">\(G(s)\)</span>为被控对象控制通道传递函数，n、u、y 分别为扰动量、控制量和输出量 假定输入量 u1=0，则有：</p><p><span class="math display">\[Y(s) = Y_1(s) + Y_2(s) = [D_n(s)G(s) + G_n(s)]N(s)\]</span></p><p>若使前馈控制作用完全补偿扰动作用，则应使<span class="math inline">\(Y(s) = 0\)</span>即：</p><p><span class="math display">\[D_n(s)G(s) + G_n(s) = 0\]</span></p><p>所以前馈控制器的传递函数为：</p><p><span class="math display">\[D_n(s) = - \frac{G_n(s)}{G(s)}\]</span></p><p>在实际应用中。因为前馈控制为一个开环系统。因此常常采用反馈+前馈的复合控制方式。</p><h2 id="电机控制中的前馈控制">电机控制中的前馈控制</h2><p>在电机控制中加入前馈控制，其结构框图如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/foc-ff.png"></p><h2 id="参考文献">参考文献</h2><p>《2.ST MC SDK 5.x 矢量控制理论基础》<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzU3MjMxMw==">永磁同步电机也能弱磁调速<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODgwMzE0MjU=">永磁同步电机弱磁控制<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83ODcwNTA4NA==">永磁同步电机-弱磁<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Actuator </tag>
            
            <tag> FOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOC 原理</title>
      <link href="/next/2020/Algorithm/focPrinciple/"/>
      <url>/next/2020/Algorithm/focPrinciple/</url>
      
        <content type="html"><![CDATA[<h1 id="物理学基础概念">物理学基础概念</h1><h2 id="左手定则">左手定则</h2><p>将左手的食指，中指和拇指伸直，使其在空间内相互垂直。食指方向代表磁场的方向（从 N 级到 S 级），中指代表电流的方向（从正极到负极），那拇指所指的方向就是受力的方向。可用于判断安培力（运动导体所受到的力）和洛伦兹力（运动电荷所受的力）。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/leftHandRule.png"></p><h2 id="右手定则">右手定则</h2><p>伸开右手，使拇指与其余四个手指垂直，并且都与手掌在同一平面内；让磁感线垂直于手心进入，并使拇指指向导线运动方向，这时四指所指的方向就是感应电流的方向。用于判断导体在做切割磁场时产生的电流方向。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/rightHandRule.jpg"></p><span id="more"></span><h2 id="安培定则右手螺旋定则">安培定则（右手螺旋定则）</h2><p>电直导线中的安培定则（安培定则一）：用右手握住通电直导线，让大拇指指向直导线中电流方向，那么四指指向就是通电导线周围磁场的方向； 通电螺线管中的安培定则（安培定则二）：用右手握住通电螺线管，让四指指向电流的方向，那么大拇指所指的那一端是通电螺线管的 N 极。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/AmperesRule.jpg"></p><h2 id="安培力定则">安培力定则</h2><p><strong>安培力：</strong> 以电流强度为 I 的长度为 L 的直导线，置于磁感应强度为 B 的均匀外磁场中，则导线受到的安培力的大小为：</p><p><span class="math display">\[F = IBLsin\alpha \]</span></p><p>式中α为导线中的电流方向与 B 方向之间的夹角。 设定两条细直、无限长、固定的、相互平行的载流导线，则在自由空间内，任意一条导线施加于对方的每单位长度作用力<span class="math inline">\(f_m\)</span>是：</p><p><span class="math display">\[f_m = \frac{\mu_0 I_1 I_2 }{2\pi r}\]</span></p><p>其中，<span class="math inline">\(\mu_{0}\)</span> 是真空磁导率，<span class="math inline">\(I_1,I_2\)</span> 分别是流动于两条导线的电流，r 是两条导线之间的垂直距离。采用国际单位制，<span class="math inline">\(\mu_{0}\)</span>值定义为：</p><p><span class="math display">\[\mu _{0} = 4\pi \times 10^{-7}\]</span></p><h2 id="毕奥萨伐尔定律">毕奥─萨伐尔定律</h2><p>长直载流导线周围的磁感应强度大小与距离成反比、与电流成正比。</p><p><span class="math display">\[dB = \frac{\mu _0}{4\pi} \frac{Idl sin\theta }{r^2}\]</span></p><p>真空磁导率：</p><p><span class="math display">\[\mu _0 = 4 \pi \times 10^{-7} N \cdot A^{-2}\]</span></p><p>载流直导线、圆形载流导线、载流密绕直螺线管的磁场都是通过该公式求取。具体细节可参考 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDIzNzYzODM=">毕奥─萨伐尔定律<i class="fa fa-external-link-alt"></i></span> 在通电螺线管中产生的磁场强度是正比与导线中的电流和导线匝数的。</p><h2 id="洛伦兹力">洛伦兹力</h2><p>在电动力学里，若考虑一带电粒子在电磁场中的受力，可以用以下的劳仑兹力定律表示：</p><p><span class="math display">\[F = q(E + v \times B)\]</span></p><p>这里 F 是洛伦兹力，q 是是带电粒子的电荷量，E 是电场，v 是带电粒子的速度，B 是磁场。这方程式右边有两项，第一项是电场力<span class="math inline">\(F_E = qE\)</span> ，第二项是磁场力<span class="math inline">\(F_B = qv \times B\)</span>。</p><h1 id="直流电机基本方程">直流电机基本方程</h1><h2 id="电枢绕组的感应电动势">电枢绕组的感应电动势</h2><p>若电枢导体的有效长度为 l，导体切割气隙磁场的线速度为 v，则每根导体中的感应电动势<span class="math inline">\(e_c\)</span>为：</p><p><span class="math display">\[e_c = b_{\sigma}lv\]</span></p><p>式中<span class="math inline">\(b_{\sigma}\)</span>为导体所在位置处的气隙磁通密度。，若电枢绕组的总导体数为<span class="math inline">\(Z_a\)</span>每条支路串联导体数等于<span class="math inline">\(\frac{Z_a}{2a}\)</span>则支路电动势<span class="math inline">\(E_a\)</span>为：</p><p><span class="math display">\[E_a = \sum_{1}^{\frac{Z_a}{2a}}b_{\delta }lv = lv\sum_{1}^{\frac{Z_a}{2a}}b_{\delta }(x_i)\]</span></p><p>式中各点气隙磁通密度<span class="math inline">\(b_{\delta }(x_i)\)</span>互不相同，所以每根导体的电动势也不相同，为简单记，引入平均气隙磁通密度<span class="math inline">\(B_{av}\)</span>，记：</p><p><span class="math display">\[B_{av} \approx \frac{1}{\frac{Z_a}{2a}} \sum_{1}^{\frac{Z_a}{2a}}b_{\delta }(x_i)\]</span></p><p>则<span class="math inline">\(E_a\)</span>可以写为：</p><p><span class="math display">\[E_a = lv\frac{Z_a}{2a}B_{av}\]</span></p><p>考虑到线速度<span class="math inline">\(v = 2p \tau \frac{n}{60}\)</span>, 其中<span class="math inline">\(\tau\)</span>为极距，$2$为电枢周长将 v 代入可以得到：</p><p><span class="math display">\[E_a = 2\frac{pn}{60}\frac{Z_a}{2a}(B_{av}\tau l) = \frac{pZ_a}{60a}n\Phi = C_e n \Phi \]</span></p><p>式中<span class="math inline">\(\Phi\)</span>表示每极的总磁通量，他等于一个极下的平均气隙磁通密度<span class="math inline">\(B_av\)</span>乘以一个极的面积<span class="math inline">\(l\tau\)</span>即$= B_{av}l$, <span class="math inline">\(C_e\)</span>称为电动势常数，<span class="math inline">\(C_e = \frac{p Z_a}{60a}\)</span> . 这就是电枢绕组的电动势方程。对发电机和电动机都适用。</p><h2 id="电枢的电磁转钜">电枢的电磁转钜</h2><p>设导体中电流为<span class="math inline">\(i_a\)</span>导体所在位置的气隙磁通密度为<span class="math inline">\(b_{\delta}\)</span>, 则作用在该导体上的电磁转钜<span class="math inline">\(T_c\)</span>为：</p><p><span class="math display">\[T_c = b_{\delta} l i_a \frac{D_a}{2}\]</span></p><p><span class="math inline">\(D_a\)</span>为电枢外径，由于一个极下载流导体数为<span class="math inline">\(\frac{Z_a}{2p}\)</span>，所以作用在一个极下载流导体上的合成电磁转钜<span class="math inline">\(T_p\)</span>应为：</p><p><span class="math display">\[T_p = li_a \frac{D_a}{2}\sum_{1}^{\frac{Z_a}{2p}}b_{\delta }(x_i) = (\frac{Z_a}{2p}B_{av})li_a\frac{D_a}{2}\]</span></p><p>式中<span class="math inline">\(B_{av}\)</span>为气隙磁通密度平均值，作用在整个电枢上的电磁转钜<span class="math inline">\(T_e\)</span>应为<span class="math inline">\(T_p\)</span>乘以 2p 即：</p><p><span class="math display">\[T_e = 2pT_p = Z_aB_{av}li_a \frac{D_a}{2}\]</span></p><p>考虑到<span class="math inline">\(\pi D_a = 2p\tau , \Phi = B_{av}l \tau\)</span>支路电流<span class="math inline">\(i_a = \frac{I_a}{2a}\)</span>, 其中<span class="math inline">\(I_a\)</span>为电枢电流，可得：</p><p><span class="math display">\[T_e = Z_aB_{av}l(\frac{I_a}{2a}) \frac{p \tau}{\pi} = \frac{p}{2\pi} \frac{Z_a}{a} \Phi  I_a = C_T \Phi  I_a\]</span></p><p>式中<span class="math inline">\(C_T\)</span>为转钜常数，这就是直流电机的转钜公式。对发电机和电动机都适用。</p><h1 id="六步驱动">六步驱动</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc-step1-2.jpg"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc-step3-4.jpg"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc-step5-6.jpg"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc-table.png"></p><p>采用动图表示如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc6step.gif"></p><p>BLDC 的六步方波控制参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQwMDA3NC9hcnRpY2xlL2RldGFpbHMvMTEyMTczNTE3">BLDC 的六步方波控制<i class="fa fa-external-link-alt"></i></span></p><p>BLDC 就是通过三相进行改变线圈的电流方向来改变磁场方向，从而免去使用换向器来提高电机的性能，以上是 bldc 的六步控制法， 但是这个控制太粗略了，不能实现对电机的力矩，速度以及位置的闭环控制，为此前人开发了一些控制算法，本文只介绍 foc 这一种控制算法。</p><h1 id="foc-算法">FOC 算法</h1><h2 id="整体控制框图">整体控制框图</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/foc.jpg"></p><p>这里先将 FOC 控制框图列出，在下面将会一个模块一个模块当介绍。 ## clark 变换 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/clark.jpg"></p><p>在上图中 clark 变换是将<span class="math inline">\(I_a I_b I_c\)</span>三相电流变为<span class="math inline">\(I_{\alpha} I_{\beta}\)</span>两项电流，在实际的使用中需要对三相电流进行采集以获得实际电机中的电流，但是三相电流呈 120 度相位差分布并不够直观而且有信息冗余，根据基尔霍夫定律，三相电流矢量和应该为 0，因此可以使用两项进行表示，我们对直角坐标系很熟悉，因此这里将三相电流转化为直角系的两项坐标系的过程就是 clark 变换，详细变换如下：</p><p><span class="math display">\[\begin{aligned}&amp;I_{\alpha } = I_a - cos(\frac{\pi }{3})I_b - cos(\frac{2\pi }{3})I_c \\&amp;I_{\beta } = sin(\frac{\pi }{3})I_b - sin(\frac{\pi }{3})I_c\end{aligned}\]</span></p><p>写成矩阵形式如下：</p><p><span class="math display">\[\begin{bmatrix} I_{\alpha }\\  I_{\beta } \end{bmatrix} = \begin{bmatrix} 1 &amp; -\frac{1}{2} &amp; -\frac{1}{2}\\ 0 &amp; \frac{\sqrt{3}}{2} &amp; -\frac{\sqrt{3}}{2} \end{bmatrix} \begin{bmatrix} I_a\\ I_b\\ I_c\end{bmatrix}\]</span></p><p>但是到这里还没完，我们在实际使用过程中使用的公司并不是这个而是有一个系数 k 来调整为等幅变换或等功率变换，实际使用的公式如下：</p><p><span class="math display">\[\begin{bmatrix} I_{\alpha }\\  I_{\beta } \end{bmatrix} = k * \begin{bmatrix} 1 &amp; -\frac{1}{2} &amp; -\frac{1}{2}\\ 0 &amp; \frac{\sqrt{3}}{2} &amp; -\frac{\sqrt{3}}{2} \end{bmatrix} \begin{bmatrix} I_a\\ I_b\\ I_c\end{bmatrix}\]</span></p><p>在等幅值变换中<span class="math inline">\(k = \frac{2}{3}\)</span>具体推导如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/clark2-3.png"></p><p>以相电压来作为推导而不是相电流，设<span class="math inline">\(V_m\)</span>是相电压峰值，则：</p><p><span class="math display">\[\begin{aligned}&amp;U_a = V_m * cos(\theta) \\&amp;U_b = V_m * cos(\theta - \frac{2\pi }{3}) \\&amp;U_c = V_m * cos(\theta + \frac{2\pi }{3}) \\&amp;U_a + U_b + U_c = 0\end{aligned}\]</span></p><p>这里<span class="math inline">\(\theta = 2\pi ft\)</span>将这三相电压合成空间电压矢量<span class="math inline">\(U_t\)</span>为：</p><p><span class="math display">\[U_t = U_a + U_b * e^{\frac{2 \pi j}{3}} + U_c * e^{\frac{4 \pi j}{3}} = \frac{3}{2}V_m * e^{j\theta }\]</span></p><p>由此可以看出合成的电压矢量是原来的<span class="math inline">\(\frac{3}{2}\)</span>, 但是为什么会多出来？？？ 因此当<span class="math inline">\(k = \frac{2}{3}\)</span>时合成矢量将与变换前一致，就是等幅值转换，将<span class="math inline">\(k = \frac{2}{3}\)</span>代入先前公式并化简可以得到：</p><p><span class="math display">\[\begin{aligned}&amp;U_{\alpha } = U_a \\&amp;U_{\beta } = \frac{1}{\sqrt{3}}(U_a + 2U_b)\end{aligned}\]</span></p><p>另一种变换是等功率变换，当<span class="math inline">\(k = \sqrt{\frac{2}{3}}\)</span>为等功率变换，详细推导过程可以参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRpMTk4OS9hcnRpY2xlL2RldGFpbHMvODk5MjYzMjQ=">Clark 变换及比例系数 2/3 推导过程<i class="fa fa-external-link-alt"></i></span></p><h2 id="park-变换">park 变换</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/park.gif"></p><p>dq 坐标系是建立在转子上的直角坐标系，其中：</p><p>d 轴方向与转子磁链方向重合，又叫直轴； q 轴方向与转子磁链方向垂直，又叫交轴；</p><p>d 轴和𝑞轴 q 轴如下图所示； <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/qd.png"></p><p>相对与定子来说是旋转的坐标系，在 dq 坐标系下<span class="math inline">\(i_d i_q\)</span>为恒定值而不再是正弦值。park 变换的本质是静止坐标系αβ乘以一个旋转矩阵，从而得到 dq 坐标系：</p><p><span class="math display">\[\begin{aligned}&amp;i_d = i_{\alpha} * cos(\theta) + i_{\beta} * sin(\theta) \\&amp;i_q = -i_{\alpha} * sin(\theta) + i_{\beta} * cos(\theta)\end{aligned}\]</span></p><p>写成矩阵式为：</p><p><span class="math display">\[\begin{bmatrix}i_d\\ i_q\end{bmatrix} = \begin{bmatrix}cos(\theta ) &amp; sin(\theta )\\ -sin(\theta ) &amp; cos(\theta )\end{bmatrix}\begin{bmatrix}i_{\alpha }\\ i_{\beta }\end{bmatrix}\]</span></p><p>通过 park 变换后将交流信号转变为直流信号，这样就方便进行信号调节，像使用 pid 控制器对电机信号进行控制。</p><h2 id="park-反变换">Park 反变换</h2><p>Park 反变换又叫直交变换，由 dq 轴的直流量，最终变换到αβ的交流量，其公式如下：</p><p><span class="math display">\[\begin{aligned}&amp;i_{\alpha} = i_d * cos(\theta) - i_q * sin(\theta) \\&amp;i_{\alpha} = i_d * sin(\theta) + i_q * cos(\theta)\end{aligned}\]</span></p><p>写成矩阵形式如下：</p><p><span class="math display">\[\begin{bmatrix}i_{\alpha }\\ i_{\beta }\end{bmatrix} = \begin{bmatrix}cos(\theta ) &amp; -sin(\theta )\\ sin(\theta ) &amp; cos(\theta )\end{bmatrix}\begin{bmatrix}i_d\\ i_q\end{bmatrix}\]</span></p><p>因为 svpwm 使用的坐标系还是αβ坐标系，在经过 park 变换后进行调控例如使用 pid 控制器对其中的参数进行调控后需要再经过反 park 变换回去输入到 svpwn 模块中去。</p><p>这里需要注意 park 变换是需要电角度信息的，因此这里涉及无感和有感两种 foc，由于本人也没有研究过无感 foc 因此这里只讲下有感 foc。所谓有感就是有传感器，通过传感器获得电机转子的位置，传感器种类很多有光电式和霍尔传感器式，按照获取角度类型可以分为绝对式编码器和相对式编码器，但无论哪种传感器最终都是获得电机转子的位置，然后在 park 变换的时候用于将<span class="math inline">\(\alpha \beta\)</span>坐标系转换到 dq 坐标系下。这里以常见的霍尔传感器为例来说明一下，霍尔传感器又分为线性霍尔传感器和开关型霍尔传感器，线性霍尔传感器可以获得更精细的角度信息，例如 ti 的 DRV5055, 这种传感器如果想要获得较好的性能一般使用两个传感器呈 90 度角度排列，这种传感器使用前需要进行校准，对磁场的最大值和最小值进行校准更精确的校准是对其进行尺度因子的校准这个一般不需要；另一种是开关型霍尔传感器一般使用 3 个传感器彼此之间呈 60 度或 120 度排布。除此之外还有一种集成式传感器，通过 iic 或 spi 接口数字输出角度信息，例如 as5600，tle5012b 等，这种使用起来更加简单，不需要对传感器进行校准只需要对电角度和机械角度进行校准即可。 下面以 drv5055 这种线性霍尔传感器为例说明一下使用注意事项： drv5055 线性霍尔传感器输出的是模拟信号，可以检测磁场强弱信号，在电机的转子上需要安装一个径向冲磁的圆形或圆环型磁铁，然后两个 drv5055 呈 90 度分布在磁铁的外环位置，当电机转转一周传感器将经历完整的从 N 极到 S 极的磁场信号，输出为一个周期的正弦曲线，两个传感器输出如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/drv5055.png"></p><p>两个呈 90 摆放的 drv5055 传感器在电机转子旋转一周输出的波形如上图所示，这里主要说明两点：</p><ul><li>使用呈 90 度摆放的两个传感器的好处：单个传感器以上图<span class="math inline">\(B_x\)</span>为例在最大值和最小值的地方斜率为 0 附近斜率也非常小，在值为 0 附近斜率最大，因此当转子在极值处值变化不明显会容易出现误差，而两个呈 90 度摆放的传感器就刚好弥补了这个缺点。</li><li>关于传感器校准，从上图可以看到两个传感器的幅值不同，一般情况下都是不同的，两个传感器不可能做的完全一样而且安装也会又偏差，因此需要对传感器进行校准，校准方法就是对两个传感器进行归一化处理，分别找到两个传感器对极值进而就确定了中值（理想情况下中值为 0 但实际上往往存在偏差）将其归一化到 [-1, 1] 这个值域内就完成了对传感器对校准。</li></ul><h2 id="svpwm">SVPWM</h2><h3 id="概述">概述</h3><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/bldc-driver.jpg"></p><p>SVPWM 是近年发展的一种比较新颖的控制方法，是由三相功率逆变器的六个功率开关元件组成的特定开关模式产生的脉宽调制波，能够使输出电流波形尽 可能接近于理想的正弦波形。空间电压矢量 PWM 与传统的正弦 PWM 不同，它是从三相输出电压的整体效果出发，着眼于如何使电机获得理想圆形磁链轨迹。 SVPWM 技术与 SPWM 相比较，绕组电流波形的谐波 成分小，使得电机转矩脉动降低，旋转磁场更逼近圆形，而且使直流母线电压的利用率有了很大提高，且更易于实现数字化。下面将对该算法进行详细分析阐述。</p><h3 id="基本原理">基本原理</h3><p>SVPWM 的理论基础是平均值等效原理，即在一个开关周期内通过对基本电压矢量加以组合，使其平均值与给定电压矢量相等。在某个时刻，电压矢量旋转到某个区域中，可由组成这个区域的两个相邻的非零矢量和零矢量在时间上的不同组合来得到。两个矢量的作用时间在一个采样周期内分多次施加，从而控制各个电压矢量的作用时间，使电压空间矢量接近按圆轨迹旋转，通过逆变器的不同开关状态所产生的实际磁通去逼近理想磁通圆，并由两者的比较结果来决定逆变器的开关状态，从而形成 PWM 波形。 由于逆变器三相桥臂共有 6 个开关管，为了研究各相上下桥臂不同开关组合时逆变器输出的 空间电压矢量，特定义开关函数 Sx ( x = a、b、c) 为：</p><p><span class="math display">\[S_x = \left\{\begin{matrix}1（上桥臂导通）\\ 0（下桥臂导通）\end{matrix}\right.\]</span></p><p>(Sa、Sb、Sc) 的全部可能组合共有八个，包括 6 个非零矢量 Ul(001)、U2(010)、U3(011)、U4(100)、U5(101)、U6(110)、和两个零矢量 U0(000)、U7(111)，下面以其中一 种开关组合为例分析，假设 Sx ( x= a、b、c)= (100)， 此时： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm100.png"></p><p><span class="math display">\[\begin{aligned}&amp;U_{ab} = U_{dc}, U_{bc} = 0, U_{ca} = -U_{dc} \\&amp;U_{aN} - U_{bN} = U_{dc},U_{aN} - U_{cN} = U_{dc} \\&amp;U_{aN} + U_{bN} + U_{cN} = 0\end{aligned}\]</span></p><p>求解上述方程可得：</p><p><span class="math display">\[\begin{aligned}&amp;U_{aN} = \frac{2U_d}{3} \\&amp;U_{bN} = - \frac{U_d}{3} \\&amp;U_{cN} = - \frac{U_d}{3}\end{aligned}\]</span></p><p>同理可计算出其它各种组合下的空间电压矢量，列表如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-table.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm.png"></p><p>其中非零矢量的幅值相同（模长为 <span class="math inline">\(\frac{2U_{dc}}{3}\)</span>），相邻的矢量间隔 60°，而两个零矢量幅值为零，位于中心。在每一个扇区，选择相邻的两个电压矢量以及零矢量，按照伏秒平衡的原则来合成每个扇区内的任意电压矢量，即：</p><p><span class="math display">\[\int_{0}^{T}U_{ref} dt = \int_{0}^{T_x}U_x dt + \int_{T_x}^{T_x + T_y}U_y dt + \int_{T_x + T_y}^{T}U_0 dt\]</span></p><p>等效与下式：</p><p><span class="math display">\[U_{ref} * T = U_x * T_x + U_y * T_y + U_0 * T_0\]</span></p><p>其中，<span class="math inline">\(U_{ref}\)</span> 为期望电压矢量；T 为采样周期；<span class="math inline">\(T_x、T_y、T_0\)</span> 分别为对应两个非零电压矢量 <span class="math inline">\(U_x、U_y\)</span>和零电压矢量<span class="math inline">\(U_0\)</span>在一个采样周期的作用时间；其中<span class="math inline">\(U_0\)</span>包括了<span class="math inline">\(U_0\)</span>和<span class="math inline">\(U_7\)</span>两个零矢量。上式的意义是，矢量 <span class="math inline">\(U_{ref}\)</span> 在 T 时间内所产生的积分效果值和 <span class="math inline">\(U_x、U_y、U_0\)</span>分别在时间<span class="math inline">\(T_x、T_y、T_0\)</span>内产生的积分效果相加总和值相同。由于三相正弦波电压在电压空间向量中合成一个等效的旋转电压，其旋转速度是输入电源角频率，等效旋转电压的轨迹将是如上图所示的圆形。所以要产生三相正弦波电压，可以利用以上电压向量合成的技术，在电压空间向量上，将设定的电压向量由 U4(100) 位置开始，每一次增加一个小增量，每一个小增量设定电压向量可以用该区中相邻的两个基本非零向量与零电压向量予以合成，如此所得到的设定电压向量就等效于一个在电压空间向量平面上平滑旋转的电压空间向量，从而达到电压空间向量脉宽调制的目的。</p><h3 id="推导">推导</h3><p>三相电压给定所合成的电压向量旋转角速度为ω=2πf，旋转一周所需的时间为 T =1/f ；若载波频率是 fs，则频率比为 R = fs / f。这样将电压旋转平面等切割成 R 个小增量，亦 即设定电压向量每次增量的角度是 ：</p><p><span class="math display">\[\gamma = \frac{2}{R} = \frac{2 \pi f}{fs} = \frac{2Ts}{T}\]</span></p><p>假设欲合成的电压向量 <span class="math inline">\(U_{ref}\)</span> 在第Ⅰ区中第一个增量的位置，如下图所示，欲用 U4、U6、U0 及 U7 合成，用平均值等效可得：<span class="math inline">\(U_ref * Tz =U4 * T4 +U6 * T6\)</span> 。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-1.png"></p><p>在两相静止参考坐标系（α，β）中，令<span class="math inline">\(U_{ref}\)</span>和 U4 间的夹角是θ，由正弦定理可得：</p><p><span class="math display">\[\left | U_{ref} \right | cos(\theta ) = \frac{T_4}{T_s}\left | U_4 \right | + \frac{T_6}{T_s} \left | U_6 \right | cos(\frac{\pi }{3})\\\left | U_{ref} \right | sin(\theta ) =  \frac{T_6}{T_s} \left | U_6 \right | sin(\frac{\pi }{3})\]</span></p><p>因为 |U4 |=|U6|=2Udc/3 ，所以可以得到各矢量的状态保持时间为：</p><p><span class="math display">\[\begin{aligned}&amp;T_4 = mT_s sin(\frac{\pi }{3} - \theta ) \\&amp;T_6 = mT_s sin(\theta )\end{aligned}\]</span></p><p>式中 m 为 SVPWM 调制系数（调制比）， <span class="math inline">\(m= \frac{\sqrt{3}\left | U_{ref} \right |}{U_{dc}}\)</span>。而零电压向量所分配的时间为：T7=T0=(TS-T4-T6 ) /2 或者 T7 =(TS-T4-T6 ) 得到以 U4、U6、U7 及 U0 合成的 Uref 的时间后，接下来就是如何产生实际的脉宽调制波形。在 SVPWM 调制方案中，零矢量的选择是最具灵活性的，适当选择零矢量，可最大限度地减少开关次数，尽可能避免在负载电流较大的时刻的开关动作，最大限度地减少开关损耗。</p><h3 id="七段式-svpwm">七段式 SVPWM</h3><p>我们以减少开关次数为目标，将基本矢量作用顺序的分配原则选定为：在每次开关状态转换时，只改变其中一相的 开关状态。并且对零矢量在时间上进行了平均分配，以使产生的 PWM 对称，从而有效地降低 PWM 的谐波分量。当 U4(100) 切换至 U0(000) 时，只需改变 A 相上下一对切换开关，若由 U4(100) 切换至 U7(111) 则需改变 B、C 相上下两对切换开关，增加了一倍的切换损失。因此要改变电压向量 U4(100)、U2(010)、 U1(001) 的大小，需配合零电压向量 U0(000)，而要改变 U6(110)、U3(011)、U5(100)， 需配合零电压向量 U7(111)。这样通过在不同区间内安排不同的开关切换顺序， 就可以获得对称的输出波形，其它各扇区的开关切换顺序如下表所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-7.png"></p><p>现的先后顺序为 U0、U4、U6、U7、U6、U4、U0，各电压向量的三相波形则与上表中的开关表示符号相对应。再下一个 TS 时段，Uref 的角度增加一个γ，利用式上式可以重新计算新的 T0、T4、T6 及 T7 值；这样每一个载波周期 Ts 就会合成一个新的矢量，随着θ的逐渐增大，<span class="math inline">\(U_ref\)</span> 将依序进入第Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ、Ⅵ区。在电压向量旋转一周期后，就会产生 R 个合成矢量。</p><h3 id="合成矢量u_ref所处扇区-n-的判断">合成矢量<span class="math inline">\(U_ref\)</span>所处扇区 N 的判断</h3><p>空间矢量调制的第一步是判断由 Uα和 Uβ所决定的空间电压矢量所处的扇区。假定合成的电压矢量落在第 I 扇区，可知其等价条件如下：0º &lt; arctan(Uβ/Uα) &lt; 60 º 以上等价条件再结合矢量图几何关系分析，可以判断出合成电压矢量<span class="math inline">\(U_ref\)</span>落在第 X 扇区的充分必要条件，得出下表： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-sector.png"></p><p>若进一步分析以上的条件，有可看出参考电压矢量<span class="math inline">\(U_ref\)</span>所在的扇区完全由<span class="math inline">\(U_{\beta }, \sqrt{3}U_{\alpha } - U_{\beta }, -\sqrt{3}U_{\alpha } - U_{\beta }\)</span>三式决定，因此令：</p><p><span class="math display">\[\begin{aligned}&amp;U_1 = U_{\beta} \\&amp;U_2 = \sqrt{3}U_{\alpha } - U_{\beta } \\&amp;U_3 = -\sqrt{3}U_{\alpha } - U_{\beta }\end{aligned}\]</span></p><p>再定义，若 U1&gt;0 ，则 A=1，否则 A=0； 若 U 2&gt;0 ，则 B=1，否则 B=0；若 U3&gt;0 ，则 C=1，否则 C=0。可以看出 A，B，C 之间共有八种组合，但由判断扇区的公式可知 A，B，C 不会同时为 1 或同时为 0，所以实际的组合是六种，A，B，C 组合取不同的值对 应着不同的扇区，并且是一一对应的，因此完全可以由 A，B，C 的组合判断所在的扇区。为区别六种状态，令 N=4 * C + 2 * B + A，则可以通过下表计算参考电压 矢量 Uref 所在的扇区。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-sectorx.png"></p><p>采用上述方法，只需经过简单的加减及逻辑运算即可确定所在的扇区，对于提高系统的响应速度和进行仿真都是很有意义的。</p><h3 id="基本矢量作用时间计算">基本矢量作用时间计算</h3><p>在传统 SVPWM 算法中用到了空间角度及三角函数，使得直接计算基本电压矢量作用时间变得十分困难。实际上只要充分利用 Uα 和 Uβ 就可以使计算大为简化。以 Uref 处在第Ⅰ扇区时进行分析有：</p><p><span class="math display">\[\begin{bmatrix}U_{\alpha }\\ U_{\beta }\end{bmatrix} = U_{ref}\begin{bmatrix}cos(\theta )\\ sin(\theta )\end{bmatrix} T_s = \frac{2}{3}U_{dc}\left ( \begin{bmatrix}1\\ 0\end{bmatrix} T_4 + \begin{bmatrix}cos(\frac{\pi }{3})\\ sin(\frac{\pi }{3})\end{bmatrix}T_6\right )\]</span></p><p>经过整理后得出：</p><p><span class="math display">\[\begin{aligned}&amp;U_{\alpha } T_s = \frac{2}{3}U_{dc}(T_4 + \frac{1}{2}T_6) \\&amp;U_{\beta } T_s = \frac{2}{3}U_{dc}(\frac{\sqrt{3}}{2}T_6)\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;T_4 = \frac{2U_{\alpha } T}{2U_{dc}} - \frac{1}{2}T_6 = \frac{2U_{\alpha } T_s}{2U_{dc}} - \frac{\sqrt{3}}{2}\frac{U_{\beta }T_s}{U_{dc}} = \frac{\sqrt{3}T_s}{U_{dc}}U_2 \\&amp;T_6 = \frac{\sqrt{3} U_{\beta }T_s}{U_{dc}} = \frac{\sqrt{3}T_s}{U_{dc}}U_1 \\&amp;T_7 = T_0 = \frac{T_s - T_4 - T_6}{2}\end{aligned}\]</span></p><p>同理可求得<span class="math inline">\(U_ref\)</span>在其它扇区中各矢量的作用时间，结果如下表所示。由此可根据前式中的 U1 、U 2 、U3 判断合成矢量所在扇区，然后查表得出两非零矢量的作用时间， 最后得出三相 PWM 波占空比，下表可以使 SVPWM 算法编程简易实现。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-time1.png"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-time2.png"></p><p>将 I 扇区的时间图画出来如下： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Algorithm/svpwm-time1sector.png"></p><h3 id="svpwm-物理含义">SVPWM 物理含义</h3><p>SVPWM 实质是一种对在三相正弦波中注入了零序分量的调制波进行规则采样的一种变形 SPWM。但 SVPWM 的调制过程是在空间中实现的，而 SPWM 是在 ABC 坐标系下分相实现的；SPWM 的相电压调制波是正弦波，而 SVPWM 没有明确的相电压调制波，是隐含的。为了揭示 SVPWM 与 SPWM 的内在联系，需求出 SVPWM 在 ABC 坐标系上的等效调制波方程，也就是将 SVPWM 的隐含调制波显化。 我们知道了各扇区的矢量发送顺序： 奇数区依次为：U 0 ，U k ，U k+1 ，U 7 ，U k+1 ，U k ，U 0 偶数区依次为：U 0 ，U k+1 ，U k ，U 7 ，U k ，U k+1 ，U 0 利用空间电压矢量近似原理，可总结出下式：</p><p><span class="math display">\[\begin{bmatrix}T_k\\ t_{k+1}\end{bmatrix} = \begin{bmatrix}sin(\frac{k\pi }{3}) &amp; -cos(\frac{k\pi }{3})\\ sin(\frac{(k -1) \pi }{3}) &amp; -cos(\frac{(k-1)\pi }{3})\end{bmatrix}\begin{bmatrix}cos(\theta )\\ sin(\theta )\end{bmatrix}\]</span></p><p>式中 m 仍为 SVPWM 调制系数，利用以上各式就可得到在第Ⅰ扇区的各相电压平均值：</p><p><span class="math display">\[\begin{aligned}&amp;U_a(\theta ) = \frac{U_{dc}}{T_s}(-\frac{T_0}{2} + \frac{T_4}{2} + \frac{T_6}{2} + \frac{T_7}{2} + \frac{T_7}{2} + \frac{T_6}{2} + \frac{T_4}{2} - \frac{T_0}{2} ) = \frac{\sqrt{3}}{2}\left | U_{ref} \right | cos(\theta - \frac{\pi }{6}) \\&amp;U_b(\theta ) = \frac{U_{dc}}{T_s}(-\frac{T_0}{2} + \frac{T_4}{2} + \frac{T_6}{2} + \frac{T_7}{2} + \frac{T_7}{2} + \frac{T_6}{2} + \frac{T_4}{2} - \frac{T_0}{2} ) = \frac{\sqrt{3}}{2}\left | U_{ref} \right | sin(\theta - \frac{\pi }{6}) \\&amp;U_c(\theta ) = \frac{U_{dc}}{T_s}(-\frac{T_0}{2} + \frac{T_4}{2} + \frac{T_6}{2} + \frac{T_7}{2} + \frac{T_7}{2} + \frac{T_6}{2} + \frac{T_4}{2} - \frac{T_0}{2} ) = -\frac{\sqrt{3}}{2}\left | U_{ref} \right | cos(\theta - \frac{\pi }{6})\end{aligned}\]</span></p><p>同样可以推导出其它扇区的调制波函数，其相电压调制函数如下：</p><p><span class="math display">\[U_a(\theta ) = \left\{\begin{matrix}\frac{\sqrt{3}}{2}\left | U_{ref} \right | cos(\theta - \frac{\pi }{6}) ---(0 \leqslant  \theta &lt; \frac{\pi }{3}, \pi \leqslant \theta &lt; \frac{4\pi }{3})\\ \frac{\sqrt{3}}{2}\left | U_{ref} \right | cos(\theta ) ---(\frac{\pi }{3}\leqslant \theta &lt; \frac{2\pi }{3}, \frac{4\pi }{3} \leqslant \theta &lt; \frac{5\pi }{3})\\ \frac{\sqrt{3}}{2}\left | U_{ref} \right | cos(\theta + \frac{\pi }{6}) ---(\frac{2\pi }{3} \leqslant  \theta &lt; \pi , \frac{5\pi }{3} \leqslant \theta &lt; 2\pi )\end{matrix}\right. \\U_b(\theta ) = U_a(\theta - \frac{2\pi }{3}) \\U_c(\theta ) = U_a(\theta - \frac{4\pi }{3})\]</span></p><p>其线电压的调制波函数为：</p><p><span class="math display">\[\begin{aligned}&amp;U_{ab}(\theta) = U_a(\theta) - U_b(\theta) = \sqrt{3 } \left| U_{ref} \right |sin(\theta + \frac{\pi }{3}) \\&amp;U_{bc}(\theta ) = U_{ab}(\theta - \frac{2\pi }{3}) \\&amp;U_{ca}(\theta ) = U_{a}(\theta - \frac{4\pi }{3})\end{aligned}\]</span></p><p>从相电压调制波函数来看，输出的是不规则的分段函数，为马鞍波形。当调制波为正弦波时为 spwm，调制波为在理想正弦波基础上加入三次谐波注入就是 svpwm。比单纯正弦调制波输出的 SPWM，SVPWM 的优点：</p><ul><li>谐波优化程度高，转矩脉动小。</li><li>通过共模分量注入，等效基波增大，电压利用率提高。</li></ul><h1 id="开环控制">开环控制</h1><p>对于一个完整当 FOC 控制器是需要电流采样的，只有在有电流采样的情况下才可以进行 clark 变换，而在实际的使用过程中有时我们并不需要进行电流闭环控制，可以采用开环控制算法，那么在没有电流反馈的情况下该如何进行开环控制呢？这里可以将 clark 变换和 park 变换省略掉，直接对 dq 轴变量进行调控，然后直接进行反 park 变换回去，再经过 svpwm 模块输出最终的信号给到电机。这里的开环控制跟有感还是无感是没有关系的，这里让然可以采用有感的开环控制，只是这里就没有办法做电流闭环控制，只能做力矩，速度和位置闭环控制。</p><h1 id="总结">总结</h1><p>回到一开始的 FOC 控制总体框图，整个 FOC 流程是通过电流采样获得三相电流值，对三相电流值进行 clark 变换到<span class="math inline">\(\alpha \beta\)</span>坐标系下（两相直角坐标系），再经过 park 变换，变换到转子的 dq 坐标系下，到这里交流信号已经转变为直流信号，然后对这个直流信号进行调节，一般采用 pid 控制器进行调节，可以进行力矩，速度和位置闭环调节，将调节后对 dq 坐标轴数据再经过反 park 变换再经过 svpwm 运算后输出 pwm 信号到电机，这就是完整对 foc 控制算法。</p><h2 id="参考文献">参考文献</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGVuZ2t5LmNuL3lvbmdjaURKLzA0LXd1c2h1YVlDRERKLVlMMTEvd3VzaHVhWUNESi1ZTDExLmh0bWw=">二相导通星形三相六状态无刷直流永磁电动机工作原理<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yOTM0NzA5MTI=">Clark 变换与 Park 变换<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80Nzc2NjQ1Mg==">如何深入理解 SVPWM？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIzNTY3NzA3">三相对称电流通过向 dq 坐标轴上投影得到的 Id、Iq 与通过 park 变换得到的 Id、Iq 有什么区别和联系么？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDc2NTk4MjA=">深入浅出讲解 FOC 算法与 SVPWM 技术<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkdWNvbGxpbnMvYXJ0aWNsZS9kZXRhaWxzLzc5MjYwMTc2">永磁同步电机 (PMSM) 的 FOC 闭环控制详解<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTczNDczNTE=">克拉克 (Clark) 变换中等幅值 (2/3) 和等功率 (sqrt(2/3)) 变换的公式推导<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2ZpbGUuZWxlY2ZhbnMuY29tL3dlYjEvTTAwLzdGL0Q0L3BJWUJBRndtOXZpQURITE5BQVNNUWE1ZlZuZzQ2Ny5wZGY=">SVPWM 技术<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> Robot </tag>
            
            <tag> Actuator </tag>
            
            <tag> FOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openshoe 算法</title>
      <link href="/next/2020/Algorithm/openshoe/"/>
      <url>/next/2020/Algorithm/openshoe/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>openshoe 是一种通过惯性测量元件 (IMU) 来对运动进行积分以得到路径的控制算法。算法的核心是 ZUPT（零速度更新算法），在只有 IMU 惯性测量元件的情况下获得路径只能通过对加速度积分得到速度，再将速度对时间进行积分得到路径，这里如果不能对积分得到的速度进行有效的校正那么这个速度误差会时刻对时间进行积分，导致路径完全失效，因此必须采取有效手段及时对速度误差进行校正以得到较为准确的路径信息，ZUPT 就是一种基于检测零速度进行路径积分校正的算法。该算法的关键是对零速度的准确检测。</p><h1 id="零速度检测算法">零速度检测算法</h1><p>openshoe 采用广义似然检测算法对零速度进行检测，以判断 IMU 是否处于静止状态。</p><h2 id="广义似然检测原理">广义似然检测原理</h2><p>要理解广义似然检测原理需要先熟悉几个概率论中相关的概念，详细如下：</p><span id="more"></span><h3 id="条件概率公式">条件概率公式</h3><p>设 A 与 B 为样本空间 Ω 中的两个事件，其中 P(B)&gt;0。那么在事件 B 发生的条件下，事件 A 发生的条件概率为：</p><p><span class="math display">\[P(A|B) = \frac{P(AB)}{P(B)}\]</span></p><h3 id="贝叶斯公式">贝叶斯公式</h3><p><span class="math display">\[P(A|B) = \frac{P(B|A) P(A)}{P(B)}\]</span></p><p>其中 A 以及 B 为随机事件，且 P(B) 不为零。P(A|B) 是指在事件 B 发生的情况下事件 A 发生的概率。</p><h3 id="全概率公式">全概率公式</h3><p>若事件 A1，A2，…构成一个完备事件组且都有正概率，则对任意一个事件 B，有如下公式成立：</p><p><span class="math display">\[\begin{aligned}P(B)&amp;=P(BA1)+P(BA2)+...+P(BAn) \\&amp;=P(B|A1)P(A1) + P(B|A2)P(A2) + ... + P(B|An)P(An) \\&amp;=\sum_{i=1}^{n}P(A_i)P(B|A_i))\end{aligned}\]</span></p><h3 id="似然函数">似然函数</h3><p>似然函数是一种关于统计模型参数的函数。给定输出 x 时，关于参数θ的似然函数<span class="math inline">\(L(\theta|x)\)</span>（在数值上）等于给定参数θ后变量 X 的概率：</p><p><span class="math display">\[L(\theta |x) = P(X = x|\theta )\]</span></p><h3 id="最大似然估计">最大似然估计</h3><p>给定一个概率分布<span class="math inline">\(D\)</span>，已知其概率密度函数（连续分布）或概率质量函数（离散分布）为<span class="math inline">\(f_D\)</span>，以及一个分布参数<span class="math inline">\(\theta\)</span> ，我们可以从这个分布中抽出一个具有<span class="math inline">\(n\)</span>个值的采样<span class="math inline">\(X_1, X_2,\ldots, X_n\)</span>，利用<span class="math inline">\(f_D\)</span>计算出其似然函数：</p><p><span class="math display">\[{\displaystyle (\theta \mid x_{1},\dots ,x_{n})=f_{\theta }(x_{1},\dots ,x_{n}).}\]</span></p><p>若 D 是离散分布，<span class="math inline">\({\displaystyle f_{\theta }}\)</span>即是在参数为<span class="math inline">\(\theta\)</span> 时观测到这一采样的概率。若其是连续分布，<span class="math inline">\({\displaystyle f_{\theta }}\)</span>则为<span class="math inline">\(X_1, X_2,\ldots, X_n\)</span>联合分布的概率密度函数在观测值处的取值。一旦我们获得<span class="math inline">\(X_1, X_2,\ldots, X_n\)</span>，我们就能求得一个关于<span class="math inline">\(\theta\)</span> 的估计。最大似然估计会寻找关于<span class="math inline">\(\theta\)</span> 的最可能的值（即，在所有可能的<span class="math inline">\(\theta\)</span> 取值中，寻找一个值使这个采样的“可能性”最大化）。从数学上来说，我们可以在<span class="math inline">\(\theta\)</span> 的所有可能取值中寻找一个值使得似然函数取到最大值。这个使可能性最大的<span class="math inline">\(\widehat{\theta}\)</span>值即称为<span class="math inline">\(\theta\)</span> 的最大似然估计。由定义，最大似然估计是样本的函数。</p><h3 id="似然比检测">似然比检测</h3><p>似然比检验是利用似然函数来检测某个假设是否有效的一种检验。一般情况下，要检测某个附加的参数限制是否是正确的，可以将加入附加限制条件的较复杂模型的似然函数最大值与之前的较简单模型的似然函数最大值进行比较。如果参数限制是正确的，那么加入这样一个参数应当不会造成似然函数最大值的大幅变动。一般使用两者的比例来进行比较，这个比值是卡方分配。 设<span class="math inline">\(L(x_{1:n}; θ)\)</span>为似然函数，<span class="math inline">\(\theta_1 \theta_2 \in \Theta\)</span>, 两个参数 <span class="math inline">\(θ_1,θ_2\)</span>下似然函数的比值称为似然比。</p><p><span class="math display">\[LR = \frac{L(x_{1:n};\theta _1)}{L(x_{1:n};\theta _2)}\]</span></p><h2 id="算法实现">算法实现</h2><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:N-W+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ya_m=<span class="built_in">mean</span>(u(<span class="number">1</span>:<span class="number">3</span>,k:k+W<span class="number">-1</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l=k:k+W<span class="number">-1</span></span><br><span class="line">        tmp=u(<span class="number">1</span>:<span class="number">3</span>,l)-g*ya_m/norm(ya_m);</span><br><span class="line">        T(k)=T(k)+u(<span class="number">4</span>:<span class="number">6</span>,l)'*u(<span class="number">4</span>:<span class="number">6</span>,l)/sigma2_g + tmp'*tmp/sigma2_a;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T=T./W;</span><br></pre></td></tr></tbody></table></figure><p>既然这里是采用似然比检验方法，自然要涉及到似然函数的建立与约束条件的选取，广义似然比是对似然比的扩展应用，不依赖于统计量的特性，似然函数和约束需要进行自己建模。对于陀螺仪数据的似然函数就是三轴陀螺仪数据的模的平方，陀螺仪没有重力加速度分量的影响建模比较简单，对于加速度则是先将原始数据进行滑动均值滤波，然后去每个数据与滑动均值滤波的残差的模的平方作为似然函数。而这里的约束就是 IMU 的状态了，我们要判断 IMU 是否是静止，则约束条件就是静止，（IMU 的全状态可能包括 IMU 的各轴平移加旋转的组合）因此采样广义似然比算法是一个比较好的求解约束条件是否成立的方法，我们已知的是 IMU 的结果（状态）反求约束条件是否是静止。以上就是运用广义似然比的建模解析对应的实现就是上面的代码，求解未知约束的似然值与已知约束（IMU 静止）似然值的比值即似然比，如果未知约束的条件与已知约束（IMU 静止）约束相同则似然比就很小接近于 1，否则会很大。通过以上方法可以比较好的判断 IMU 是否处于静止状态，当然结果的好坏取决于 sigma2_g 和 sigma2_a 这两个约束条件为 IMU 静止的似然值的选取，如果这个值不能很好代表静止状态下 IMU 的特征则判断会出现很大误差。</p><h1 id="kalman-滤波求解-odometry">kalman 滤波求解 odometry</h1><h2 id="预测阶段">预测阶段</h2><h3 id="更新里程信息">更新里程信息</h3><p>首先是 IMU 姿态更新，openshoe 采用更新四元数的算法进行姿态解算，</p><p><span class="math display">\[q_k = \Omega (w_k dt) q_{k-1}\]</span></p><p><span class="math inline">\(\Omega\)</span>是四元数更新矩阵，<span class="math inline">\(w_k\)</span>是角速度，dt 是采样间隔。算法实现如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">% u(4:6) 为陀螺仪数据</span><br><span class="line">w_tb=u(4:6);</span><br><span class="line"></span><br><span class="line">P=w_tb(1)*Ts;</span><br><span class="line">Q=w_tb(2)*Ts;</span><br><span class="line">R=w_tb(3)*Ts;</span><br><span class="line"></span><br><span class="line">OMEGA=zeros(4);</span><br><span class="line">OMEGA(1,1:4)=0.5*[0 R -Q P];</span><br><span class="line">OMEGA(2,1:4)=0.5*[-R 0 P Q];</span><br><span class="line">OMEGA(3,1:4)=0.5*[Q -P 0 R];</span><br><span class="line">OMEGA(4,1:4)=0.5*[-P -Q -R 0];</span><br><span class="line"></span><br><span class="line">v=norm(w_tb)*Ts;</span><br><span class="line"></span><br><span class="line">% 四元数更新方程</span><br><span class="line"><span class="keyword">if</span> v~=0</span><br><span class="line">    q=(cos(v/2)*eye(4)+2/v*sin(v/2)*OMEGA )*q;</span><br><span class="line">    q=q./norm(q);  %四元数归一化</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>然后更新位置和速度：</p><p><span class="math display">\[p_k = p_{k-1} + v_{k-1} dt \\v_k = v_{k-1} + (q_{k-1}f_kq_{k-1}^{*} -g)dt\]</span></p><p><span class="math inline">\(p_k\)</span>代表 k 时刻位置，<span class="math inline">\(v_k\)</span>代表 k 时刻速度<span class="math inline">\(f_k\)</span>为牵引力，算法实现如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">% Gravity vector</span><br><span class="line">g_t=[0 0 simdata.g]<span class="string">';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">% f_t 是旋转矩阵 x acc 向量，得到瞬时加速度量在 navigation coordinat 坐标系下的表示</span></span><br><span class="line"><span class="string">f_t=q2dcm(q)*u(1:3);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">% Subtract (add) the gravity, to obtain accelerations in navigation</span></span><br><span class="line"><span class="string">% coordinat system.</span></span><br><span class="line"><span class="string">acc_t=f_t+g_t;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">% State space model matrices</span></span><br><span class="line"><span class="string">A=eye(6);</span></span><br><span class="line"><span class="string">A(1,4)=Ts;</span></span><br><span class="line"><span class="string">A(2,5)=Ts;</span></span><br><span class="line"><span class="string">A(3,6)=Ts;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B=[(Ts^2)/2*eye(3);Ts*eye(3)];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">% Update the position and velocity estimates.</span></span><br><span class="line"><span class="string">y(1:6)=A*x(1:6)+B*acc_t;</span></span><br></pre></td></tr></tbody></table></figure><p>该过程会不断更新 IMU 在世界坐标系下的位置，速度和姿态信息。每一轮数据更新一次，实现里程信息的更新。这里说明一下<span class="math inline">\(q_{k-1}f_kq_{k-1}^{*}\)</span>这个公式，这是四元数旋转公式的表达，表示<span class="math inline">\(f_k\)</span>按照<span class="math inline">\(q_k-1\)</span>这个四元数进行旋转，这里其实就是用 acc 原始数据按照当前 IMU 姿态进行旋转得到世界坐标系下的姿态，而速度更新方程就是<span class="math inline">\(v = v_0 + at\)</span>这个方程。</p><h3 id="更新状态转移矩阵">更新状态转移矩阵</h3><p>状态转移矩阵其实就是将上面的更新状态方程写成矩阵的形式，将其中的矩阵系数提取出来，并在每一次循环中更新。下面先写出上面状态更新的矩阵形式：</p><p><span class="math display">\[\begin{bmatrix}p_k\\ v_k\\ q_k\end{bmatrix} = \begin{bmatrix}p_{k-1} + v_{k-1}dt\\ v_{k-1} + (q_{k-1}f_kq_{k-1}^{*}-g)dt\\ \Omega (w_kdt)q_{k-1}\end{bmatrix} = \begin{bmatrix}I &amp; Idt &amp; O\\ O &amp; I &amp; (q_{k-1}f_kq_{k-1}^{*}-g)q_{k-1}^{*}dt \\ O &amp; O &amp; \Omega (w_kdt)\end{bmatrix}\begin{bmatrix}p_{k-1}\\ v_{k-1}\\ p_{k-1}   \tag{1}\end{bmatrix}\]</span></p><p>这里：</p><p><span class="math display">\[F = \begin{bmatrix}I &amp; Idt &amp; O\\ O &amp; I &amp; (q_{k-1}f_kq_{k-1}^{*}-g)q_{k-1}^{*}dt \\ O &amp; O &amp; \Omega (w_kdt)\end{bmatrix}\]</span></p><p>就是状态转移矩阵，下面我们看看具体的实现。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Convert quaternion to a rotation matrix</span></span><br><span class="line">Rb2t=q2dcm(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Transform measured force to force in</span></span><br><span class="line"><span class="comment">% the navigation coordinate system.</span></span><br><span class="line">f_t=Rb2t*u(<span class="number">1</span>:<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create a ske symmetric matrix of the specific fore vector</span></span><br><span class="line">St=[<span class="number">0</span> -f_t(<span class="number">3</span>) f_t(<span class="number">2</span>); f_t(<span class="number">3</span>) <span class="number">0</span> -f_t(<span class="number">1</span>); -f_t(<span class="number">2</span>) f_t(<span class="number">1</span>) <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Zero matrix</span></span><br><span class="line">O=<span class="built_in">zeros</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Identity matrix</span></span><br><span class="line">I=<span class="built_in">eye</span>(<span class="number">3</span>);</span><br><span class="line">...</span><br><span class="line">Fc=[O I O;</span><br><span class="line">    O O St;</span><br><span class="line">    O O O];</span><br><span class="line">    </span><br><span class="line"><span class="comment">% Noise gain matrix</span></span><br><span class="line">Gc=[O O; Rb2t O; O -Rb2t];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Approximation of the discret time state transition matrices</span></span><br><span class="line">F=<span class="built_in">eye</span>(<span class="built_in">size</span>(Fc))+simdata.Ts*Fc;</span><br><span class="line">G=simdata.Ts*Gc;</span><br></pre></td></tr></tbody></table></figure><p>为了更清楚的看到结果，这里把这个转移矩阵写为公式形式：</p><p><span class="math display">\[F = \begin{bmatrix}I &amp; O &amp; O\\ O &amp; I &amp; St * dt\\ O &amp; O &amp; I\end{bmatrix}\]</span></p><p>我们看到这里实现上有一点差异就是这个状态转移矩阵其实是不包括四元数 q 的更新项的，这里这样做其实是很合理的，在我们当前这个系统中四元数的更新是不需要进行卡尔曼滤波的，其实在实现上我们也看到这里并不是通过整个状态转移矩阵直接更新所有状态的而是分拆将每个状态进行更新，我们主要是对位置和速度这两个量进行滤波，实际上也也是只对这两个状态量进行滤波，因此这里状态转移矩阵在跟新前先更新了四元数 q 然后四元数的更新<span class="math inline">\(q=q_{k-1}\)</span>就是上面代码中的形式。 在标准卡尔曼滤波中还有一个是测量转移矩阵，由于我们的系统模型中系统状态量是位置 p 和速度 v 这两个量都是不可测量的，只有速度 v 是间接通过 ZUPT 进行估计的因此测量转移矩阵为：</p><p><span class="math display">\[H = \begin{bmatrix}O &amp; I &amp; O\end{bmatrix}\]</span></p><p>这里其实并不需要进行什么运算在因此在实现上就省略了。 接着是前验状态协方差矩阵的更新：</p><p><span class="math display">\[\hat{P}=F*\hat{P}*F'+G*Q*G'\tag{2}\]</span></p><p>其中 G 为过程噪声转移矩阵，Q 为过程噪声，原始噪声就是加速度跟陀螺仪的噪声，Q 初值的选取是按照加速度和陀螺仪的噪声大小来选取的，系统中选取 0.1 个加速度和 0.1 度每秒作为初始系统误差值。</p><h2 id="观测阶段">观测阶段</h2><p>先说明下整个卡尔曼滤波的建模形式，系统的状态共三个，位置，速度和四元数（四元数可以转化为欧拉角）卡尔曼滤波中更新两个系统量位置和速度（对速度进行滤波间接更新到位置）上文列出了状态更新相关过程，只有上面的过程系统速度误差无法被消除，而速度误差会无时无刻的累加到位置信息上，导致位置信息误差无限扩大最终里程信息不可用。而观测过程就是为了消除速度误差的，观测过程只存在于检测到速度为 0（ZUPT 返回 true）时进行观测过程的更新。 卡尔曼系数的更新：</p><p><span class="math display">\[K = \frac{HP*H'}{H*P*H'+R}\tag{3}\]</span></p><p>H 为单位矩阵 R 为测量误差矩阵都是固定矩阵，分子和分母分别代表了对预测和观测的信任度。 现在有了卡尔曼系数 K 就可以按照对预测和观测的信任度来修正误差了，对于速度误差的修正比较好理解，当前通过陀螺仪积分得到的速度是不为 0 的，而我们通过 ZUPT 检测出来的速度却为 0，我们根据卡尔曼系数来衡量两个数据的可信任程度，然后将 K 作用到现在的积分速度上：</p><p><span class="math display">\[v_{err} = -K * v \\v = v+v_{err}     \tag{4}\]</span></p><p>用这个来修正速度误差。并更新测量误差矩阵 R，最后是更新后验协方差矩阵 P:</p><p><span class="math display">\[P_k = (I-K*H)*\hat{P}_k \tag{5}\]</span></p><p>其实现如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">K=(P*H<span class="string">')/(H*P*H'</span>+R);</span><br><span class="line">z=-x_h(4:6,k);</span><br><span class="line">        </span><br><span class="line">% Estimation of the perturbations <span class="keyword">in</span> the estimated navigation</span><br><span class="line">% states</span><br><span class="line">dx=K*z;</span><br><span class="line">% Correct the navigation state using the estimated perturbations. </span><br><span class="line">% (Subfunction located further down <span class="keyword">in</span> the file.)</span><br><span class="line">% 使用误差估计进行校正姿态，x_h(:,k) 校正后的姿态，quat 校正后四元数，dx 是误差评估</span><br><span class="line">[x_h(:,k) quat]=comp_internal_states(x_h(:,k),dx,quat);</span><br><span class="line">{</span><br><span class="line">    % Correct the state vector</span><br><span class="line">    x_out=x_in+dx;</span><br><span class="line"></span><br><span class="line">    % Correct the rotation matrics</span><br><span class="line">    % dx[7:9] 分量代表了旋转误差估计，OMEGA 则构造了旋转误差转移矩阵，对旋转矩阵 R 进行校正</span><br><span class="line">    epsilon=dx(7:9);</span><br><span class="line">    OMEGA=[0 -epsilon(3) epsilon(2); epsilon(3) 0 -epsilon(1); -epsilon(2) epsilon(1) 0];</span><br><span class="line">    R=(eye(3)-OMEGA)*R;</span><br><span class="line">}</span><br><span class="line">% Update the filter state covariance matrix P.</span><br><span class="line">P=(Id-K*H)*P;</span><br></pre></td></tr></tbody></table></figure><p>这样整个数据卡尔曼滤波过程就完了，可以看到在 ZUPT 检测到 0 速度前只有一个预测过程，即只更新系统状态和前验系统协方差矩阵，在系统 ZUPT 检测到 0 速度时进行下面的卡尔曼系数，误差校正及后验协方差矩阵的更新，实现对系统速度的最优解算。最终的系统状态的准确性主要取决于 0 速的发生及准确的检测，在人步行的场景下，每一步都会有一个停顿很适合用来检测 0 速，在准确检测到 0 速后速度误差被消除，这样速度误差可以实时得到修正而位置误差仍然会累积，但是这个误差只会在运动状态下累积，对应精度要求不高的场合数据可用。</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Robot </category>
          
          <category> Actuator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robot </tag>
            
            <tag> Actuator </tag>
            
            <tag> IMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMU 误差模型及校准</title>
      <link href="/next/2020/Algorithm/imuCalibration/"/>
      <url>/next/2020/Algorithm/imuCalibration/</url>
      
        <content type="html"><![CDATA[<h1 id="传感器误差模型">传感器误差模型</h1><p>对于理想的 IMU 三轴加速度计两两正交，构成一个正交的三轴直角坐标系，加速度计每一轴单独测量该轴的加速度，而陀螺仪则测量该轴的角速度。在实际的真实 IMU 中由于制造工艺的误差，三个坐标轴不可能完全两两正交，加速度计与陀螺仪的坐标系也不会完全重合，并且单个传感器也不是完全精确的。在实际器件中将数字输出量转化为实际物理量的 scale 参数在不同轴上是不同的，但是设备生产商都会提供一个默认的 scale 参数用于转换所有轴的数据，而且数字量的输出还会受到零偏（传感器在静止情况下也会有微小量的输出）的影响，这些就是造成 IMU 传感器的系统误差。</p><p>我们取实际器件的加速度计坐标系为 AF, 陀螺仪坐标系为 GF，根据 AF 和 GF 分别建立对应的正交坐标系 AOF 和 GOF，其建立约束为</p><ul><li>AOF 的 x 轴与 AF 的 x 轴重合。</li><li>AOF 的 y 轴位于 AF 的 x 与 y 轴的平面中。</li></ul><p>对于 GOF 的建立约束与 AOF 的约束类比建立。最后再建立一个正交机体坐标系 BF，BF 通常与 AF 和 GF 之间有一个小角度的偏差。在非正交坐标系（AF 或 GF）中测量得到的物理量<span class="math inline">\(s^S\)</span>可以转换到机体坐标系 BF 中得到<span class="math inline">\(s^B\)</span>于是得到下式：</p><p><span class="math display">\[s^B = Ts^S, T = \begin{bmatrix}1 &amp; -\beta_{yz}  &amp; \beta_{zy} \\ \beta_{xz} &amp; 1 &amp; -\beta_{zx} \\ -\beta_{xy} &amp; \beta_{yx} &amp; 1 \end{bmatrix}   \tag{1}\]</span></p><p><span class="math inline">\(s^B 和 s^S\)</span> 表示加速度或角速度在机体坐标系 BF 和加速度坐标系 AF 或陀螺仪坐标系 GF 下测量表示量，<span class="math inline">\(\beta_{ij}\)</span> 表示加速度或陀螺仪的 i 轴绕机体坐标系 BF 的 j 轴的旋转角度。如图二所示： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/imuErr.png"></p><span id="more"></span><p>另外 BF 与 AOF 以及 BF 与 GOF 坐标系之间只有纯粹的旋转关系，我们假设 BF 的 x 轴恰巧与 AOF 的 x 轴重合在这种情况下<span class="math inline">\(\beta_{xz},\beta_{xy},\beta_{yx}\)</span>变为 0 因此上一式可以写为如下：</p><p><span class="math display">\[a^O = T^aa^S, T^a = \begin{bmatrix}1 &amp; -\alpha_{yz} &amp; \alpha_{zy} \\ 0 &amp; 1 &amp; -\alpha_{zx} \\ 0 &amp; 0 &amp; 1\end{bmatrix}   \tag{2}\]</span></p><p>这里<span class="math inline">\(a^O\)</span>和<span class="math inline">\(a^S\)</span>表示加速度在 AOF 和 AF 坐标系下的表示。这里已经改变了<span class="math inline">\(\beta\)</span>的含义，用<span class="math inline">\(\alpha\)</span>来表示在 AF 与 AOF 的 x 轴重合的情况下 AF 与 AOF 各轴之间的旋转情况而不再是与机体坐标系 BF 之间的旋转关系了。 如前所述，陀螺仪可以按照同样的方式进行定义，</p><p><span class="math display">\[w^O = T^gw^S, T^g = \begin{bmatrix}1 &amp; -\gamma_{yz} &amp; \gamma_{zy} \\ \gamma_{xz} &amp; 1 &amp; -\gamma_{zx} \\ -\gamma_{xy} &amp; \gamma_{yx}  &amp; 1\end{bmatrix}   \tag{3}\]</span></p><blockquote><p>注意到目前为止要重点区分 5 个坐标系，首先是加速度计坐标系 AF 和陀螺仪坐标系 GF 由于制造工艺的原因这两个坐标系都不是正交的，且这两个坐标系也不重合，然后根据 AF 和 GF 分创建了两个正交坐标系 AOF 和 GOF，建立的约束就是上文中提到的，最后又建立了一个机体坐标系。后面我们假设机体坐标系的 x 轴与加速度正交坐标系 AOF 的 x 轴重合于是建立了加速计方程（1）和（2）最后 BF 与 GOF 的 x 轴不重合因此只有第一步公式（3）没有后续的推导。</p></blockquote><p>综上加速度计和陀螺仪的误差都是包含两部分比例误差 scale 和 0 偏误差 bias，比例偏差 scale 用如下表示：</p><p><span class="math display">\[K^a = \begin{bmatrix}s_{a}^{x} &amp; 0 &amp; 0 \\ 0 &amp; s_{a}^{y} &amp; 0 \\ 0 &amp; 0 &amp; s_{a}^{z}\end{bmatrix}, K^g = \begin{bmatrix}s_{g}^{x} &amp; 0 &amp; 0 \\ 0 &amp; s_{g}^{y} &amp; 0 \\ 0 &amp; 0 &amp; s_{g}^{z}\end{bmatrix}   \tag{4}\]</span></p><p>两个 bias 向量用如下表示：</p><p><span class="math display">\[b^a = \begin{bmatrix}b_{a}^{x}\\ b_{a}^{y}\\ b_{a}^{z}\end{bmatrix}, b^g = \begin{bmatrix}b_{g}^{x}\\ b_{g}^{y}\\ b_{g}^{z}\end{bmatrix}   \tag{5}\]</span></p><p>完整的加速度误差模型如下：</p><p><span class="math display">\[a^O = T^aK^a(a^S + b^a + v^a)   \tag{6}\]</span></p><p>完整的角速度误差模型如下：</p><p><span class="math display">\[w^O = T^gK^g(w^S + b^g + v^g)   \tag{7}\]</span></p><p>其中<span class="math inline">\(v^a\)</span>和<span class="math inline">\(v^g\)</span>不是系统误差是测量噪声。到此 IMU 的误差模型就讲清楚了，后面会基于这个误差模型进行建模校准传感器。</p><h1 id="校准框架">校准框架</h1><p>为了校准加速度计我们需要估计如下未知参数：</p><p><span class="math display">\[\theta^{acc} = [\alpha_{yz},\alpha_{zy},\alpha_{zx},s_{a}^{x},s_{a}^{y},s_{a}^{z},b_{a}^{x},b_{a}^{y}b_{a}^{z}] \tag{8}\]</span></p><p>我们定义如下函数：</p><p><span class="math display">\[a^O = h(a^S,\theta_{acc}) = T^aK^a(a^S + b^a)   \tag{9}\]</span></p><p>实际上是忽略了测量噪声。像传统的多位置方案中，我们移动 IMU 到 M 个不同的临时稳定状态，可以提取加速度向量<span class="math inline">\(a_{k}^S\)</span>（在非正交坐标系 AF 中）计算加速度计在每个静止状态下的平均值，使用如下代价方程来估计加速度计的参数：</p><p><span class="math display">\[L(\theta_{acc}) =  \sum_{k=1}^{M}(||g||^2 - ||h(a_k^S,\theta_{acc})||^2)^2  \tag{10}\]</span></p><p><span class="math inline">\(||g||\)</span>是真实的当地重力加速度计，可以根据当地的经纬度非常容易的获取到，我们采用 Levenberg-Marquardt 方法来求取当代价函数的最小值时的参数。</p><p>为了校准陀螺仪我们可以在 IMU 初始的静止阶段读取陀螺仪数据并取均值，作为陀螺仪 bias。 我们定义<span class="math inline">\(\Psi\)</span>操作，用读取的陀螺仪数据<span class="math inline">\(w_i^S\)</span>和重力向量<span class="math inline">\(u_{a,k-1}\)</span>作为输入队列（重力向量是经过上面步骤校准过的）该操作返回最终的重力向量<span class="math inline">\(u_{g,k}\)</span>。该操作可以是任意一个通过上一时刻加速度计与角速度计融合后得到当前重力向量的算法。</p><p><span class="math display">\[u_{g,k} = \Psi(w_i^S,u_{a,k-1}) \tag{11}\]</span></p><p>我们需要估计的未知陀螺仪参数如下：</p><p><span class="math display">\[\theta^{gyro} = [\gamma_{yz},\gamma_{zy},\gamma_{xz},\gamma_{zx},\gamma_{xy},\gamma_{yx},s_x^g,s_y^g,s_z^g] \tag{12}\]</span></p><p>在这种情况下我们定义代价函数：</p><p><span class="math display">\[L(\theta_{gyro}) = \sum_{k=2}^M||u_{a,k} - u_{g,k}||^2  \tag{13}\]</span></p><p>M 是静态状态读取数据的数量<span class="math inline">\(u_{a,k}\)</span>是加速度计计算得到的重力向量，<span class="math inline">\(u_{g,k}\)</span>是通过（13）式计算得到的，我们要获得<span class="math inline">\(\theta_{gyro}\)</span>的最小值同样采用上面提到的 Levenberg-Marquardt 方法来求取。</p><h1 id="校准过程">校准过程</h1><h2 id="静态检测">静态检测</h2><p>如前面校准框架所述，校准 IMU 需要收集加速度计和陀螺仪的原始数据，采集的数据应该包含 IMU 在各个稳定状态及其间隔状态下的数据。为了减小 bias 噪声对上面两个代价函数的影响需要先对 0 偏进行校准，初始阶段需要一段时间的静止用于校准陀螺仪的 bias 以及用于静态检测参考。</p><p>校准精度取决于对静止状态判断的准确性，校准加速度计需要在几个静态状态下进行运算，校准陀螺仪需要静态以及各个不同状态的静态之间的运动数据。根据经验对实际的数据集采用基于滤波的算子效果会较差，例如准静态检测器，检测静止状态通常会包含一些小的运动。而且基于滤波器的算法通常依赖滤波参数，需要对滤波参数进行调整。 我们建议采用基于方差的静态检测器运算，他利用上面的静态检测间隔。我们的检测器基于<span class="math inline">\(t_{wait}\)</span>时间间隔进行采集加速度信号并计算方差大小：</p><p><span class="math display">\[\zeta(t) = \sqrt{[var_{t_w}(a_x^t)]^2 + [var_{t_w}(a_y^t)]^2 + [var_{t_w}(a_z^t)]^2}    \tag{14}\]</span></p><p>其中<span class="math inline">\(var_{t_w}(a^t)\)</span>是以时间 t 为中心每隔时间间隔<span class="math inline">\(t_w\)</span>加速度信号的方差值，我们要对该状态进行分类为静止还是运动只需要对<span class="math inline">\(\zeta(t)\)</span>跟一个阈值进行比较就可以了。这个阈值我们可以选取 IMU 在初始静止状态下的值<span class="math inline">\(\zeta(init)\)</span>，从而不依赖任何外部参数的调整。</p><h2 id="龙格库塔法积分">龙格库塔法积分</h2><p>在上面的 11 式中，通过 k-1 时刻的加速度计得到的重力向量与 k-1 到 k 时刻的加速度进行运算得到 k 时刻的重力向量，这里 k-1 和 k 是两个稳定状态，因此 k-1 和 k 之间有一段时间的运动，需要对陀螺仪数据进行积分到加速度计的重力向量中去，在我们的实验中采用 4 阶龙格库塔积分法（RK4n）比标准线性积分精度要高，下式 15 用微分方程来描述四元数运动方程：</p><p><span class="math display">\[f(q,t) = \dot{q} = \frac{1}{2}\Omega(w(t))q \tag{15}\]</span></p><p>这里 q 是 t-1 时刻的重力向量的四元数表示，而<span class="math inline">\(\Omega(w)\)</span>是将角速度转化为斜对称旋转矩阵的操作，形式如下：</p><p><span class="math display">\[\Omega(w) = \begin{bmatrix}0 &amp; -w_x &amp; -w_y &amp; -w_z \\ w_x &amp; 0 &amp; w_z &amp; -w_y \\ w_y &amp; -w_z &amp; 0 &amp; w_x \\ w_z &amp; w_y &amp; -w_x &amp; 0\end{bmatrix}   \tag{16}\]</span></p><p>RK4n 算法如下：</p><p><span class="math display">\[q_{k+1} = q_k + \Delta t \frac{1}{6} (k_1 + 2k_2 + 2k_3 + k_4)  \tag{17}\]</span></p><p><span class="math display">\[k_i = f(q^{(i)},t_k + c_i\Delta t)  \tag{18}\]</span></p><p><span class="math display">\[q^{(i)} = q_k, for i = 1    \tag{19}\]</span></p><p><span class="math display">\[q^{(i)} = q_k + \Delta t \sum_{j=1}^{i-1}a_{ij}k_j, for i&gt;1     \tag{20}\]</span></p><p>所有需要的系数<span class="math inline">\(c_i\)</span>和<span class="math inline">\(a_{ij}\)</span>为：</p><p><span class="math display">\[c_1 = 0, c_2 = \frac{1}{2}, c_3 =  \frac{1}{2},c_4 = 1, \\a_{21} = \frac{1}{2}, a_{31} = 0, a_{41} = 0,   \\a_{32} =  \frac{1}{2}, a_{42} = 0, a_{43} = 1.\]</span></p><p>最后对于每一步我们需要归一化四元数 q：</p><p><span class="math display">\[q_{k+1} \rightarrow  \frac{q_{k+1}}{||q_{k+1}||}  \tag{21}\]</span></p><h2 id="阿伦方差">阿伦方差</h2><p>我们使用艾伦方差来表示陀螺仪的随机漂移误差，这里用<span class="math inline">\(\delta_a^2\)</span>来衡量连续间隔陀螺仪数据平均值之间的方差：</p><p><span class="math display">\[\delta_a^2 = &lt;(x(\tilde{t},k) - x(\tilde{t},k-1))^2&gt;   \\=\frac{1}{2K}\sum_{k=1}^K(x(\tilde{t},k) - x(\tilde{t},k-1))^2   \tag{22}\]</span></p><p>其中<span class="math inline">\(x(t,k)\)</span>是第 k 个<span class="math inline">\(\tilde{t}\)</span>时间间隔陀螺仪数据的均值，K 是所有时间的<span class="math inline">\(\tilde{t}\)</span>个数，我们对每一个轴计算阿伦方差，当阿伦方差收敛到很小的一个值时就表示校准 ok 了，在初始阶段我们将对陀螺仪数据进行求阿伦方差进行校准。</p><h2 id="完成校准">完成校准</h2><p>为了得到较好的校准结果至少需要 9 种不同姿态的数据，实验表明姿态数越多校准结果越好。</p><h1 id="附录">附录</h1><h2 id="levenberg-marquardt-算法">Levenberg-Marquardt 算法</h2><h3 id="牛顿法">牛顿法</h3><p>牛顿法（英语：Newton's method）又称为牛顿-拉弗森方法（英语：Newton-Raphson method），它是一种在实数域和复数域上近似求解方程的方法。方法使用函数<span class="math inline">\(f(x)\)</span>的泰勒级数的前面几项来寻找方程<span class="math inline">\(f(x)=0\)</span>的根。 算法过程： 首先选择一个接近函数<span class="math inline">\(f(x)\)</span>零点的<span class="math inline">\(x_0\)</span>, 计算相应的<span class="math inline">\(f(x_0)\)</span>和切线斜率<span class="math inline">\({f}'(x_0)\)</span>，然后计算穿过点<span class="math inline">\((x_0,f(x_0))\)</span>并且斜率为<span class="math inline">\({f}'(x_0)\)</span>的直线和<span class="math inline">\(x\)</span>轴的交点的<span class="math inline">\(x\)</span>坐标，也就是求如下方程的解：</p><p><span class="math display">\[0 = (x - x_0)\cdot f'(x_0) + f(x_0)\]</span></p><p>我们求解 x，过程如下：</p><p><span class="math display">\[0 = (x - x_0) + \frac{f(x_0)}{f'(x_0)}x - x_0 = - \frac{f(x_0)}{f'(x_0)}x = x_0 - \frac{f(x_0)}{f'(x_0)}\]</span></p><p>我们将新求得的点<span class="math inline">\(x\)</span>坐标命名为<span class="math inline">\(x_1\)</span>，通常<span class="math inline">\(x_1\)</span>会比<span class="math inline">\(x_0\)</span>更接近方程<span class="math inline">\(f(x) = 0\)</span>的解，因此我们可以利用<span class="math inline">\(x_1\)</span>开始下一轮的迭代，迭代公式如下：</p><p><span class="math display">\[x_{n+1} = x_n - \frac {f(x_n)}{f'(x_n)}\]</span></p><p>对于多维的情况，对<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>处进行二阶泰勒展开：</p><p><span class="math display">\[f(x) = f(x_0) + \bigtriangledown f(x_0)^T(x - x_0) + \frac{1}{2}(x - x_0)^TH(x_0)(x - x_0)\]</span></p><p>这里<span class="math inline">\(\bigtriangledown f(x_0)\)</span>是<span class="math inline">\(f(x)\)</span>的梯度向量在点<span class="math inline">\(x_0\)</span>处的值；<span class="math inline">\(H(x_0)\)</span>是<span class="math inline">\(f(x)\)</span>的海塞矩阵在点<span class="math inline">\(x_0\)</span>处的值，函数<span class="math inline">\(f(x)\)</span>有极值的必要条件是在极值点处一阶导数为 0. 利用极小点的必要条件<span class="math inline">\(\bigtriangledown f(x_k) = 0\)</span>每次迭代从<span class="math inline">\(x_k\)</span>开始求目标函数的极小点，作为第<span class="math inline">\(k+1\)</span>次迭代值<span class="math inline">\(x_{k+1}\)</span> 假如<span class="math inline">\(x_{k+1}\)</span>满足<span class="math inline">\(\bigtriangledown f(x_{k+1}) = 0\)</span>对<span class="math inline">\(\bigtriangledown f(x)\)</span>进行泰勒展开：</p><p><span class="math display">\[\bigtriangledown f(x) = \bigtriangledown f(x_k) + H(x_k)(x - x_k) \\\bigtriangledown f(x_k) + H(x_k)(x_{k+1} - x_k) = 0x_{k+1} = x_k - H(x_k)^{-1} \bigtriangledown f(x_k)\]</span></p><p>可以写为如下：</p><p><span class="math display">\[x_{k+1} = x_k - H_k^{-1}g_k\]</span></p><p>这就是牛顿法的多维公式，其中<span class="math inline">\(g_k = \bigtriangledown f(x_k)\)</span></p><h3 id="高斯-牛顿法">高斯-牛顿法</h3><p>给定 m 个方程<span class="math inline">\(\textbf{r} = (r_1,r_2,...r_m)\)</span>（通常叫做残差方程）和 n 个变量<span class="math inline">\(\beta = (\beta_1,\beta_2,...\beta_n)\)</span>, 其中<span class="math inline">\(m \geqslant n\)</span>, 高斯-牛顿算法迭代找出下式取最小值时的最优值。</p><p><span class="math display">\[s(\beta) = \sum_{i=1}^{m}r_i(\beta)^2\]</span></p><p>从给定初始值<span class="math inline">\(\beta_0\)</span>开始，通过下式进行迭代寻找<span class="math inline">\(s(\beta)\)</span>的最小值：</p><p><span class="math display">\[\beta_{s+1} = \beta_{s} - (J_rJ_r)^{-1} J_r^T r \beta_s\]</span></p><p>这里<span class="math inline">\(r\)</span>和<span class="math inline">\(\beta\)</span>都是列向量，<span class="math inline">\(J_r\)</span>Jacobian matrix 为：</p><p><span class="math display">\[(J_r)_{ij} = \tfrac{\partial r_i \beta_s}{\partial \beta_j}\]</span></p><p>其中符号<span class="math inline">\(^T\)</span>是 matrix transpose. 如果 m=n 则可以简化为如下：</p><p><span class="math display">\[\beta_{s+1} = \beta_{s} - (J_r)^{-1} r \beta_s\]</span></p><p>这就是一维牛顿法的直接推广。 在数据拟合中，目标是找到最佳参数<span class="math inline">\(\beta\)</span>使得<span class="math inline">\(\beta\)</span>满足给定模型<span class="math inline">\(y = f(x,\beta)\)</span>可以最好的符合数据点<span class="math inline">\((x,y)\)</span>, 方程<span class="math inline">\(r\)</span>是残差方程，如下：</p><p><span class="math display">\[r_i(\beta) = y_i - f(x_i, \beta)\]</span></p><p>高斯-牛顿法可以用函数<span class="math inline">\(f\)</span>的雅克比<span class="math inline">\(J_f\)</span>表示：</p><p><span class="math display">\[\beta_{s+1} = \beta_{s} - (J_fJ_f)^{-1} J_f^T r \beta_s\]</span></p><p>这里<span class="math inline">\((J_fJ_f)^{-1} J_f^T\)</span>是<span class="math inline">\(J_f\)</span>的伪逆（摩尔-彭罗斯逆）。</p><p>高斯-牛顿算法将通过近似从牛顿方法优化函数中推导而来。牛顿方法最小化参数函数<span class="math inline">\(s\)</span>的递归关系<span class="math inline">\(\beta\)</span>为：</p><p><span class="math display">\[\beta_{s+1} = \beta_s - H^{-1}g\]</span> 其中<span class="math inline">\(g\)</span>表示<span class="math inline">\(S\)</span>梯度向量，<span class="math inline">\(H\)</span>表示<span class="math inline">\(S\)</span>的海塞矩阵 ( Hessian matrix). 由于<span class="math inline">\(S =\sum_{i=1}^{m}r_i \frac{\partial r_i}{\partial \beta_j}\)</span>其梯度通过下式给出：</p><p><span class="math display">\[g_{j}=2\sum _{i=1}^{m}r_{i}{\frac {\partial r_{i}}{\partial \beta _{j}}}\]</span></p><p>海塞矩阵<span class="math inline">\(H\)</span>的元素通过梯度<span class="math inline">\(g_j\)</span>的不同元素<span class="math inline">\(\beta_k\)</span>计算得到：</p><p><span class="math display">\[H_{jk}=2\sum _{i=1}^{m}\left({\frac {\partial r_{i}}{\partial \beta _{j}}}{\frac {\partial r_{i}}{\partial \beta _{k}}}+r_{i}{\frac {\partial ^{2}r_{i}}{\partial \beta _{j}\partial \beta _{k}}}\right)\]</span></p><p>高斯-牛顿法忽略二阶小项，海塞矩阵<span class="math inline">\(H\)</span>可以近似写为：</p><p><span class="math display">\[H_{jk}\approx 2\sum _{i=1}^{m}J_{ij}J_{ik}\]</span></p><p>这里<span class="math inline">\(J_{ij}={\frac {\partial r_{i}}{\partial \beta _{j}}}\)</span>是雅克比矩阵<span class="math inline">\(J_r\)</span>的一项，梯度和海塞矩阵可以通过如下符号来表示：</p><p><span class="math display">\[\mathbf {g} =2{\mathbf {J} _{\mathbf {r} }}^{\mathsf {T}}\mathbf {r} ,\quad \mathbf {H} \approx 2{\mathbf {J} _{\mathbf {r} }}^{\mathsf {T}}\mathbf {J_{r}} \]</span></p><p>将这些表达式代入上述递归关系中以获得运算方程式就得到：</p><p><span class="math display">\[{\boldsymbol {\beta }}_{(s+1)}={\boldsymbol {\beta }}_{(s)}-\left(\mathbf {J_{r}} ^{\mathsf {T}}\mathbf {J_{r}} \right)^{-1}\mathbf {J_{r}} ^{\mathsf {T}}\mathbf {r} \left({\boldsymbol {\beta }}_{(s)}\right)\]</span></p><p>注意并非在所有情况下都保证高斯-牛顿法的收敛性，下式要能够得到保证才可以：</p><p><span class="math display">\[\left|r_{i}{\frac {\partial ^{2}r_{i}}{\partial \beta _{j}\partial \beta _{k}}}\right|\ll \left|{\frac {\partial r_{i}}{\partial \beta _{j}}}{\frac {\partial r_{i}}{\partial \beta _{k}}}\right|\]</span></p><p>二阶导数足够小可以被忽略，在如下两种情况下都会收敛：</p><p>1.<span class="math inline">\(r_i\)</span>在选取值附近要足够小，至少在最小值附近要足够小。 2. 函数只有轻度的非线性，因此$ $在选取值附近才会足够小。</p><h3 id="levenberg-marquardt-算法-1">Levenberg-Marquardt 算法</h3><p>莱文贝格－马夸特方法（Levenberg–Marquardt algorithm）能提供数非线性最小化（局部最小）的数值解。、 和其他最小化算法一样，LM 算法也是采用迭代过程，首先也是要提供一个参数<span class="math inline">\(\beta\)</span>的猜测值，在只有一个最小值的情况下初始猜测参数为<span class="math inline">\({\boldsymbol {\beta }}^{\text{T}}={\begin{pmatrix}1,\ 1,\ \dots ,\ 1\end{pmatrix}}\)</span>也可以很好的工作，在有多个极小值的情况下仅当猜测值以及接近最终解时，算法才会收敛到全局最小值。在每一步迭代中参数向量<span class="math inline">\(\beta\)</span>用新的评估值<span class="math inline">\(\beta + \delta\)</span>替代之前的值，为了确定<span class="math inline">\(\delta\)</span>函数<span class="math inline">\({\displaystyle f\left(x_{i},{\boldsymbol {\beta }}+{\boldsymbol {\delta }}\right)}\)</span>需要近似线性化。</p><p><span class="math display">\[f\left(x_{i},{\boldsymbol {\beta }}+{\boldsymbol {\delta }}\right)\approx f\left(x_{i},{\boldsymbol {\beta }}\right)+\mathbf {J} _{i}{\boldsymbol {\delta }}\]</span></p><p>其中：</p><p><span class="math display">\[\mathbf {J} _{i}={\frac {\partial f\left(x_{i},{\boldsymbol {\beta }}\right)}{\partial {\boldsymbol {\beta }}}}\]</span></p><p>是函数<span class="math inline">\(f\)</span>对参数<span class="math inline">\(\beta\)</span>的梯度。 <span class="math inline">\(s(\beta)\)</span> 平方偏差之和在 <span class="math inline">\(f\)</span>对<span class="math inline">\(\beta\)</span> 的梯度为 0 时取最小值，上面是 <span class="math inline">\(f\left(x_{i},{\boldsymbol {\beta }}+{\boldsymbol {\delta }}\right)\)</span> 的一阶近似，则：</p><p><span class="math display">\[S\left({\boldsymbol {\beta }}+{\boldsymbol {\delta }}\right)\approx \sum _{i=1}^{m}\left[y_{i}-f\left(x_{i},{\boldsymbol {\beta }}\right)-\mathbf {J} _{i}{\boldsymbol {\delta }}\right]^{2}\]</span></p><p>或者用向量符号表示：</p><p><span class="math display">\[{\begin{aligned}S\left({\boldsymbol {\beta }}+{\boldsymbol {\delta }}\right)&amp;\approx \left\|\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)-\mathbf {J} {\boldsymbol {\delta }}\right\|^{2}\\&amp;=\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)-\mathbf {J} {\boldsymbol {\delta }}\right]^{\mathrm {T} }\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)-\mathbf {J} {\boldsymbol {\delta }}\right]\\&amp;=\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]^{\mathrm {T} }\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]-\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]^{\mathrm {T} }\mathbf {J} {\boldsymbol {\delta }}-\left(\mathbf {J} {\boldsymbol {\delta }}\right)^{\mathrm {T} }\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]+{\boldsymbol {\delta }}^{\mathrm {T} }\mathbf {J} ^{\mathrm {T} }\mathbf {J} {\boldsymbol {\delta }}\\&amp;=\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]^{\mathrm {T} }\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]-2\left[\mathbf {y} -\mathbf {f} \left({\boldsymbol {\beta }}\right)\right]^{\mathrm {T} }\mathbf {J} {\boldsymbol {\delta }}+{\boldsymbol {\delta }}^{\mathrm {T} }\mathbf {J} ^{\mathrm {T} }\mathbf {J} {\boldsymbol {\delta }}.\end{aligned}}\]</span></p><p>这里暂时先不做理论推导了，目前没找到好的推导方法，直接上结论吧，</p><p><span class="math display">\[(\mu \mathbf  {I}+(\mathbf  {J}^{T}\mathbf  {J})) \delta _{p}=\mathbf  {J}^{T}\epsilon_k\]</span></p><p>就是莱文贝格－马夸特方法。如此一来 <span class="math inline">\(\mu\)</span> 大的时候这种算法会接近最速下降法，小的时候会接近高斯-牛顿方法。为了确保每次 <span class="math inline">\(\mathbf {\epsilon }\)</span> 长度的减少，我们这么作：先采用一个小的 <span class="math inline">\(\mu\)</span> ，如果 <span class="math inline">\(\mathbf {\epsilon }\)</span> 长度变大就增加 <span class="math inline">\(\mu\)</span> 。这个算法当以下某些条件达到时结束迭代：</p><ul><li>如果发现 <span class="math inline">\({\mathbf {\epsilon }}\)</span> 长度变化小于特定的给定值就结束。</li><li>发现 <span class="math inline">\({\mathbf {\delta _{p}}}\)</span> 变化小于特定的给定值就结束。</li><li>到达了迭代的上限设定就结束。</li></ul><h1 id="参考文献">参考文献</h1><p>《A Robust and Easy to Implement Method for IMU Calibration without External Equipments》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robot </tag>
            
            <tag> IMU </tag>
            
            <tag> EIS </tag>
            
            <tag> Image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMU 姿态解算</title>
      <link href="/next/2020/Algorithm/imuAttitudeCalculation/"/>
      <url>/next/2020/Algorithm/imuAttitudeCalculation/</url>
      
        <content type="html"><![CDATA[<h1 id="imu-通过加速度计解算姿态角">IMU 通过加速度计解算姿态角</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/imuOrigin.png"></p><p>通过三角函数可以将加速度计三个轴的角速度解算为姿态角，其中 <span class="math inline">\(\alpha\)</span> , <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\gamma\)</span>（ <span class="math inline">\(\gamma\)</span> 是 z 轴与重力加速度之间的夹角）与三个轴之间的关系如上图所示：</p><p><span class="math display">\[\begin{aligned}&amp;\beta = arcsin(\frac{a_x}{g}) \\&amp;\gamma  = arcsin(\frac{a_y}{g})\end{aligned}\]</span></p><p>其中重力加速度 $ g $ 的取值使用三轴角速度的矢量和即：</p><p><span class="math display">\[g = \sqrt{a_x^{2} + a_y^{2} + a_z^{2}}\]</span></p><p>将 g 的值带入上式可以得到：</p><p><span class="math display">\[\begin{aligned}&amp;\beta = arctan(\frac{a_x}{\sqrt{a_y^{2} + a_z^{2}}}) \\&amp;\gamma  = arctan(\frac{a_y}{\sqrt{a_x^{2} + a_z^{2}}})\end{aligned}\]</span></p><p>其中 α 为俯仰角 pitch，β 为滚转角 roll，其中航向角 yaw 是没有办法通过加速度计来计算的。</p><span id="more"></span><h1 id="陀螺仪积分得到角度">陀螺仪积分得到角度</h1><p>陀螺仪积分最直接的就是将陀螺仪输出的角速度与时间相乘做累加实现对角速度的积分得到角度，数据精度较高但是漂移很严重。在积分算法上常用龙格库塔法计算积分。</p><h1 id="数据融合">数据融合</h1><h2 id="一阶互补滤波">一阶互补滤波</h2><h3 id="推导">推导</h3><p>角速度计和陀螺仪都可以解算得到姿态角，如下：</p><p><span class="math display">\[\begin{aligned}&amp;z_1 = x + u \\&amp;z_2 = x + v\end{aligned}\]</span></p><p>其中 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 分别是加速度通过三角函数计算得到的欧拉角和陀螺仪积分得到的欧拉角，<span class="math inline">\(x\)</span> 是真实欧拉角，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 分别是测量噪声符合高斯噪声其中 <span class="math inline">\(u\)</span> 为高频噪声 v 是低频噪声。<span class="math inline">\(x\)</span> 的估计值为：</p><p><span class="math display">\[\begin{aligned}&amp;\hat{x} = k_1 \times  z_1 + k_2 \times  z_2 \\&amp;k_1 + k_2 = 1\end{aligned}\]</span></p><p>将 k1、k2 用一阶滤波传递函数表示：</p><p><span class="math display">\[\begin{aligned}&amp;k_1(s) = \frac{1}{fs + 1} \\&amp;k_2(s) = \frac{fs}{fs + 1}\end{aligned}\]</span></p><p>其中 s 是拉普拉斯变换的 s 域即频域，<span class="math inline">\(\frac{1}{f}\)</span> 是截止频率。于是得到：</p><p><span class="math display">\[\hat{x}(s) = k_1(s)z_1(s) + k_2(s)z_2(s) = \frac{1}{fs+1}z_1(s) + \frac{fs}{fs+1}z_2(s)\]</span></p><p>根据拉普拉斯变换微分定理变换公式：</p><p><span class="math display">\[L[\frac{d^{n}f(t)}{dt^{n}}] = s^{n} F(s)\]</span></p><p>用拉普拉斯反变换回去得到：</p><p><span class="math display">\[f\dot{\hat{x}}(t) + \hat{x}(t) = z_1(t) + f\dot{\hat{z_2}}(t)\]</span></p><p>离散化后得到：</p><p><span class="math display">\[f\frac{\hat{x}(k) - \hat{x}(k-1)}{dt} + \hat{x}_k = z_1(k) + f\frac{\hat{z_2}(k) - \hat{z_2}(k-1)}{dt}\]</span></p><p>化简整理后得：</p><p><span class="math display">\[\hat{x}(k) = \frac{f}{f+dt}[\hat{x}(k-1) + z_2(k) - z_2(k-1)] + \frac{dt}{f+dt}z_1(k)\]</span> 取 <span class="math display">\[K=\frac{dt}{f+dt}\]</span></p><p>得到：</p><p><span class="math display">\[\hat{x}(k) = (1-K)[\hat{x}(k-1) + z_2(k) - z_2(k-1)] + K z_1(k)\]</span></p><p>这就是一阶互补滤波的最终公式。</p><p>将上面推导出的公式写成代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief 一阶互补滤波器单轴</span><br><span class="line"> * @param acc_angle 通过三角函数计算加速度计的值得到的角度值</span><br><span class="line"> * @param gyro_rate 陀螺仪输出的角速度值</span><br><span class="line"> * @param K1 滤波器系数，远小于 1</span><br><span class="line"> * @<span class="built_in">return</span> 返回融合后角度值</span><br><span class="line"> */</span><br><span class="line">static void firstOrderComplementaryFiltering(<span class="built_in">float</span> acc_angle, <span class="built_in">float</span> gyro_rate, <span class="built_in">float</span>* angle)</span><br><span class="line">{</span><br><span class="line">  *angle = K * acc_angle + (1 - K) * (*angle + gyro_rate * dt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="调参">调参</h3><p>陀螺仪采样率是 1kHZ，dt 为 0.001 则算法涉及的参数只有一个就是 K 参数，假如取截止频率为 100 的话：</p><p><span class="math display">\[K = \frac{dt}{f + dt} = \frac{0.001}{\frac{1}{100} + 0.001} \doteq 0.1\]</span></p><h2 id="kalman-滤波">kalman 滤波</h2><h3 id="原理">原理</h3><p>卡尔曼滤波包括预测和更新两个过程，下面是两个过程的详细推导：</p><h4 id="预测过程">预测过程</h4><p>预测阶段主要是根据陀螺仪数据预测角度值，系统状态量是角度值和角速度偏差，而不是角度值和角速度值：</p><p><span class="math display">\[\begin{aligned}&amp;\hat{x}(k|k-1) = \hat{x}(k-1|k-1) + (\acute{\theta} - \acute{\theta }_b) \bigtriangleup t + w_\theta \\&amp;\acute{\theta }_b(k|k-1) = \acute{\theta }_b(k-1|k-1) + w_{\acute{\theta }_b}  \\&amp;w(k) = \begin{bmatrix}w_{\theta } &amp;w_{\acute{\theta}_b}\end{bmatrix}\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\acute{\theta}_b\)</span> 是角度偏差， <span class="math inline">\(\acute{\theta }\)</span> 是角速度， <span class="math inline">\(w(k)\)</span> 是预测过程噪声符合高斯噪声写成矩阵的形式：</p><p><span class="math display">\[\hat{x}(k|k-1) = F\hat{x}(k-1|k-1) + B\acute{\theta }(k) +W(K)  \tag{1} \\F = \begin{bmatrix}1 &amp; - \bigtriangleup t\\  0&amp;1 \end{bmatrix} \\B=\begin{bmatrix}\bigtriangleup T \\ 0\end{bmatrix}\]</span></p><p>将矩阵写成展开形式：</p><p><span class="math display">\[\begin{bmatrix}\theta_k\\ \acute{\theta }_b\end{bmatrix} = \begin{bmatrix}1 &amp; -\bigtriangleup t\\  0&amp;1 \end{bmatrix}\begin{bmatrix}\theta_{k-1}\\ \acute{\theta }_{k-1}\end{bmatrix} + \begin{bmatrix}\bigtriangleup t\\ 0\end{bmatrix}\acute{\theta }_k + w_k\]</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * kalman 公式一、角度的先验状态估计 x(k|k-1) = F * x(k-1|k-1) + B* u</span><br><span class="line"> * x 为角度和角速度的列向量 F=（[1,-dt],</span><br><span class="line"> *                           [0, 1]）</span><br><span class="line"> */</span><br><span class="line"> gyro_rate-=q_bias;</span><br><span class="line"> *angle+=gyro_rate * dt;</span><br></pre></td></tr></tbody></table></figure><p>协方差矩阵的更新如下： 协方差矩阵为向量$ \begin{bmatrix}_k\ _b\end{bmatrix}$的协方差矩阵，该协方差矩阵会随着系统变换而变换，其原理是一个矩阵作用到向量后的矩阵协方差求法，如下：</p><p><span class="math display">\[\begin{aligned}&amp;Cov(x) = \Sigma \\&amp;cov(Ax) = A\Sigma A^{T} \\cov(Ax)&amp; = E[(Ax - E[Ax])(Ax - E[Ax])^{T}] \\        &amp;= E[Ax -AE[x](Ax - AE[x])^{T}]  \\        &amp;= E(A(x-E[x])(x-E[x])^{T}A^{T}) \\        &amp;= AE[(X-E[x])(X-E[x])^{T}]A^{T} \\        &amp;= A\Sigma A^{T}\end{aligned}\]</span></p><p>故协方差方程为：</p><p><span class="math display">\[P_{expect}(K|K-1) = FP(K-1|K-1)F^{T} + Q_k  \tag{2}\]</span></p><p>这个方程表达的是新的协方差由上一次的协方差通过矩阵变换而来且再加上外部干扰，而协方差矩阵表征的是一个误差范围也就是不确定性，每次的不确定性由上一次的不确定性通过矩阵变换加上新的不确定性而来。将矩阵写为展开形式并化简得到：</p><p><span class="math display">\[\begin{aligned}\begin{bmatrix}P_{00} &amp;P_{01} \\ P_{10}&amp; P_{11}\end{bmatrix}_{k|k-1} &amp;= \begin{bmatrix}1 &amp; -\bigtriangleup t\\  0&amp;1 \end{bmatrix}\begin{bmatrix}P_{00} &amp;P_{01} \\ P_{10}&amp; P_{11}\end{bmatrix}_{k-1|k-1}\begin{bmatrix}1 &amp; 0\\  -\bigtriangleup t&amp;1 \end{bmatrix} + \begin{bmatrix}Q_\theta  &amp; 0\\ 0&amp;Q_{\acute{\theta }} \end{bmatrix}\bigtriangleup t \\  &amp;=\begin{bmatrix}P_{00}-\bigtriangleup tP_{10} &amp;P_{01}-\bigtriangleup tP_{11} \\ P_{10}&amp;P_{11} \end{bmatrix}_{k-1|k-1}\begin{bmatrix}1 &amp; \\ 0-\bigtriangleup t &amp; 1\end{bmatrix} + \begin{bmatrix}Q_\theta  &amp; 0\\ 0&amp;Q_{\acute{\theta }} \end{bmatrix}\bigtriangleup t \\  &amp;=\begin{bmatrix}P_{00}-\bigtriangleup tP_{10}-\bigtriangleup t(P_{01}-\bigtriangleup tP_{11}) &amp;P_{01}-\bigtriangleup tP_{11} \\ P_{10}-\bigtriangleup tP_{11}&amp;P_{11} \end{bmatrix}_{k-1|k-1} + \begin{bmatrix}Q_\theta  &amp; 0\\ 0&amp;Q_{\acute{\theta }} \end{bmatrix}\bigtriangleup t \\  &amp;=\begin{bmatrix}P_{00}-\bigtriangleup tP_{10}-\bigtriangleup t(P_{01}-\bigtriangleup tP_{11}) +Q_\theta \bigtriangleup t&amp;P_{01}-\bigtriangleup tP_{11} \\ P_{10}-\bigtriangleup tP_{11}&amp;P_{11}+Q_{\acute{\theta }}\bigtriangleup t \end{bmatrix} \\  &amp;=\begin{bmatrix}P_{00}-\bigtriangleup t(\bigtriangleup tP_{11}-P_{10}-P_{01} +Q_\theta )&amp;P_{01}-\bigtriangleup tP_{11} \\ P_{10}-\bigtriangleup tP_{11}&amp;P_{11}+Q_{\acute{\theta }}\bigtriangleup t \end{bmatrix}\end{aligned}\]</span></p><p><span class="math inline">\(Q_k\)</span> 是过程噪声协方差矩阵，由于加速度计的误差与陀螺仪之间的误差是相互独立的，不存在相关性（实际使用的时候角度值每次都是使用上次的最优值因此两者实际是有一定的相关性的），因此该矩阵是一个对称矩阵。其中陀螺仪的误差为累积误差，与时间<span class="math inline">\(\bigtriangleup t\)</span>有关，其表达式如下：</p><p><span class="math display">\[Q_k = \begin{bmatrix}Q_\theta &amp; 0\\ 0&amp; Q_{\acute{\theta }_b}\end{bmatrix}\bigtriangleup t \\\]</span></p><p>其中 <span class="math inline">\(Q_{\acute{\theta }_b}\)</span> 表征了陀螺仪的漂移误差， <span class="math inline">\(Q_\theta\)</span> 表征了姿态角的误差。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * kalman 公式二、预测协方差矩阵 P(k|k-1) = F * P(k-1|k-1) * F<span class="string">' + Q(k)</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"> P[0][0] += (Q_angle - P[0][1] - P[1][0] + P[1][1] * dt) * dt;</span></span><br><span class="line"><span class="string"> P[0][1] += (-P[1][1]) * dt;</span></span><br><span class="line"><span class="string"> P[1][0] += (-P[1][1]) * dt;</span></span><br><span class="line"><span class="string"> P[1][1] += Q_gyro * dt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="更新过程">更新过程</h4><p>观测值 <span class="math inline">\(z_k\)</span> 为：</p><p><span class="math display">\[z_k = H * x_k + v_k\]</span></p><p>这里 <span class="math inline">\(z_k\)</span> 为观测值，是通过加速度计解算的姿态角，<span class="math inline">\(H\)</span> 为观测矩阵这里只能获取角度值，不能直接获取角度偏差值因此 <span class="math inline">\(H=[\begin{bmatrix}1 &amp;0 \end{bmatrix}]\)</span>（当然如果你将原始的加速度计值输入到 kalman 方程里，这里的 <span class="math inline">\(H\)</span> 就是由加速度值到姿态角的变换矩阵，这里提前将加速度解算为姿态角后输入到 kalman 方程），<span class="math inline">\(v_k\)</span> 为测量噪声符合高斯分布。</p><p><span class="math display">\[z_k \sim N(0,R)\]</span></p><p>本系统中测量值只有一个角速度值，因此<span class="math inline">\(R\)</span>可以用一个方差来表示。而加速度计解算姿态角是与时间无关的，该误差不会被累加到系统因此 <span class="math inline">\(v_k = v\)</span> , 这个值设置的比较大代表测量噪声比较大，则系统相信预测值大一些，如果这个值设置的比较小代表测量噪声很小，相信测量值大一些在本系统中加速度计解算的姿态角代表测量值也就是相信加速度值大一些。 观测量与预测量一样有一个对不确定性的更新，就是预测过程的协方差，测量过程的协方差基于上一次的协方差来计算，如下：</p><p><span class="math display">\[P_{measure}(k|k) = H*P(k|k-1)H^{T} + R\]</span></p><p>将其写成矩阵展开形式并化简得到如下：</p><p><span class="math display">\[P_{measure}(k|k) =\begin{bmatrix}1 &amp;0 \end{bmatrix} * \begin{bmatrix}P_{00} &amp;P_{01} \\ P_{10} &amp;P_{11} \end{bmatrix}_{k|k-1} *\begin{bmatrix}1\\ 0\end{bmatrix} + R = P_{00 k|k-1} +R\]</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 中间变量 E = H * P(k|k-1) H<span class="string">' + R</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string"> PCt_0 = C_0 * P[0][0];</span></span><br><span class="line"><span class="string"> PCt_1 = C_0 * P[1][0];</span></span><br><span class="line"><span class="string"> E = R_angle + C_0 * PCt_0;</span></span><br></pre></td></tr></tbody></table></figure><p>测量过程的协方差结果就是一个数值（看到这应该很庆幸不用对矩阵进行求逆，这个参数其实就是卡尔曼增益里面求逆矩阵那一项），其实就是方差值。到这里有两个协方差，一个是预测过程的协方差另一个是测量过程的协方差，两个协方差代表了两个数据源的噪声，哪个值大代表哪个过程的噪声越大，对其信任度就会降低。 下面终于到了卡尔曼增益的计算，先看下卡尔曼增益张什么样子吧：</p><p><span class="math display">\[K = H_k*P_k*H^{T}_k (H_k*P_k*H^{T}_k + R)^{-1}\]</span></p><p>这个公式看起来非常不友好，其实卡尔曼系数是将上面通过预测和测量得到的两个高斯方程相乘而得到的。具体可以参考以下链接，其中之一是中文翻译版： 英文原版链接 <span class="exturl" data-url="aHR0cDovL3d3dy5iemFyZy5jb20vcC9ob3ctYS1rYWxtYW4tZmlsdGVyLXdvcmtzLWluLXBpY3R1cmVzLw==">How a Kalman filter works, in pictures<i class="fa fa-external-link-alt"></i></span> 中文翻译版：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MjA2NjEvYXJ0aWNsZS9kZXRhaWxzLzYzMjUzNTA5">详解卡尔曼滤波原理<i class="fa fa-external-link-alt"></i></span> 为了这里公式的完整性，还是决定把与之相关的内容搬过来吧，如下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/kalman.png"></p><p>这张图是原作者的图但是有些不准确，蓝色的融合后的曲线应该是更高的曲线才对。将红色和绿色两个高斯方程相乘可以得到蓝色曲线代表的高斯方程，这就是估计的最优值。先看一维数据下的高斯方程相乘的结果如下：</p><p><span class="math display">\[\begin{aligned}&amp;{\mu }' = \mu_0 + \frac{\sigma_0 ^{2} (\mu_1 - \mu_0)}{\sigma_0 ^{2} + \sigma_1 ^{2}} \\&amp;{\sigma}'^{2} = \sigma_0^{2} - \frac{\sigma_0^{4}}{\sigma_0 ^{2} + \sigma_1 ^{2}}\end{aligned}\]</span></p><p>取</p><p><span class="math display">\[k = \frac{\sigma_0^{2}}{\sigma_0 ^{2} + \sigma_1 ^{2}}\]</span></p><p>得到：</p><p><span class="math display">\[\begin{aligned}&amp;{\mu }' = \mu_0 + k(\mu_1 - \mu_0) \\&amp;{\sigma}'^{2} = \sigma_0 ^{2} - k \sigma_0 ^{2}\end{aligned}\]</span></p><p>用 <span class="math inline">\(\Sigma\)</span> 表示协方差，写成矩阵的形式如下：</p><p><span class="math display">\[\begin{aligned}&amp;K = \Sigma_0 (\Sigma_0 + \Sigma_1)^{-1} \\&amp;\vec{\mu'} = \vec{\mu_0} + K (\vec{\mu_1} - \vec{\mu_0}) \\&amp;{\Sigma}' = \Sigma_0 - K \Sigma_0\end{aligned}\]</span></p><p>将我们前面推导的预测和测量带入到上面的公式就得到下面卡尔曼滤波的后三个公式如下：</p><p><span class="math display">\[\begin{aligned}&amp;K = H_k * P_k * H^{T}_k (H_k * P_k * H^{T}_k + R)^{-1} \\&amp;H_k * \hat{x}_{k|k} = H_k * \hat{x}_{k|k-1} + K (z_k -  H_k * \hat{x}_{k|k-1}) \\&amp;H_k * {P}'_{k|k} * H^{T}_k = H_k * P_{k|k} * H^{T}_k - K * (H_k * P_{k|k} * H^{T}_k)\end{aligned}\]</span></p><p>将这三个方程联系起来做运算得到如下更新方程：</p><p><span class="math display">\[K_k = P_{k|k-1}  * H^T * P^{-1}_{measure}(k|k)  \tag{3}\]</span></p><p>将其写为矩阵展开形式并化简得到：</p><p><span class="math display">\[\begin{aligned}\begin{bmatrix}K_0\\ K_1\end{bmatrix}_k &amp;= \begin{bmatrix}P_{00} &amp;P_{01} \\ P_{10}&amp;P_{11} \end{bmatrix}_{k|k-1} * \begin{bmatrix}1\\ 0\end{bmatrix} * P^{-1}_{measure}(k|k) \\&amp;=\begin{bmatrix}P_{00}\\ P_{10}\end{bmatrix}_{k|k-1} * P^{-1}_{measure}(k|k)\end{aligned}\]</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * kalman 公式三、K = P(k|k-1) * H<span class="string">' / (H * P(k|k-1) H'</span> + R)</span><br><span class="line"> */</span><br><span class="line"> K_0 = PCt_0 / E;</span><br><span class="line"> K_1 = PCt_1 / E;</span><br></pre></td></tr></tbody></table></figure><p>协方差的更新：</p><p><span class="math display">\[P_{k|k} = (I - K_k* H_k)P_{k|k-1} \tag{4}\]</span></p><p>将矩阵写为展开形式并化简得到如下：</p><p><span class="math display">\[\begin{aligned}\begin{bmatrix}P_{00} &amp; P_{01} \\ P_{10} &amp; P_{11}\end{bmatrix}_k &amp;= (\begin{bmatrix}1 &amp; 0\\ 0 &amp; 1\end{bmatrix} -\begin{bmatrix}K_0\\ K_1\end{bmatrix}_k * \begin{bmatrix}1 &amp; 0 \end{bmatrix}) * \begin{bmatrix}P_{00} &amp; P_{01} \\ P_{10} &amp; P_{11}\end{bmatrix}_{k-1} \\&amp;=(\begin{bmatrix}1 &amp; 0\\ 0 &amp; 1\end{bmatrix} -\begin{bmatrix}K_0 &amp;0 \\ K_1 &amp;0 \end{bmatrix}_k) * \begin{bmatrix}P_{00} &amp; P_{01} \\ P_{10} &amp; P_{11}\end{bmatrix}_{k-1} \\&amp;=\begin{bmatrix}P_{00} &amp; P_{01} \\ P_{10} &amp; P_{11}\end{bmatrix}_{k-1} - \begin{bmatrix}K_0P_{00} &amp;K_0P_{01} \\ K_1P_{00} &amp;K_1P_{01} \end{bmatrix}\end{aligned}\]</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * kalman 公式四、P(k|k) = (I - K * H) * P(k|k-1)</span><br><span class="line"> */</span><br><span class="line"> t_0 = PCt_0;</span><br><span class="line"> t_1 = C_0 * P[0][1];</span><br><span class="line"> P[0][0] -= K_0 * t_0;</span><br><span class="line"> P[0][1] -= K_0 * t_1;</span><br><span class="line"> P[1][0] -= K_1 * t_0;</span><br><span class="line"> P[1][1] -= K_1 * t_1;</span><br></pre></td></tr></tbody></table></figure><p>下面是最优估计值</p><p><span class="math display">\[\hat{x}_{k|k} = \hat{x}_{k|k-1} + K * (z_k  -  H_k * \hat{x}_{k|k-1})   \tag{5}\]</span></p><p>写成矩阵的展开形式并化简如下：</p><p><span class="math display">\[\begin{bmatrix}\theta \\ \acute{\theta_b}\end{bmatrix}_{k|k} = \begin{bmatrix}\theta \\ \acute{\theta_b}\end{bmatrix}_{k|k-1} + \begin{bmatrix}K_0\\ K_1\end{bmatrix}_k * (z_k - \theta_{k|k-1})\]</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 中间变量 角度残差 z(k) - H * x(k)</span><br><span class="line"> * H = ([1,0])</span><br><span class="line"> */</span><br><span class="line"> angle_err = acc_angle - *angle;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * kalman 公式五、x(k|k) = x(k|k-1) + K * (z(k) - H * x(k))</span><br><span class="line"> */</span><br><span class="line"> *angle += K_0 * angle_err;</span><br><span class="line"> q_bias += K_1 * angle_err;</span><br></pre></td></tr></tbody></table></figure><p>以上就是卡尔曼滤波的预测和更新过程。但是我们前面在说卡尔曼系数的时候是将两个卡尔曼方程相乘得到了最优解，这里有个问题就是这种方式得到的值是不是合理，或者说卡尔曼滤波是不是无偏估计的，这里贴出网上的一个推导，自行查看。<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzMTU2ODMyOC9hbnN3ZXIvNzM1Mjg3NTU2">https://www.zhihu.com/question/331568328/answer/735287556<i class="fa fa-external-link-alt"></i></span></p><h3 id="调参-1">调参</h3><p>卡尔曼系数<span class="math inline">\(K\)</span>表征了对预测量和测量量的信任程度，如下式：</p><p><span class="math display">\[\hat{x}_{k|k} = \hat{x}_{k|k-1} + K * (z_k  -  H_k * \hat{x}_{k|k-1})\]</span></p><p>这个式子中 <span class="math inline">\(H_k\)</span> 只是选取了角度信息去掉了加速度值，暂时可以忽略掉不看，当 <span class="math inline">\(K\)</span> 为 <span class="math inline">\(0\)</span> 时，最优值完全取预测值即完全相信预测值是真实值不相信测量值，当<span class="math inline">\(K\)</span>取 1 时最优值取<span class="math inline">\(z_k\)</span>测量值，则完全相信测量值而不相信预测值。<span class="math inline">\(K\)</span>越大则越相信测量值，<span class="math inline">\(K\)</span>越小越相信预测值。<span class="math inline">\(K\)</span>的值动态调整预测和测量之间的比例因子。对于我们的系统中一开始相信陀螺仪数据多一些，随着时间不短累积则相信加速度计数据逐渐增多，最后会收敛到一个固定的值。 接下来是系统里的几个关键参数 <span class="math inline">\(Q\)</span> 和 <span class="math inline">\(R\)</span>，这里详细看下具体每个参数该怎么选取： 参数 <span class="math inline">\(Q\)</span> 的角度误差的方差 <span class="math inline">\(Q_{\theta }\)</span> ，该参数是预测角度的噪声，预测主要是基于上一次的最优值对陀螺仪数据进行积分得到预测值，该值代表了陀螺仪的整体误差，调试参数的时候该值一般设的比较小，对陀螺仪的信任度比较大。 角速度误差 <span class="math inline">\(Q_{\acute{\theta }}\)</span> 就是陀螺仪的漂移方差，这个值反应的是陀螺仪漂移的方差，即在每次的漂移量都是符合高斯噪声的，但是这个值跟环境温度等相关，在不同温度下漂移值是不同的可以对温度漂移进行多次测量修正，还有跟陀螺仪的运动状态有关，例如在一个系统中陀螺仪固定像一个方向旋转，则可以在陀螺仪以固定角速度旋转下测量该漂移。整体 Q 代表的是预测噪声。 测量噪声 <span class="math inline">\(R\)</span> 是代表了实际数据与测量值之间的误差，传感器不能 100%获取到实际物理量数据测量一定是有误差的，该值可以通过 IMU 的 datasheet 获取相关参数。例如 icm20602 的加速度误差为 <span class="math inline">\(100ug/\sqrt{hz}\)</span> 则对于 1kz 的采样率则为 <span class="math inline">\(100ug * \sqrt{1000}\)</span> , 但是这个值不能直接作为加速度计的观测噪声，还要看具体场景，加速度计的平移运动会产生加速度值，而这个值对计算角度来讲就是噪声，所以对于本系统 <span class="math inline">\(R\)</span> 不仅仅是传感器本身误差，同时还包括 IMU 的平移运动产生的误差。在一个非常平稳的系统中加速度计的各轴平移加速度非常小，甚至可以忽略，此时加速度计的噪声是非常小的可以近似等于传感器测量噪声，相反在一个震动频率很高的场景下，加速度计的平移加速度就非常大，这个时候<span class="math inline">\(R\)</span>的取值就应该比传感器的本身误差大很多。手册上的误差值代表了最理想情况下的误差，实际系统中应该根据具体情况去调整这个值。 整体调试过程中，<span class="math inline">\(R\)</span>值的选取跟收敛速度相关，该值取的很小则收敛速度越快，因为长期来看滤波的值是像加速度计的值进行收敛的，对加速度的信任度越高则收敛越快反之则收敛越慢，但是对加速度计的信任度越高就会导致滤波效果不好有毛刺，<span class="math inline">\(Q\)</span>和<span class="math inline">\(R\)</span>的值共同决定了滤波效果。在实际的调参过程中将加速度计的曲线和滤波的曲线同时输出，对比两条曲线的关系就可以看到滤波的平滑程度以及收敛速度了。具体效果可以以缓慢旋转 IMU，快速旋转 IMU，不做旋转而左右晃动 IMU 来看滤波后的值是否是我们期望的。</p><h2 id="mahony-滤波">mahony 滤波</h2><h3 id="陀螺仪模型">陀螺仪模型</h3><p><span class="math display">\[\omega = \hat{\omega} + b_g + n_g\]</span></p><p>这里， <span class="math inline">\(\omega\)</span> 是陀螺仪测得的角速度， <span class="math inline">\(\hat{\omega}\)</span> 是我们希望恢复的潜在理想角速度， <span class="math inline">\(b_g\)</span> 陀螺仪偏差会随时间和温度等其他因素而变化， <span class="math inline">\(n_g\)</span>是陀螺仪高斯白噪声。</p><h3 id="加速度计模型">加速度计模型</h3><p><span class="math display">\[a = R^{T}(\hat{a} - g) + b_a + n_a\]</span></p><p>这里<span class="math inline">\(a\)</span>是加速度测量值，<span class="math inline">\(\hat{a}\)</span> 是加速度真实值，<span class="math inline">\(R\)</span>是传感器在世界坐标系下的转换矩阵，<span class="math inline">\(g\)</span> 是重力加速度， <span class="math inline">\(b_a\)</span> 是随时间和温度等其他因素而变化的 acc 偏差， <span class="math inline">\(n_a\)</span> 是白色高斯 acc 噪声。</p><h3 id="mahony-算法流程">Mahony 算法流程</h3><p>在开始讨论 mahony 滤波器公式之前，让我们正式定义将要使用的坐标轴。让 <span class="math inline">\(I,W,B\)</span> 分别表示惯性，世界和机体坐标系。通常 <span class="math inline">\(B\)</span> 和 <span class="math inline">\(I\)</span> 是相同的。下标表示源坐标系，上标表示目的坐标系。下图是 mahony 滤波器的主要流程： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/mahony.png"></p><h4 id="步骤一获取传感器值">步骤一：获取传感器值</h4><p>从传感器获取陀螺仪和 acc 测量值。让 <span class="math inline">\(I_{w_t}\)</span> 和 <span class="math inline">\(I_{a_t}\)</span> 分别表示陀螺仪和 acc 测量值。<span class="math inline">\(I_{\hat{a}_t}\)</span> 表示标准化的 acc 测量。 代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recipNorm = invSqrt(ax * ax + ay * ay + az * az);</span><br><span class="line">ax *= recipNorm;</span><br><span class="line">ay *= recipNorm;</span><br><span class="line">az *= recipNorm;</span><br></pre></td></tr></tbody></table></figure><h4 id="步骤二使用-acc-测量计算误差">步骤二：使用 acc 测量计算误差</h4><p>根据先验估计值利用 acc 计算误差：</p><p><span class="math display">\[\begin{aligned}&amp;v(\hat{_{I}^{W}\textrm{}q_{est}},t) = \begin{bmatrix}2(q_2q_4-q_1q_3)\\ 2(q_1q_2+q_3q_4)\\ (q_1^{2} - q_2^{2} - q_3^{2} + q_4^{2})\end{bmatrix} \\&amp;e_{t+1} = I_{\hat{a_{t+1}}} \times v(\hat{_{I}^{W}\textrm{}q_{est}},t) \\&amp;e_{i,t+1} = e_{i,t} + e_{t+1}\Delta t\end{aligned}\]</span></p><p><span class="math inline">\(\Delta t\)</span> 是采样间隔，即 t 到 t+1 的时间间隔。看到这里是不是一头雾水，当时我看到这里是完全没搞懂这是什么啊，没关系，还有望不到尽头的路子要走呢，继续 先放下前面那一堆乱七八糟的东西，看点简单的东西，about 复数和四元数 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Image/imuCal.png"></p><p>如果有一个复数 <span class="math inline">\(z = a + bi\)</span>，那么 <span class="math inline">\(z\)</span> 与任意一个复数 <span class="math inline">\(c\)</span> 相乘都会将 <span class="math inline">\(c\)</span> 逆时针旋转 <span class="math inline">\(θ = atan2(b, a)\)</span> 度，并将其缩放 <span class="math inline">\(|z| = \sqrt{a^{2} + b^{2}}\)</span> 倍．如果 <span class="math inline">\(|z| =1\)</span> 那么久完全变成旋转了，<span class="math inline">\(z\)</span>也就变成了旋转矩阵如下：</p><p><span class="math display">\[z = \begin{bmatrix}cos(\theta ) &amp;-sin(\theta) \\ sin(\theta)&amp; cos(\theta)\end{bmatrix}\]</span></p><p>则对应的旋转公式（矩阵型）如下：</p><p><span class="math display">\[{v}' = \begin{bmatrix}cos(\theta ) &amp;-sin(\theta) \\ sin(\theta)&amp; cos(\theta)\end{bmatrix} v\]</span></p><p>其中 z 可以用复数形式来表示即<span class="math inline">\(z = x + yi\)</span>构造一个<span class="math inline">\(z = cos(\theta) + sin(\theta)i\)</span>复数，则旋转可以表示为</p><p><span class="math display">\[{v}' = zv = (cos(\theta) + i sin(\theta))v\]</span></p><p>这是二维的情况，推广到 3D 空间中任意一个 <span class="math inline">\(v\)</span> 沿着单位向量 <span class="math inline">\(u\)</span> 旋转 <span class="math inline">\(θ\)</span> 角度之后的 v′ 为：</p><p><span class="math display">\[v′ = cos(θ)v + (1 − cos(θ))(u · v)u + sin(θ)(u × v)\]</span></p><p>接着给出四元数旋转公式任意向量 <span class="math inline">\(v\)</span> 沿着以单位向量定义的旋转轴 <span class="math inline">\(u\)</span> 旋转 <span class="math inline">\(θ\)</span> 度之后的 <span class="math inline">\(v′\)</span> 可以使用四元数 乘法来获得．令 <span class="math inline">\(v = [0, v]，q = \begin{bmatrix}cos(\frac{1}{2}\theta ), sin(\frac{1}{2}\theta )u \end{bmatrix}\)</span>，那么：</p><p><span class="math display">\[{v}' = qvq^{*} = qvq^{-1}\]</span></p><p>换句话说，如果我们有 <span class="math inline">\(q = [cos(θ), sin(θ)u]\)</span>，那么 <span class="math inline">\(v′ = qvq^{*}\)</span> 可以将 <span class="math inline">\(v\)</span> 沿着 <span class="math inline">\(u\)</span> 旋 转 <span class="math inline">\(2θ\)</span> 度。写为矩阵形式如下： 任意向量 <span class="math inline">\(v\)</span> 沿着以单位向量定义的旋转轴 <span class="math inline">\(u\)</span> 旋转 <span class="math inline">\(θ\)</span> 角度之后的 <span class="math inline">\(v′\)</span> 可以使用矩阵 乘法来获得．令 <span class="math inline">\(a =cos(\frac{1}{2}\theta ), b = sin(\frac{1}{2}\theta )u_x, c = sin(\frac{1}{2}\theta )u_y, d = sin(\frac{1}{2}\theta )u_z\)</span> 那么：</p><p><span class="math display">\[{v}' = \begin{bmatrix}1-2c^2-2d^2 &amp; 2bc - 2ad &amp; 2ac+2bd \\ 2bc+2ad &amp; 1-2b^2-2d^2  &amp;2cd - 2ab \\ 2bd-2ac &amp; 2ad+2cd  &amp; 1-2b^2-2c^2 \end{bmatrix}v\]</span></p><p>其中这里的四元数是归一化四元数即<span class="math inline">\(1 = q_1^2 + q_2^2 + q_3^2 + q_4^2\)</span>并用更通用的符号来表示则上面式子可以写为如下：</p><p><span class="math display">\[v = \begin{bmatrix}q_1^2 + q_2^2 -q_3^2 -q_4^2 &amp;2(q_2q_3 - q_1q_4)  &amp;2(q_2q_4 + q_1q_3) \\ 2(q_2q_3 + q_1q_4) &amp; q_1^2 - q_2^2 + q_3^2 -q_4^2  &amp; 2(q_3q_4 - q_1q_2) \\ 2(q_2q_4 - q_1q_3)&amp; 2(q_3q_4 + q_1q_2)  &amp; q_1^2 - q_2^2 -q_3^2 +q_4^2 \end{bmatrix}v\]</span></p><p>这里其实是省略了相关推导，其中的详细推导过程我会在下面给出链接，这里我们直接使用这些已知的结论，不然东西太多，看着太累（其实是写起来太累）。到这里其实只是列出了四元数的旋转公式，好回到前面第二步中我们那个公式是怎么来的呢，下面看机体坐标系下的重力表示，将机体坐标系的三轴分量通过旋转矩阵的旋转后就是地理坐标系下的重力分量表示。而我们这里的旋转矩阵是正交矩阵即 <span class="math inline">\(M*M^T = I\)</span>则有<span class="math inline">\(g = M*\hat{g}\)</span> 则 <span class="math inline">\(\hat{g} = M^T * g\)</span> 展开了写就是如下形式</p><p><span class="math display">\[\begin{aligned}\hat{g} &amp;= \begin{bmatrix}q_1^2 + q_2^2 -q_3^2 -q_4^2 &amp;2(q_2q_3 - q_1q_4)  &amp;2(q_2q_4 + q_1q_3) \\ 2(q_2q_3 + q_1q_4) &amp; q_1^2 - q_2^2 + q_3^2 -q_4^2  &amp; 2(q_3q_4 - q_1q_2) \\ 2(q_2q_4 - q_1q_3)&amp;2(q_3q_4 + q_1q_2)  &amp; q_1^2 - q_2^2 -q_3^2 +q_4^2 \end{bmatrix}' * \begin{bmatrix}0\\ 0\\ 1\end{bmatrix} \\&amp;=\begin{bmatrix}2(q_2q_4 - q_1q_3)\\  2(q_3q_4 + q_1q_2)\\ q_1^2 - q_2^2 -q_3^2 +q_4^2\end{bmatrix}\end{aligned}\]</span></p><p>这就是上面我们第二步中的公式，在自然坐标系下的机体三轴表示。写成代码就是如下： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Estimated direction of gravity and vector perpendicular to magnetic flux</span><br><span class="line">halfvx = imu-&gt;q1 * imu-&gt;q3 - imu-&gt;q0 * imu-&gt;q2;</span><br><span class="line">halfvy = imu-&gt;q0 * imu-&gt;q1 + imu-&gt;q2 * imu-&gt;q3;</span><br><span class="line">//halfvz = imu-&gt;q0 * imu-&gt;q0 - 0.5f + imu-&gt;q3 * imu-&gt;q3;</span><br><span class="line">halfvz = imu-&gt;q0 * imu-&gt;q0 - imu-&gt;q1 * imu-&gt;q1 - imu-&gt;q2 * imu-&gt;q2 + imu-&gt;q3 * imu-&gt;q3;</span><br></pre></td></tr></tbody></table></figure> 这第二步还没完，后面还两个公式呢，先看第一个公式<p></p><p><span class="math display">\[e_{t+1} = I_{\hat{a_{t+1}}} \times v(\hat{_{I}^{W}\textrm{}q_{est}},t)\]</span></p><p>这一步将加速度计获取的数据与陀螺仪准确来讲是预测值进行叉乘，来表示陀螺仪与加速度计的误差，这里为什么可以通过叉乘得到误差呢，其实是存疑的，向量的叉乘结果跟两个向量的夹角和模长相关，这里 acc 与 gyro 的数据如果是相同的那么他们之间的夹角为 0 则 <span class="math inline">\(sin(\theta) = 0\)</span> 两个向量的叉积为 0 向量，而 acc 和 gyro 不同则两个向量不同但是笔者认为两者不能视为线性关系，叉乘的大小可以用来表示 acc 与 gyro 的误差大小，而这个计算恰好用于 pi 调节器来调节 gyro 的数据。到现在误差也出来了两个向量的叉乘，取 <span class="math inline">\(z_1 = a + bi z_2 = c + di\)</span> 则两个向量叉乘结果为：</p><p><span class="math display">\[\begin{aligned}z_1\times z_2 &amp;= \begin{bmatrix}a &amp;-b \\ b &amp; a\end{bmatrix}  \times \begin{bmatrix}c &amp;-d \\ d &amp; c\end{bmatrix} \\&amp;= \begin{bmatrix}ac-bd &amp;-(bc + ad) \\ bc + ad &amp; ac-bd\end{bmatrix}\end{aligned}\]</span></p><p>写为代码就是下面： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Error is <span class="built_in">sum</span> of cross product between estimated and measured direction of gravity</span><br><span class="line">halfex = (ay * halfvz - az * halfvy);</span><br><span class="line">halfey = (az * halfvx - ax * halfvz);</span><br><span class="line">halfez = (ax * halfvy - ay * halfvx);</span><br></pre></td></tr></tbody></table></figure> 第三个公式就比较简单了对误差进行累计，这里代码跟下面第三步放到一起。第二步完。..<p></p><h4 id="步骤三对误差进行-pi-调节器调节">步骤三：对误差进行 PI 调节器调节</h4><p><span class="math display">\[I{w_{t+1}} = I{w_{t+1}} + K_p * e_{t+1} K_i * e_{i,t+1}\]</span></p><p>这个公式对于比较熟悉 pid 算法的人来讲应该是轻而易举的事了吧，关于 pid 调节这里也不是一两句话可以说的清楚的，后面专门再写一篇关于 pid 调节的文章吧，后续一定会用到的，这里先偷下懒，通俗点将这里就是对误差进行一个比例扩大或缩小即误差的积分累计运算，这个量会用于调节陀螺仪的数据，以纠正陀螺仪的累计误差让陀螺仪的数据最终收敛于加速度计数据。照例贴下代码如下： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Compute and apply integral feedback <span class="keyword">if</span> enabled</span><br><span class="line"><span class="keyword">if</span>(twoKi &gt; 0.0f) {</span><br><span class="line">imu-&gt;integralFBx += twoKi * halfex * (1.0f / sampleFreq);// integral error scaled by Ki</span><br><span class="line">        imu-&gt;integralFBy += twoKi * halfey * (1.0f / sampleFreq);</span><br><span class="line">imu-&gt;integralFBz += twoKi * halfez * (1.0f / sampleFreq);</span><br><span class="line">gx += imu-&gt;integralFBx;// apply integral feedback</span><br><span class="line">gy += imu-&gt;integralFBy;</span><br><span class="line">gz += imu-&gt;integralFBz;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">imu-&gt;integralFBx = 0.0f;// prevent integral windup</span><br><span class="line">imu-&gt;integralFBy = 0.0f;</span><br><span class="line">imu-&gt;integralFBz = 0.0f;</span><br><span class="line">}</span><br><span class="line">// Apply proportional feedback</span><br><span class="line">gx += twoKp * halfex;</span><br><span class="line">gy += twoKp * halfey;</span><br><span class="line">gz += twoKp * halfez;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="步骤四对陀螺仪数据进行积分">步骤四：对陀螺仪数据进行积分</h4><p>前面我们对姿态角的变化量加速度进行 pi 调节器的调节后（使其收敛于加速度计计算的重力向量）就可以进行积分了，其积分就涉及到微分方程的求解和运算，下面会给出推导步骤如下：</p><p>四元数微分方程 定义<span class="math inline">\(n\)</span>为自然坐标系，<span class="math inline">\(b\)</span>为机体坐标系，则<span class="math inline">\(n\)</span>系到<span class="math inline">\(b\)</span>系的旋转四元数为：</p><p><span class="math display">\[Q = cos( \frac{1}{2}\theta ) + sin(\frac{1}{2}\theta )u^n\]</span></p><p>其中<span class="math inline">\(u^n\)</span>为旋转轴，$$ 为旋转角。 将四元数 <span class="math inline">\(Q = cos(\frac{1}{2}\theta ) + sin(\frac{1}{2}\theta )u\)</span> 对时间进行微分则：</p><p><span class="math display">\[Q  = cos(\frac{1}{2}\theta ) + sin(\frac{1}{2}\theta )u^n \\\frac{dQ}{dt} = -\frac{1}{2}sin(\frac{1}{2}\theta )\cdot \frac{d\theta }{dt} + \frac{du^n}{dt}\cdot sin(\frac{1}{2}\theta ) + u^n \cdot \frac{1}{2}cos(\frac{1}{2}\theta )\cdot \frac{d\theta }{dt}\]</span></p><p>其中这是一个旋转四元数，其旋转轴是固定不变的，变化的是旋转角度，因此 <span class="math inline">\(\frac{du^n}{dt} = 0\)</span> 故有：</p><p><span class="math display">\[\frac{dQ}{dt} = -\frac{1}{2}sin(\frac{1}{2}\theta ) \cdot \frac{d\theta }{dt} + u^n \cdot \frac{1}{2}cos(\frac{1}{2}\theta )\cdot \frac{d\theta }{dt}\]</span></p><p>两边都乘以 <span class="math inline">\(\frac{1}{2} u^n \frac{d\theta }{dt}\)</span> 得：</p><p><span class="math display">\[\begin{aligned}\frac{1}{2} u^n \frac{d\theta }{dt} \otimes Q &amp;= \frac{1}{2} u^n \frac{d\theta }{dt} * (cos(\frac{\theta }{2}) + sin(\frac{\theta }{2}) u^n) \\&amp; = \frac{\dot{\theta }}{2}cos(\frac{\theta }{2})u^n + u^n \otimes  u^n \frac{\dot{\theta }}{2}sin(\frac{\theta }{2})r\end{aligned}\]</span></p><p>其中 $u^n u^n = -1 $ 得：</p><p><span class="math display">\[\begin{aligned}\frac{1}{2} u^n \frac{d\theta }{dt} \otimes Q =  \frac{\dot{\theta }}{2}cos(\frac{\theta }{2})u^n - \frac{\dot{\theta }}{2}sin(\frac{\theta }{2})r\end{aligned}\]</span></p><p>这个结果与上面推导的 <span class="math inline">\(\frac{dQ}{dt}\)</span> 是不是一样的，于是 <span class="math inline">\(\frac{dQ}{dt}\)</span> 可以写为如下：</p><p><span class="math display">\[\frac{dQ}{dt} = \frac{1}{2} u^n \frac{d\theta }{dt} \otimes Q = \frac{1}{2} w_{nb}^{n}\otimes Q\]</span></p><p>式中 <span class="math inline">\(w_{nb}^{n}\)</span> 是自然坐标系下角速度，而 IMU 获得的角速度是机体坐标系下的角速度，因此需要转换一下如下：</p><p><span class="math display">\[r^n = Q  \otimes r^b  \otimes Q^*\]</span></p><p>带入上式得：</p><p><span class="math display">\[\frac{dQ}{dt} = \frac{1}{2}  Q  \otimes w_{nb}^{b}  \otimes Q^* \otimes Q\]</span></p><p>对于单位四元数有：<span class="math inline">\(Q^* \otimes Q = 1\)</span> 则：</p><p><span class="math display">\[\frac{dQ}{dt} =  \frac{1}{2}  Q  \otimes w_{nb}^b\]</span></p><p>其中 <span class="math inline">\(w_{nb}^{b}\)</span> 为陀螺仪测量数据，如下：</p><p><span class="math display">\[w_{nb}^{b} = \begin{bmatrix}0\\ w_x\\ w_y\\ w_z\end{bmatrix}\]</span></p><p>由四元数乘法公式可以得到：</p><p><span class="math display">\[\begin{bmatrix}\dot{q_0}\\ \dot{q_1}\\ \dot{q_2}\\ \dot{q_3}\end{bmatrix} = \frac{1}{2}\begin{bmatrix}q_0 &amp; -q_1 &amp; -q_2 &amp; -q_3 \\q_1 &amp; q_0 &amp; -q_3 &amp; q_2 \\q_2 &amp; q_3 &amp; q_0 &amp; -q_1 \\q_3 &amp; -q_2 &amp; q_1 &amp; q_0\end{bmatrix} * \begin{bmatrix}{0}\\ w_x\\ {w_y}\\ {w_z}\end{bmatrix}\]</span></p><p>或者：</p><p><span class="math display">\[\begin{bmatrix}\dot{q_0}\\ \dot{q_1}\\ \dot{q_2}\\ \dot{q_3}\end{bmatrix} =  \frac{1}{2}\begin{bmatrix}0 &amp; -w_x &amp; -w_y&amp; -w_z \\w_x&amp; 0 &amp; w_z&amp; -w_y \\w_y&amp; -w_z&amp; 0 &amp; w_x \\w_z&amp; w_y&amp; -w_x&amp; 0\end{bmatrix} * \begin{bmatrix}{q_0}\\ q_1\\ {q_2}\\ {q_3}\end{bmatrix}\]</span></p><p>剩下的就是求解四元数微分方程了，求解方法有欧拉方法、毕卡算法，龙格库塔法，其中常用的是龙格库塔法求解，采用一阶龙格库塔法解算过程如下： 一阶龙格库塔公式 <span class="math inline">\(y_{n+1} = y_n + h \cdot y^{'}\)</span> 其中 h 为步长，$y^{'} $ 为斜率。则微分方程 $ = f(t,Q) $ 可以写为：</p><p><span class="math display">\[Q(t+\triangle t) = Q(t) + \triangle t \frac{dQ}{dt}\]</span></p><p>故可以得到：</p><p><span class="math display">\[\begin{bmatrix}{q_0}\\ q_1\\ {q_2}\\ {q_3}\end{bmatrix}_{t+\triangle t } = \begin{bmatrix}{q_0}\\ q_1\\ {q_2}\\ {q_3}\end{bmatrix}_{t } + \frac{\triangle t }{2} * \begin{bmatrix}0 &amp; -w_x &amp; -w_y&amp; -w_z \\w_x&amp; 0 &amp; w_z&amp; -w_y \\w_y&amp; -w_z&amp; 0 &amp; w_x \\w_z&amp; w_y&amp; -w_x&amp; 0\end{bmatrix} * \begin{bmatrix}{q_0}\\ q_1\\ {q_2}\\ {q_3}\end{bmatrix}_{t}\]</span></p><p>写为代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Integrate rate of change of quaternion</span><br><span class="line">gx *= (0.5f * (1.0f / sampleFreq));// pre-multiply common factors</span><br><span class="line">gy *= (0.5f * (1.0f / sampleFreq));</span><br><span class="line">gz *= (0.5f * (1.0f / sampleFreq));</span><br><span class="line">qa = q0;</span><br><span class="line">qb = q1;</span><br><span class="line">qc = q2;</span><br><span class="line">q0 += (-qb * gx - qc * gy - q3 * gz);</span><br><span class="line">q1 += (qa * gx + qc * gz - q3 * gy);</span><br><span class="line">q2 += (qa * gy - qb * gz + q3 * gx);</span><br><span class="line">q3 += (qa * gz + qb * gy - qc * gx);</span><br></pre></td></tr></tbody></table></figure><p>最后再对四元数进行归一化，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Normalise quaternion</span><br><span class="line">recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);</span><br><span class="line">q0 *= recipNorm;</span><br><span class="line">q1 *= recipNorm;</span><br><span class="line">q2 *= recipNorm;</span><br><span class="line">q3 *= recipNorm;</span><br></pre></td></tr></tbody></table></figure><p>至此所有理论推导都完成了，剩下的就是不停的循环上面的步骤就得到了四元数，剩下的任务就是将四元数转为欧拉角了，这里转欧拉角里面也是有坑的，需要考虑欧拉角的奇异性，在转化的过程中要注意对欧拉角的奇异性进行考虑就可以了。</p><h1 id="参考文献">参考文献</h1><p><span class="exturl" data-url="aHR0cDovL2ZpbGUuZWxlY2ZhbnMuY29tL3dlYjEvTTAwLzdGLzg5L280WUJBRndub0oyQUdkanBBQ0FYaDdKRS1fSTAwNS5wZGY=">http://file.elecfans.com/web1/M00/7F/89/o4YBAFwnoJ2AGdjpACAXh7JE-_I005.pdf<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL3F1YXRlcm5pb24ucGRm">https://krasjet.github.io/quaternion/quaternion.pdf<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDM2MjM4Nzk=">https://zhuanlan.zhihu.com/p/103623879<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NTY4MTgwNw==">https://zhuanlan.zhihu.com/p/55681807<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly94LWlvLmNvLnVrL29wZW4tc291cmNlLWltdS1hbmQtYWhycy1hbGdvcml0aG1zLw==">https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uaXRpbmpzYW5rZXQuZ2l0aHViLmlvL3R1dG9yaWFscy9hdHRpdHVkZWVzdC9tYWhvbnk=">https://nitinjsanket.github.io/tutorials/attitudeest/mahony<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5iemFyZy5jb20vcC9ob3ctYS1rYWxtYW4tZmlsdGVyLXdvcmtzLWluLXBpY3R1cmVzLw==">http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Nhcmx5bGVMaXUvS2FsbWFuRmlsdGVy">https://github.com/CarlyleLiu/KalmanFilter<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Image </category>
          
          <category> Stabilization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robot </tag>
            
            <tag> IMU </tag>
            
            <tag> EIS </tag>
            
            <tag> Image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buildroot 常见编译错误记录</title>
      <link href="/next/2019/Note/BuildrootCommonIssue/"/>
      <url>/next/2019/Note/BuildrootCommonIssue/</url>
      
        <content type="html"><![CDATA[<h1 id="openwrt-编译错误">openwrt 编译错误</h1><p>you should not run configure as root (set FORCE_UNSAFE_CONFIGURE=1 in environment to bypass this check)</p><p>解决方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> FORCE_UNSAFE_CONFIGURE=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="切换-gcc-版本">切换 gcc 版本</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 20 --slave /usr/bin/g++ g++ /usr/bin/g++-9</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 30 --slave /usr/bin/g++ g++ /usr/bin/g++-11</span><br></pre></td></tr></tbody></table></figure><h1 id="buildroot-报错">buildroot 报错：</h1><p>c-stack.c:55:26: error: missing binary operator before token</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将 buildroot 的 host-m4 版本升级一下就可以使用</span><br><span class="line">A possible workaround is to configure buildroot to build host-m4 version 1.4.19 instead of 1.4.18, because it no longer uses SIGSTKSZ.</span><br></pre></td></tr></tbody></table></figure><p>修改后：m4.mk:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># m4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"></span><br><span class="line">M4_VERSION = 1.4.19</span><br><span class="line">M4_SOURCE = m4-$(M4_VERSION).tar.xz</span><br><span class="line">M4_SITE = $(BR2_GNU_MIRROR)/m4</span><br><span class="line">M4_LICENSE = GPL-3.0+</span><br><span class="line">M4_LICENSE_FILES = COPYING</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">eval</span> $(host-autotools-package))</span><br></pre></td></tr></tbody></table></figure><p>m4.hash:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Locally calculated after checking pgp signature</span></span><br><span class="line">sha256  63aede5c6d33b6d9b13511cd0be2cac046f2e70fd0a07aa9573a04a82783af96  m4-1.4.19.tar.xz</span><br><span class="line"><span class="comment"># License files, locally calculated</span></span><br><span class="line">sha256  3972dc9744f6499f0f9b2dbf76696f2ae7ad8af9b23dde66d6af86c9dfb36986  COPYING</span><br></pre></td></tr></tbody></table></figure><h1 id="根文件系统编译报错">根文件系统编译报错</h1><p>libfakeroot.c:99:40: error: ‘_STAT_VER 问题解决</p><p>由于 fakeroot 别人修复了一个 bug，把_STATA_VER 删掉了，重新打上最新的补丁即可。</p><h2 id="下载最新补丁">下载最新补丁</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXQuYnVzeWJveC5uZXQvYnVpbGRyb290L2NvbW1pdC8/aWQ9ZjQ1OTI1YTk1MTMxOGU5ZTUzYmVhZDgwYjM2M2UwMDQzMDFhZGM2Zg==">访问这个链接<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXQuYnVzeWJveC5uZXQvYnVpbGRyb290L2NvbW1pdC8/aWQ9ZjQ1OTI1YTk1MTMxOGU5ZTUzYmVhZDgwYjM2M2UwMDQzMDFhZGM2Zg==">buildroot - Buildroot: Making Embedded Linux easy<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxBuild1.png"></p><p>解压进入后 /package/fakeroot/下，备份原来补丁，并替换成现在的，原来补丁目录</p><p><strong>usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x10): multiple definition of ‘yylloc‘； scripts/dtc/d</strong></p><p>找到出错的源文件并做如下修改：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘YYLTYPE yylloc’ and change it to ‘extern YYLTYPE yylloc’</span><br></pre></td></tr></tbody></table></figure><p><strong>/usr/bin/ld: libsim.a(maverick.o):(.bss+0x60): multiple definition of `DSPregs';libsim.a(wrapper.o):(.bss+0x60): first defined here</strong></p><p>问题已经解决，参考： <span class="exturl" data-url="aHR0cHM6Ly9nbnV0b29sY2hhaW4tZ2Vycml0Lm9zY2kuaW8vci9jL2JpbnV0aWxzLWdkYi8lMmIvNzI2">https://gnutoolchain-gerrit.osci.io/r/c/binutils-gdb/%2b/726<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9nbnV0b29sY2hhaW4tZ2Vycml0Lm9zY2kuaW8vci9jL2JpbnV0aWxzLWdkYi8rLzcyNg==">https://gnutoolchain-gerrit.osci.io/r/c/binutils-gdb/+/726<i class="fa fa-external-link-alt"></i></span></p><p>添加 patch 后重新编译模块</p><h1 id="解决-python3-no-module-named-_sqlite3错误-安装-sqlite3">解决 Python3 No module named '_sqlite3'错误 ## 安装 sqlite3</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载安装包：wget &lt;https://www.sqlite.org/2018/sqlite-autoconf-3240000.tar.gz&gt;</span><br><span class="line">解压：tar -xvzf sqlite-autoconf-3240000.tar.gz</span><br><span class="line">进入目录：<span class="built_in">cd</span> sqlite-autoconf-3240000/</span><br><span class="line">编译：./configure --prefix=/usr/local/sqlite</span><br><span class="line">安装 ：make -j4&amp;&amp;sudo make install</span><br></pre></td></tr></tbody></table></figure><h2 id="重新安装-python3">重新安装 python3</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget &lt;https://www.python.org/ftp/python/3.8.8/Python-3.8.8.tgz&gt;</span><br><span class="line">tar xvf Python-3.8.8.tgz</span><br><span class="line"></span><br><span class="line">修改 setup.py</span><br><span class="line">查找<span class="string">" sqlite_inc_paths"</span> 新增</span><br><span class="line"><span class="string">'/usr/local/sqlite/include'</span></span><br><span class="line"><span class="string">'/usr/local/sqlite/include/sqlite3'</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-loadable-sqlite-extensions</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></tbody></table></figure><h2 id="切换-python3-版本">切换 python3 版本</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /usr/bin/python</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/python3.8 /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> /usr/bin/python3</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/python3.8 /usr/bin/python3</span><br></pre></td></tr></tbody></table></figure><h2 id="warning-setlocale-lc_all-cannot-change-locale-en_us">warning: setlocale: LC_ALL: cannot change locale (en_US)</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get install -y locales</span><br><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></tbody></table></figure><p>这个时候在 Configuring locales（配置区域）下方就看到 en_US 了，要注意的是，只需要有 en_US 就行了，并不需要将默认设置改成 en_US；按键盘↓箭头将光标移动到 en_US.UTF-8 上，然后按 TAB 键将光标移动到 Ok 按钮上，回车。</p><p>执行 locale -a 命令查看已经配置的区域。</p><h2 id="切换-python-版本">切换 python 版本</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ whereis python</span><br><span class="line">$ <span class="built_in">rm</span> /usr/bin/python</span><br><span class="line">$ <span class="built_in">ln</span> -s /usr/bin/python3.10 /usr/bin/python</span><br></pre></td></tr></tbody></table></figure><h1 id="repo-更新代码是报错">repo 更新代码是报错：</h1><p>ModuleNotFoundError: No module named ‘formatter‘**</p><p><span class="exturl" data-url="aHR0cHM6Ly9nZXJyaXQtcmV2aWV3Lmdvb2dsZXNvdXJjZS5jb20vYy9naXQtcmVwby8rLzMwMzI4Mg==">https://gerrit-review.googlesource.com/c/git-repo/+/303282<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buildroot</title>
      <link href="/next/2019/Note/Buildroot/"/>
      <url>/next/2019/Note/Buildroot/</url>
      
        <content type="html"><![CDATA[<h1 id="buildroot-配置">Buildroot 配置</h1><h2 id="交叉编译工具链">交叉编译工具链</h2><p>Buildroot 为交叉编译工具链提供两种解决方案：</p><ul><li>内部工具链后端，在配置界面中调用“Buildroot toolchain”</li><li>外部工具链后端，在配置界面中调用“External toolchain“；有三种方式来使用外部工具链：<ul><li>让 Buildroot 基于预定义的外部工具链 profile 自动下载、安装。在&nbsp;<code>Toolchain</code>&nbsp;中选择已有的 profile 即可</li><li>为 Buildroot 手动指定提前安装好的、预定义了 profile 的工具链。在&nbsp;<code>Toolchain</code>&nbsp;中选择 profile 后，反选掉&nbsp;<code>Download toolchain automatically</code>&nbsp;并在&nbsp;<code>Toolchain path</code>&nbsp;中填写已有工具链路径即可</li><li>使用定制的外部工具链。通常用于使用 crosstool-NG 或 Buildroot 生成的已有定制工具链。选择&nbsp;<code>Toolchain</code>&nbsp;列表中的&nbsp;<code>Custom toolchain</code>&nbsp;，然后填写&nbsp;<code>Toolchain path</code>,&nbsp;<code>Toolchain prefix</code>,&nbsp;<code>External toolchain C librrary</code>&nbsp;选项。若外部工具链使用 glibc 库，只需要选择工具链是否支持 C++ 以及是否内建 RPC 支持即可。如果使用 uClibc 库，则还有宽字符、本地化、程序 invocation、线程支持等选项</li></ul></li></ul><p>Buildroot 不支持由 OpenEmbedded、Yocto 支持的工具链，因为这些工具生成的工具链并不是单纯的工具链——它们除了编译器、binutils、C/C++ 库之外还加了一大堆预编译的库和程序。因此 Buildroot 并没有办法导入它们的 sysroot 。Buildroot 也不支持发行版提供的工具链，这些工具链包含的东西也比较复杂，所以无法加载到构建环境中。</p><span id="more"></span><h2 id="dev-管理">/dev 管理</h2><ul><li><p>第一种方式是“Static using device table”<br>设备文件会被持久存储在根文件系统中（即重新启动后它们仍然存在），并且在系统添加或者移除硬件设备时，不能自动创建和删除这些设备文件。</p></li><li><p>第二种方式是“Dynamic using devtmpfs only”<br>使用 devtmpfs 时需要启用以下内核配置选项：CONFIG_DEVTMPFS 和 CONFIG_DEVTMPFS_MOUNT。</p></li><li><p>第三种方式是“Dynamic using devtmpfs+mdev”<br>每次添加或移除设备时，内核都会调用 mdev。由于使用/etc/mdev.conf 配置文件，因此 mdev 可以进行相关配置，例如给设备文件设置特定的权限或所有权、在设备出现或消失时调用脚本或应用程序等等</p></li><li><p>第四种方式是“Dynamic using devtmpfs+eudev”<br>eudev 是后台运行的守护程序，当系统添加或者移除设备时，内核将会调用它。与 mdev 相比，它是重量级的解决方案，但是具有更高的灵活性。eudev 是 udev 的独立版本</p></li></ul><h2 id="初始化系统">初始化系统</h2><ul><li>第一种是“BusyBox”：BusyBox init 程序会在启动时去读取/etc/inittab 文件</li><li>第二种是“systemV”：Sysvinit 同样使用 inittab 文件（其语法与 BusyBox 中的语法略有不同）</li><li>第三种是“systemd”：systemd 是用于 Linux 的新一代 init 系统。它的功能远远超过传统的 init 程序：强大的并行处理能力、使用 socket 和 D-Bus 激活启动服务、按需启动守护程序、使用 Linux 控制组跟踪进程、支持对系统状态进行快照和还原等等。</li></ul><h1 id="ildroot一般用法">ildroot一般用法</h1><h2 id="目录树外构建">目录树外构建</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/build; make O=<span class="variable">$PWD</span> -C path/to/buildroot</span><br></pre></td></tr></tbody></table></figure><p>注意：“O”指定的路径可以是绝对路径，也可以是相对路径，但如果是相对路径，则需要注意，它是相对于 Buildroot 的主目录而不是当前工作目录。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">CURRENT_DIR=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$0</span>); <span class="built_in">pwd</span>)</span><br><span class="line">make O=<span class="variable">${CURRENT_DIR}</span>/output -C ./Buildroot-2023.11/ stm32mp157_pro_ddr512m_systemV_core_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建软件包依赖关系图</span></span><br><span class="line">make graph-depends</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成构建时间图</span></span><br><span class="line">make graph-build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制软件包对文件系统大小贡献图</span></span><br><span class="line">make graph-size</span><br></pre></td></tr></tbody></table></figure><h2 id="在开发期间使用-buildroot">在开发期间使用 Buildroot</h2><p>问题：直接在 output/build/<package>-<version>中进行修改是不合适的，因为在“make clean”时会删除该目录。</version></package></p><p>解决办法：Buildroot 针对此场景提供了一种特定的机制：<pkg>_OVERRIDE_SRCDIR 机制。Buildroot 会读取 override 文件，而该文件可以让用户告诉 Buildroot 某些软件包的源码位置</pkg></p><p>override 文件的默认位置是<span class="math inline">\((CONFIG_DIR)/local.mk，由 BR2_PACKAGE_OVERRIDE_FILE 配置选项定义。\)</span>(CONFIG_DIR)是 Buildroot 中.config 文件的位置，因此默认情况下，<span class="exturl" data-url="aHR0cDovL2xvY2FsLm1r">local.mk<i class="fa fa-external-link-alt"></i></span> 与.config 文件在同一个目录下，这意味着： • 在目录树内构建的 Buildroot 源码顶级目录中（即不使用“O=”时） • 在目录树外构建的“O”参数指定的目录中（即使用“O=”时） 如果需要的位置与默认位置不同，则可以通过 BR2_PACKAGE_OVERRIDE_FILE 配置选项指定该位置。在该 override 文件中，Buildroot 希望找到以下形式的参数行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pkg1&gt;_OVERRIDE_SRCDIR = /path/to/pkg1/sources</span><br><span class="line">&lt;pkg2&gt;_OVERRIDE_SRCDIR = /path/to/pkg2/sources</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINUX_OVERRIDE_SRCDIR = /home/bob/linux/</span><br><span class="line">BUSYBOX_OVERRIDE_SRCDIR = /home/bob/busybox/</span><br></pre></td></tr></tbody></table></figure><p>当 Buildroot 发现指定软件包已经定义了<pkg>_OVERRIDE_SRCDIR 时，它将不再尝试下载、提取和修补软件包。取而代之的是，它将直接使用指定目录中可用的源代码，并且使用“make clean”时不会删除该目录。</pkg></p><p>此机制最好与 make <pkg>-rebuild 和 make <pkg>-reconfigure 目标结合使用。make <pkg>-rebuild all 将使源代码从<pkg>_OVERRIDE_SRCDIR 同步到 output/build/<package>-custom（由于 rsync，它仅复制修改过的文件），然后重新启动该软件包的构建过程。</package></pkg></pkg></pkg></pkg></p><p>在上述 linux 软件包示例中，开发人员可以在/home/bob/linux 中更改源代码，然后运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make linux-rebuild all</span><br></pre></td></tr></tbody></table></figure><h1 id="特定项目的定制">特定项目的定制</h1><p>...</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTOS 的设计</title>
      <link href="/next/2019/Program/rtosDesign/"/>
      <url>/next/2019/Program/rtosDesign/</url>
      
        <content type="html"><![CDATA[<h1 id="何为实时性">何为实时性？</h1><p>RTOS 的实时性该怎么理解呢？快速？确定性？</p><h2 id="从中断控制器视角看实时性">从中断控制器视角看实时性</h2><p>我们知道一般都是 Cortex-M 跑 RTOS，Cortex-A 很少跑 RTOS，一般都是跑 Linux、Android 这些非实时系统。如果单纯从速度来看 A 核在高主频加持下一定会具有更快的速度才对呀，那 M 核的竞争力在哪里呢？实际上这就是 A 核和 M 核在设计上的两个不同方向的取舍。</p><p>首先我们看 NVIC 中断控制器的设计：</p><ul><li>中断延迟波动很小：NVIC 支持中断嵌套，这样即使当前中断在处理中且非常耗时也没关系，因为可以通过高优先级的中断来响应更紧急的事件，这样中断延迟就不依赖与中断处理时间了，从设计上保证了延迟的确定性。</li><li>中断延迟小：NVIC 在不同的中断会跳转到不同地址运行，且可以直接在硬中断上下文中执行中断程序，这样整个 pipeline 很短，且 NVIC 还支持<strong>尾链</strong>这个概念进一步降低延迟（当高优先级的 ISR 抢占低优先级 ISR 时，处理器会跳过上下文保存和恢复，直接处理第二个 ISR，没有任何额外的开销）。通常 NVIC 中断响应时间在十几到几十 ns 之间。</li></ul><p>NVIC 中断控制器在实时性上是满足要求的，快速和确定性都满足，但是他不适合处理大量中断，假如每秒要处理成千上万（这个中断数量对于 A 核来讲是很常见的 UAC、UVC，DSP 等一个模块每秒可能就有几千个中断）个中断，那么对 NVIC 来讲这是灾难性的，各种嵌套设计各种性能评估，除此之外对于多核系统 NVIC 也没有一套将中断分配给各个 CPU 核的机制，那么就无法充分利用多核的优势提高中断处理能力。而 A 核的 GIC 控制器就是为解决这些问题而设计的。</p><p>Cortex-A 核的 GIC 中断控制器设计很复杂，但是不支持中断嵌套，由 Distributor、CPU interface、Redistributor、ITS 组成，Distributor 具有仲裁和分发的作用，会将中断发送给 Redistributor，Redistributor 将中断发送给 CPU interface。这样第一解决了多核问题，其次 GIC 没有中断嵌套，当中断发生后跳转到一个固定地址，然后判断中断源进行下一步跳转，在 Linux 中接下来就会分为中断上半部和下半部机制，上半部在硬中断上下文快速响应然后返回，以更快处理其他中断兼顾实时性。中断下半部为了不同的应用需求设计了 softirq、tasklet、workqueue、thread 等机制来实现大量的中断任务，兼顾高性能。GIC 中断控制器解决了 NVIC 的问题但是却丢了硬实时性。</p><ul><li>中断延迟比较大：中断处理的 PipeLine 比较长，中断响应延迟一般在 us 级别。</li><li>中断延迟波动比较大：中断不支持嵌套那么就一定要等上一个中断返回才能得到处理，这个延迟就不可控了。</li></ul><p>从中断控制器视角看实时性是快速+确定的 latency。</p><span id="more"></span><h2 id="从内存管理角度看实时性">从内存管理角度看实时性</h2><p>如果单纯重调度器的角度看，Linux 不仅有 RT 实时调度策略，还有 DeadLine 这种强实时性调度策略，也就是说 Linux 系统在调度算法上是具备实时性（软实时）的，但实时性不仅仅取决于调度器还有其他因素的影响，其中虚拟内存机制就是极为关键的因素，下面我们做下详细说明。</p><p>我们知道 Linux 下有一套极为复杂的内存管理系统，物理内存由 Node-Zone-Section-Page 链管理，虚拟内存由 slab-buddySystem-page-pagetable 链管理，当内存不足的时候可以通过相似页合并，页面迁移、页面回收等机制回收内存使用。而 RTOS 一般只实现简单的 memory pool。虚拟内存机制有非常多的好处，但是 RTOS 为什么不实现 Linux 下这套软件机制呢，因为没有 MMU？因为资源受限？其实现在 MCU 频率也都跑到上 Ghz 了，也可以外挂 DDR，那么塞个 MMU 放进去也不是什么难事为什么都不这么做呢？其实这是跟实时性相关的，Cortex-M 相较于 A 核的一个优势在于实时性（硬实时性）。引入 MMU 后硬实时性无法保证，我们看下 Linux 下的内存管理存在的问题就知道了。</p><p>加入你在 Linux 下采用 DeadLine 调度器，设计好了调度周期核 dead line，让调度器保证在每个周期的 dead line 时间前分配给 thread 需要的时间片。但是你 thread 中使用了一块 heap 里分配的内存，Linux 下申请一块内存是直接返回成功的，这个时候只得到了虚拟地址空间，并没有实际的物理地址被分配。然后你开始写这块内存，然后系统发现并没有实际的物理内存被映射，这个时候系统通过触发缺页异常进入异常处理，一旦触发缺页异常会走页面分配器这个路径，如果申请到页面还好，如果申请不到要走慢速通道，通过回收内存、页面合并、页面迁移等操作来腾出内存，emm，这个操作的耗时情况就完全不可控了。那么这个操作在 Deadline 调度周期内就很有可能无法完成。</p><p>当然也有解决办法就是 Reserved 内存，这就相当于没有使用虚拟内存机制了。</p><p>因此何为实时性呢？从内存管理角度看确定性更为接近答案，事实上硬实时性同时需要快速核确定性来保证。</p><h1 id="task-调度中存在的问题">task 调度中存在的问题</h1><h2 id="优先级反转">优先级反转</h2><p>使用实时内核，优先级反转问题是实时系统中出现得最多的问题。下图解释优先级反转是如何出现的：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/prio_revert.png"></p><p>如图，task 的优先级为 task1 &gt; task2 &gt; task3：</p><ul><li>阶段一：task1 和 task2 处于休眠态，task 申请持有锁。</li><li>阶段二：task1 切换到运行态，也要申请该锁，因申请不到而休眠。</li><li>阶段三：task2 切换到运行态，由于优先级高于 task3 而先运行。</li><li>阶段四：task2 运行结束，task3 运行，释放锁、然后 task1 恢复运行态开始运行。</li></ul><p>实际 task 运行的优先级相当于 task2 &gt; task1，发生了优先级反转。</p><p>解决措施：在 task3 使用共享资源时，提升 task3 的优先级，task 完成时予以恢复。task3 的优先级必须升至最高，高于允许使用该资源的任何 task 优先级。</p><p>然而改变 task 的优先级是很花时间的。如果 task3 并没有先被 task2 剥夺 CPU 使用权，花很多时间在共享资源使用前提升 task3 的优先级，然后又在资源使用后花时间恢复 task3 的优先级，则无形中浪费了很多 CPU 时间。真正需要的是，为防止发生优先级反转，内核能自动变换 task 的优先级，这叫做优先级继承 (Priority inheritance) 但 ucos-Ⅱ不支持优先级继承。</p><h2 id="死锁">死锁</h2><p>死锁也称作抱死，指两个 task 无限期地互相等待对方控制着的资源。设 task T1 正独享资源 R1,task T2 在独享资源 R2, 而此时 T1 又要独享 R2,T2 也要独享 R1, 于是哪个 task 都没法继续执行了，发生了死锁。最简单的防止发生死锁的方法是让每个 task 都：</p><ul><li>先得到全部需要的资源再做下一步的工作。</li><li>用同样的顺序去申请多个资源，释放资源时使用相反的顺序。</li></ul><h1 id="rtos-延时抖动">RTOS 延时抖动</h1><h2 id="概述">概述</h2><p>对于操作系统来讲时间是颗粒性的不是连续的（物理世界也是这样的），就是操作系统有最小时间颗粒，假如操作系统的时钟滴答是 1ms 那么操作系统是没办法区分小于这个时间的，这就是操作系统延时抖动的一个重要原因。操作系统会把 999us 到 1ms 的这个 1us 当 1ms 处理，当然也会将 1us 到 1999us 这个接近 2ms 的时间当成 1ms 计算，这就造成了一定的延时误差；另一个延时误差来自 task 的运行，task 是轮询运行的也就是延时 1ms 后时间到了，但是高优先级 task 会先运行，之后再将 cpu 控制权转交给该 task，这两个延时共同构成了操作系统的延时抖动。对于精确的延时需要采用硬件定时器实现，但是对于精度要求不是那么高利用操作系统提供的延时是非常方便的，其延时误差在时钟颗粒级别非常小。</p><h2 id="task-调度时机">task 调度时机</h2><p>假设时钟节拍是 1ms 发生一次，要求 task A 延时一个时钟节拍，下面三种情况体现了延时抖动的原因。</p><ul><li>第一种情况下执行延时函数后不到 1ms 就到来时钟节拍而其他高优先级 task 又没有多少 task 可以执行很快轮到 task A 执行因此 task A 实际延时小于 1ms。</li><li>第二种情况当调用延时函数后高优先级 task 执行时间较长大于上一次时钟节拍到来到调用延时 task 的时间，那么延时将大于 1ms。</li><li>第三种情况是高优先级 task 执行时间过长超过一个时钟节拍，那么实际延时可能是 2ms。</li></ul><p>因此，采用操作系统延时是不准确的，下图是 task 调度时机：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/rtos_latency_jiif.png"></p><p>延时的实际执行过程是这样的，在每一次时钟周期到来将发生一次中断，调用节拍服务函数 OSTimeTick()，该函数主要的功能是给每个 task 控制块 OS_TCB 中的时钟延时项 OSTCBDly 减一直到等于 0，在减到 0 之前 task 是挂起的，而当 task 延时减到 0 时 task 不一定是就绪态最高优先级 task，因此 task 不一定立即得到执行，而产生延时误差。如果需要精确的延时可以采用定时器延时，定时器延时产生的中断优先级更高需要立即处理。</p><h1 id="同步">同步</h1><h2 id="用于行为同步的通信手段">用于行为同步的通信手段</h2><ul><li>二值信号量：二值信号量的使用范围是：被控制方总能够及时响应控制方发出的信号，完成相应处理 task, 并在下一次信号来到之前进入等待状态。</li><li>计数信号量：计数信号量的使用范围是：被控制方不能保证在下一次信号到来之前处理完本次控制方发出的信号，但总体上可以响应所有信号。</li><li>事件标志组：“事件标志组”可以实现多个 task（包括 ISR) 协同控制一个 task, 当各个相关 task（包括 ISR) 先后发出自己的信号后（使事件标志组的对应标志有效）, 预定的逻辑运算结果有效，触发被控制的 task。</li><li>消息邮箱：由于“消息邮箱”里只能存放一条消息，所以在用“消息邮箱”进行同步控制时，必须满足一个前提：任何时候消息的生产速度都比消息的消费速度慢，即被控制 task 总是在等待消息。这和二值信号量的情况类似。</li><li>消息队列：“消息队列”可以存放多个消息，能够有效解决消息的“临时堆积”问题。与计数信号量的情况类似，“消息队列”的使用仍然需要满足一个条件：消息的平均生产时间比消息的平均消费时间长；否则，再长的“消息队列”也会“溢出”。</li></ul><p>将以上通信手段用于 task 之间的行为同步时需要根据实际情况来选择：</p><ul><li>当同步过程不需要传输具体内容时，可选择信号量类手段（二值信号量、计数信号量和事件标志组）。</li><li>当同步过程需要传输具体内容时，可选择消息类手段（消息邮箱和消息队列）。</li><li>当满足“任何时候同步信息的生产速度都比同步信息的消费速度慢”时，可选择简单的通信手段（二值信号量、事件标志组和消息邮箱）。</li><li>对于非周期性同步信息，当不能保证“任何时候同步信息的生产速度都比同步信息的消费速度慢”时，可选择有缓冲功能的通信手段（计数信号量和消息队列）。</li><li>当同步信号为多个信号的逻辑运算结果时，采用事件标志组作为同步手段。</li></ul><h2 id="数据通信">数据通信</h2><ul><li>全局变量与内存数据块：在没有行为同步要求的前提下，当传输的数据量不大时，采用全局变量并配合关中断的资源同步揹施是一种经济、有效的方法。</li><li>消息邮箱：“消息邮箱”就是具有行为同步功能的通信手段，不具备缓存功能，消费必须及时。</li><li>消息队列：消息队列”是具有行为同步功能和缓冲功能的数据通信手段。</li></ul><h1 id="参考文献">参考文献</h1><p>《嵌入式实时操作系统 ucos-ii 教程》<br>《周慈航-基于嵌入式实时操作系统的程序设计技术》<br>《嵌入式实时操作系统μCOS-II 原理及应用-任哲》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Driver Tips</title>
      <link href="/next/2019/Note/LinuxDriverTips/"/>
      <url>/next/2019/Note/LinuxDriverTips/</url>
      
        <content type="html"><![CDATA[<h1 id="获取-ns-时间戳已弃用">获取 ns 时间戳（已弃用）</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timekeeping32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">u64 ns;</span><br><span class="line"></span><br><span class="line">getnstimeofday(&amp;ts);</span><br><span class="line">ns = timespec_to_ns(&amp;ts);</span><br></pre></td></tr></tbody></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvY29yZS1hcGkvdGltZWtlZXBpbmcuaHRtbA==">ktime accessors — The Linux Kernel documentation<i class="fa fa-external-link-alt"></i></span></p><p>可以使用 ktime_get_ns() 替代。 如果要获取 us 时间会涉及到 64bit 除法问题，会遇到如下问题：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: modpost: <span class="string">"__aeabi_uldivmod"</span> [common_drivers/drivers/usb/dwc_otg.ko] undefined!</span><br></pre></td></tr></tbody></table></figure><p>调用 div_u64() 函数，需要 include &lt;linux/math64.h&gt;</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64tm = div_u64(ktime_get_raw_ns(),<span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="dump-stack">Dump Stack</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ptrace.h&gt;</span></span></span><br><span class="line">dump_stack();</span><br></pre></td></tr></tbody></table></figure><h1 id="linux-中根据函数指针打印函数名">Linux 中根据函数指针打印函数名</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(<span class="string">"func: %pS at address: %px\\n"</span>, func, func);</span><br></pre></td></tr></tbody></table></figure><h1 id="调整线程优先级">调整线程优先级</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/sched/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> { .sched_priority = <span class="number">99</span> };</span><br><span class="line">thread_handle = kthread_run(thread_capture, audio_pcm, <span class="string">"dsp_cap"</span>);</span><br><span class="line">sched_setscheduler(thread_handle, SCHED_FIFO, &amp;param);</span><br></pre></td></tr></tbody></table></figure><h1 id="信号量">信号量</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sema_init(&amp;sem, <span class="number">0</span>);</span><br><span class="line">up(&amp;sem);</span><br><span class="line">down_timeout(&amp;sem, usecs_to_jiffies(sleep_us))</span><br></pre></td></tr></tbody></table></figure><h1 id="timer">Timer</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tests</span>{</span></span><br><span class="line"><span class="type">int</span> my_number；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>；</span></span><br><span class="line"><span class="class">} <span class="title">my_data</span>;</span>  <span class="comment">//声明定时器全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义定时器到期执行的函数，在此只有显示的功能，不做任何处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span><span class="comment">//这里参数有变化！</span></span><br><span class="line">{</span><br><span class="line">    printk(<span class="string">"In the my_timer_function\\n"</span>);</span><br><span class="line">    printk(<span class="string">"the jiffies is :%ld\\n"</span>, jiffies);     <span class="comment">//显示当前的节拍数</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tests</span> *<span class="title">datas</span> =</span> from_timer(datas,t,my_timer);<span class="comment">//在这里从 timer 找到包含其的结构体首地址！</span></span><br><span class="line">    printk(<span class="string">"my number is :%d\\n"</span>, tests-&gt;my_number);                                              </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">setup_timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    printk(<span class="string">"my_timer will be created.\\n"</span>);</span><br><span class="line">    printk(<span class="string">"the jiffies is :%ld\\n"</span>, jiffies);      <span class="comment">//显示当前的节拍数</span></span><br><span class="line">    my_data.my_timer.expires = jiffies + <span class="number">1</span>*HZ;            <span class="comment">//HZ=250，初始化字段 expires 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化定时器变量的 function 和 data 字段</span></span><br><span class="line">    timer_setup(&amp;my_data.my_timer, my_timer_function, <span class="number">0</span>);<span class="comment">//设置定时器</span></span><br><span class="line">    add_timer(&amp;my_data.my_timer);     <span class="comment">//将定时器变量加入到合适的链表，激活定时器</span></span><br><span class="line">    printk(<span class="string">"my_timer init.\\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">setup_timer_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    printk(<span class="string">"Goodbye setup_timer\\n"</span>);</span><br><span class="line">    del_timer(&amp;my_data.my_timer);  <span class="comment">//删除定时器变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(setup_timer_init);</span><br><span class="line">module_exit(setup_timer_exit);</span><br></pre></td></tr></tbody></table></figure><h1 id="module-param">module param</h1><h2 id="module_paraminsmod-ko-文件时传递参数">module_param(insmod ko 文件时传递参数）</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define MY_MAJOR 0x09</span></span><br><span class="line">static int global_val_test = MY_MAJOR;</span><br><span class="line">module_param(global_val_test, int, 0644);</span><br></pre></td></tr></tbody></table></figure><p>再编译模块后，再 insmod 加载模块时就可以传参数进去了，如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon hello_world]<span class="comment"># insmod first_hello.ko global_val_test=5</span></span><br><span class="line">[root@bogon hello_world]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">May 26 14:20:08 localhost kernel: [63460.994397] global_val_test = 5</span><br><span class="line">May 26 14:20:08 localhost kernel: [63460.994409] hello world enter</span><br><span class="line">May 26 14:20:08 localhost kernel: global_val_test = 5</span><br><span class="line">May 26 14:20:08 localhost kernel: hello world enter</span><br></pre></td></tr></tbody></table></figure><p>同时，在模块目录下会生成 parameter 目录及参数文件，如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon hello_world]<span class="comment"># cat /sys/module/first_hello/</span></span><br><span class="line">coresize     holders/     initsize     initstate    notes/       parameters/  refcnt       rhelversion  sections/    srcversion   taint        uevent       version</span><br><span class="line">[root@bogon hello_world]<span class="comment"># ls -alt /sys/module/first_hello/parameters/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 16384 May 26 14:54 global_val_test</span><br></pre></td></tr></tbody></table></figure><h2 id="module_parm_desc">MODULE_PARM_DESC</h2><p>MODULE_PARM_DESC 是用来描述驱动模块的参数信息的。 例如驱动内有这么一行代码：MODULE_PARM_DESC(stacfgpath, "Get path of sta cfg"); 假设编译生成的驱动文件为 test.ko 我们使用：modinfo test.ko</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#:modinfo test.ko</span></span><br><span class="line">filename:    /home/test/test.ko</span><br><span class="line">license:     GPL</span><br><span class="line">srcversion:  </span><br><span class="line">depends:</span><br><span class="line">retpoline:   Y</span><br><span class="line">name:        <span class="built_in">test</span></span><br><span class="line">vermagic:    4.15.0-129-generic SMP mod_unload</span><br><span class="line">parm:        stacfgpath:Get path of sta cfg (charp)</span><br></pre></td></tr></tbody></table></figure><p>MODULE_PARM_DESC 内描述的信息就会在 parm 这一行参数显示出来，这样用户就知道要加载这个驱动可以传入哪些参数了。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/next/2019/Note/DockerUsage/"/>
      <url>/next/2019/Note/DockerUsage/</url>
      
        <content type="html"><![CDATA[<h1 id="基本使用">基本使用</h1><h2 id="设置开机自启动并启动-docker-ce">设置开机自启动并启动 Docker-CE</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="添加当前用户到-docker-用户组可以不用-sudo-运行-docker">添加当前用户到 docker 用户组，可以不用 sudo 运行 docker</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></tbody></table></figure><h2 id="获取-archlinux-镜像">获取 archlinux 镜像</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull base/archlinux</span><br></pre></td></tr></tbody></table></figure><h1 id="镜像使用">镜像使用</h1><h2 id="列出所有镜像">列出所有镜像</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span> -a</span><br></pre></td></tr></tbody></table></figure><h2 id="删除镜像">删除镜像</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> image_id</span><br></pre></td></tr></tbody></table></figure><h1 id="容器使用">容器使用</h1><h2 id="新建容器并挂载本地目录"><strong>新建容器并挂载本地目录</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/carlyleliu/share/docker/ubuntu18:/share/ techliu/ubuntu /bin/bash</span><br><span class="line">docker run -it -v /home/carlyleliu/share/docker/ubuntu20:/share/ ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -it -v /home/carlyleliu/Workspace/Docker/ubuntu22:/share/ ubuntu:22.04 /bin/bash</span><br><span class="line"></span><br><span class="line">docker network create --subnet=172.18.0.0/16 docker_net</span><br><span class="line">docker run --net docker_net --ip 172.18.0.11 -p 2222:22 -it --name ubuntu -v /d/Docker/ubuntu:/share/ ubuntu /bin/bash</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="启动容器"><strong>启动容器</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start ubuntu</span><br></pre></td></tr></tbody></table></figure><h2 id="进入-shell"><strong>进入 shell</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach ubuntu</span><br></pre></td></tr></tbody></table></figure><h1 id="制作镜像并上传">制作镜像并上传</h1><h2 id="制作镜像"><strong>制作镜像</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">"xxxx"</span> -a <span class="string">"techliu &lt;yyliushuai@gmail.com&gt;"</span> container_id repository_name</span><br></pre></td></tr></tbody></table></figure><h2 id="登录"><strong>登录</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></tbody></table></figure><h2 id="上传"><strong>上传</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu18:latest techliu/ubuntu:latest</span><br><span class="line">docker push techliu/ubuntu:latest</span><br></pre></td></tr></tbody></table></figure><h2 id="兼容多平台">兼容多平台</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64 --tag techliu/ubuntu:latest --push .</span><br></pre></td></tr></tbody></table></figure><h2 id="验证"><strong>验证</strong></h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect techliu/ubuntu</span><br></pre></td></tr></tbody></table></figure><h1 id="容器与主机之间文件拷贝">容器与主机之间文件拷贝</h1><h2 id="容器到主机">容器到主机</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> ubuntu20.04:/workspace/dir /host-dir</span><br></pre></td></tr></tbody></table></figure><h2 id="主机到容器">主机到容器</h2><p><strong>获取确定容器 id</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></tbody></table></figure><p><strong>确定容器长 id</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">'{{.ID}}'</span> ubuntu20.04</span><br></pre></td></tr></tbody></table></figure><p><strong>拷贝文件</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span>  /host-dir docker-long-id:/workspace/docker-dir</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ Tips</title>
      <link href="/next/2019/Note/CPPTips/"/>
      <url>/next/2019/Note/CPPTips/</url>
      
        <content type="html"><![CDATA[<h1 id="c-tips">C Tips</h1><h2 id="区别以下函数">区别以下函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">()</span>;        <span class="comment">//f 为一个函数，函数返回值为指向整形的指针</span></span><br><span class="line"><span class="type">int</span> (*f)();      <span class="comment">//f 为一个指针，该指针指向一个函数</span></span><br><span class="line"><span class="type">int</span>* f[];        <span class="comment">//f 为一个数组，数组内容为指针</span></span><br><span class="line"><span class="type">int</span> (*f[])();    <span class="comment">//f 为数组，数组的内容为指向函数的指针</span></span><br><span class="line"><span class="type">int</span>*(*f[])();    <span class="comment">//f 为数组，数组的内容为指向函数的指针，该函数返回一个指向整形的指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>[];       <span class="comment">//不存在</span></span><br><span class="line"><span class="type">int</span> f[]();       <span class="comment">//不存在</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="宏定义">宏定义</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _SYSCALL_CONCAT(arg1, arg2) __SYSCALL_CONCAT(arg1, arg2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_CONCAT(arg1, arg2) ___SYSCALL_CONCAT(arg1, arg2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___SYSCALL_CONCAT(arg1, arg2) arg1##arg2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SYSCALL_NARG(...) __SYSCALL_NARG(__VA_ARGS__, __SYSCALL_RSEQ_N())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_NARG(...) __SYSCALL_ARG_N(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_ARG_N(_1, _2, _3, _4, _5, _6, _7, N, ...) N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_RSEQ_N() 6, 5, 4, 3, 2, 1, 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Z_SYSCALL_HANDLER(...) \\</span></span><br><span class="line"><span class="meta"> _SYSCALL_CONCAT(__SYSCALL_HANDLER, \\</span></span><br><span class="line"><span class="meta">   _SYSCALL_NARG(__VA_ARGS__))(__VA_ARGS__)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="container_of-宏">container_of 宏</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) ({ \\</span></span><br><span class="line"><span class="meta">const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\</span></span><br><span class="line"><span class="meta">(type *)( (char *)__mptr - offsetof(type,member) );})</span></span><br></pre></td></tr></tbody></table></figure><p>可以通过结构体中的一个成员获得该结构体首地址。精髓在于定义该结构体并将其放到 0 地址处通过已知成员获得偏移从而计算出首地址</p><h2 id="builtin_expect">__builtin_expect</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect((bool)!!(x), true)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect((bool)!!(x), false)</span></span><br></pre></td></tr></tbody></table></figure><p>这个宏定义的作用是优化代码，减少指令跳转次数。</p><p>在实际使用中例如</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="built_in">likely</span>( x ) ) {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 x 为 true 的场景较多时可以优化代码减少跳转次数相反当 x 倾向于 false 时用 unlikely，这个主要是 cpu 预取指相关内容。</p><h1 id="c-tips-1">C++ Tips</h1><h2 id="conversion-function">conversion function</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fraction</span>(<span class="type">int</span> num,<span class="type">int</span> den = <span class="number">1</span>):</span><br><span class="line"><span class="built_in">m_numerator</span>(num),</span><br><span class="line"><span class="built_in">m_denominnator</span>(den)</span><br><span class="line">{}</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>{</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominnator);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;    <span class="comment">//分子</span></span><br><span class="line"><span class="type">int</span> m_denominnator; <span class="comment">//分母</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">4</span> + f; <span class="comment">//调用 double() 将 f 转换为 0.6</span></span><br></pre></td></tr></tbody></table></figure><p>实际上做（）运算符的重载。</p><h2 id="explicit">explicit</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Fraction</span>(<span class="type">int</span> num,<span class="type">int</span> den = <span class="number">1</span>):</span><br><span class="line"><span class="built_in">m_numerator</span>(num),</span><br><span class="line"><span class="built_in">m_denominnator</span>(den)</span><br><span class="line">{}</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>{</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominnator);</span><br><span class="line">}</span><br><span class="line">Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f){</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">} </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;    <span class="comment">//分子</span></span><br><span class="line"><span class="type">int</span> m_denominnator; <span class="comment">//分母</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d = f + <span class="number">4</span>; <span class="comment">//4: 调用 none-explicitctor 将 4 转化为 Fraction(4,1) 然后调用 operator+</span></span><br><span class="line"><span class="comment">//f: 可以将 f 转化为 double 这样就有歧义</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> den = <span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">m_numerator(num),</span></span><br><span class="line"><span class="function">m_denominnator(den)</span></span><br><span class="line"><span class="function">{</span>}</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>{</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominnator);</span><br><span class="line">}</span><br><span class="line">Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f){</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">} </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_numerator;    <span class="comment">//分子</span></span><br><span class="line"><span class="type">int</span> m_denominnator; <span class="comment">//分母</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样 4 就没办法转化为 Fractor(4,1) 了，这个关键字只对单参数 class 起作用</p><h2 id="share_ptr">share_ptr</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Program1.png"></p><h2 id="iterator">iterator</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Program2.png"></p><h2 id="模板特化和偏特化">模板特化和偏特化</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 特化 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt; {</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>{<span class="keyword">return</span> x;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; {</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>{<span class="keyword">return</span> x;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt; {</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">long</span> x)</span> <span class="type">const</span> </span>{<span class="keyword">return</span> x;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偏特化 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector {</span><br><span class="line">...</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>,Alloc&gt; {</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="模板模板参数">模板模板参数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,  </span><br><span class="line">         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">             <span class="keyword">class</span> <span class="title class_">Container</span> </span><br><span class="line">    &gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span> </span><br><span class="line">{  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Container&lt;T&gt; c; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">XCls</span>() { </span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="override">override</h2><p>派生类定义了一个函数与基类中的虚函数名字相同但是参数却不同，我们本来想 overwrite 基类中的虚函数，但是参数不同并不会报错而是两个独立的函数，这不是我们想要的，这个问题一般很难发现，因此可以通过 overridr 关键字来进行检查。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">virture <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">virture <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A {</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">//正确 f1 与基类的 f1 匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;       <span class="comment">//错误，A 中没有 f2（int）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">//错误，f3() 不是虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">//错误 A 中没有 f4() 函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="final">final</h2><p>定义为 final 的函数，之后派生类的任何覆盖该函数的行为都是非法的</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>; <span class="comment">//错误 C 中已经将 f1 声明为 final 了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="stdremove_cv-stdremove_reference"><strong>std::remove_cv &amp; std::remove_reference</strong></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove_cv example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="type">char</span> cvchar;</span><br><span class="line">  std::remove_cv&lt;cvchar&gt;::type a;       <span class="comment">// char a</span></span><br><span class="line">  std::remove_cv&lt;<span class="type">char</span>* <span class="type">const</span>&gt;::type b;  <span class="comment">// char* b</span></span><br><span class="line">  std::remove_cv&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::type c;  <span class="comment">// const char* c (no changes)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"type of a is const"</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"type of a is not const"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::is_volatile&lt;<span class="keyword">decltype</span>(a)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"type of a is volatile"</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"type of a is not volatile"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> of a is not const</span><br><span class="line"><span class="built_in">type</span> of a is not volatile</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="stdfunction"><strong>std::function</strong></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::function, std::negate</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a function:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">half</span><span class="params">(<span class="type">int</span> x)</span> </span>{<span class="keyword">return</span> x/<span class="number">2</span>;}</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function object class:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">third_t</span> {</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>{<span class="keyword">return</span> x/<span class="number">3</span>;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// a class with data members:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyValue</span> {</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">fifth</span><span class="params">()</span> </span>{<span class="keyword">return</span> value/<span class="number">5</span>;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fn1 = half;                    <span class="comment">// function</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fn2 = &amp;half;                   <span class="comment">// function pointer</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fn3 = <span class="built_in">third_t</span>();               <span class="comment">// function object</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fn4 = [](<span class="type">int</span> x){<span class="keyword">return</span> x/<span class="number">4</span>;};  <span class="comment">// lambda expression</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fn5 = std::<span class="built_in">negate</span>&lt;<span class="type">int</span>&gt;();      <span class="comment">// standard function object</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fn1(60): "</span> &lt;&lt; <span class="built_in">fn1</span>(<span class="number">60</span>) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fn2(60): "</span> &lt;&lt; <span class="built_in">fn2</span>(<span class="number">60</span>) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fn3(60): "</span> &lt;&lt; <span class="built_in">fn3</span>(<span class="number">60</span>) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fn4(60): "</span> &lt;&lt; <span class="built_in">fn4</span>(<span class="number">60</span>) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fn5(60): "</span> &lt;&lt; <span class="built_in">fn5</span>(<span class="number">60</span>) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stuff with members:</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(MyValue&amp;)&gt; value = &amp;MyValue::value;  <span class="comment">// pointer to data member</span></span><br><span class="line">  std::function&lt;<span class="type">int</span>(MyValue&amp;)&gt; fifth = &amp;MyValue::fifth;  <span class="comment">// pointer to member function</span></span><br><span class="line"></span><br><span class="line">  MyValue sixty {<span class="number">60</span>};</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"value(sixty): "</span> &lt;&lt; <span class="built_in">value</span>(sixty) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"fifth(sixty): "</span> &lt;&lt; <span class="built_in">fifth</span>(sixty) &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn1(60): 30</span><br><span class="line">fn2(60): 30</span><br><span class="line">fn3(60): 20</span><br><span class="line">fn4(60): 15</span><br><span class="line">fn5(60): -60</span><br><span class="line">value(sixty): 60</span><br><span class="line">fifth(sixty): 12</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="stdtype_index"><strong>std::type_index</strong></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type_index example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span>       <span class="comment">// operator typeid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeindex&gt;</span>      <span class="comment">// std::type_index</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>  <span class="comment">// std::unordered_map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>         <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  std::unordered_map&lt;std::type_index,std::string&gt; mytypes;</span><br><span class="line"></span><br><span class="line">  mytypes[<span class="built_in">typeid</span>(<span class="type">int</span>)]=<span class="string">"Integer type"</span>;</span><br><span class="line">  mytypes[<span class="built_in">typeid</span>(<span class="type">double</span>)]=<span class="string">"Floating-point type"</span>;</span><br><span class="line">  mytypes[<span class="built_in">typeid</span>(C)]=<span class="string">"Custom class named C"</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">"int: "</span> &lt;&lt; mytypes[<span class="built_in">typeid</span>(<span class="type">int</span>)] &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"double: "</span> &lt;&lt; mytypes[<span class="built_in">typeid</span>(<span class="type">double</span>)] &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"C: "</span> &lt;&lt; mytypes[<span class="built_in">typeid</span>(C)] &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int: Integer <span class="built_in">type</span></span><br><span class="line">double: Floating-point <span class="built_in">type</span></span><br><span class="line">C: Custom class named C</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="stdbind">std::bind</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span> <span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>{<span class="keyword">return</span> x/y;}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> {</span><br><span class="line">  <span class="type">double</span> a,b;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span> </span>{<span class="keyword">return</span> a*b;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// binding functions:</span></span><br><span class="line">  <span class="keyword">auto</span> fn_five = std::<span class="built_in">bind</span> (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fn_five</span>() &lt;&lt; <span class="string">'\\n'</span>;                          <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_half = std::<span class="built_in">bind</span> (my_divide,_1,<span class="number">2</span>);               <span class="comment">// returns x/2</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; <span class="string">'\\n'</span>;                        <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_invert = std::<span class="built_in">bind</span> (my_divide,_2,_1);            <span class="comment">// returns y/x</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fn_invert</span>(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\\n'</span>;                    <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> fn_rounding = std::<span class="built_in">bind</span>&lt;<span class="type">int</span>&gt; (my_divide,_1,_2);     <span class="comment">// returns int(x/y)</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">fn_rounding</span>(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\\n'</span>;                  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  MyPair ten_two {<span class="number">10</span>,<span class="number">2</span>};</span><br><span class="line"></span><br><span class="line">  <span class="comment">// binding members:</span></span><br><span class="line">  <span class="keyword">auto</span> bound_member_fn = std::<span class="built_in">bind</span> (&amp;MyPair::multiply,_1); <span class="comment">// returns x.multiply()</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">bound_member_fn</span>(ten_two) &lt;&lt; <span class="string">'\\n'</span>;           <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bound_member_data = std::<span class="built_in">bind</span> (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">bound_member_data</span>() &lt;&lt; <span class="string">'\\n'</span>;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0.2</span><br><span class="line">3</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure><h2 id="stdlock_guard">std::lock_guard</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock_guard example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>          <span class="comment">// std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>      <span class="comment">// std::logic_error</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_even</span> <span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) std::cout &lt;&lt; x &lt;&lt; <span class="string">" is even\\n"</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">throw</span> (std::<span class="built_in">logic_error</span>(<span class="string">"not even"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span> <span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="built_in">print_even</span>(id);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">catch</span> (std::logic_error&amp;) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"[exception caught]\\n"</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  std::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = std::<span class="built_in">thread</span>(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Possible output:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[exception caught]</span><br><span class="line">2 is even</span><br><span class="line">[exception caught]</span><br><span class="line">4 is even</span><br><span class="line">[exception caught]</span><br><span class="line">6 is even</span><br><span class="line">[exception caught]</span><br><span class="line">8 is even</span><br><span class="line">[exception caught]</span><br><span class="line">10 is even</span><br></pre></td></tr></tbody></table></figure><h2 id="stdpromise">std::promise</h2><p><strong>std::promise 和 std::future 用于线程异步</strong></p><p>waitForSubmittedTasks 函数可以通过如下方式等待所有线程执行完成，flushedFuture.wait(); 会休眠等待条件满足，flushedPromise.set_value() 会导致变量 ready，只有 ready 了线程才会被唤醒，结束函数。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void SharedExecutor::waitForSubmittedTasks() noexcept {</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock{m_queueMutex};</span><br><span class="line">    <span class="keyword">if</span> (m_threadRunning) {</span><br><span class="line">        // <span class="built_in">wait</span> <span class="keyword">for</span> thread to <span class="built_in">exit</span>.</span><br><span class="line">        std::promise&lt;void&gt; flushedPromise;</span><br><span class="line">        auto flushedFuture = flushedPromise.get_future();</span><br><span class="line">        m_queue.emplace_back([&amp;flushedPromise]() { flushedPromise.set_value(); });</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line">        flushedFuture.<span class="built_in">wait</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="stdcondition_variable"><strong>std::condition_variable</strong></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condition_variable example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_id</span> <span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">  <span class="keyword">while</span> (!ready) cv.wait(lck);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread "</span> &lt;&lt; id &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">()</span> {</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">  ready = <span class="literal">true</span>;</span><br><span class="line">  cv.notify_all();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(print_id,i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"10 threads ready to race...\\n"</span>;</span><br><span class="line">  go();                       <span class="comment">// go!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Possible output (thread order may vary):</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 threads ready to race...</span><br><span class="line">thread 2</span><br><span class="line">thread 0</span><br><span class="line">thread 9</span><br><span class="line">thread 4</span><br><span class="line">thread 6</span><br><span class="line">thread 8</span><br><span class="line">thread 7</span><br><span class="line">thread 5</span><br><span class="line">thread 3</span><br><span class="line">thread 1</span><br></pre></td></tr></tbody></table></figure><h2 id="type_traits"><strong>type_traits</strong></h2><h2 id="空类的作用">空类的作用</h2><p>还有一个关于空类的疑问就是，C++语言有必要保留空类吗？空类实现空对象有什么用？</p><p>有用的，尤其是在“泛型编程”中，空类（结构）的用处非常广：</p><p>在其他的文章中提到，我们利用类型（通常是空类）来区别对待不同类对象的属性。（其实我们是可以通过使用常数来区分的，但是区别我们很容易就能知道）。</p><p>使用常数来区分需要使用 if else 的这种运行时来确定执行的线路的方法，而使用函数重载的方法，在参数中加入一个空类域作为区分不同的函数的方法，编译的时候直接选择，而不是在运行的时候选择，这是非常提高效率的。</p><p>要知道，不同的空类，是不同的。他们代表着不同的类型（虽然他们结构一样）。在 STL 中，使用空类区分不同类型的标志，从而在编译的时候来对不同的类进行有针对性的优化是非常常见的。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>archlinux(Manjaro) 配置</title>
      <link href="/next/2019/Note/ArchLinuxConfig/"/>
      <url>/next/2019/Note/ArchLinuxConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="设置国内源">设置国内源</h1><p>设置官方镜像源（包括 core， extra， community， multilib ）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></tbody></table></figure><p>然后勾选你需要的镜像源，确认即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syy //更新数据源</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="archlinux-安装代理">archlinux 安装代理</h1><h2 id="shadowsocksr-并启用弃用">shadowsocksr 并启用（弃用）</h2><h3 id="安装">安装</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaourt shadowsocksr</span><br></pre></td></tr></tbody></table></figure><h3 id="修改配置文件">修改配置文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/shadowsocksr/config.json</span><br><span class="line"><span class="string">"protocol"</span>: <span class="string">"auth_sha1_v4"</span>,</span><br><span class="line"><span class="string">"obfs"</span>:<span class="string">"http_simple"</span>,</span><br></pre></td></tr></tbody></table></figure><h3 id="启动">启动</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python ./.local/lib/python3.6/site-packages/shadowsocks/local.py -c /etc/shadowsocksr/config.json</span><br></pre></td></tr></tbody></table></figure><h2 id="v2raya">v2raya</h2><h3 id="在应用商店里下载-v2raya-软件">在应用商店里下载 v2raya 软件</h3><h3 id="然后启动-v2raya">然后<strong>启动 v2rayA</strong>：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2raya.service</span><br></pre></td></tr></tbody></table></figure><h3 id="设置开机自动启动"><strong>设置开机自动启动：</strong></h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> v2raya.service</span><br></pre></td></tr></tbody></table></figure><h1 id="安装搜狗拼音输入法"><strong>安装搜狗拼音输入法</strong></h1><h3 id="安装-1">安装</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-im             <span class="comment"># 全部安装</span></span><br><span class="line">sudo pacman -S fcitx-configtool     <span class="comment"># 图形化配置工具</span></span><br><span class="line">yay -S fcitx-sogoupinyin</span><br></pre></td></tr></tbody></table></figure><h3 id="安装完成后新建并配置.xprofile添加如下内容">安装完成后，新建并配置~/.xprofile，添加如下内容：</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span></span><br></pre></td></tr></tbody></table></figure><h1 id="常用软件">常用软件</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VS Code 代码编辑器</span></span><br><span class="line">yay -S visual-studio-code-bin </span><br><span class="line"></span><br><span class="line"><span class="comment"># Chrome 浏览器  </span></span><br><span class="line">sudo pacman -S google-chrome        </span><br><span class="line"></span><br><span class="line"><span class="comment"># konsole</span></span><br><span class="line">sudo pacman -S konsole</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 zsh 和 oh-my-zsh</span></span><br><span class="line">sh -c <span class="string">"<span class="subst">$(curl -fsSL &lt;https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh&gt;)</span>"</span></span><br><span class="line">chsh <span class="variable">${USER}</span></span><br><span class="line">/bin/zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># teamviewer</span></span><br><span class="line">pamac install teamviewer</span><br><span class="line">sudo teamviewer --daemon <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wps</span></span><br><span class="line">yay -S wps-office</span><br><span class="line">yay -S ttf-wps-fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装网易云音乐</span></span><br><span class="line">sudo pacman -S netease-cloud-music</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装深度截图</span></span><br><span class="line">sudo pacman -S deepin-screenshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># wechat</span></span><br><span class="line">yay -S deepin-wine-wechat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装福昕 pdf 阅读器</span></span><br><span class="line">yay -S foxitreader </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 pycharm</span></span><br><span class="line">yay -S pycharm pycharm-jre </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 tmux</span></span><br><span class="line">sudo pacman -S tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvim</span></span><br></pre></td></tr></tbody></table></figure><h1 id="挂载-8t-硬盘">挂载 8T 硬盘</h1><p>首先使用<code>fdisk -l</code>确定要对哪个硬盘进行分区，确定该盘的盘符为<code>/dev/sda，</code>磁盘的空间大于 2T，不能用直接用<code>fdisk</code>分区，应当使用<code>parted</code>创建分区。</p><p>选择要分区的硬盘：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line"><span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mklabel gpt 建立磁盘标签</span></span><br><span class="line">mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">quit</span><br></pre></td></tr></tbody></table></figure><p><strong>格式化分区</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line"><span class="built_in">mkdir</span> disk1</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 disk1</span><br><span class="line">sudo mount /dev/sda1 /mnt/disk1</span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>自动挂载</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 uuid</span></span><br><span class="line">sudo blkid /dev/sda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/etc/fstab</span></span><br><span class="line">UUID=df69e7e4-3ad6-436d-a46d-00a3e90238a9 /mnt/disk1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4 &nbsp;&nbsp;&nbsp;defaults 0 2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>建立软链接</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /mnt/disk1 ~/workspace</span><br></pre></td></tr></tbody></table></figure><p>修改权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R carlyleliu /mnt/disk1</span><br><span class="line">sudo <span class="built_in">chgrp</span> -R carlyleliu /mnt/disk1</span><br></pre></td></tr></tbody></table></figure><h1 id="zsh">zsh</h1><p>powerlevel10k 很香</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 &lt;https://gitee.com/romkatv/powerlevel10k.git&gt; <span class="variable">${ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom}</span>/themes/powerlevel10k</span><br></pre></td></tr></tbody></table></figure><p>然后在。zshrc 中设置：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"powerlevel10k/powerlevel10k"</span></span><br></pre></td></tr></tbody></table></figure><p>如果你想重新配置<code>powerlevel10k</code>，只需要运行<code>p10k configure</code>即可</p><h1 id="zerotier">Zerotier</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S zerotier-one</span><br><span class="line">systemctl start zerotier-one.service</span><br><span class="line">systemctl <span class="built_in">enable</span> zerotier-one.service</span><br><span class="line">sudo zerotier-cli <span class="built_in">join</span> 3efa5cb78a408bf4</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML 类图</title>
      <link href="/next/2019/Note/UML/"/>
      <url>/next/2019/Note/UML/</url>
      
        <content type="html"><![CDATA[<h1 id="uml-类图">UML 类图</h1><h2 id="类示例">类示例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius_;</span><br><span class="line">    Point center_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">double</span> _radius)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(Point _center)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCircumfrence</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml1.png"></p><span id="more"></span><h1 id="基本概念及术语">基本概念及术语</h1><h2 id="可见性visibility">可见性（visibility）</h2><ul><li>- public</li><li>- private</li><li>- protected</li></ul><h2 id="参数的方向parameter-direction">参数的方向（parameter direction）</h2><ul><li>in：用于输入的参数，get the value</li><li>out：用于输出的参数， set the value</li><li>inout：既可作为输入又可作为输出， get the value and set the value</li></ul><h2 id="类成员变量或者函数的类型">类成员（变量或者函数）的类型</h2><ul><li>静态成员，下划线表示</li><li>纯虚函数，斜体</li></ul><h2 id="类关系">类关系</h2><ul><li>Assocation (knows a)</li><li>Dependency (uses a)</li><li>Composition (has a)</li><li>Aggregation (has a)</li><li>Inheritance (is a)</li><li>Class template</li></ul><h1 id="类关系详解">类关系详解</h1><h2 id="assocation关联">assocation（关联）</h2><p>一个对象知道另一个对象的存在，该对象持有另一个对象的<strong>指针</strong>或者<strong>引用</strong>。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml2.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(Y* _ptrY):<span class="built_in">ptrY_</span>(_ptrY) {}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(Y *y)</span> </span>{ ptrY_ = y;}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{ ptrY_-&gt;<span class="built_in">foo</span>();}</span><br><span class="line"><span class="keyword">private</span>/<span class="keyword">public</span>:</span><br><span class="line">    Y* ptrY_;       <span class="comment">// X 类持有 Y 的一个指针，可据此调用 Y 中的成员方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="dependency依赖">dependency（依赖）</h2><p>当类 Y 与类 X 彼此独立，而类 Y 是类 X 成员函数的一个<strong>参数</strong>，或者 X 中成员函数的一个<strong>局部变量</strong>。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml3.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(Y y)</span> </span>{ ...; y.<span class="built_in">foo</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Y&amp; y)</span> </span>{ ...; y.<span class="built_in">foo</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(Y* y)</span> </span>{ ...; y-&gt;<span class="built_in">foo</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> </span>{ ...; Y y; y.<span class="built_in">foo</span>(); }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">()</span> </span>{ Y::<span class="built_in">staticFoo</span>();}</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="aggregation聚合">Aggregation（聚合）</h2><p>聚类发生的场景是：一个类是另一个类的<strong>集合</strong>或者<strong>容器</strong>，但被包含的类与容器本身并不具备相同的生命期，也就是容器销毁时，其包含的内容未必。关联（association）与聚合（aggregation）的不同之处在于，关联关系不存在一个明确的容器包含另外一个类。比如汽车和轮胎的关系，就是一种聚合关系，汽车包含着轮胎的集合，汽车的销毁，轮胎仍然可以存在。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml4.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vectr&lt;Shape*&gt; ptrShapes; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml5.png"></p><h2 id="composition组合">Composition（组合）</h2><p>组合（composition）是聚合（Aggregation）的增强版。组合和聚合的根本不同在于类与其所持有元素的是否具有<strong>相同的生命期</strong>，要求必须相同是一种组合关系。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml6.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    Point center_;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml7.png"></p><h2 id="继承泛化">继承（泛化）</h2><p>类间的继承关系表达的是一种 derived class B is a base class A。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml8.png"></p><h2 id="类模板">类模板</h2><p>类模板意味着泛型类。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml9.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">{...};</span><br><span class="line"></span><br><span class="line">X&lt;Y&gt; a;</span><br></pre></td></tr></tbody></table></figure><h1 id="uml-时序图">UML 时序图</h1><h2 id="时序图的元素">时序图的元素</h2><h3 id="actor角色">Actor（角色）</h3><p>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p><h3 id="object对象">Object（对象）</h3><p>对象位于时序图的顶部，以一个矩形表示。对象的命名方式一般有三种：</p><ul><li>第一种方式包括对象名和类名</li><li>第二中方式只显示类名不显示对象名，即表示他是一个匿名对象</li><li>第三种方式只显示对象名不显示类明</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml10.png"></p><h3 id="lifeline生命线">Lifeline（生命线）</h3><p>生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml11.png"></p><h3 id="focus-of-control控制焦点">Focus of Control（控制焦点）</h3><p>控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml12.png"></p><h3 id="message消息">Message（消息）</h3><p>消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）. 如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml13.png"></p><ul><li><strong>同步消息=调用消息（Synchronous Message）</strong></li></ul><p>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</p><ul><li><strong>异步消息（Asynchronous Message）</strong></li></ul><p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</p><ul><li><strong>返回消息（Return Message）</strong></li></ul><p>返回消息表示从过程调用返回</p><h3 id="self-message自关联消息">Self-Message（自关联消息）</h3><p>表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml14.png"></p><h3 id="combined-fragments组合片段">Combined Fragments（组合片段）</h3><p>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有 13 种，名称及含义如下：</p><h2 id="一个实例">一个实例</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/uml15.png"></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTest &amp; GMock</title>
      <link href="/next/2019/Note/GtestGmock/"/>
      <url>/next/2019/Note/GtestGmock/</url>
      
        <content type="html"><![CDATA[<h1 id="assert_-expect_">ASSERT_ &amp; EXPECT_</h1><h2 id="bool">Bool</h2><table><thead><tr class="header"><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr class="odd"><td>ASSERT_TRUE(condition);</td><td>EXPECT_TRUE(condition);</td><td>condition is true</td></tr><tr class="even"><td>ASSERT_FALSE(condition);</td><td>EXPECT_FALSE(condition);</td><td>condition is false</td></tr></tbody></table><h2 id="value">Value</h2><table><thead><tr class="header"><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr class="odd"><td>ASSERT_EQ(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 == val2</td></tr><tr class="even"><td>ASSERT_NE(val1, val2);</td><td>EXPECT_NE(val1, val2);</td><td>val1 != val2</td></tr><tr class="odd"><td>ASSERT_LT(val1, val2);</td><td>EXPECT_LT(val1, val2);</td><td>val1 &lt; val2</td></tr><tr class="even"><td>ASSERT_LE(val1, val2);</td><td>EXPECT_LE(val1, val2);</td><td>val1 &lt;= val2</td></tr><tr class="odd"><td>ASSERT_GT(val1, val2);</td><td>EXPECT_GT(val1, val2);</td><td>val1 &gt; val2</td></tr><tr class="even"><td>ASSERT_GE(val1, val2);</td><td>EXPECT_GE(val1, val2);</td><td>val1 &gt;= val2</td></tr></tbody></table><h2 id="string">string</h2><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr class="odd"><td>ASSERT_STREQ(str1,str2);</td><td>EXPECT_STREQ(str1,str2);</td><td>the two C strings have the same content</td></tr><tr class="even"><td>ASSERT_STRNE(str1,str2);</td><td>EXPECT_STRNE(str1,str2);</td><td>the two C strings have different contents</td></tr><tr class="odd"><td>ASSERT_STRCASEEQ(str1,str2);</td><td>EXPECT_STRCASEEQ(str1,str2);</td><td>the two C strings have the same content, ignoring case</td></tr><tr class="even"><td>ASSERT_STRCASENE(str1,str2);</td><td>EXPECT_STRCASENE(str1,str2);</td><td>the two C strings have different contents, ignoring case</td></tr></tbody></table><p><strong>注意：“CASE”表明忽略大小写，一个 NULL 指针和空字符串不一样</strong></p><span id="more"></span><h1 id="test">TEST</h1><p>下面以 googletest/samples 中的 sample1_unittest.cc 中的 demo 为例，简单介绍下一个简单计算阶乘函数 Factorial 实现如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Factorial</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">  <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    result *= i;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用法如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三个 TEST 都是属于同一个 test suite，即 FactorialTest</span></span><br><span class="line"><span class="comment">// 正数为一组</span></span><br><span class="line">TEST(FactorialTest, Negative) {</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-5</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-1</span>));</span><br><span class="line">  EXPECT_GT(Factorial(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">TEST(FactorialTest, Zero) {</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">0</span>));</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 负数为一组</span></span><br><span class="line">TEST(FactorialTest, Positive) {</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">1</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, Factorial(<span class="number">2</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">6</span>, Factorial(<span class="number">3</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">40320</span>, Factorial(<span class="number">8</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 sample1_unittest.cc 的 main 函数中，添加 RUN_ALL_TESTS 函数即可。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Running main() from %s\\n"</span>, __FILE__);</span><br><span class="line">  testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 TEST 宏函数中，也可以像个普通函数一样，定义变量之类的行为。</p><p>比如在 sample2_unittest.cc 中，测试一个自定义类 MyString 的复制构造函数是否表现正常：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> kHelloString[] = <span class="string">"Hello, world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 TEST 内部，定义变量</span></span><br><span class="line">TEST(MyString, CopyConstructor) {</span><br><span class="line">  <span class="type">const</span> MyString <span class="title function_">s1</span><span class="params">(kHelloString)</span>;</span><br><span class="line">  <span class="type">const</span> MyString s2 = s1;</span><br><span class="line">  EXPECT_EQ(<span class="number">0</span>, <span class="built_in">strcmp</span>(s2.c_string(), kHelloString));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="test_f">TEST_F</h1><p>下面介绍 gtest 中更为高级的功能：test fixture，对应的宏函数是 TEST_F(TestFixtureName, TestName)。</p><p>fixture，其语义是固定的设施，而 test fixture 在 gtest 中的作用就是为每个 TEST 都执行一些同样的操作。</p><p>比如，要测试一个队列 Queue 的各个接口功能是否正常，因此就需要向队列中添加元素。如果使用一个 TEST 函数测试 Queue 的一个接口，那么每次执行 TEST 时，都需要在 TEST 宏函数中定义一个 Queue 对象，并向该对象中添加元素，就很冗余、繁琐。</p><p>怎么避免这部分冗余的过程？</p><p>TEST_F 就是完成这样的事情，它的第一个参数 TestFixtureName 是个类，需要继承 testing::Test，同时根据需要实现以下两个虚函数：</p><ul><li>virtual void SetUp()：在 TEST_F 中测试案例之前运行；</li><li>virtual void TearDown()：在 TEST_F 之后运行。</li></ul><p>可以类比对象的构造函数和析构函数。这样，同一个 TestFixtureName 下的每个 TEST_F 都会先执行 SetUp，最后执行 TearDwom。</p><p>此外，testing::Test 还提供了两个 static 函数：</p><ul><li>static void SetUpTestSuite()：在第一个 TEST 之前运行</li><li>static void TearDownTestSuite()：在最后一个 TEST 之后运行</li></ul><p>以 sample3-inl 中实现的 class Queue 为例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTestSmpl3</span> :</span> public testing::Test { <span class="comment">// 继承了 testing::Test</span></span><br><span class="line">protected:  </span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">SetUpTestSuite</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"run before first case..."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  } </span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">TearDownTestSuite</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"run after last case..."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">SetUp</span><span class="params">()</span> override {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter into SetUp()"</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    q1_.Enqueue(<span class="number">1</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">2</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">3</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">TearDown</span><span class="params">()</span> override {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"exit from TearDown"</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> <span class="title function_">Double</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*n;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">MapTester</span><span class="params">(<span class="type">const</span> Queue&lt;<span class="type">int</span>&gt; * q)</span> {</span><br><span class="line">    <span class="type">const</span> Queue&lt;<span class="type">int</span>&gt; * <span class="type">const</span> new_q = q-&gt;Map(Double);</span><br><span class="line"></span><br><span class="line">    ASSERT_EQ(q-&gt;Size(), new_q-&gt;Size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QueueNode&lt;<span class="type">int</span>&gt;*n1 = q-&gt;Head(), *n2 = new_q-&gt;Head();</span><br><span class="line">         n1 != nullptr; n1 = n1-&gt;next(), n2 = n2-&gt;next()) {</span><br><span class="line">      EXPECT_EQ(<span class="number">2</span> * n1-&gt;element(), n2-&gt;element());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    delete new_q;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q2_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>下面是 sample3_unittest.cc 中的 TEST_F：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in sample3_unittest.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the default c'tor.</span></span><br><span class="line">TEST_F(QueueTestSmpl3, DefaultConstructor) {</span><br><span class="line">  <span class="comment">// !!! 在 TEST_F 中可以使用 QueueTestSmpl3 的成员变量、成员函数 </span></span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q0_.Size());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Dequeue().</span></span><br><span class="line">TEST_F(QueueTestSmpl3, Dequeue) {</span><br><span class="line">  <span class="type">int</span> * n = q0_.Dequeue();</span><br><span class="line">  EXPECT_TRUE(n == nullptr);</span><br><span class="line"></span><br><span class="line">  n = q1_.Dequeue();</span><br><span class="line">  ASSERT_TRUE(n != nullptr);</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q1_.Size());</span><br><span class="line">  delete n;</span><br><span class="line"></span><br><span class="line">  n = q2_.Dequeue();</span><br><span class="line">  ASSERT_TRUE(n != nullptr);</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">1u</span>, q2_.Size());</span><br><span class="line">  delete n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the Queue::Map() function.</span></span><br><span class="line">TEST_F(QueueTestSmpl3, Map) {</span><br><span class="line">  MapTester(&amp;q0_);</span><br><span class="line">  MapTester(&amp;q1_);</span><br><span class="line">  MapTester(&amp;q2_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以 TEST_F(QueueTestSmpl3, DefaultConstructor) 为例，再具体讲解下 TEST_F 的运行流程：</p><ul><li>gtest 构造一个 QueueTestSmpl3 对象 t1；</li><li>t1.setUp 初始`t1</li><li>第一个 TEST_F 即 DefaultConstructor 开始运行并结束</li><li>t1.TearDwon 运行，用于清理工作</li></ul><h1 id="expect_call">EXPECT_CALL</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_CALL(mock_object, method(matcher))</span><br><span class="line">.Times(cardinality)</span><br><span class="line">.WillOnce(action)</span><br><span class="line">.WillRepeatedly(action);</span><br></pre></td></tr></tbody></table></figure><ul><li>第一行中 (matcher) 是可有可无的，只有存在函数同名重载的情况下，(matcher) 才是必须的，用于匹配入参格式</li><li>第二行也是可有可无的，cardinality 表示函数应该被调用的次数。常见的有：Times(n) 应该被调用 n 次；Times(::testing::AtLeast(n)) 至少应该被调用 n 次</li><li>第三行和第四行，表示做一次或重复做 action。常见的 action 有：:testing::Return(n) 表示返回一个数字</li></ul><p>例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_CALL(mock_if_impl, some_func)</span><br><span class="line">    .Times(::testing::AtLeast(<span class="number">1</span>))</span><br><span class="line">    .WillOnce(::testing::Return(<span class="literal">true</span>));</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QCC518x 开发环境搭建</title>
      <link href="/next/2019/Note/QCC518x/"/>
      <url>/next/2019/Note/QCC518x/</url>
      
        <content type="html"><![CDATA[<h1 id="软件安装">软件安装</h1><p>需要安装 visual studio c++ 2010 redistributable</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9MjY5OTk=">Microsoft Visual C++ 2010 Service Pack 1 Redistributable Package MFC Security Update<i class="fa fa-external-link-alt"></i></span></p><h1 id="编译出错路径">编译出错（路径）</h1><p>需要将 sdk 尽量放到根目录下，路径名不要太长不然会出现编译出错的问题。</p><span id="more"></span><h1 id="python-脚本对-ascii-解析出错">python 脚本对 ascii 解析出错</h1><p>修改 C:_Toolkit_1.2.15.35_x64[build.py](http://build.py)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Copyright (c) 2016 - 2021 Qualcomm Technologies International, Ltd</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract build system option from command line</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    reload(sys)</span><br><span class="line">    sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line">    index = argv.index(<span class="string">'--build_system'</span>, <span class="number">1</span>)</span><br><span class="line">    build_system = argv[index+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">    <span class="comment"># Extract build system option from environment</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> environ</span><br><span class="line">    build_system = environ.get(<span class="string">'__BUILD_SYSTEM__'</span>, <span class="string">'make'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> build_system == <span class="string">'scons'</span>:</span><br><span class="line">    <span class="keyword">from</span> maker.build_scons <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">from</span> builder.build <span class="keyword">import</span> *</span><br></pre></td></tr></tbody></table></figure><p>修改 C:_Toolkit_1.2.15.35_x64[ubuild.py](http://ubuild.py)</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Qcc518x.png"></p><p>在 173 行之前添加：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叶赛宁</title>
      <link href="/next/2019/Literature/Yesaining/"/>
      <url>/next/2019/Literature/Yesaining/</url>
      
        <content type="html"><![CDATA[<h1 id="不惋惜不呼唤我也不啼哭叶赛宁">😗不惋惜，不呼唤，我也不啼哭（叶赛宁）</h1><p>不惋惜，不呼唤，我也不啼哭，</p><p>一切将逝去……如苹果花丛的薄雾</p><span id="more"></span><p>金黄的落叶堆满我心间——</p><p>我已经再不是青春少年。</p><p>心儿啊，你已开始悄悄冷却，</p><p>如今再不会那样地跳跃：</p><p>这白桦的图案织成的家园，</p><p>再不能吸引我赤脚留连。</p><p>流浪者的激情哪！越来越不见你，</p><p>促使我轻轻吐出火热的言语。</p><p>啊，我的白白流逝的华年！</p><p>迸发的憎恨和奔放的情感！</p><p>如今我已倦于期待未来，</p><p>生活呀，难道你是一场幻梦？</p><p>仿佛我曾在喧闹的春晨</p><p>在玫瑰色的骏马上尽情驰骋。</p><p>槭树的黄叶落地无声，</p><p>世人都必将腐朽无踪……</p><p>天下的众生啊，你们生生不息，</p><p>我愿你永远美好、繁荣！</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ucos 相关实现</title>
      <link href="/next/2019/Program/ucosDesign/"/>
      <url>/next/2019/Program/ucosDesign/</url>
      
        <content type="html"><![CDATA[<h1 id="ucos-优先级调度算法">ucos 优先级调度算法</h1><h2 id="保证调度延迟的确定性">保证调度延迟的确定性</h2><p>普通查表法会从头开始遍历数组，这样就绪态最高优先级的 task 会比就绪态优先级低的 task 先被查找到，造成不同优先级 task 在调度上花费时间不一致的情况，这违背了实时性的原则。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/RTOS_Sche_issue.png"></p><span id="more"></span><h2 id="ucos-调度原理">ucos 调度原理</h2><p>为了确保调度延迟一致性，ucos 采用了空间换取时间的算法在相同时间里查找到不同优先级 task，具体算法如下。 整个算法由两个变量、两个表格和三个程序组成：两个变量是 OSRdyGrp 和 OSRdyTbl[]; 两个表格是位掩码表 OSMapTbl[] 和优先级判定表 OSUnMap[]，三个程序分别是使 task 进入就绪、脱离就绪、寻找就绪态最高优先级 task。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/prio_table.jpg"> <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/os_map_tbl.jpg"></p><p>使 task 进入就绪态的程序如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 prio 优先级放入就绪态优先级表中 */</span></span><br><span class="line">OSRdyGrp = OSMapTbl[prio&gt;&gt;<span class="number">3</span>];               <span class="comment">//设置就绪态优先级组标志</span></span><br><span class="line">OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] |= OSMapTbl[prio&amp;<span class="number">0x07</span>];   <span class="comment">//设置就绪态优先级组内的位标志</span></span><br></pre></td></tr></tbody></table></figure><p>就是将 OSRdyTbl 相应元素的相应位置位，使 task 脱离就绪状态就是将相应位置零，程序如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 prio 优先级从就绪态优先级表中删除 */</span></span><br><span class="line"><span class="keyword">if</span>(OSRdyTbl[prio&gt;&gt;<span class="number">3</span>] &amp;=~OSMapTbl[prio &amp; <span class="number">0x07</span>]) == <span class="number">0</span>)</span><br><span class="line">    OSRdyGrp &amp;=~ OSMapTbl[prio&gt;&gt;<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure><p>变量 OSRdyGrp 的每一位就代表一个组。</p><h2 id="查找最高优先级-task">查找最高优先级 task</h2><p>task 优先级计算公式 <span class="math inline">\(prio=y*8+x\)</span> ，其中 y=OSRdyGrp 最高优先级的 task 在 OSRdyGrp 的最低不为 0 的位的那个组，在这个组里优先级最高的 task 在组内最低不为 0 的位，因此寻找最高优先级 task 就相当于寻找这两个变量里最低不为 0 的位。接下来就是通过 OSUnMapTbl[] 数组来查找最低位不为 0 的位的数组：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">INT8U <span class="type">const</span> OSUnMapTbl[<span class="number">256</span>] = {</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x00 to 0x0F */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x10 to 0x1F */</span></span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x20 to 0x2F */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x30 to 0x3F */</span></span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x40 to 0x4F */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x50 to 0x5F */</span></span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x60 to 0x6F */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x70 to 0x7F */</span></span><br><span class="line">    <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x80 to 0x8F */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0x90 to 0x9F */</span></span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0xA0 to 0xAF */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0xB0 to 0xBF */</span></span><br><span class="line">    <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0xC0 to 0xCF */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0xD0 to 0xDF */</span></span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">/* 0xE0 to 0xEF */</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>  <span class="comment">/* 0xF0 to 0xFF */</span></span><br><span class="line">}；</span><br></pre></td></tr></tbody></table></figure><p>这个表格里的数据很奇怪，好像没什么规律，其实这些数据是 0x00-0xff 这些数据中最低位不为 0 的位数详细如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00 ==00000000b 最低位为 1 的位数为 bit0；</span><br><span class="line">0x01 ==00000001b 最低位为 1 的位数为 bit0；</span><br><span class="line">0x02 ==00000010b 最低位为 1 的位数为 bit1；</span><br><span class="line">0x03 ==00000011b 最低位为 1 的位数为 bit0；</span><br><span class="line">0x04 ==00000100b 最低位为 1 的位数为 bit2；</span><br><span class="line">0x05 ==00000101b 最低位为 1 的位数为 bit0；</span><br></pre></td></tr></tbody></table></figure><p>以此类推就得到 OSUnMapTbl 表格。最高优先级 task 就是在优先级组和位里找到最低位不为 0 的位并组合位一个完整的优先级，计算如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算就绪态最高优先级 */</span></span><br><span class="line">y&nbsp;= OSUnMapTbl[OSRdyGrp];</span><br><span class="line">x = OSUnMapTbl[OSRdyTbl[y]];</span><br><span class="line">OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="number">3</span>) + x);</span><br></pre></td></tr></tbody></table></figure><p>这就是用空间换时间的算法，可以保障寻找到最高优先级 task 的时间相同。</p><h2 id="调度过程">调度过程</h2><p>操作系统提供的一个基本功能就是多 task 运行，而多 task 运行实质上是轮询占用 CPU。task 的调度就是利用中断来进行 task 之间的切换，周期性进入中断函数，然后选择一个合适的 task 运行就是操作系统的 task 调度算法。调度算法是操作系统的一项核心功能，ucos 操作系统是基于优先级的可剥夺内核调度，即 task 的调度基于 task 的优先级，同时高优先级 task 可以抢占低优先级 task 运行，因此，每个 task 在运行完需要一个延时以将 cpu 资源让给其他低优先级 task。ucos 的 task 调度分为两种方式：一种是 task 级的调度由函数 OS_SChed() 函数完成，另一种是中断级的调度由函数 OSIntExt() 函数完成，本文只分析 task 级调度：</p><h3 id="os_sched-函数">OS_Sched 函数：</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">OS_Sched</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">    OS_CPU_SR  cpu_sr = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    OS_ENTER_CRITICAL();</span><br><span class="line">    <span class="keyword">if</span> (OSIntNesting == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (OSLockNesting == <span class="number">0</span>) {</span><br><span class="line">            OS_SchedNew();</span><br><span class="line">            <span class="keyword">if</span> (OSPrioHighRdy != OSPrioCur) {</span><br><span class="line">                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_TASK_PROFILE_EN &gt; 0</span></span><br><span class="line">                OSTCBHighRdy-&gt;OSTCBCtxSwCtr++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                OSCtxSwCtr++;</span><br><span class="line">                OS_TASK_SW();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    OS_EXIT_CRITICAL();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数主要完成以下工作：</p><ul><li><p>定义关中断方式：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR cpu_sr = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>定义第三种方法开关中断，这里插入讲解一下 os 开关中断的三种方式，</p><ul><li>第一种是利用 cpu 自带的总中断寄存器来实现开关全局中断，优点是实现方便缺点是总中断有可能原本就是关着的，在调用完会将全局中断打开。</li><li>第二种开关全局中断的方式是利用堆栈保存中断的状态，关中断后恢复之前的中断状态，解决了第一种中断的弊端。</li><li>第三种方法是定义一个局部变量 cpu_sr 来保存 PSW 再关中断之后再恢复 cpu_sr 到 PSW 程序状态寄存器中。</li></ul></li><li><p>关中断：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_ENTER_CRITICAL();</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>判断是否在中断里或调度器是否上锁，是就执行一次调度：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OSIntNesting == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (OSLockNesting == <span class="number">0</span>) {</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>判断当前 task 是否是就绪的最高优先级 task 以减少 task 调度带来的额外开销：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OSPrioHighRdy != OSPrioCur)</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>将准备就绪的最高优先级 task 指向该该 task 的 task 控制块：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>task 切换统计计数器加一：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSCtxSwCtr++;</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>task 切换：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_TASK_SW();</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>开中断：</p><p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_EXIT_CRITICAL();</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h3 id="os_task_sw-函数">OS_TASK_SW 函数</h3><p>下面介绍 OS_TASK_SW() 函数，task 级调度其实就是认为模拟一次中断分两步进行，第一步是将被挂起 task 的 CPU 寄存器压入堆栈，第二步是将准备就绪的最高优先级 task 的寄存器从 task 堆栈中恢复到寄存器中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OSCtxSw</span><br><span class="line">LDR R0, =NVIC_INT_CTRL ; Trigger the PendSV exception (causes context switch)</span><br><span class="line">LDR R1, =NVIC_PENDSVSET</span><br><span class="line">STR R1, [R0]</span><br><span class="line">BX LR</span><br></pre></td></tr></tbody></table></figure><p>OS_TASK_SW() 是一个宏定义他实际上是 OSCtxSw 汇编代码的宏定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NVIC_INT_CTRL EQU 0xE000ED04</span><br><span class="line"></span><br><span class="line">NVIC_PENDSVSET EQU 0x10000000</span><br></pre></td></tr></tbody></table></figure><p>这段汇编代码是为了触发 PendSV 异常，进入异常指令代码去执行，通过查询我们发现跳转到 OS_CPU_PendSVHandler 处执行，代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">OS_CPU_PendSVHandler</span><br><span class="line">CPSID I ; Prevent interruption during context switch</span><br><span class="line">MRS R0, PSP ; PSP is process stack pointer</span><br><span class="line">CBZ R0, OS_CPU_PendSVHandler_nosave ; Skip register save the first time</span><br><span class="line"></span><br><span class="line">SUBS R0, R0, #0x20 ; Save remaining regs r4-11 on process stack</span><br><span class="line">STM R0, {R4-R11}</span><br><span class="line"></span><br><span class="line">LDR R1, =OSTCBCur ; OSTCBCur-&gt;OSTCBStkPtr = SP;</span><br><span class="line">LDR R1, [R1]</span><br><span class="line">STR R0, [R1] ; R0 is SP of process being switched out; At this point, entire context of process has been saved</span><br><span class="line">OS_CPU_PendSVHandler_nosave</span><br><span class="line">PUSH {R14} ; Save LR exc_return value</span><br><span class="line">LDR R0, =OSTaskSwHook ; OSTaskSwHook();</span><br><span class="line">BLX R0</span><br><span class="line">POP {R14}</span><br><span class="line"></span><br><span class="line">LDR R0, =OSPrioCur ; OSPrioCur = OSPrioHighRdy;</span><br><span class="line">LDR R1, =OSPrioHighRdy</span><br><span class="line">LDRB R2, [R1]</span><br><span class="line">STRB R2, [R0]</span><br><span class="line"></span><br><span class="line">LDR R0, =OSTCBCur ; OSTCBCur = OSTCBHighRdy;</span><br><span class="line">LDR R1, =OSTCBHighRdy</span><br><span class="line">LDR R2, [R1]</span><br><span class="line">STR R2, [R0]</span><br><span class="line"></span><br><span class="line">LDR R0, [R2] ; R0 is new process SP; SP = OSTCBHighRdy-&gt;OSTCBStkPtr;</span><br><span class="line">LDM R0, {R4-R11} ; Restore r4-11 from new process stack</span><br><span class="line">ADDS R0, R0, #0x20</span><br><span class="line">MSR PSP, R0 ; Load PSP with new process SP</span><br><span class="line">ORR LR, LR, #0x04 ; Ensure exception return uses process stack</span><br><span class="line">CPSIE I</span><br><span class="line">BX LR ; Exception return will restore remaining context</span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure><p>总结起来就是将当前寄存器保存到当前查询堆栈中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTCPHightRdy-&gt;OSTCBsTKpTR</span><br></pre></td></tr></tbody></table></figure><p>获取到就绪态最高优先级 task 的 SP 并将其恢复到 CPU SP 寄存器中，将其他寄存器弹出执行中断返回，当前寄存器环境 sp，pc 等就是要切换 task 的环境值，运行代码就是切换后的 task，操作系统实现了 task 调度。</p><h1 id="同步的实现">同步的实现</h1><p>同步的手段有很多这里以事件控制块及其处理函数为例来说明，其他同步手段实现原理是相同的只是根据不同的需求做了响应的设计。</p><h2 id="事件控制块">事件控制块</h2><p>事件同步和资源同步都是通过事件控制块 ECB 结构来管理的，对于事件或者资源的请求或者释放伴随着 task 的挂起和恢复。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">os_event</span> {</span></span><br><span class="line">    INT8U    OSEventType;                    <span class="comment">/*事件类型 Type of event control block (see OS_EVENT_TYPE_xxxx)    */</span></span><br><span class="line">    <span class="type">void</span>    *OSEventPtr;                     <span class="comment">/*指向消息或者消息队列的指针 Pointer to message or queue structure     */</span></span><br><span class="line">    INT16U   OSEventCnt;                     <span class="comment">/*计数器 Semaphore Count (not used if other EVENT type)          */</span></span><br><span class="line">    OS_PRIO  OSEventGrp;                     <span class="comment">/*等待 task 所在的组 Group corresponding to tasks waiting for event to occur */</span></span><br><span class="line">    OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];  <span class="comment">/*等待 task 列表 List of tasks waiting for event to occur                */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_EVENT_NAME_EN &gt; 0u</span></span><br><span class="line">    INT8U   *OSEventName;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">} OS_EVENT;</span><br></pre></td></tr></tbody></table></figure><ul><li>OSEventPtr 指针，只有在所定义的事件是邮箱或者消息队列时才使用。当所定义的事件是邮箱时，它指向一个消息，而当所定义的事件是消息队列时，它指向一个数据结构。</li><li>OSEventTbl[] 和 OSEventGrp 很像前面讲到的 OSRdyTbl[] 和 OSRdyGrp，只不过前两者包含的是等待某事件的 task，而后两者包含的是系统中处于就绪状态的 task。</li><li>OSEventCnt 当事件是一个信号量时，.OSEventCnt 是用于信号量的计数器。</li><li>OSEventType 定义了事件的具体类型。它可以是信号量（OS_EVENT_SEM）、邮箱（OS_EVENT_TYPE_MBOX）或消息队列（OS_EVENT_TYPE_Q）中的一种。用户要根据该域的具体值来调用相应的系统函数，以保证对其进行的操作的正确性。</li></ul><p>对于等待事件任务的记录，uC/OS-II 又使用了与任务就绪表类似的位图，即定义了一个 UINT8 类型的数组 OSEventTbl[] 来作为等待事件任务的记录表，即等待任务表。</p><p>等待任务表仍然以任务的优先级别为顺序为每个任务分配一个二进制位，并用该位为 1 来表示这一位对应的任务为事件的等待任务，否则不是等待任务。同样，为了加快对该表的访问速度，也定义了一个 UINT8 类型的变量 OSEventGrp 来表示等待任务表中的任务组。等待任务表 OSEventTbl[] 与变量 OSEventGrp 的示意图如图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/RTOS_ECB.png"></p><p>至于等待任务的等待时限，则记录在等待任务的任务控制块 TCB 的成员 OSTCBDIy 中并在每个时钟节拍中断服务程序中对该数据进行维护。每当有任务的等待时限到时，将该务从等待任务表中删除，并使它进入就绪状态。</p><h2 id="空事件控制块链表">空事件控制块链表</h2><p>在μC/OS-II 初始化时，系统在初始化函数 OSnit() 中创建 OS_MAX_EVEINTS 个空事件控制块并借用成员 OSEventPtr 作为链接指针，把这些空事件控制块链接成一个如图 5-11 所示的单向链表。由于链表中的所有控制叫做空事件控制块且尚未与具体事件相关联，因此该链表叫空事件控制块链表。以后，每当应用程序创建一个事件时，系统就会从链表中取出一个事件控制块，并对事件控制块进行初始化以描述该事件。而当用程序删除一个事件时，就会将该事件控制块归还给空事件控制块链表。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/RTOS/rtos_event_list.png"></p><h2 id="操作函数">操作函数</h2><p>当 task 请求一个事件的时候（OS_EventTaskWait()），而该事件正好被另一个 task 持有，那么当前 task 就会挂起放到 OSEventTbl 和 OSEventGrp 里。在持有事件的 task 释放事件的时候会再将请求该事件的 task 唤醒 (OS_EventTaskRdy())。从而实现两个 task 之间的同步（事件或资源）。</p><p>其他信号量、互斥信号量、消息队列、消息邮箱等实现原理是相同的，这里不再一一列出了。</p><h1 id="统计-task">统计 task</h1><p>ucos 计算 CPU 利用率的实现方法是：</p><ul><li>在运行 task 之前计算出空闲 task 运行的最大速率 OSIdleCtrMax。</li><li>求出 task 运行时空闲 task 计数器的计数速率 OSIdleCtr。</li><li>利用公式求出 CPU 利用率就是 OSIdleCtr/OSIdleCtrMax * 100%。</li></ul><p>就是通过计算 cpu 进入空闲 task 的比例来推算出 cpu 利用率。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSCPUUsage   = (INT8U)(<span class="number">100L</span> - OSIdleCtrRun / OSIdleCtrMax);</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《嵌入式实时操作系统 ucos-ii 教程》<br>《周慈航-基于嵌入式实时操作系统的程序设计技术》<br>《嵌入式实时操作系统μCOS-II原理及应用-任哲》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> ucos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宋词-其他</title>
      <link href="/next/2019/Literature/SongciOther/"/>
      <url>/next/2019/Literature/SongciOther/</url>
      
        <content type="html"><![CDATA[<h1 id="长相思汴水流">长相思·汴水流</h1><p>白居易</p><p>汴水流，泗水流，流到瓜州古渡头。吴山点点愁。</p><p>思悠悠，恨悠悠，恨到归时方始休。月明人倚楼。</p><span id="more"></span><h1 id="浪淘沙借问江潮与海水">浪淘沙·借问江潮与海水</h1><p>白居易</p><p>借问江潮与海水，何似君情与妾心？</p><p>相恨不如潮有信，相思始觉海非深。</p><h1 id="花非花">花非花</h1><p>白居易</p><p>花非花，雾非雾。</p><p>夜半来，天明去。</p><p>来如春梦几多时？</p><p>去似朝云无觅处。</p><h1 id="忆江南江南好">忆江南·江南好</h1><p>白居易</p><p>江南好，风景旧曾谙。日出江花红胜火，春来江水绿如蓝。能不忆江南？</p><h1 id="十二月二日夜梦游沈氏园亭">十二月二日夜梦游沈氏园亭</h1><p>陆游</p><p>城南小陌又逢春，只见梅花不见人。</p><p>玉骨久成泉下土，墨痕犹锁壁间尘。</p><h1 id="卜算子咏梅">卜算子·咏梅</h1><p>陆游</p><p>驿外断桥边，寂寞开无主。已是黄昏独自愁，更著风和雨。</p><p>无意苦争春，一任群芳妒。零落成泥碾作尘，只有香如故。</p><h1 id="诉衷情当年万里觅封侯">诉衷情·当年万里觅封侯</h1><p>陆游</p><p>当年万里觅封侯，匹马戍梁州。关河梦断何处？尘暗旧貂裘。</p><p>胡未灭，鬓先秋，泪空流。此生谁料，心在天山，身老沧洲。</p><h1 id="鹊桥仙华灯纵博">鹊桥仙·华灯纵博</h1><p>陆游</p><p>华灯纵博，雕鞍驰射，谁记当年豪举。酒徒一半取封侯，独去作、江边渔父。</p><p>轻舟八尺，低篷三扇，占断苹洲烟雨。镜湖元自属闲人，又何必、君恩赐与。</p><h1 id="夜游宫记梦寄师伯浑">夜游宫·记梦寄师伯浑</h1><p>陆游</p><p>雪晓清笳乱起。梦游处、不知何地。铁骑无声望似水。想关河，雁门西，青海际。</p><p>睡觉寒灯里。漏声断、月斜窗纸。自许封侯在万里。有谁知，鬓虽残，心未死。</p><h1 id="钗头凤红酥手">钗头凤·红酥手</h1><p>陆游</p><p>红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。</p><p>春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！</p><h1 id="秋波媚七月十六日晚登高兴亭望长安南山">秋波媚·七月十六日晚登高兴亭望长安南山</h1><p>陆游</p><p>秋到边城角声哀，烽火照高台。悲歌击筑，凭高酹酒，此兴悠哉。</p><p>多情谁似南山月，特地暮云开。灞桥烟柳，曲江池馆，应待人来。</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辛弃疾</title>
      <link href="/next/2019/Literature/Xinqiji/"/>
      <url>/next/2019/Literature/Xinqiji/</url>
      
        <content type="html"><![CDATA[<h1 id="西江月遣兴">西江月·遣兴</h1><p>醉里且贪欢笑，要愁那得工夫。</p><p>近来始觉古人书。信著全无是处。</p><p>昨夜松边醉倒，问松我醉何如。</p><p>只疑松动要来扶。以手推松曰去。</p><span id="more"></span><h1 id="清平乐独宿博山王氏庵">清平乐·独宿博山王氏庵</h1><p>绕床饥鼠，蝙蝠翻灯舞。屋上松风吹急雨，破纸窗间自语。</p><p>平生塞北江南，归来华发苍颜。布被秋宵梦觉，眼前万里江山。</p><h1 id="西江月夜行黄沙道中">西江月·夜行黄沙道中</h1><p>明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。</p><p>七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。</p><h1 id="贺新郎别茂嘉十二弟">贺新郎·别茂嘉十二弟</h1><p>别茂嘉十二弟。鹈鴂、杜鹃实两种，见《离骚补注》</p><p>绿树听鹈鴂。更那堪、鹧鸪声住，杜鹃声切。啼到春归无寻处，苦恨芳菲都歇。算未抵、人间离别。马上琵琶关塞黑，更长门、翠辇辞金阙。看燕燕，送归妾。</p><p>将军百战身名裂。向河梁、回头万里，故人长绝。易水萧萧西风冷，满座衣冠似雪。正壮士、悲歌未彻。啼鸟还知如许恨，料不啼清泪长啼血。谁共我，醉明月。</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线相关概念</title>
      <link href="/next/2019/Note/WirelessSummery/"/>
      <url>/next/2019/Note/WirelessSummery/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Linuxwire1.png"></p><h1 id="频谱划分">频谱划分</h1><ul><li>IEEE 802.11b/g 标准工作在 2.4G 频段，频率范围为 2.400—2.4835GHz，共 83.5M 带宽</li><li>划分为 14 个子信道</li><li>每个子信道宽度为 22MHz</li><li>相邻信道的中心频点间隔 5MHz</li><li>相邻的多个信道存在频率重叠（如 1 信道与 2、3、4、5 信道有频率重叠）</li><li>整个频段内只有 3 个（1、6、11）互不干扰信道</li></ul><span id="more"></span><h1 id="接收灵敏度">接收灵敏度</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Linuxwire2.png"></p><h1 id="信道划分">信道划分</h1><p>2.4G 信道中国划分 802.11b 和 802.11g 的工作频段在 2.4GHz（2.4GHz-2.4835GHz），其可用带宽为 83.5MHz，中国划分为 13 个信道，每个信道带宽为 22MHz</p><p>北美/FCC 2.412-2.461GHz(11 信道） 欧洲/ETSI 2.412-2.472GHz(13 信道） 日本/ARIB 2.412-2.(14 信道）</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/Linuxwire3.png"></p><h1 id="ssid-和-bssid">SSID 和 BSSID</h1><h2 id="基本服务集bss">基本服务集（BSS）</h2><p>基本服务集是 802.11 LAN 的基本组成模块。能互相进行无线通信的 STA 可以组成一个 BSS（Basic Service Set） 。如果一个站移出 BSS 的覆盖范围，它将不能再与 BSS 的其它成员通信。</p><h2 id="扩展服务集ess">扩展服务集（ESS）</h2><p>多个 BSS 可以构成一个扩展网络，称为扩展服务集（ESS）网络，一个 ESS 网络内部的 STA 可以互相通信，是采用相同的 SSID 的多个 BSS 形成的更大规模的虚拟 BSS。连接 BSS 的组件称为分布式系统（Distribution System，DS）。</p><h2 id="ssid">SSID</h2><p>服务集的标识，在同一 SS 内的所有 STA 和 AP 必须具有相同的 SSID，否则无法进行通信。</p><p>SSID 是一个 ESS 的网络标识（如：TP_Link_1201)，BSSID 是一个 BSS 的标识，BSSID 实际上就是 AP 的 MAC 地址，用来标识 AP 管理的 BSS，在同一个 AP 内 BSSID 和 SSID 一一映射。在一个 ESS 内 SSID 是相同的，但对于 ESS 内的每个 AP 与之对应的 BSSID 是不相同的。如果一个 AP 可以同时支持多个 SSID 的话，则 AP 会分配不同的 BSSID 来对应这些 SSID。</p><p>BSSID(MAC)&lt;----&gt;SSID</p><h1 id="ap-种类">AP 种类</h1><p>FAT AP 和 FIT AP 比较如下图所示：</p><h1 id="无线接入过程">无线接入过程</h1><p>无线接入过程 STA（工作站）启动初始化、开始正式使用 AP 传送数据帧前，要经过三个阶段才能够接入（802.11MAC 层负责客户端与 AP 之间的通讯，功能包括扫描、接入、认证、加密、漫游和同步等功能）：</p><ul><li>扫描阶段（SCAN）</li><li>认证阶段 (Authentication)</li><li>关联（Association）</li></ul><h2 id="scanning">Scanning</h2><p>802.11 MAC 使用 Scanning 来搜索 AP，STA 搜索并连接一个 AP，当 STA 漫游时寻找连接一个新的 AP，STA 会在在每个可用的信道上进行搜索。</p><h3 id="passive-scanning特点找到时间较长但-sta-节电">Passive Scanning（特点：找到时间较长，但 STA 节电）</h3><p>通过侦听 AP 定期发送的 Beacon 帧来发现网络，该帧提供了 AP 及所在 BSS 相关信息：“我在这里”…</p><h3 id="active-scanning-特点能迅速找到">Active Scanning （特点：能迅速找到）</h3><p>STA 依次在 13 个信道发出 Probe Request 帧，寻找与 STA 所属有相同 SSID 的 AP, 若找不到相同 SSID 的 AP，则一直扫描下去。.</p><h2 id="authentication">Authentication</h2><p>当 STA 找到与其有相同 SSID 的 AP，在 SSID 匹配的 AP 中，根据收到的 AP 信号强度，选择一个信号最强的 AP，然后进入认证阶段。只有身份认证通过的站点才能进行无线接入访问。AP 提供如下认证方法：</p><ul><li>开放系统身份认证 (open-system authentication)</li><li>共享密钥认证 (shared-key authentication)</li><li>WPA PSK 认证（Pre-shared key）</li><li>802.1X EAP 认证</li></ul><h2 id="association">Association</h2><p>当 AP 向 STA 返回认证响应信息，身份认证获得通过后，进入关联阶段。</p><ul><li>STA 向 AP 发送关联请求</li><li>AP 向 STA 返回关联响应</li></ul><p>至此，接入过程才完成，STA 初始化完毕，可以开始向 AP 传送数据帧。</p><h2 id="认证和关联过程">认证和关联过程</h2><p>...</p><h2 id="漫游过程">漫游过程</h2><p>...</p><h1 id="相关命令">相关命令</h1><ul><li><strong>swconfig</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swconfig list</span><br><span class="line">swconfig dev switch0 show | grep <span class="built_in">link</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>iwpriv 命令</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iwpriv ra0 get_mac_table 查看连接用户</span><br><span class="line"></span><br><span class="line">设置白名单：</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> AccessPolicy=1</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> ACLAddEntry=<span class="string">"64:a2:f9:25:4e:32"</span> 该用户被加入白名单</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> ACLShowAll=1</span><br><span class="line">设置为黑名单</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> AccessPolicy=2  之前的白名单用户会变为黑名单用户</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> ACLShowAll=1</span><br><span class="line">清除列表</span><br><span class="line">iwpriv ra0 <span class="built_in">set</span> ACLClearAll=1</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>vnstat</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnstat -l 查看流量</span><br></pre></td></tr></tbody></table></figure><h1 id="dns">dns</h1><h2 id="resolv.conf.auto">resolv.conf.auto</h2><p>来源：由 netifd 生成， netifd 在每次 wan 口 up 事件时，重写该文件。 作用：当 wan 口有包请求 dns 时， foward 到该地址上，从该处获取 dns。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏轼</title>
      <link href="/next/2019/Literature/SuShi/"/>
      <url>/next/2019/Literature/SuShi/</url>
      
        <content type="html"><![CDATA[<h1 id="临江仙">临江仙</h1><p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p><p>长恨此身非我有，何时忘却营营？夜阑风静縠纹平。小舟从此逝，江海寄余生。</p><span id="more"></span><h1 id="西江月世事一场大梦">西江月·世事一场大梦</h1><p>世事一场大梦，人生几度秋凉？夜来风叶已鸣廊。看取眉头鬓上。</p><p>酒贱常愁客少，月明多被云妨。中秋谁与共孤光。把盏凄然北望。</p><h1 id="江城子乙卯正月二十日夜记梦">江城子·乙卯正月二十日夜记梦</h1><p>十年生死两茫茫，不思量，自难忘。</p><p>千里孤坟，无处话凄凉。</p><p>纵使相逢应不识，尘满面，鬓如霜。</p><p>夜来幽梦忽还乡，小轩窗，正梳妆。</p><p>相顾无言，惟有泪千行。</p><p>料得年年肠断处，明月夜，短松冈。</p><h1 id="念奴娇赤壁怀古">念奴娇·赤壁怀古</h1><p>大江东去，浪淘尽，千古风流人物。</p><p>故垒西边，人道是，三国周郎赤壁。</p><p>乱石穿空，惊涛拍岸，卷起千堆雪。</p><p>江山如画，一时多少豪杰。</p><p>遥想公瑾当年，小乔初嫁了，雄姿英发。</p><p>羽扇纶巾，谈笑间，樯橹灰飞烟灭。</p><p>故国神游，多情应笑我，早生华发。</p><p>人生如梦，一尊还酹江月。</p><h1 id="水龙吟次韵章质夫杨花词">水龙吟·次韵章质夫杨花词</h1><p>似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。</p><p>不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。</p><h1 id="水调歌头明月几时有">水调歌头·明月几时有</h1><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</p><p>明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。</p><h1 id="蝶恋花春景">蝶恋花·春景</h1><p>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！</p><p>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</p><h1 id="定风波莫听穿林打叶声">定风波·莫听穿林打叶声</h1><p>三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。</p><p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p><p>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。</p><h1 id="江城子密州出猎">江城子·密州出猎</h1><p>老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。为报倾城随太守，亲射虎，看孙郎。</p><p>酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。</p><h1 id="永遇乐彭城夜宿燕子楼">永遇乐·彭城夜宿燕子楼</h1><p>彭城夜宿燕子楼，梦盼盼，因作此词。</p><p>明月如霜，好风如水，清景无限。曲港跳鱼，圆荷泻露，寂寞无人见。紞如三鼓，铿然一叶，黯黯梦云惊断。夜茫茫，重寻无处，觉来小园行遍。</p><p>天涯倦客，山中归路，望断故园心眼。燕子楼空，佳人何在，空锁楼中燕。古今如梦，何曾梦觉，但有旧欢新怨。异时对，黄楼夜景，为余浩叹。</p><h1 id="浣溪沙游蕲水清泉寺">浣溪沙·游蕲水清泉寺</h1><p>游蕲水清泉寺，寺临兰溪，溪水西流。</p><p>山下兰芽短浸溪，松间沙路净无泥，潇潇暮雨子规啼。</p><p>谁道人生无再少？门前流水尚能西！休将白发唱黄鸡。</p><h1 id="卜算子黄州定慧院寓居作">卜算子·黄州定慧院寓居作</h1><p>缺月挂疏桐，漏断人初静。时见幽人独往来，缥缈孤鸿影。</p><p>惊起却回头，有恨无人省。拣尽寒枝不肯栖，寂寞沙洲冷。</p><h1 id="定风波南海归赠王定国侍人寓娘">定风波·南海归赠王定国侍人寓娘</h1><p>常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。</p><p>万里归来颜愈少，微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR 安装</title>
      <link href="/next/2019/Note/SSRInstall/"/>
      <url>/next/2019/Note/SSRInstall/</url>
      
        <content type="html"><![CDATA[<h1 id="安装并开启ssr">安装并开启SSR</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/flyzy2005/ss-fly</span><br><span class="line"></span><br><span class="line">ss-fly/ss-fly.sh -ssr</span><br><span class="line">...</span><br><span class="line">Congratulations, ShadowsocksR server install completed!</span><br><span class="line">Your Server IP        :  xxx.xxx.xxx.xxx </span><br><span class="line">Your Server Port      :  12210 </span><br><span class="line">Your Password         :  password</span><br><span class="line">Your Protocol         :  origin </span><br><span class="line">Your obfs             :  plain </span><br><span class="line">Your Encryption Method:  aes-256-cfb </span><br><span class="line"></span><br><span class="line">Welcome to visit:https://shadowsocks.be/9.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></tbody></table></figure><h2 id="相关操作ssr命令">相关操作ssr命令</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br><span class="line"></span><br><span class="line">配置文件路径：/etc/shadowsocks.json</span><br><span class="line">日志文件路径：/var/log/shadowsocks.log</span><br><span class="line">代码安装目录：/usr/local/shadowsocks</span><br></pre></td></tr></tbody></table></figure><h2 id="卸载ssr服务">卸载ssr服务</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocksR.sh uninstall</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="一键开启bbr加速">一键开启BBR加速</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -bbr</span><br></pre></td></tr></tbody></table></figure><p>判断BBR加速有没有开启成功。输入以下命令： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果返回值为： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></tbody></table></figure> 则开启成功。<p></p><p>Enjoy...</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 启动优化</title>
      <link href="/next/2019/Debug/LinuxSystemStartOptimization/"/>
      <url>/next/2019/Debug/LinuxSystemStartOptimization/</url>
      
        <content type="html"><![CDATA[<h1 id="启动流程">启动流程</h1><p>Linux 系统当前的启动流程如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brom --&gt; boot0 --&gt; (monitor/secure os) --&gt; uboot --&gt; rootfs --&gt; app</span><br></pre></td></tr></tbody></table></figure><p>brom 固化在 IC 内部，芯片出厂后就无法更改。后续将从 boot0 开始分阶段介绍启动优化的方法。</p><p>对于某些方案，会存在 monitor 或 secure os，这两者耗时很短，略过。</p><span id="more"></span><p>下文涉及到一些配置文件，提前在此说明。</p><p>env 配置文件路径：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdk/device/config/chips/&lt;chip&gt;/configs/&lt;board&gt;/linux/env-&lt;kernel-version&gt;.cfg <span class="comment">#优先级高</span></span><br><span class="line">sdk/device/config/chips/&lt;chip&gt;/configs/default/env.cfg <span class="comment">#优先级低</span></span><br><span class="line">sdk/target/allwinner/&lt;board&gt;/configs/env-&lt;kernel-version&gt;.cfg <span class="comment">#旧 SDK</span></span><br></pre></td></tr></tbody></table></figure><p>sys_config.fex 路径：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sdk/device/config/chips/&lt;chip&gt;/configs/&lt;board&gt;/sys_config.fex <span class="comment">#新 SDK</span></span><br><span class="line">sdk/target/allwinner/&lt;board&gt;/configs/sys_config.fex <span class="comment">#旧 SDK</span></span><br></pre></td></tr></tbody></table></figure><h1 id="测量方法">测量方法</h1><h2 id="printk-time">printk time</h2><p>打开 kernel 配置，使能如下选项：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel hacking ---&gt;</span><br><span class="line">    [*] Show timing information on printks</span><br></pre></td></tr></tbody></table></figure><p>将会在内核的 log 前加入时间戳。</p><p>💡 注：此方法主要用来测量内核启动过程中各个阶段的耗时。</p><h2 id="initcall_debug">initcall_debug</h2><p>修改 env 文件，在 kernel 的 cmdline 中加入参数，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加 initcall_debug 变量</span></span><br><span class="line">initcall_debug=1</span><br><span class="line"><span class="comment"># 将 initcall_debug=${initcall_debug} 加入 setargs_xxx 中，如 setargs_nand， setargs_mmc，</span></span><br><span class="line">setargs_nor， setatgs_nand_ubi 等，</span><br><span class="line">setargs_nand=setenv bootargs console=<span class="variable">${console}</span> earlyprintk=<span class="variable">${earlyprintk}</span> root=<span class="variable">${nand_root</span></span><br><span class="line"><span class="variable">}</span> initcall_debug=<span class="variable">${initcall_debug}</span> init=<span class="variable">${init}</span></span><br></pre></td></tr></tbody></table></figure><p>开启之后，启动中会打印每个 initcall 函数调用及其耗时。</p><p>💡 注：此方法主要用来测量内核 initcall 的耗时。</p><p>一般需同时配置上内核符号表，即 kallsyms 选项，以打印函数名。</p><h2 id="bootgraph">bootgraph</h2><p>在内核源码中自带了一个工具 (scripts/bootgraph.pl) 可用于分析启动时间。</p><ul><li>kernel 编译时需要包含 CONFIG_PRINTK_TIME 选项</li><li>在 kernel cmdline 加上"initcall_debug=1"</li><li>在系统启动完毕后执行"dmesg | perl $(Kernel_DIR)/scripts/bootgraph.pl &gt; output.svg"</li><li>使用 SVG 浏览器（比如 Inkscape， Gimp， Firefox 等）来查看输出文件 output.svg</li></ul><p>💡 注：此方法主要用来测量内核启动过程中各个阶段的耗时。</p><h2 id="bootchart">bootchart</h2><p>bootchart 是一个用于 linux 启动过程性能分析的开源软件工具，在系统启动过程自动收集 CPU 占用率、进程等信息，并以图形方式显示分析结果，可用作指导优化系统启动过程</p><ul><li>修改 kernel cmdline。修改 env 配置文件 （路径见上文说明），将其中的 init 修改为"init=/sbin/bootchartd”</li><li>收集信息。 bootchartd 会从/proc/stat， /proc/diskstat， /proc/[pid]/stat 中采集信息，经过处理后保存为 bootchart.tgz 文件</li><li>转换图片。在 PC 上通过 pybootchartgui.py 工具将 bootchart.tgz 转换为 bootchart.png，方便分析</li></ul><p>💡 注：此方法主要用来测量挂载文件系统到主应用程序启动过程中的耗时。</p><h2 id="gpio-示波器">gpio + 示波器</h2><p>在适当的地方加入操作 gpio 的代码，通过示波器抓取波形得到各阶段耗时。</p><p>💡 注：此方法可用来测量整个启动中各阶段的耗时。</p><h2 id="grabserial">grabserial</h2><p>Grabserial 是 Tim Bird 用 python 写的一个抓取串口的工具，这个工具能够为收到的每一行信息添加上时间戳。可从如下路径下载使用： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RiaXJkMjBkL2dyYWJzZXJpYWw=">https://github.com/tbird20d/grabserial<i class="fa fa-external-link-alt"></i></span></p><p>介绍文档： <span class="exturl" data-url="aHR0cDovL2VsaW51eC5vcmcvR3JhYnNlcmlhbA==">http://elinux.org/Grabserial<i class="fa fa-external-link-alt"></i></span></p><p>常见的用法：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grabserial -v -S -d /dev/ttyUSB0 -e 30 -t</span><br></pre></td></tr></tbody></table></figure><p>如果要在某个字符串重置时间戳，可以使用-m 参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grabserial -v -S -d /dev/ttyUSB0 -e 30 -t -m <span class="string">"Starting kernel"</span></span><br></pre></td></tr></tbody></table></figure><ul><li>-v 显示参数等信息</li><li>-s 跳过对串口的检查</li><li>-d 指定串口，如上述为指定 /dev/ttyUSB0 为操作的串口</li><li>-e 参数指定时间，如上述命令表示抓取 30s 的串口记录</li><li>-t 表示加上时间戳</li><li>-m 匹配到指定字符串就重置时间戳的时间，也就是从 0 开始</li></ul><p>更多配置可以使用 -h 参数查看帮助。</p><p>💡 注：此方法可用来测量整个启动中各阶段的耗时。</p><h1 id="优化方法">优化方法</h1><p>💡 注：本节提供一些优化方法以供参考，并非所有都在 sdk 上集成，主要原因有：</p><ul><li>优化没有止境。需要根据目标来选择优化方法，综合考虑优化效果与优化难度</li><li>优化需要具有针对性。由于各方案 CPU 个数及频率、 flash 类型及大小、 kernel/rootfs 压缩类型与尺寸、所需功能、主应用等的不同，需要针对性的进行优化</li></ul><h2 id="boot0-启动优化">boot0 启动优化</h2><p>boot0 运行在 SRAM，主要功能是对 DRAM 进行初始化，并将 uboot 加载至 DRAM。 对于安全方案来说， boot0 还会对 uboot、 monitor、 secure-os 等进行签名校验。</p><p>boot0 可优化的地方不多，可以做的是：</p><ul><li>关闭串口输出。</li><li>减少检测按键和检测串口的等待时间。</li><li>加载 uboot 的时候，不要先加载后搬运，直接加载到 uboot 的运行地址</li></ul><p>对于 spinor 的方案，还可以直接从 boot0 启动，只需要在 boot0 中加载好 kernel 和 dtb，不需要经过 uboot ，然后直接跳转到 kernel 运行，可节省一定的时间。如果采用 boot0 启动 OS，则 boot0 读取数据量较大，其 flash 驱动也需要进行优化，如提高时钟，开启双线/四线/DMA/Cache 等。</p><h2 id="uboot-启动优化">uboot 启动优化</h2><p>uboot 主要功能是引导内核、量产升级、电源管理、开机音乐/logo、 fastboot 刷机等。</p><ul><li><p>完全去掉 uboot：<br>uboot 的包含很多重要功能，通常会保留。某些情况可以去掉，直接从 boot0 加载内核并启动，可节省一些时间</p></li><li><p>避免 burnkey 的影响：<br>对于启用了 burnkey 支持，且还没使用 DragonSN 工具将 key 烧录进去的板子，每次启动到 uboot 都会尝试跟 PC 端工具交互产生如下 log，带来延时</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1.334]usb burn from boot</span><br><span class="line">...</span><br><span class="line">[1.400]usb prepare ok</span><br><span class="line">usb sof ok</span><br><span class="line">[1.662]usb probe ok</span><br><span class="line">[1.664]usb setup ok</span><br><span class="line">...</span><br><span class="line">[4.698]do_burn_from_boot usb : have no handshake</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果产品不需要 burnkey，可将 sys_config.fex 中的 [target] 下 burn_key 设置为 0。</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[target]</span><br><span class="line">burn_key = 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者使用 DragonSN 工具，烧录一次 key，并设置烧录标志，以使后续启动可跳过检测。</p></li><li><p>提高 CPU 以及 flash 读取频率：<br>可设置 sys_config.fex 中的 [target] 下 boot_clock 来修改 uboot 运行时 CPU 频率 （注：不能超过 SPEC 最大频率）</p><p>对于 spinor/spinand，使用较高的时钟频率（一般是 100M），使用四线模式或者双线模式（看硬件是否支持），提高加载速度</p></li><li><p>关闭串口输出<br>可将 sys_config.fex 中的 [platform] 下 debug_mode 设置为 0 来关闭 uboot 和 boot0 串口输出。</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[platform]</span><br><span class="line">debug_mode = 0</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置此项后，如果还有少量输出，有两个可能的原因：</p><ul><li>第一是这些输出是在读取 sys_config.fex 禁止串口输出流程之前产生</li><li>第二是因为源码中直接使用了 puts 而没有使用 printf</li></ul><p>对于这两者情况，需要修改源码来完全关闭串口输出。</p></li><li><p>修改 kernel 加载位置：<br>如果 uboot 将内核加载到 DRAM 的地址与内核中 load address 不匹配，就需要将内核移动到正确位置，这样会浪费一定的时间。因此，可以直接修改 uboot 加载内核为正确的地址。具体是修改 env 文件 （路径见上文） 的 boot_normal 与 boot_recovery 变量。需要根据不同的内核镜像格式来设置不同的值。</p><p>假设 kernel 的 load address 为 0x40008000。如果使用的是 uImage，也就是在 kernel 的镜像前加了 64 字节，所以 uboot 应该将 kernel 加载到 0x40008000 - 0x40 = 0x40007fc0。</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#uImage/raw</span></span><br><span class="line">boot_normal=sunxi_flash <span class="built_in">read</span> 40007fc0 <span class="variable">${boot_partition}</span>;bootm 40007fc0</span><br><span class="line">boot_recovery=sunxi_flash <span class="built_in">read</span> 40007fc0 recovery;bootm 40007fc0</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果使用的是 boot.img，即 android 的 kernel 格式，其头部大小为 0x800，所以 uboot 应该将 kernel 加载 到 0x40008000 - 0x800 = 40007800。</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#boot.img/raw</span></span><br><span class="line">boot_normal=sunxi_flash <span class="built_in">read</span> 40007800 <span class="variable">${boot_partition}</span>;bootm 40007800</span><br><span class="line">boot_recovery=sunxi_flash <span class="built_in">read</span> 40007800 recovery;bootm 40007800</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果 uboot 加载 kernel 地址与 load address 不匹配， uboot 过程中串口输出可能会有：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loading Kernel Image ... OK</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果是匹配的， uboot 过程中串口输出可能会有：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XIP Kernel Image ... OK</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>修改 kernel 加载大小：<br>最新代码会根据 uImage/boot.img 的头部信息，只读取必要的大小，可忽略此优化项。 对于旧代码， uboot 在加载内核的时候，有些情况会直接将整个分区读取出来。</p><p>就是说假如内核只有 2M，而分区分了 4M 的话， uboot 就会读取 4M。这种情况下，可以将分区大小设置得刚好容纳 下内核，这样可避免 uboot 在加载内核的时候浪费时间。</p><p>可修改 sys_partition*.fex 中 boot 分区的大小。 uboot 具体读出多少，通常会有 log 信息，可同真正内核镜像的 size 进行比较。</p></li><li><p>关闭 kernel 校验：<br>uboot 加载了内核以后，默认会对内核进行校验，可以在串口输出中看到：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Verifying Checksum ... OK</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果不想校验可以去掉，目前的情况是可以减少几十毫秒 （不同平台，不同内核大小，时间不同）的启动时间。</p></li><li><p>uboot 重定位：<br>目前的启动过程中， uboot 在执行过程中会进行一次重定位，可以在串口中打印出这个值，然后修改 uboot 的加载地 址使得 boot0 将 uboot 加载进 DRAM 的时候就直接加载到这个地址。</p><p>修改文件 sdk/lichee/brandy<em>/u-boot</em>/include/configs/sun_iw_p*.h 中的</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define CONFIG_SYS_TEXT_BASE (0x40900000)</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>但这个方法有个弊端，如果后续修改了 uboot 的代码，则可能需要重新设置。</p><p>目前这个操作耗时很少（某平台测得十几毫秒），不必要的话不建议做这个修改</p></li><li><p>裁剪 uboot：<br>即使流程没有简化， uboot 体积的减小也可减少加载 uboot 的时间。 依据具体情况，可对 uboot 不需要的功能的模块进行裁剪，避免了启动中执行不必要的流程，可减少 uboot 加载时间。</p></li><li><p>开启 logo 及音乐：<br>可尝试在 uboot 中开启开机 logo/音乐，尽快播出第一帧/声，提升用户体验。 此操作会延缓到达 OS/APP 的时间，但如果产品定义/用户体验是以第一帧/声为准的话，则有较大价值。</p></li></ul><h2 id="kernel-启动优化">kernel 启动优化</h2><p>通常来说，内核启动耗时较多，需要更深入的优化。</p><h3 id="kernel-压缩方式">kernel 压缩方式</h3><p>比较不同压缩方式的启动时间和 flash 占用情况，选择一种符合实际情况的。此处给出某次测试结果供参考。实际优化的时候，需要重新测试，根据实际情况选择。</p><table><thead><tr class="header"><th>压缩方式</th><th>内核大小（M）</th><th>加载时间（s）</th><th>解压时间（s）</th><th>总时间（s）</th></tr></thead><tbody><tr class="odd"><td>LZO</td><td>2.4</td><td>0.38</td><td>0.23</td><td>0.61</td></tr><tr class="even"><td>GZIP</td><td>1.9</td><td>0.35</td><td>0.44</td><td>0.79</td></tr><tr class="odd"><td>XZ</td><td>1.5</td><td>0.25</td><td>2.17</td><td>2.42</td></tr></tbody></table><h3 id="加载位置">加载位置</h3><p>内核镜像可以由 kernel 自解压，也有 uboot 进行解压的情况。</p><p>对于 kernel 自解压的情况，如果压缩过的 kernel 与解压后的 kernel 地址冲突，则会先把自己复制到安全的地方，然后再解压，防止自我覆盖。这就需要耗费复制的时间。</p><p>比如对于运行地址为 0x80008000 的内核来说， bootloader 可以将其加载到 0x81008000，当然其他位置也可以。</p><h3 id="内核裁剪">内核裁剪</h3><p>裁剪内核，带来的加速是两个方面的。一是体积变小，加载解压耗时减少；二是内核启动时初始化内容变少。</p><p>裁剪要根据产品的实际情况来，将不需要的功能及模块都去掉。具体是执行"make kernel_menuconfig"，关闭不需要的选项。</p><h3 id="预设置-lpj-数值">预设置 lpj 数值</h3><p>LPJ 也就是 loops_per_jiffy，每次启动都会计算一次，但如果没有做修改的话，这个值每次启动算出来都是一样的，可以直接提供数值跳过计算。</p><p>如下 log 所示，有 skipped， lpj 由 timer 计算得来，不需要再校准 calibrate 了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 0.019918] Calibrating delay loop (skipped), value calculated using timer frequency..</span><br><span class="line">48.00 BogoMIPS (lpj=240000)</span><br></pre></td></tr></tbody></table></figure><p>如果没有 skipped，则可以在 cmdline 中添加 lpj=XXX 进行预设。</p><h3 id="initcall-优化">initcall 优化</h3><p>在 cmdline 中设置 initcall_debug=1，即可打印跟踪所有内核初始化过程中调用 initcall 的顺序以及耗时。</p><p>具体修改 env 配置文件（路径见上文），新增一行"initcall_debug=1"，并在"setargs_*"后加入"initcall_debug=${initcall_debug}"，如下所示。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setargs_nand=setenv bootargs console=<span class="variable">${console}</span> console=tty0 root=<span class="variable">${nand_root}</span> init=<span class="variable">${init}</span></span><br><span class="line">loglevel=<span class="variable">${loglevel}</span> partitions=<span class="variable">${partitions}</span> initcall_debug=<span class="variable">${initcall_debug}</span></span><br></pre></td></tr></tbody></table></figure><p>加入后，内核启动时就会有类似如下的打印，对于耗时较多的 initcall，可进行深入优化。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 0.021772] initcall sunxi_pinctrl_init+0x0/0x44 returned 0 after 9765 usecs</span><br><span class="line">[ 0.067694] initcall param_sysfs_init+0x0/0x198 returned 0 after 29296 usecs</span><br><span class="line">[ 0.070240] initcall genhd_device_init+0x0/0x88 returned 0 after 9765 usecs</span><br><span class="line">[ 0.080405] initcall init_scsi+0x0/0x90 returned 0 after 9765 usecs</span><br><span class="line">[ 0.090384] initcall mmc_init+0x0/0x84 returned 0 after 9765 usecs</span><br></pre></td></tr></tbody></table></figure><h3 id="内核-initcall-module-并行">内核 initcall module 并行</h3><p>内核 initcall 有很多级别，其中启动中最耗时的就是各 module 的 initcall，针对多核方案，可以考虑将 module initcall 并行执行来节省时间。</p><p>目前内核 do_initcalls 是一个一个按照顺序来执行，可以修改成新建内核线程来执行。</p><p>💡 注：当前 sdk 还未加入该优化。</p><h3 id="减少-ptytty-个数">减少 pty/tty 个数</h3><p>加入 initcall 打印之后，部分平台发现 pty/tty init 耗时很多，可减少个数来缩短 init 时间。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initcall pty_init+0x0/0x3c4 returned 0 after 239627 usecs</span><br><span class="line">initcall chr_dev_init+0x0/0xdc returned 0 after 36581 usecs</span><br></pre></td></tr></tbody></table></figure><h3 id="内核-module">内核 module</h3><p>需要考虑启动速度的界定，对于内核 module 的优化主要有两点：</p><ul><li>对于必须要加载的模块，直接编译进内核</li><li>对于不急需的功能，可以编译成模块</li></ul><p>比如某个应用，会开启主界面联网，启动速度以出现主界面为准，那么可以考虑将 disp 编入内核， wifi 编译成模块，后续需要时再动态加载</p><h3 id="deferred-initcalls">Deferred Initcalls</h3><p>介绍页面及 patch： <span class="exturl" data-url="aHR0cDovL2VsaW51eC5vcmcvRGVmZXJyZWRfSW5pdGNhbGxz">http://elinux.org/Deferred_Initcalls<i class="fa fa-external-link-alt"></i></span></p><p>打上这个 patch 之后，可以标记一些 initcall 为 Deferred_Initcall。这些被标记的初始化函数，在系统启动的时候不会被调用</p><p>进入文件系统后，在合适的时间，比如启动主应用之后，再通过文件系统接口，启动这些推迟了的调用，彻底完成初始化。</p><h2 id="rootfs-启动优化">rootfs 启动优化</h2><p>rootfs 启动优化主要是优化 rootfs 的挂载到 init 进程执行。</p><h3 id="initramfs">initramfs</h3><p>initramfs 是一个内存文件系统，会占用较多 DRAM。</p><p>部分产品可能会用到 initramfs 来过渡到 rootfs，其优化思路大体与 rootfs 类似。可参考本节后续的优化方案。</p><h3 id="rootfs-类型以及压缩">rootfs 类型以及压缩</h3><p>存储介质、文件系统类型，压缩方式对 rootfs 挂载有很大影响。</p><p>此处给出某次测试结果供参考。实际优化的时候，需要重新测试，根据实际情况选择</p><table><thead><tr class="header"><th>类型</th><th>压缩</th><th>介质</th><th>总时间（s）</th></tr></thead><tbody><tr class="odd"><td>squashfs</td><td>gzip</td><td>emmc</td><td>0.12</td></tr><tr class="even"><td>squashfs</td><td>xz</td><td>emmc</td><td>0.27</td></tr><tr class="odd"><td>squashfs</td><td>xz</td><td>nand</td><td>0.26</td></tr><tr class="even"><td>ext4</td><td>-</td><td>emmc</td><td>0.12</td></tr></tbody></table><h3 id="rootfs-裁剪">rootfs 裁剪</h3><p>文件系统越小，加载速度越快。裁剪的主要思路是：删换压，即删除没有用到的，用小的换大的，选择合适的压缩方式</p><h3 id="指定文件系统类型">指定文件系统类型</h3><p>内核在挂载 rootfs 时，会有一个 try 文件系统类型的过程。可以在 cmdline 直接指定，节省时间。</p><p>具体是在 cmdline 中添加"rootfstype=<type>"，其中 type 为文件系统类型，如 ext4、 squashfs 等。</type></p><h3 id="静态创建-dev-节点">静态创建 dev 节点</h3><p>对于 dev 下面的节点，事先根据实际情况创建好，而不是在系统启动后动态生成，理论上也可以节省一定的时间。</p><h3 id="rootfs-拆分">rootfs 拆分</h3><p>可以将 rootfs 拆分成两个部分，一个小的文件系统先挂载执行，大的文件系统根据需要动态挂载</p><h2 id="主应用程序启动优化">主应用程序启动优化</h2><p>主应用程序主要是由客户开发，因此主导优化的还是客户，这里提一些优化措施：</p><ul><li>提升运行顺序。将应用程序放在 init 很前面执行</li><li>动态/静态链接</li><li>编译选项</li><li>暂时不使用的库采用 dlopen 方式</li><li>应用程序拆分</li></ul><h1 id="参考文献">参考文献</h1><p>[1] <span class="exturl" data-url="aHR0cHM6Ly9lbGludXgub3JnL0Jvb3RfVGltZQ==">https://elinux.org/Boot_Time<i class="fa fa-external-link-alt"></i></span><br>[2] <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmJsYWNrZmluLnVjbGludXgub3JnL2Rva3UucGhwP2lkPWZhc3RfYm9vdF9leGFtcGxl">https://docs.blackfin.uclinux.org/doku.php?id=fast_boot_example<i class="fa fa-external-link-alt"></i></span><br>[3] <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RiaXJkMjBkL2dyYWJzZXJpYWw=">https://github.com/tbird20d/grabserial<i class="fa fa-external-link-alt"></i></span><br>[4] <span class="exturl" data-url="aHR0cDovL3d3dy5ib290Y2hhcnQub3Jn">http://www.bootchart.org<i class="fa fa-external-link-alt"></i></span><br>[5] A Framework for Optimization of the Boot Time on Embedded Linux Environment with Raspberry Pi Platform<br>《全志SDK文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李清照</title>
      <link href="/next/2019/Literature/LiQingzhao/"/>
      <url>/next/2019/Literature/LiQingzhao/</url>
      
        <content type="html"><![CDATA[<h1 id="一剪梅红藕香残玉簟秋">一剪梅·红藕香残玉簟秋</h1><p>红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。</p><p>花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</p><span id="more"></span><h1 id="如梦令常记溪亭日暮">如梦令·常记溪亭日暮</h1><p>常记溪亭日暮，沉醉不知归路。</p><p>兴尽晚回舟，误入藕花深处。</p><p>争渡，争渡，惊起一滩鸥鹭。</p><h1 id="如梦令昨夜雨疏风骤">如梦令·昨夜雨疏风骤</h1><p>昨夜雨疏风骤，浓睡不消残酒。</p><p>试问卷帘人，却道海棠依旧。</p><p>知否，知否？应是绿肥红瘦。</p><h1 id="醉花阴薄雾浓云愁永昼">醉花阴·薄雾浓云愁永昼</h1><p>薄雾浓云愁永昼，瑞脑消金兽。佳节又重阳，玉枕纱橱，半夜凉初透。</p><p>东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。</p><h1 id="南歌子天上星河转">南歌子·天上星河转</h1><p>天上星河转，人间帘幕垂。凉生枕簟泪痕滋。起解罗衣聊问、夜何其。</p><p>翠贴莲蓬小，金销藕叶稀。旧时天气旧时衣。只有情怀不似、旧家时。</p><h1 id="点绛唇蹴罢秋千">点绛唇·蹴罢秋千</h1><p>蹴罢秋千，起来慵整纤纤手。露浓花瘦，薄汗轻衣透。</p><p>见客入来，袜刬金钗溜。和羞走，倚门回首，却把青梅嗅。</p><h1 id="清平乐年年雪里">清平乐·年年雪里</h1><p>年年雪里，常插梅花醉。挼尽梅花无好意，赢得满衣清泪。</p><p>今年海角天涯，萧萧两鬓生华。看取晚来风势，故应难看梅花。</p><h1 id="武陵春春晚">武陵春·春晚</h1><p>风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。</p><p>闻说双溪春尚好，也拟泛轻舟。只恐双溪舴艋舟，载不动许多愁。</p><h1 id="声声慢寻寻觅觅">声声慢·寻寻觅觅</h1><p>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急？雁过也，正伤心，却是旧时相识。</p><p>满地黄花堆积。憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑？梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北岛的诗</title>
      <link href="/next/2019/Literature/NorthIsland/"/>
      <url>/next/2019/Literature/NorthIsland/</url>
      
        <content type="html"><![CDATA[<h1 id="北岛的长诗白日梦的第四节">😭北岛的长诗《白日梦》的第四节</h1><p>你没有如期归来</p><p>而这正是离别的意义</p><span id="more"></span><p>一次爱的旅行</p><p>有时候就象抽烟那样</p><p>简单</p><p>地下室空守着你</p><p>内心的白银</p><p>水仙花在暗中灿然开放</p><p>你听凭所有的坏天气</p><p>发怒、哭喊</p><p>乞求你打开窗户</p><p>书页翻开</p><p>所有的文字四散</p><p>只留下一个数字</p><p>--我的座位号码</p><p>靠近窗户</p><p>本次列车的终点是你</p><h1 id="过节北岛">😧过节（北岛）</h1><p>毒蛇炫耀口中的钉子</p><p>大地有著毒蛇</p><p>吞吃鸟蛋的寂静</p><p>所有钟表</p><p>停止在无梦的时刻</p><p>丰收聚敛着</p><p>田野死后的笑容</p><p>从水银的镜子</p><p>影像成双的人们</p><p>乘家庭的轮子</p><p>去集市</p><p>一位本地英雄</p><p>在废弃的停车场上</p><p>唱歌</p><p>玻璃晴朗</p><p>桔子辉煌</p><h1 id="回答北岛">😶‍🌫️回答（北岛）</h1><p>卑鄙是卑鄙者的通行证，</p><p>高尚是高尚者的墓志铭，</p><p>看吧，在那镀金的天空中，</p><p>飘满了死者弯曲的倒影。</p><p>冰川纪过去了，</p><p>为什么到处都是冰凌？</p><p>好望角发现了，</p><p>为什么死海里千帆相竞？</p><p>我来到这个世界上，</p><p>只带着纸、绳索和身影，</p><p>为了在审判前，</p><p>宣读那些被判决的声音。</p><p>告诉你吧，世界</p><p>我——不——相——信！</p><p>纵使你脚下有一千名挑战者，</p><p>那就把我算作第一千零一名。</p><p>我不相信天是蓝的，</p><p>我不相信雷的回声，</p><p>我不相信梦是假的，</p><p>我不相信死无报应。</p><p>如果海洋注定要决堤，</p><p>就让所有的苦水都注入我心中，</p><p>如果陆地注定要上升，</p><p>就让人类重新选择生存的峰顶。</p><p>新的转机和闪闪星斗，</p><p>正在缀满没有遮拦的天空。</p><p>那是五千年的象形文字，</p><p>那是未来人们凝视的眼睛。</p>]]></content>
      
      
      <categories>
          
          <category> Literature Appreciation </category>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统裁剪</title>
      <link href="/next/2019/Debug/LinuxSystemCropping/"/>
      <url>/next/2019/Debug/LinuxSystemCropping/</url>
      
        <content type="html"><![CDATA[<h1 id="系统裁剪简介">系统裁剪简介</h1><p>固件中通常包含 boot0、 uboot、 kernel、 rootfs 等镜像。基于经验，各个镜像尺寸的量级如下表所示：</p><table><thead><tr class="header"><th>Image</th><th>size</th></tr></thead><tbody><tr class="odd"><td>boot0</td><td>&lt; 100k</td></tr><tr class="even"><td>uboot</td><td>&lt; 1M</td></tr><tr class="odd"><td>kernel</td><td>3-15M</td></tr><tr class="even"><td>rootfs</td><td>&gt; 4M</td></tr></tbody></table><p>可以看到 boot0、 uboot、 kernel、 rootfs 的尺寸是依次增大的。对于大尺寸的裁剪效果往往比小尺寸的裁剪效果明显，比如 rootfs 裁剪 1M 可能很容易，对于 uboot 来说，则非常困难。因此，后续主要介绍 kernel 以及 rootfs 的裁剪。</p><span id="more"></span><h2 id="boot0-裁剪">boot0 裁剪</h2><p>由于 boot0 很小，通常来说 boot0 代码也不开源，因此略过。</p><h2 id="uboot-裁剪">uboot 裁剪</h2><p>uboot 代码位于 sdk/vendor/brandy<em>/u-boot </em>目录下，主要有下面两种裁剪思路：</p><ul><li>修改 uboot 配置文件，删减不需要的配置。 uboot 配置文件通常位于源码下 include/configs/${CHIP}.h 或者 configs/${CHIP}_*_defconfig</li><li>删除不需要的 uboot 命令</li></ul><h2 id="内核裁剪">内核裁剪</h2><p>通常关于 Linux 内核裁剪主要有如下方法：</p><ul><li>删除不使用的功能。如符号表、打印、调试等功能</li><li>删除不使用的驱动</li><li>修改内核源代码</li><li>内核压缩</li></ul><h3 id="删除不使用的功能">删除不使用的功能</h3><p>根据自己的功能需求进行开启或关闭对应模块功能。</p><h3 id="删除不使用的驱动">删除不使用的驱动</h3><p>方案明确之后，所需的内核驱动也明确了。可以执行 make kernel_menuconfig，将没有用到的驱动关闭。</p><h3 id="修改内核源代码">修改内核源代码</h3><p>内核源码庞大，直接修改往往难度很大，可借助相关工具来评估模块以及符号的大小，然后进行针对性的裁剪。</p><ul><li>size 工具</li></ul><p>size 命令可查看内核镜像的 text、 data、 bss 等段的大小。如执行"size vmlinux"，将会得到：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text data bss dec hex filename</span><br><span class="line">5818117 1378944 168972 7366033 706591 vmlinux</span><br></pre></td></tr></tbody></table></figure><ul><li>nm 命令</li></ul><p>nm 命令可查看内核模块中各个符号的尺寸。如执行"nm --size -r vmlinux | head -10"，可得到：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">000b0000 D pwrsv_lgc_tab</span><br><span class="line">00004ad8 T hidinput_connect</span><br><span class="line">00004000 b __log_buf</span><br><span class="line">00003fb4 T __blockdev_direct_IO</span><br><span class="line">00002ba4 t machines</span><br><span class="line">000026a0 b g_fbi</span><br><span class="line">00002120 t test_atomics</span><br><span class="line">00002000 b page_address_maps</span><br><span class="line">00002000 d nmi_print_seq</span><br><span class="line">00002000 D init_thread_union</span><br></pre></td></tr></tbody></table></figure><p>说明，一共有三列数据，分别表示大小、符号类型、符号名。其中符号类型：</p><ul><li>b/B - 符号位于 bss 段</li><li>t/T - 符号位于 text 段</li><li>d/D - 符号位于 data 段</li></ul><p>如果某些函数或者全局变量占用较大，可以进行针对性的优化。</p><h2 id="文件系统裁剪">文件系统裁剪</h2><p>对于文件系统裁剪来说，主要思路是删、换、压。</p><ul><li>删，删除不需要的内容。如帮助文档、没用到的库、调试程序等</li><li>换，使用小尺寸的实现替换大尺寸的实现。如使用 musl libc 库替换 glibc 库等</li><li>压，使用合适的压缩算法</li></ul><h3 id="应用程序及冗余文件裁剪">应用程序及冗余文件裁剪</h3><p>在不影响整体功能的情况下，一些应用程序或冗余文件往往可以删除：</p><ul><li>调试工具。比如 tcpdump、 mpstat、 strace 等等</li><li>性能测试工具。比如 lmbench、 sysstat、 tiobench 等等</li><li>冗余文件。帮助文档、辅助程序、配置文件和数据模块等，又比如很多应用有相同的共能，只留其一</li><li>采用具有通用功能的替代软件包。 Linux 上有许多具有相似功能的软件包，可以选择其中占存储空间较小的软件包并移植到嵌入式设备上</li><li>资源文件。一些音视频以及 UI 资源往往占用很大空间，如果没有用到，也需要删除</li></ul><h3 id="库的裁剪">库的裁剪</h3><p>关于库的裁剪主要有两个思路：</p><ul><li>使用较小的 C 库，如 musl libc， uclibc 等来替换 glibc</li><li>删除没有用到的库</li></ul><h3 id="删除没用到的库">删除没用到的库</h3><p>嵌入式产品通常应用程序有限，因此可能存在很多库不会被用到，可以进行删除。当前 Tina 环境提供了一种删除方法，执行 make menuconfig，打开如下选项</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tina Configuration</span><br><span class="line">    Target Images ---&gt;</span><br><span class="line">        [*] downsize the root filesystem or initramfs</span><br></pre></td></tr></tbody></table></figure><p>打开之后，在生成 rootfs/initramfs 之前会对其中没有用到的库进行删除。</p><p>具体可参考 scripts/reduce-rootfs-size.sh 文件，其主要思路是：</p><ul><li>分析 rootfs 下的应用程序所依赖的库</li><li>分析 “应用程序依赖库” 所依赖的库，一直递归下去，直到完全找出所有依赖的库</li><li>根据上述查找结果，删除没有被依赖的库</li></ul><h3 id="应用程序与库-strip">应用程序与库 strip</h3><p>strip 会去掉应用程序与库的符号信息和调试信息，大大减少空间占用。</p><p>当前 Tina 环境下默认开启了 strip 功能，如果没开启，请确保开启以减少空间占用。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tina Configuration</span><br><span class="line">    Global build settings ---&gt;</span><br><span class="line">        Binary stripping method (strip) ---&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="文件系统压缩">文件系统压缩</h3><p>有些文件系统支持压缩，有些不支持。比较常用的是 squahfs、 ext4、 jfss2 三种文件系统。具体可执行 make menuconfig 进行选择：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tina Configuration</span><br><span class="line">   Target Images ---&gt;</span><br><span class="line">   *** Root filesystem images ***</span><br><span class="line">       [ ] ext4 ----</span><br><span class="line">       [ ] jffs2</span><br><span class="line">       [*] squashfs ---&gt;</span><br></pre></td></tr></tbody></table></figure><p>常见的压缩有 lzop， gzip， xz 等，压缩率最高的是 xz。但是 xz 压缩解压最慢，非常影响启动速度。实际在选择压缩方式时应综合考虑</p><h1 id="参考文献">参考文献</h1><p>[1] <span class="exturl" data-url="aHR0cHM6Ly9lbGludXgub3JnL0tlcm5lbF9TaXplX1R1bmluZ19HdWlkZQ==">https://elinux.org/Kernel_Size_Tuning_Guide<i class="fa fa-external-link-alt"></i></span><br>[2] Karim Yaghmour. Building Embedded Linux Systems [M]<br>[3] Michael Opdenacker. Embedded Linux size reduction techniques<br>[4] <span class="exturl" data-url="aHR0cHM6Ly90aW55Lndpa2kua2VybmVsLm9yZw==">https://tiny.wiki.kernel.org<i class="fa fa-external-link-alt"></i></span><br>《全志SDK文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户空间 backtrace</title>
      <link href="/next/2019/Note/UserapaceBacktrace/"/>
      <url>/next/2019/Note/UserapaceBacktrace/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FRAMES 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc1</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc2</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc3</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printCallers</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> layers = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ** symbols = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> * frames[MAX_FRAMES];</span><br><span class="line">    <span class="built_in">memset</span>(frames, <span class="number">0</span>, <span class="keyword">sizeof</span>(frames));</span><br><span class="line">    layers = backtrace(frames, MAX_FRAMES);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;layers; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Layer %d: %p\\n"</span>, i, frames[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------\\n"</span>);</span><br><span class="line">    </span><br><span class="line">    symbols = backtrace_symbols(frames, layers);</span><br><span class="line">    <span class="keyword">if</span> (symbols) {</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;layers; i++) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"SYMBOL layer %d: %s\\n"</span>, i, symbols[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(symbols);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to parse function names\\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc1</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b = a + <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = myfunc2(b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc2</span><span class="params">(<span class="type">int</span> b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> c = b * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> result = c + myfunc3(c);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfunc3</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">{</span><br><span class="line">    printCallers();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = myfunc1(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\\n"</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><ul><li>backtrace</li></ul><p>backtrace 有 2 个参数，第 1 个参数实际上是一个 void * 类型的数组，将来所有的 frame 信息都会存在这个数组里；第 2 个参数 size 的含义是指明该数组的大小。比如，数组大小为 5，而实际 frames 有 10 层，则只存储最新的 5 个 frames; backtrace 的返回值的含义是究竟返回了多少层的 frames，比如，size 指定为 10，而 frames 只有 5 层，则返回 5； 若 size 指定为 5，而 frames 有 10 层，则也返回 5.</p><ul><li><p>backtrace_symbols</p><p>这个函数用来解析每个 frame 中的函数地址代表的函数名称是什么。它必须要在运行完了上面的 backtrace 函数之后才能用。为什么呢？因为它的第 1 个参数就是被上面的 backtrace 函数填充了的那个 void * 数组。而它的第 2 个参数指的是要解析该 buffer 数组中的几个元素。</p><ul><li>它返回的是一个 char *数组，代表函数名数组，但是返回的这个 char ** 必须要被调用者 free 掉，而该 char * 数组内的每个 char * 是不能被 free 的</li><li>出错情况下返回 NULL</li><li>一般情况下，该函数解析不出函数名；只有在编译的时候加了 “-rdynamic” 选项，将来运行时才能解析出函数名</li></ul></li><li><p>backtrace_symbols_fd</p></li></ul><p>该函数和 backtrace_symbols 类似，都是把函数地址解析成函数名称。不同点在于，它不会返回任何东西，而是把解析出的函数名称写进第 3 个参数，即一个文件描述符。</p><ul><li>其他<ul><li>编译器优化，比如 “-O3”, “-O2” 等，可能会导致调用层次丢失</li><li>inline 函数没有 stack frame ，因此不会被打印出来</li><li>ail-call 优化也会导致函数名称的打印丢失</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内存优化</title>
      <link href="/next/2019/Debug/LinuxMemoryOptimization/"/>
      <url>/next/2019/Debug/LinuxMemoryOptimization/</url>
      
        <content type="html"><![CDATA[<h1 id="内存使用情况分析">内存使用情况分析</h1><h2 id="dram-大小">DRAM 大小</h2><p>硬件上 DDR 确定之后， DRAM 大小就已经确定。</p><p>uboot 会根据 DRAM 驱动提供的接口获取 DRAM 的大小，然后修改 dts 中的 memory 节点，Linux 启动时解析 dts 获取 DRAM 的大小。 uboot 启动 log 中会打印 dram 的大小。比如 R329 方案 uboot 启动时会有如下 log：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[01.300]DRAM: 128 MiB</span><br></pre></td></tr></tbody></table></figure><p>执行： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@TinaLinux:/<span class="comment"># hexdump -C /sys/firmware/devicetree/base/memory@40000000/reg</span></span><br><span class="line">00000000 00 00 00 00 40 00 00 00 00 00 00 00 08 00 00 00 |....@...........|</span><br><span class="line">00000010</span><br></pre></td></tr></tbody></table></figure><p></p><p>也可以获取 dram 的起始地址与大小。如下面 R329 例子所示，其中 0x40000000 为起始地址， 0x08000000 为 dram 的 size.</p><span id="more"></span><h2 id="系统内存使用情况">系统内存使用情况</h2><h3 id="free-命令">free 命令</h3><p>进入 Linux 用户空间，执行 free 命令可获得当前系统的内存使用情况。比如 R329 方案，某次执行 free 命令的结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@TinaLinux:/<span class="comment"># free</span></span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 110592 79960 30632 36 9172 22860</span><br><span class="line">-/+ buffers/cache: 47928 62664</span><br><span class="line">Swap: 0 0 0</span><br></pre></td></tr></tbody></table></figure><p>free 命令输出说明如下：</p><h4 id="第一行-mem当前系统内存的使用情况">第一行 Mem，当前系统内存的使用情况</h4><ul><li>total： Linux 内核可支配的内存</li><li>used：系统已使用的内存</li><li>free：系统尚未使用的内存</li><li>shared：共享内存以及 tmpfs、 devtmpfs 所占用的内存。共享内存指使用 shmget、shm_open、 mmap 等接口创建的共享内存</li><li>buffers： Buffers 表示块设备 block device 所占用的缓存页，包括直接读写块设备、以及文件系统元数据 metadata 等</li><li>cached： Cache 里包括所有与文件对应的内存页。如果一个文件不再与进程关联，该文件不会立即回收，此时仍然包含在 Cached 中；此外， Cached 中还包含 tmpfs 中的文件以及 shmem 等</li></ul><h4 id="第二行">第二行</h4><p>-/+ buffers/cache，减号表示第一行 used 内存减去 buffers 与 cached 内存，即 Mem_used - Mem_buffers - Mem_cached； 加号表示第一行 free 内存加上 buffers 与 cached 内存，即 Mem_free + Mem_buffers + Mem_cached。从应用程序的角度看， buffers 和 cached 是潜在可用的内存。</p><h4 id="第三行-swap交换分区的使用情况">第三行 Swap，交换分区的使用情况</h4><p>Tina 产品上使用 flash 作为存储器，读写次数是有限的，而 swap 分区特点是会被频繁地读写，导致 flash 寿命变短，因此 tina 上没有创建 swap 分区。</p><ul><li>total: 交换分区总大小</li><li>used: 已使用的交换分区大小</li><li>free: 空闲的交换分区大小</li></ul><h3 id="procmeminfo-节点">/proc/meminfo 节点</h3><p>实际上 free 命令信息来源是从/proc/meminfo 节点。比如 R329 方案，某次执行 cat /proc/meminfo 命令的结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@TinaLinux:/<span class="comment"># cat /proc/meminfo</span></span><br><span class="line">MemTotal: 110592 kB</span><br><span class="line">MemFree: 30380 kB</span><br><span class="line">MemAvailable: 62044 kB</span><br><span class="line">Buffers: 9276 kB</span><br><span class="line">Cached: 22872 kB</span><br><span class="line">SwapCached: 0 kB</span><br><span class="line">Active: 17580 kB</span><br><span class="line">Inactive: 16336 kB</span><br><span class="line">Active(anon): 1780 kB</span><br><span class="line">Inactive(anon): 24 kB</span><br><span class="line">Active(file): 15800 kB</span><br><span class="line">Inactive(file): 16312 kB</span><br><span class="line">Unevictable: 0 kB</span><br><span class="line">Mlocked: 0 kB</span><br><span class="line">SwapTotal: 0 kB</span><br><span class="line">SwapFree: 0 kB</span><br><span class="line">Dirty: 0 kB</span><br><span class="line">Writeback: 0 kB</span><br><span class="line">AnonPages: 1800 kB</span><br><span class="line">Mapped: 3324 kB</span><br><span class="line">Shmem: 36 kB</span><br><span class="line">Slab: 13536 kB</span><br><span class="line">SReclaimable: 4224 kB</span><br><span class="line">SUnreclaim: 9312 kB</span><br><span class="line">KernelStack: 1232 kB</span><br><span class="line">PageTables: 200 kB</span><br><span class="line">NFS_Unstable: 0 kB</span><br><span class="line">Bounce: 0 kB</span><br><span class="line">WritebackTmp: 0 kB</span><br><span class="line">CommitLimit: 55296 kB</span><br><span class="line">Committed_AS: 29116 kB</span><br><span class="line">VmallocTotal: 263061440 kB</span><br><span class="line">VmallocUsed: 0 kB</span><br><span class="line">VmallocChunk: 0 kB</span><br><span class="line">CmaTotal: 24576 kB</span><br><span class="line">CmaFree: 2684 kB</span><br></pre></td></tr></tbody></table></figure><p>相关说明如下：</p><ul><li>MemTotal、 MemFree、 Buffers、 Cached、 Shmem，即 free 命令第一行。</li><li>MemAvailable：使用 MemFree, Active(file), Inactive(file), SReclaimable 和/proc/zoneinfo 中的 low watermark 根据特定算法计算得出，是一个估值，并不精确。可用来评估应用程序层面可用的内存。</li><li>Active/Inactive： Active 表示最近使用的内存，回收的优先级低； Inactive 表示最近较少使用的内存，回收的优先级高。可细分为 Active/Inactive 匿名页与文件页。所谓文件页，就是与文件对应的内存页，如进程的代码、映射的文件都属于文件页，当内存不足时，这部分的内存可以写回到存储器中；与之对应的就属于匿名页，即没有与具体文件对应的页，如进程的堆栈等，内存不足时，如果存在 swap 分区，可以将匿名页写入到交换分区，如果没有 swap 分区，则只能常驻内存中。</li><li>AnonPages：匿名页。</li><li>Mapped：设备或文件映射的大小。比如共享内存、动态库、 mmap 的文件等都统计在该内存中。</li><li>slab/SReclaimable/SUnreclaim：内核 slab 使用的内存，包含可回收与不可回收部分。</li><li>KernelStack：内核栈大小。</li><li>PageTables：页表的大小（用于将虚拟地址翻译为物理地址），内存分配越多，此块内存就会增大。</li><li>CommitLimit/Committed_AS： overcommit 的阈值/已经申请的内存大小（不是已分配）。 Overcommit 是 Linux 一种内存申请处理方式，为了跑更多更大的程序，大部分申请内存的请求都回复 “yes”，总申请的内存大于总物理内存。</li><li>VmallocTotal/VmallocUsed/VmallocChunk： vmalloc 区 域 大 小/vmalloc 区 域 使 用大小/vmalloc 区域中最大可用的连续区块大小。这部分在新版本内核上移除了。</li><li>CmaTotal/CmaFree：总 CMA 内存/空闲 CMA 内存。</li></ul><h2 id="保留内存">保留内存</h2><p>R329 DRAM 大小为 128M，而 free 命令中显示系统可支配总内存只有 110592KB=108M，为什么？ 这里就涉及到一个概念：保留内存（Reserved Memory）。保留内存是指把系统中的一部分内存保留起来用作特殊用途，这部分内存通常不会被释放，也不会被转移到交换分区。</p><p>进入控制台，执行 cat /sys/kernel/debug/memblock/reserved 可以查看 reserved memory 使用情况：当前 R329 reserved memory 使用情况如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@TinaLinux:/<span class="comment"># cat /sys/kernel/debug/memblock/reserved</span></span><br><span class="line">0: 0x0000000040080000..0x00000000408a3fff, size:8336K</span><br><span class="line">1: 0x00000000408a5000..0x00000000408a5fff, size:4K</span><br><span class="line">2: 0x0000000041700000..0x000000004171767f, size:93K</span><br><span class="line">3: 0x0000000041800000..0x00000000420fffff, size:9216K</span><br><span class="line">4: 0x0000000045000000..0x00000000467fffff, size:24576K</span><br><span class="line">5: 0x0000000046d86000..0x0000000046f85fff, size:2048K</span><br><span class="line">6: 0x0000000047f29e00..0x0000000047f59e5f, size:192K</span><br><span class="line">7: 0x0000000047f59e80..0x0000000047f59edf, size:0K</span><br><span class="line">8: 0x0000000047f59f00..0x0000000047f8400f, size:168K</span><br><span class="line">9: 0x0000000047f84080..0x0000000047f84087, size:0K</span><br><span class="line">10: 0x0000000047f84100..0x0000000047f84107, size:0K</span><br><span class="line">11: 0x0000000047f85180..0x0000000047fff2e6, size:488K</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>在内核 cmdline 加上 memblock=debug bootmem_debug=1 参数，在内核启动时，会打印上述 reserved memory 详细信息。由于内容太多，这里不展示了。</p><p>经分析对比，当前 R329 reserved memory 主要包含如下几个部分：</p><ul><li><p>0: 0x0000000040080000..0x00000000408a3fff, size:8336K<br>内核代码段、数据段。详细包括 text， init， data， bss 四段，其中 init 在内核启动完成后会被释放。</p></li><li><p>1: 0x00000000408a5000..0x00000000408a5fff, size:4K<br>略</p></li><li><p>2: 0x0000000041700000..0x000000004171767f, size:93K<br>DTB 占用内存</p></li><li><p>3: 0x0000000041800000..0x00000000420fffff, size:9216K<br>TEE 内存（共 8M，包括 SHM 2M， ATF 1M， OS 1M， TA 4M）。DSP 内存（共 1M）。</p></li><li><p>4: 0x0000000045000000..0x00000000467fffff, size:24576K<br>CMA 内存，共 24M，在 cmdline 中通过 cma=24M 配置而来。在初始化的过程中， CMA 内存会全部导入伙伴系统（具体是通过 cma_init_reserved_areas 函数来实现），所以内核是可以支配 CMA 内存的</p></li><li><p>5: 0x0000000046d86000..0x0000000046f85fff, size:2048K<br>所有 struct page 结构体的总大小。 struct page 结构体用来描述物理上的页帧。当前 R329 上配置一个页的大小为 4K，因此总共有 128M / 4K = 32768 个页，而 sizeof(struct page) 的值为 64B，因此这一块共 32768 * 64 = 2048 KB。注： aarch64 内核 sizeof(struct page) 的值为 64B， arm32 内核 sizeof(struct page) 的值为 32B。</p></li><li><p>6: 0x0000000047f29e00..0x0000000047f59e5f, size:192K<br>主要是 vfs cache，包括 Dentry 和 Inode 的 hash table，存放最近访问的 Dentry 和 Inode 节点，加速对虚拟文件系统的访问。</p></li><li><p>8: 0x0000000047f59f00..0x0000000047f8400f, size:168K<br>主要是 per-cpu 变量占用的内存。</p></li><li><p>11: 0x0000000047f85180..0x0000000047fff2e6, size:488K<br>主要是解析 dtb 生成 struct device_node 结构体所用的内存。</p></li></ul><h2 id="buffers-cached">buffers &amp; cached</h2><p>free 命令第二行为什么要-/+ buffers/cache？ buffers 与 cached 内存都属于空闲内存么？</p><p>Linux 为加速 IO 访问速度，会使用空闲内存来缓存文件以及元数据等内容，这就是 buffers 和 cached 内存。当内存不足时，这些内存会被回收，供内核与应用使用。所以 buffer 与 cache 实际上是已经使用了的内存，由于可以回收，属于潜在的空闲内存。但是并非所有的 buffer 和 cache 都可以回收，比如：</p><ul><li>如果有某个进程访问块设备或者普通文件，就需要 buffers 和 cached 空间，这部分就不能释放。</li><li>shared、 tmpfs 也包含在 cached 空间中。</li></ul><h2 id="系统使用的内存">系统使用的内存</h2><p>free 命令的结果展示系统已经使用了 47928KB 的内存，都用到哪里去了呢？</p><h3 id="进程使用的内存">进程使用的内存</h3><p>新增一个进程使用了哪些内存？ 首先，访问文件系统加载进程的可执行文件、库等，导致 buffer/cache 增大；其次，进程本身在用户空间运行时需要有自己的地址空间信息（用 mm_struct 结构体来表示，包含代码段、数据段、用户栈等地址空间描述）；再次，内核会为进程创建进程描述符（task_struct）、内存描述符（mm_struct）等结构体，用于管理进程；此外，进程还有对应的内核栈，当进程陷入内核时需要内核栈来支持内核函数调用等等。 我们常说的进程使用的内存，指的是在用户空间所使用的内存。 关于用户进程的内存使用，涉及几个通用概念：</p><ul><li>VSS： Virtual Set Size 使用的虚拟内存（包含共享库占用的内存）</li><li>RSS： Resident Set Size 实际使用物理内存（包含共享库占用的内存）</li><li>PSS： Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）</li><li>USS： Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</li></ul><p>一般来说： VSS &gt;= RSS &gt;= PSS &gt;= USS</p><p>在/proc/<pid>/smaps 节点中包含了进程的每一个内存映射的统计值，包含了 PSS、 RSS 等信息。 所以对/proc/<pid>/smaps 节点中所有的 PSS 进行累加，即可统计出所有进程在用户空间所使用的内存，具体命令如下：</pid></pid></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^Pss /proc/[0-9]*/smaps | awk <span class="string">'{total+=$2}; END {print total}'</span></span><br></pre></td></tr></tbody></table></figure><p>查看 rss 信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/`pidof ***app`/status | grep RSS</span><br></pre></td></tr></tbody></table></figure><p>此外还有 ramparser 统计工具：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Tina:/proc/684<span class="comment">#  ramparser -a | grep Total</span></span><br><span class="line">Mem      Total = 256 Mb   (Free 7.39 Mb, Available 7.75 Mb)</span><br><span class="line">Mem Used Total = 235.96 Mb</span><br><span class="line">Mem Used Total = Kernel used total(21.21Mb) + pss total(100.72Mb) +</span><br></pre></td></tr></tbody></table></figure><h3 id="总使用内存">总使用内存</h3><p>单一个进程，涉及到了很多种类的内存使用，完全统计起来不太现实。为统计系统总使用内存，可将其划分为用户空间使用内存与内核使用内存。 用户空间使用的内存 = Buffers + Cached + AnonPages。 内核使用的内存 = Slab + PageTable + KernelStack + CmaUsed + Vmalloc + X。</p><p>其中，</p><ul><li>CmaUsed = CmaTotal - CmaFree。</li><li>Vmalloc 表示/proc/vmallocinfo 中的 vmalloc 分配的内存，包含了内核模块使用的内存。计算方法为 grep vmalloc /proc/vmallocinfo | awk '{total+=$2}; END {print total}'。</li><li>X 表示直接通过 alloc_pages/get_free_page 分配的内存，这部分内存未纳入统计，属于内存黑洞。</li></ul><h1 id="内存优化">内存优化</h1><p>主要包括：</p><ul><li>保留内存优化</li><li>内核使用内存优化</li><li>用户空间使用内存优化</li></ul><h2 id="保留内存优化">保留内存优化</h2><h3 id="内核静态内存优化">内核静态内存优化</h3><p>内核静态内存包括内核代码段数据段。优化方法主要有如下几种： 关闭不需要的模块，关闭模块下不需要的功能</p><ul><li><p>在内核根目录，执行。/scripts/ksize vmlinux 各个模块的代码段数据段的统计信息： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">Linux Kernel (vmlinux)                                      total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">vmlinux                                                   6471329 |    4315221    2013884     142224</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">drivers                                                   2899612 |    2032098     819710      47804</span><br><span class="line">net                                                        753530 |     721792      23658       8080</span><br><span class="line">fs                                                         664960 |     642997       3151      18812</span><br><span class="line">kernel                                                     543470 |     467211      34187      42072</span><br><span class="line">mm                                                         314765 |     288517       6932      19316</span><br><span class="line">crypto                                                     254117 |     196774      57271         72</span><br><span class="line">sound                                                      193477 |     188029       3852       1596</span><br><span class="line">lib                                                        156575 |     154010        236       2329</span><br><span class="line">block                                                      151072 |     147441       2399       1232</span><br><span class="line">ipc                                                         30522 |      29794        724          4</span><br><span class="line">init                                                        25199 |      10990      14145         64</span><br><span class="line">security                                                     4780 |       4756          8         16</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                       5992079 |    4884409     966273     141397</span><br><span class="line">delta                                                      479250 |    -569188    1047611        827</span><br><span class="line"></span><br><span class="line">drivers                                                     total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">drivers/built-in.o                                        2899612 |    2032098     819710      47804</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">drivers/video                                             1012684 |     244524     739328      28832</span><br><span class="line">drivers/usb                                                247516 |     235586       8306       3624</span><br><span class="line">drivers/mtd                                                180132 |     171969       5455       2708</span><br><span class="line">drivers/media                                              171917 |     167120       3313       1484</span><br><span class="line">drivers/base                                               168782 |     164886       3264        632</span><br><span class="line">drivers/mmc                                                150962 |     149050       1716        196</span><br><span class="line">drivers/tty                                                 92952 |      89978       1070       1904</span><br><span class="line">drivers/clk                                                 71921 |      55673      15584        664</span><br><span class="line">drivers/hid                                                 69921 |      66181       3728         12</span><br><span class="line">drivers/regulator                                           60558 |      58806       1612        140</span><br><span class="line">drivers/char                                                59195 |      54555       3640       1000</span><br><span class="line">drivers/input                                               57220 |      54728       2348        144</span><br><span class="line">drivers/pinctrl                                             56336 |      49295       6957         84</span><br><span class="line">drivers/spi                                                 46753 |      45264       1485          4</span><br><span class="line">drivers/cpufreq                                             46675 |      41339       1088       4248</span><br><span class="line">drivers/i2c                                                 46201 |      45552        597         52</span><br><span class="line">drivers/of                                                  36229 |      35370        371        488</span><br><span class="line">drivers/thermal                                             30927 |      28822       2029         76</span><br><span class="line">drivers/gpio                                                30829 |      30392        404         33</span><br><span class="line">drivers/staging                                             27577 |      27104        449         24</span><br><span class="line">drivers/power                                               24587 |      22547       1708        332</span><br><span class="line">drivers/iommu                                               23637 |      23029        544         64</span><br><span class="line">drivers/rtc                                                 21690 |      21150        384        156</span><br><span class="line">drivers/mfd                                                 21408 |      14180       7220          8</span><br><span class="line">drivers/iio                                                 18761 |      18545        160         56</span><br><span class="line">drivers/dma                                                 18404 |      17998        310         96</span><br><span class="line">drivers/pwm                                                 17398 |      16766        456        176</span><br><span class="line">drivers/irqchip                                             15919 |      13483       2340         96</span><br><span class="line">drivers/dma-buf                                             14119 |      14064         23         32</span><br><span class="line">drivers/soc                                                 12843 |      11375       1332        136</span><br><span class="line">drivers/watchdog                                            10668 |      10174        449         45</span><br><span class="line">drivers/clocksource                                          9076 |       8380        592        104</span><br><span class="line">drivers/bus                                                  6536 |       5762        738         36</span><br><span class="line">drivers/hwmon                                                5226 |       5054        144         28</span><br><span class="line">drivers/misc                                                 4730 |       4358        360         12</span><br><span class="line">drivers/reset                                                3838 |       3718        120          0</span><br><span class="line">drivers/firmware                                             3587 |       3527          4         56</span><br><span class="line">drivers/net                                                  1479 |       1431         48          0</span><br><span class="line">drivers/mpp                                                   350 |        334          8          8</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                       2899543 |    2032069     819684      47790</span><br><span class="line">delta                                                          69 |         29         26         14</span><br><span class="line"></span><br><span class="line">net                                                         total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">net/built-in.o                                             753530 |     721792      23658       8080</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">net/ipv4                                                   343777 |     327407      12726       3644</span><br><span class="line">net/core                                                   231660 |     222656       7276       1728</span><br><span class="line">net/xfrm                                                    50407 |      48727       1292        388</span><br><span class="line">net/unix                                                    27015 |      24614        344       2057</span><br><span class="line">net/packet                                                  26639 |      26370        269          0</span><br><span class="line">net/netlink                                                 25701 |      25138        423        140</span><br><span class="line">net/key                                                     20676 |      20372        300          4</span><br><span class="line">net/*.o                                                     15735 |      15307        376         52</span><br><span class="line">net/sched                                                    8093 |       7528        565          0</span><br><span class="line">net/ethernet                                                 2443 |       2403         40          0</span><br><span class="line">net/ipv6                                                     1263 |       1227         28          8</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        753409 |     721749      23639       8021</span><br><span class="line">delta                                                         121 |         43         19         59</span><br><span class="line"></span><br><span class="line">fs                                                          total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">fs/built-in.o                                              664960 |     642997       3151      18812</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">fs/*.o                                                     351463 |     339657       1550      10256</span><br><span class="line">fs/proc                                                     83517 |      78968        361       4188</span><br><span class="line">fs/jffs2                                                    79570 |      79278        136        156</span><br><span class="line">fs/fat                                                      51402 |      51230        144         28</span><br><span class="line">fs/kernfs                                                   21130 |      16955         75       4100</span><br><span class="line">fs/configfs                                                 19069 |      18820        237         12</span><br><span class="line">fs/squashfs                                                 19013 |      18965         44          4</span><br><span class="line">fs/debugfs                                                  15752 |      15688         52         12</span><br><span class="line">fs/nls                                                      11112 |      10996        116          0</span><br><span class="line">fs/sysfs                                                     7133 |       7086         39          8</span><br><span class="line">fs/devpts                                                    3299 |       2938        353          8</span><br><span class="line">fs/ramfs                                                     1840 |       1796         40          4</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        664300 |     642377       3147      18776</span><br><span class="line">delta                                                         660 |        620          4         36</span><br><span class="line"></span><br><span class="line">kernel                                                      total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">kernel/built-in.o                                          543470 |     467211      34187      42072</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">kernel/*.o                                                 228463 |     209842      11969       6652</span><br><span class="line">kernel/time                                                 94112 |      83229       6691       4192</span><br><span class="line">kernel/printk                                               54979 |      18467       8424      28088</span><br><span class="line">kernel/sched                                                47388 |      43798       3446        144</span><br><span class="line">kernel/irq                                                  43205 |      40313        812       2080</span><br><span class="line">kernel/rcu                                                  31236 |      29275       1932         29</span><br><span class="line">kernel/power                                                18951 |      17575        828        548</span><br><span class="line">kernel/locking                                              16625 |      16616          5          4</span><br><span class="line">kernel/bpf                                                   8404 |       8048         64        292</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        543363 |     467163      34171      42029</span><br><span class="line">delta                                                         107 |         48         16         43</span><br><span class="line"></span><br><span class="line">sound                                                       total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">sound/built-in.o                                           193477 |     188029       3852       1596</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">sound/soc                                                  101278 |      98458       2688        132</span><br><span class="line">sound/core                                                  91802 |      89198       1148       1456</span><br><span class="line">sound/*.o                                                     586 |        558         20          8</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        193666 |     188214       3856       1596</span><br><span class="line">delta                                                        -189 |       -185         -4          0</span><br><span class="line"></span><br><span class="line">lib                                                         total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">lib/built-in.o                                             156575 |     154010        236       2329</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">lib/*.o                                                    192773 |     192059        644         70</span><br><span class="line">lib/zlib_deflate                                            16704 |      14364         60       2280</span><br><span class="line">lib/zlib_inflate                                            11187 |      11187          0          0</span><br><span class="line">lib/xz                                                       8199 |       8163         36          0</span><br><span class="line">lib/lzo                                                      2551 |       2551          0          0</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        231414 |     228324        740       2350</span><br><span class="line">delta                                                      -74839 |     -74314       -504        -21</span><br><span class="line"></span><br><span class="line">block                                                       total |       text       data        bss</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">block/built-in.o                                           151072 |     147441       2399       1232</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">block/*.o                                                  143829 |     140218       2383       1228</span><br><span class="line">block/partitions                                             7227 |       7207         16          4</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">sum</span>                                                        151056 |     147425       2399       1232</span><br><span class="line">delta                                                          16 |         16          0          0</span><br></pre></td></tr></tbody></table></figure><p></p></li><li>关闭内核调试功能</li><li>开启 CONFIG_CC_OPTIMIZE_FOR_SIZE 宏，使能-Os 编译参数</li><li><p>排查内核占用空间大的符号</p></li></ul><p>执行 nm --size -r vmlinux，可以列出所有符号占用的内存</p><ul><li>开启 CONFIG_THUMB2_AVOID_R_ARM_THM_JUMP11 和 CONFIG_THUMB2_KERNEL。注：会带来性能损失，具体损失根据实际平台典型应用场景进行测试</li></ul><h3 id="dtb-内存优化">DTB 内存优化</h3><p>Tina 内核中提供的 DTS 一般来说比较全面，对于特定的方案，往往用不了那么多，可以针对性的删除一些节点。</p><h3 id="tee-内存优化">TEE 内存优化</h3><p>Tina 中一些平台，会默认配置一些 TEE 保留内存。对于特定方案来说，很有可能用不了那么多内存。 TEE 默认保留配置与 bl31.bin、 optee-${CHIP}.bin 是配套的，因此修改时需要注意步更新。 比如 R329 默认配置了 8M 内存（SHM 2M,ATF 1M,OS 1M,TA 4M），但是对于非安全方案来说，只需要保留 ATF 就够了；对于不使用 TA 的安全方案，只需要保留 ATF 与 OS 的内存就可以了。</p><h2 id="内核使用内存优化">内核使用内存优化</h2><p>内核使用的内存包括 Slab、 PageTable、 KernelStack、 CmaUsed、Vmalloc 等</p><h2 id="slab-优化">Slab 优化</h2><p>目前 Tina 上大部分方案默认选用的是 SLUB 分配器</p><ul><li>关闭 slab 调试宏 COFNIG_SLUB_DEBUG 与 CONFIG_SLABINFO</li><li>尝试使用针对微小的嵌入式系统的 SLOB</li></ul><h2 id="内核模块优化">内核模块优化</h2><ul><li>不要开机全部加载，实时加载，实时卸载</li><li>将内核模块编译到内核镜像中</li></ul><h2 id="用户空间使用内存优化">用户空间使用内存优化</h2><ul><li>使用更小的 C 库</li><li>使用 size 优化的编译选项，比如-Os， -mthumb 等</li><li>将 tmpfs 下大文件保持到 flash 上</li><li>对于 64 位 CPU，可以使用 32 位的 rootfs</li><li>使用更小的库或应用程序。比如使用 mbedtls，而不是 openssl</li><li>减少守护进程数量，实时运行/关闭特定程序</li><li>将只被一次依赖的动态库转化为动态库；使用 dlopen 来控制动态库的生存周期</li><li>优化程序源码</li></ul><h1 id="参考文献">参考文献</h1><p>《全志SDK文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 性能分析</title>
      <link href="/next/2019/Debug/LinuxPerf/"/>
      <url>/next/2019/Debug/LinuxPerf/</url>
      
        <content type="html"><![CDATA[<h1 id="cpu-使用分析">cpu 使用分析</h1><h2 id="top-命令">top 命令</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procps-ng-top -H -p 899 -w 120</span><br></pre></td></tr></tbody></table></figure><ul><li>-H 是线程模式</li><li>-p 指定进程 id</li><li>-w 指定显示宽度（列数）</li><li>-d 指定延时 ，屏幕更新间隔</li></ul><p>shift+p 按照 cpu 使用率对线程排序。如下是一个实例：</p><span id="more"></span><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">procps-ng-top - 10:11:13 up  1:00,  0 <span class="built_in">users</span>,  load average: 3.90, 4.10, 3.89</span><br><span class="line">Threads:  81 total,   0 running,  81 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  46.6/30.7   77[|||||||||||||||||||||||||||||||||||||||||            ]</span><br><span class="line">GiB Mem : 84.5/0.239    [                                                     ]</span><br><span class="line">GiB Swap:  0.0/0.000    [                                                     ]</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES %CPU %MEM     TIME+ S COMMAND             </span><br><span class="line">  915 root      20   0  191.4m 174.1m 13.7 71.2   8:33.07 S VIChnDMS            </span><br><span class="line">  890 root      20   0  191.4m 174.1m 10.9 71.2   6:11.33 S isp_yhread          </span><br><span class="line">  869 root      20   0  191.4m 174.1m  9.7 71.2   5:36.66 S app                 </span><br><span class="line"> 1163 root      20   0  191.4m 174.1m  4.0 71.2   2:32.27 S AEncComp            </span><br><span class="line"> 1158 root      20   0  191.4m 174.1m  3.4 71.2   2:16.15 S RecSink[0]          </span><br><span class="line"> 1145 root     -21   0  191.4m 174.1m  2.3 71.2   1:01.76 S VEncComp            </span><br><span class="line"> 1154 root      20   0  191.4m 174.1m  1.7 71.2   1:15.99 S MuxerComp           </span><br><span class="line"> 1170 root      20   0  191.4m 174.1m  1.7 71.2   0:55.57 S RecSink[0]          </span><br><span class="line"> 1146 root     -21   0  191.4m 174.1m  1.7 71.2   1:16.99 S VEncComp            </span><br><span class="line"> 1139 root      20   0  191.4m 174.6m  1.1 71.4   0:23.14 S CDX_VRender         </span><br><span class="line"> 1166 root      20   0  191.4m 174.1m  1.1 71.2   0:49.78 S MuxerComp           </span><br><span class="line"> 1155 root      20   0  191.4m 174.1m  1.1 71.2   0:53.52 S RecSink[0]          </span><br><span class="line"> 1134 root      20   0  191.4m 174.6m  1.1 71.4   0:28.99 S CDX_VRender         </span><br><span class="line"> 1161 root      20   0  191.4m 174.1m  1.1 71.2   0:48.20 S recordThread        </span><br><span class="line"> 1141 root     -21   0  191.4m 174.1m  1.1 71.2   0:45.83 D VEncComp            </span><br><span class="line">  926 root      20   0  191.4m 174.1m  1.1 71.2   0:42.77 S app                 </span><br><span class="line">  885 root      20   0  191.4m 174.1m  0.6 71.2   0:27.83 S VIChnPreview</span><br></pre></td></tr></tbody></table></figure><p><strong>第一行任务队列信息：</strong></p><ul><li><em>10:11:13</em> - 当前时间<br></li><li><em>up 1:00</em> - 系统已经运行 1 小时<br></li><li><em>0 users</em> - 当前系统有 0 个用户登录<br></li><li><em>load average: 3.90, 4.10, 3.89</em> - load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。</li></ul><p>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。</p><p><strong>第二行 Tasks 或 Thread 信息：</strong><br>Threads: 81 total - 线程总数 81 个</p><ul><li>0 running - 当前没有线程在运行</li><li>81 sleeping - 81 个线程在睡眠</li><li>0 stopped -stoped 状态的线程为 0 个</li><li>0 zombie - zombie 状态（僵尸）的有 0 个</li></ul><p><strong>第三行 cpu 状态信息：</strong><br>%Cpu0 46.6/30.7 当前 cpu0 的用户态线程占 cpu46.6%，内核态占 cpu30.7% 如果在 pc 上运行可能是如下信息</p><p><strong>Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st</strong></p><ul><li>5.9%us&nbsp;—&nbsp;用户空间占用 CPU 的百分比。</li><li>3.4%&nbsp;sy&nbsp;—&nbsp;内核空间占用 CPU 的百分比。</li><li>0.0%&nbsp;ni&nbsp;—&nbsp;改变过优先级的进程占用 CPU 的百分比</li><li>90.4%&nbsp;id&nbsp;—&nbsp;空闲 CPU 百分比</li><li>0.0%&nbsp;wa&nbsp;—&nbsp;IO 等待占用 CPU 的百分比</li><li>0.0%&nbsp;hi&nbsp;—&nbsp;硬中断（Hardware&nbsp;IRQ）占用 CPU 的百分比</li><li>0.2%&nbsp;si&nbsp;—&nbsp;软中断（Software&nbsp;Interrupts）占用 CPU 的百分比</li></ul><p><strong>第四行内存状态信息：</strong><br>GiB Mem : 84.5/0.239 - 用户态占内存 84.5%，内核态占内存 0.239%</p><p>如果是 pc 上可能是如下信息</p><p><strong>Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers</strong></p><ul><li>32949016k&nbsp;total&nbsp;—&nbsp;物理内存总量（32GB）</li><li>14411180k&nbsp;used&nbsp;—&nbsp;使用中的内存总量（14GB）</li><li>18537836k&nbsp;free&nbsp;—&nbsp;空闲内存总量（18GB）</li><li>169884k&nbsp;buffers&nbsp;—&nbsp;缓存的内存量&nbsp;（169M）</li></ul><p><strong>第五行 swap 交换分区信息：</strong></p><ul><li>GiB Swap: 0.0/0.000 - 当前系统没有使用交换分区</li><li>如果是 pc 则可能是如下信息</li></ul><p><strong>Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached</strong></p><ul><li>32764556k&nbsp;total&nbsp;—&nbsp;交换区总量（32GB）</li><li>0k&nbsp;used&nbsp;—&nbsp;使用的交换区总量（0K）</li><li>32764556k&nbsp;free&nbsp;—&nbsp;空闲交换区总量（32GB）</li><li>3612636k&nbsp;cached&nbsp;—&nbsp;缓冲的交换区总量（3.6GB）</li></ul><p><strong>第六行空行：</strong></p><p><strong>第七行各进程或线程的状态信息：</strong></p><ul><li>PID&nbsp;—&nbsp;进程 id</li><li>USER&nbsp;—&nbsp;进程所有者</li><li>PR&nbsp;—&nbsp;进程优先级</li><li>NI&nbsp;—&nbsp;nice 值。负值表示高优先级，正值表示低优先级</li><li>VIRT&nbsp;—&nbsp;进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES</li><li>RES&nbsp;—&nbsp;进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA</li><li>SHR&nbsp;—&nbsp;共享内存大小，单位 kb</li><li>S&nbsp;—&nbsp;进程状态。D=不可中断的睡眠状态&nbsp;R=运行&nbsp;S=睡眠&nbsp;T=跟踪/停止&nbsp;Z=僵尸进程</li><li>%CPU&nbsp;—&nbsp;上次更新到现在的 CPU 时间占用百分比</li><li>%MEM&nbsp;—&nbsp;进程使用的物理内存百分比</li><li>TIME+&nbsp;—&nbsp;进程使用的 CPU 时间总计，单位 1/100 秒</li><li>COMMAND&nbsp;—&nbsp;进程名称（命令名/命令行）</li></ul><h2 id="perf-工具">perf 工具</h2><p>查看消耗 cpu 比较高的内核函数或者进程：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pert top</span><br></pre></td></tr></tbody></table></figure><p>列出 perf 支持的事件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf list</span><br></pre></td></tr></tbody></table></figure><p>统计 profiling 进程的各种信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf <span class="built_in">stat</span></span><br></pre></td></tr></tbody></table></figure><p>profiling 进程的数据，生成 xx.data 文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf record</span><br></pre></td></tr></tbody></table></figure><p>读取 xx.data 文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf report</span><br></pre></td></tr></tbody></table></figure><h1 id="gdb">GDB</h1><h2 id="打出程序崩溃的调用栈">打出程序崩溃的调用栈</h2><ul><li><p>选中 gdb 工具：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig --&gt;</span><br><span class="line">    Development --&gt;</span><br><span class="line">        &lt;*&gt; gdb------------------- GNU Debugger</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>配置 coredump：<br>程序运行过程中遇到异常终止或崩溃，操作系统会保存一个文件到本地目录，这个文件就是 coredump 文件，选中工具：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make kernel menuconfig，选中以下配置。</span><br><span class="line">Userspace binary formats --&gt;</span><br><span class="line">    [*]Enable core dump support</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited //对产生的 coredump 文件大小不做限制</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/tmp/core-%e-%p-%t"</span> &gt; /proc/sys/kernel/core_pattern //产生的文件带有崩溃的程序名称以及进程 <span class="built_in">id</span></span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>运行 app<br>运行 app 的时候会在/tmp 目录下生成 corexxxxx 文件。</p></li><li><p>获取程序崩溃的调用栈<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb /usr/bin/app /tmp/corexxxx</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后执行 bt 就会打出函数调用栈。</p></li></ul><h2 id="其他命令">其他命令</h2><p>frame、x、info、disassemble ...</p><h2 id="交叉调试">交叉调试</h2><p>有时 flash 空间大小不足以装下 gdb，这时需要在 pc 上使用交叉编译工具链中的 gdb 调试，详细过程如下：</p><ul><li>编译完的固件保存好 app 的 bin 文件，带符号表的那个</li><li>当应用挂掉后从机器里取出 core 文件，放入 pc 上</li><li>执行 arm-xxxx-gdb app core-file</li><li><p>设置 sysroot 路径 set sysroot /home/workspace/project/out/project/staging_dir/target/rootfs 得到如下，说明设置成功： </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/lib/libstdc  ++.so.6...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ libasound.so.2...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/libz.    so.1...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ eyesee-mpp/libcdx_base.so...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ eyesee-mpp/libcdx_parser.so...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ eyesee-mpp/libcdx_stream.so...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ eyesee-mpp/libcdx_common.so...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/lib/libgcc_s.    so.1...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/lib/ ld-musl-armhf.so.1...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ts/  input.so...done.</span><br><span class="line">Reading symbols from /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs/usr/lib/ libts.so.0...done.</span><br></pre></td></tr></tbody></table></figure><p></p></li><li>执行 bt 命令，会打出崩溃时的函数调用栈。</li><li>frame n&nbsp;命令表示在 GDB 下切换到编号为&nbsp;<em>n</em>&nbsp;的栈帧 (<em>n</em>&nbsp;表示一个正整数）。例如，frame 4&nbsp;将切换到栈的第 5 层。切换完后，如果想查看当前栈帧的编号、函数名、函数参数值、函数所在文件及行号、函数执行到的语句等信息，可直接使用&nbsp;<code>frame</code>&nbsp;命令，如下图所示。</li><li><p>info 命令查看当前栈帧的信息，如函数地址、调用函数的地址、被调用函数的地址、当前函数由哪种编程语言编写、函数参数地址及形参值、局部变量的地址等 </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> PATH=/home/user/workspace/sdk/prebuilt/gcc/linux-x86/arm/toolchain-sunxi-musl/    toolchain/bin</span><br><span class="line"><span class="built_in">set</span> sysroot /home/user/workspace/sdk/out/vendor/staging_dir/target/rootfs</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><h1 id="内存查看">内存查看</h1><p>内存碎片化查看工具</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/buddyinfo</span><br><span class="line">Node 0, zone   Normal    115    148     72     34      1      0      1      0      1      0      0</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《全志SDK文档》</p>]]></content>
      
      
      <categories>
          
          <category> Technology Blog </category>
          
          <category> Programming </category>
          
          <category> Performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming </tag>
            
            <tag> Debug </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leaktrace 使用方法</title>
      <link href="/next/2019/Note/LeakTracer/"/>
      <url>/next/2019/Note/LeakTracer/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>LeakTracer 是在检查 C++ 程序内存泄漏时编写的一个小工具。我无法让 dmalloc 显示我想要的内容，我只看到了提到的 __builtin_return_address gcc-extension。</p><p>要使用 LeakTracer，请使用提供的 LeakCheck 脚本运行您的程序。它使用 LD_PRELOAD 特性在你的函数之上“覆盖”一些函数（不需要重新编译）。如果您的平台不支持 LD_PRELOAD，您可以将 LeakTracer.o 对象文件添加到 Makefile 中的对象并运行您的应用程序。</p><p>LeakTracer 利用 gdb 去输出发生内存泄露所发生的位置，它是通过 override operator new, operator delete, operator malloc, operator free 来实现检测。</p><span id="more"></span><h1 id="用法">用法</h1><h2 id="加载-leaktracer-库的-3-种方法"><strong>加载 leaktracer 库的 3 种方法：</strong></h2><ul><li>将您的程序链接到 libleaktracer.a</li><li>将您的程序链接到 <span class="exturl" data-url="aHR0cDovL2xpYmxlYWt0cmFjZXIuc28v">libleaktracer.so<i class="fa fa-external-link-alt"></i></span>。您需要将 -lleaktracer 选项作为链接命令的第一个选项</li><li>使用 LD_PRELOAD 环境变量以确保它在任何其他库之前加载</li></ul><h2 id="将-leaktracer-添加到程序中"><strong>将 leaktracer 添加到程序中：</strong></h2><ul><li>添加头文件 MemoryTrace.hpp</li><li>添加 leaktracer::MemoryTrace::GetInstance().startMonitoringAllThreads() 函数，作为起始检测位置</li><li>添加 leaktracer::MemoryTrace::GetInstance().writeLeaksToFile("/mnt/extsd/leaks.out") 函数，作为结束位置，生成检测报告</li><li>编译选项中添加-funwind-tables 生成 backtrace 信息表，添加-rdynamic</li><li>链接选项中添加-Wl,-Bstatic -lleaktracer 静态链接 libleaktracer，最好加上-g3，处理报告时可以显示对应的代码</li><li>编译后保存生成的 bin 文件，备用</li></ul><h2 id="生成报告及处理"><strong>生成报告及处理：</strong></h2><h3 id="生成的报告中一行信息如下">生成的报告中一行信息如下：</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># LeakTracer report diff_utc_mono=<span class="number">1588164717.365890</span></span><br><span class="line">leak, time=<span class="number">1434.190531</span>, stack=<span class="number">0x7f05d63801d5</span> <span class="number">0x7f05d638e594</span> <span class="number">0x7f05d638d8f8</span> <span class="number">0x7f05d638c28d</span> <span class="number">0x7f05d6382738</span>, size=<span class="number">1024</span>, data=***********************************************...</span><br><span class="line">leak, time=<span class="number">1444.194638</span>, stack=<span class="number">0x7f05d70f9c58</span> <span class="number">0x4027f5</span> <span class="number">0x7f05d6333830</span> <span class="number">0x402369</span>, size=<span class="number">100</span>, data=.<span class="string">"%...............................................</span></span><br><span class="line"><span class="string">leak, time=1434.190625, stack=0x4024d7 0x7f05d6333830 0x402369, size=100, data=..................................................</span></span><br><span class="line"><span class="string">leak, time=1444.194222, stack=0x7f05d70f9a5c 0x4027f0 0x7f05d6333830 0x402369, size=100, data=. %...............................................</span></span><br><span class="line"><span class="string">leak, time=1434.190651, stack=0x402500 0x7f05d6333830 0x402369, size=100,</span></span><br></pre></td></tr></tbody></table></figure><ul><li>leak：代表内存泄露</li><li>time：代表调用分配内存函数的时间（开机到当前的时间）</li><li>stack：调用栈</li><li>size：泄露的内存大小</li><li>data：申请时内存中的数据</li></ul><p>明显可以看到调用栈，callstack 全是地址，我们以使用 helpers 文件夹中的 leak-analyze-addr2line，leak-analyze-gdb 二个工具进行解析。或者借助 gdb、objdump 或 map 文件等手段得到该泄露源的真正文件/行号或函数范围。</p><h3 id="报告处理">报告处理</h3><ul><li><p>使用 addr2line 处理 leaks.out，生成可读的调用栈：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leak-analyze-addr2line {bin} leaks.out &gt; leaks.addr2line.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>生成的报告示例如下：</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./helpers/leak-analyze-addr2line memleak_test_so leaks.out </span><br><span class="line">Processing <span class="string">"leaks.out"</span> log <span class="keyword">for</span> <span class="string">"memleak_test_so"</span></span><br><span class="line">Matching addresses to <span class="string">"memleak_test_so"</span></span><br><span class="line">found <span class="number">49</span> <span class="built_in">leak</span>(s)</span><br><span class="line"><span class="number">100</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1444.194222</span>), from following call stack:</span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">110</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br><span class="line"><span class="number">400</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1444.194550</span>), from following call stack:</span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">110</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br><span class="line"><span class="number">328</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1434.190960</span>), from following call stack:</span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">83</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br></pre></td></tr></tbody></table></figure><p></p><p>解析：49 个重复调用，泄露 100 个字节的内存，其中一个泄漏点在 leaks.out 中的时间是 06219.879013，调用栈从下 往上看。</p></li><li><p>使用 gdb 处理 leaks.out，生成可读的调用栈及源码对应：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leak-analyze-gdb {bin} leaks.out &gt; leaks.gdb.txt</span><br></pre></td></tr></tbody></table></figure><p></p><p>生成的报告示例如下：</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./helpers/leak-analyze-gdb memleak_test_so  leaks.out </span><br><span class="line">found <span class="number">49</span> <span class="built_in">leak</span>(s)</span><br><span class="line">(gdb) Reading symbols from memleak_test_so...done.</span><br><span class="line"><span class="number">16</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1434.190803</span>), from following call stack:</span><br><span class="line">main + <span class="number">364</span> in section .text</span><br><span class="line"><span class="number">0x4025e4</span> <span class="function">is in <span class="title">main</span><span class="params">()</span> <span class="params">(memleak_test.cpp:<span class="number">80</span>)</span>.</span></span><br><span class="line"><span class="function">80new_delete_test *p_new_class_no_free </span>=  <span class="keyword">new</span> new_delete_test;</span><br><span class="line">No symbol matches <span class="number">0x7f05d6333830</span>.</span><br><span class="line">_start + <span class="number">41</span> in section .text</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1444.194798</span>), from following call stack:</span><br><span class="line">No symbol matches <span class="number">0x7f05d70f9cee</span>.</span><br><span class="line">main + <span class="number">893</span> in section .text</span><br><span class="line"><span class="number">0x4027f5</span> <span class="function">is in <span class="title">main</span><span class="params">()</span> <span class="params">(memleak_test.cpp:<span class="number">111</span>)</span>.</span></span><br><span class="line"><span class="function">111leaktracer::<span class="title">MemoryTrace::GetInstance</span><span class="params">()</span>.<span class="title">stopAllMonitoring</span><span class="params">()</span></span>;</span><br><span class="line">No symbol matches <span class="number">0x7f05d6333830</span>.</span><br></pre></td></tr></tbody></table></figure><p></p><p>无论是 leak-analyze-addr2line，leak-analyze-gdb 二个工具进行解析。或者借助 gdb、objdump 或 map 文件等手段 得到该泄露源的真正文件/行号或函数范围。其中都会碰上各种库引用等问题导致？？？。都会很麻烦，然而 leaktracer 提供了相关源码，我们可以对 leaktracer 进行改造成符合我们的定制化需求。</p></li></ul><h1 id="定制">定制</h1><p>通过上述文章我们可以轻松理解 leaktracer 使用与 leaktracer 设计与实现。在实际使用过程中，基本上都会碰到一些小问题。需要对 leaktracer 进行定制化修改。以下的定制化请根据各自项目实际需求酌情进行修改。</p><ul><li><p><strong>callstack 深度问题</strong><br>callstack 深度默认只有 5 个。</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALLOCATION_STACK_DEPTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOCATION_STACK_DEPTH 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>因此当 callstack 深度较大时无法显示详细的调用关系。如下：</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">0x7f05d63801d5</span> <span class="number">0x7f05d638e594</span> <span class="number">0x7f05d638d8f8</span> <span class="number">0x7f05d638c28d</span> <span class="number">0x7f05d6382738</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>将默认 callstack 深度 5 修改为较大值，本文是 50。请根据实际情况调整，一般情况下对整个情况影响不大</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALLOCATION_STACK_DEPTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOCATION_STACK_DEPTH 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p><strong>callstatck 地址问题</strong><br>无论是 leak-analyze-addr2line，leak-analyze-gdb 二个工具进行解析。或者借助 gdb、objdump 或 map 文件等手段 得到该泄露源的真正文件/行号或函数范围。因多个动态库及其他原因，或多或少都会碰上各种库引用等问题导 致？？？。会很麻烦</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./helpers/leak-analyze-addr2line memleak_test_so leaks.out </span><br><span class="line">Processing <span class="string">"leaks.out"</span> log <span class="keyword">for</span> <span class="string">"memleak_test_so"</span></span><br><span class="line">Matching addresses to <span class="string">"memleak_test_so"</span></span><br><span class="line">found <span class="number">49</span> <span class="built_in">leak</span>(s)</span><br><span class="line"><span class="number">100</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1444.194222</span>), from following call stack:</span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">110</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br><span class="line"><span class="number">400</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1444.194550</span>), from following call stack:</span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">110</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br><span class="line"><span class="number">328</span> bytes lost in <span class="number">1</span> <span class="built_in">blocks</span> (one of them allocated at <span class="number">1434.190960</span>), from following call stack:</span><br><span class="line">/home/cll/<span class="number">99</span>_temp/memory_leak/leaktracer/memleak_way1/memleak_test.cpp:<span class="number">83</span></span><br><span class="line">??:<span class="number">0</span></span><br><span class="line">??:?</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p><strong>文件路径不存在无法生成文件问题</strong><br>使用 void writeLeaksToFile(const char* reportFileName); 接口生成文件时，若文件夹路径不存在，则会生成文件失败。然而实际在较大工程中使用时，均会将内存泄露文件统一到某个指定路径。可能存在文件夹路径不存在的情况。</p></li><li><p>未内存泄露确生成文件问题<br>在较大工程中使用时，进程数较多。若未内存泄露确产生文件，对 UI 交互及直观上总有些不协调。</p></li><li><p>解决办法参考 https://github.com/carlyleliu/LeakTracer/commit/49513580316bf998796b19ae7587b1a3e32bbfac</p></li></ul><h1 id="原理">原理</h1><h2 id="leaktracer-主要的设计思路为">leaktracer 主要的设计思路为：</h2><ul><li>实现一组内存的分配/释放函数，这组函数的函数原型与系统的那一组完全一样，让被 trace 的 library 对于内存的分配/释放函数的调用都链接到自己实现的这一组函数中以 override 掉系统的那组内存/分配释放函数；</li><li>自己实现的这组函数中的内存分配函数记录分配相关的信息，包括分配的内存的大小，callstack 等，并调用系统本来的内存分配函数去分配内存；</li><li>自己实现的这组函数中的内存释放函数则销毁内存分配的相关记录，并使用系统的内存释放函数真正的释放内存；</li><li>在 trace 结束时，遍历所有保存的内存分配记录的信息，并把这些信息保存进文件以供进一步的分析</li></ul><h2 id="override-系统内存分配释放函数">override 系统内存分配/释放函数</h2><p>LeakTracer 实现的用于 override 系统内存分配/释放函数的那组函数在 AllocationHandlers.cpp 中定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[]</span></span><br><span class="line"><span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LeakTracer</span></span><br><span class="line"><span class="comment">// Contribution to original project by Erwin S. Andreasen</span></span><br><span class="line"><span class="comment">// site: &lt;http://www.andreasen.org/LeakTracer/&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Added by Michael Gopshtein, 2006</span></span><br><span class="line"><span class="comment">// mgopshtein@gmail.com</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Any comments/suggestions are welcome</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MemoryTrace.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"LeakTracer_l.hpp"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* (*lt_malloc)(<span class="type">size_t</span> size);</span><br><span class="line"><span class="built_in">void</span>  (*lt_free)(<span class="type">void</span>* ptr);</span><br><span class="line"><span class="type">void</span>* (*lt_realloc)(<span class="type">void</span> *ptr, <span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span>* (*lt_calloc)(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="type">size_t</span> size) {</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span> *p)</span> </span>{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(p, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="type">void</span> *p) {</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(p, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** -- libc memory operators -- **/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* malloc</span></span><br><span class="line"><span class="comment"> * in some malloc implementation, there is a recursive call to malloc</span></span><br><span class="line"><span class="comment"> * (for instance, in uClibc 0.9.29 malloc-standard )</span></span><br><span class="line"><span class="comment"> * we use a InternalMonitoringDisablerThreadUp that use a tls variable to prevent several registration</span></span><br><span class="line"><span class="comment"> * during the same malloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line">p = <span class="built_in">LT_MALLOC</span>(size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(ptr, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">LT_FREE</span>(ptr);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"> </span><br><span class="line">p = <span class="built_in">LT_REALLOC</span>(ptr, size);</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (p != ptr)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerRelease</span>(ptr, <span class="literal">false</span>);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerReallocation</span>(p, size, <span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">Setup</span>();</span><br><span class="line"> </span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line">p = <span class="built_in">LT_CALLOC</span>(nmemb, size);</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">leaktracer::MemoryTrace::<span class="built_in">GetInstance</span>().<span class="built_in">registerAllocation</span>(p, nmemb*size, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>内存分配函数记录分配相关的信息</p><p>inline void registerAllocation(void *p, size_t size, bool is_array); 记录每一次内存分配的相关信息</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers new memory allocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting "new" calls */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** registers memory reallocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting realloc calls */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>inline void registerReallocation(void *p, size_t size, bool is_array); 记录每一次内存分配的相关信 息，限 realloc</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers memory reallocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting realloc calls */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adds all relevant info regarding current allocation to map</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MemoryTrace::registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">allocation_info_t</span> *info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AllMonitoringIsDisabled</span>() &amp;&amp; (__monitoringAllThreads || <span class="built_in">getThreadOptions</span>().    monitoringAllocations) &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="function">MutexLock <span class="title">lock</span><span class="params">(__allocations_mutex)</span></span>;</span><br><span class="line">info = __allocations.<span class="built_in">insert</span>(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line">info-&gt;size = size;</span><br><span class="line">info-&gt;isArray = is_array;</span><br><span class="line"><span class="built_in">storeTimestamp</span>(info-&gt;timestamp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> <span class="comment">// we store the stack without locking __allocations_mutex</span></span><br><span class="line"><span class="comment">// it should be safe enough</span></span><br><span class="line"><span class="comment">// prevent a deadlock between backtrave function who are now using advanced dl_iterate_phdr     function</span></span><br><span class="line"> <span class="comment">// and dl_* function which uses malloc functions</span></span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">storeAllocationStack</span>(info-&gt;allocStack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// adds all relevant info regarding current allocation to map</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MemoryTrace::registerReallocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AllMonitoringIsDisabled</span>() &amp;&amp; (__monitoringAllThreads || <span class="built_in">getThreadOptions</span>().    monitoringAllocations) &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="function">MutexLock <span class="title">lock</span><span class="params">(__allocations_mutex)</span></span>;</span><br><span class="line"><span class="type">allocation_info_t</span> *info = __allocations.<span class="built_in">find</span>(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line">info-&gt;size = size;</span><br><span class="line">info-&gt;isArray = is_array;</span><br><span class="line"><span class="built_in">storeAllocationStack</span>(info-&gt;allocStack);</span><br><span class="line"><span class="built_in">storeTimestamp</span>(info-&gt;timestamp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>内存释放函数则销毁内存分配的相关记录</p><p>inline void registerReallocation(void *p, size_t size, bool is_array); 记录每一次内存释放的相关信息</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** registers new memory allocation, should be called by the</span></span><br><span class="line"><span class="comment"> *  function intercepting "new" calls */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">registerAllocation</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">bool</span> is_array)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removes allocation's info from the map</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MemoryTrace::registerRelease</span><span class="params">(<span class="type">void</span> *p, <span class="type">bool</span> is_array)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AllMonitoringIsDisabled</span>() &amp;&amp; __monitoringReleases &amp;&amp; p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="function">MutexLock <span class="title">lock</span><span class="params">(__allocations_mutex)</span></span>;</span><br><span class="line"><span class="type">allocation_info_t</span> *info = __allocations.<span class="built_in">find</span>(p);</span><br><span class="line"><span class="keyword">if</span> (info != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;isArray != is_array) {</span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"><span class="comment">// WARNING</span></span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">}</span><br><span class="line">__allocations.<span class="built_in">release</span>(p);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>遍历所有保存的内存分配记录的信息，并把这些信息保存</p><p>void writeLeaksToFile(const char* reportFileName); 保存内存分配记录信息到文件。</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** writes report with all memory leaks */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeLeaksToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* reportFileName)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writes all memory leaks to given stream</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryTrace::writeLeaksToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* reportFilename)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">MutexLock <span class="title">lock</span><span class="params">(__allocations_mutex)</span></span>;</span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadUp</span>();</span><br><span class="line"></span><br><span class="line">std::ofstream oleaks;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isFolderExist</span>(reportFilename)) {</span><br><span class="line"><span class="built_in">createDirectory</span>(reportFilename);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (__allocations.<span class="built_in">empty</span>()) {</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//no memory leak, not need to create leak file</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">oleaks.<span class="built_in">open</span>(reportFilename, std::ios_base::out);</span><br><span class="line"><span class="keyword">if</span> (oleaks.<span class="built_in">is_open</span>())</span><br><span class="line">{</span><br><span class="line"><span class="built_in">writeLeaksPrivate</span>(oleaks);</span><br><span class="line">oleaks.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">std::cerr &lt;&lt; <span class="string">"Failed to write to \\"</span><span class="string">" &lt;&lt; reportFilename &lt;&lt; "</span>\\<span class="string">"\\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">InternalMonitoringDisablerThreadDown</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>遍历自定义 MapMemoryInfo 中所有元素</p><p></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writes all memory leaks to given stream</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryTrace::writeLeaksPrivate</span><span class="params">(std::ostream &amp;out)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> mono, utc, diff;</span><br><span class="line"><span class="type">allocation_info_t</span> *info;</span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> precision = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> maxsecwidth;</span><br><span class="line"></span><br><span class="line"><span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;utc);</span><br><span class="line"><span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;mono);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (utc.tv_nsec &gt; mono.tv_nsec) {</span><br><span class="line">diff.tv_nsec = utc.tv_nsec - mono.tv_nsec;</span><br><span class="line">diff.tv_sec = utc.tv_sec - mono.tv_sec;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">diff.tv_nsec = <span class="number">1000000000</span> - (mono.tv_nsec - utc.tv_nsec);</span><br><span class="line">diff.tv_sec = utc.tv_sec - mono.tv_sec <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">maxsecwidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(mono.tv_sec &gt; <span class="number">0</span>) {</span><br><span class="line">mono.tv_sec = mono.tv_sec/<span class="number">10</span>;</span><br><span class="line">maxsecwidth++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (maxsecwidth == <span class="number">0</span>) maxsecwidth=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">out &lt;&lt; <span class="string">"# LeakTracer report"</span>;</span><br><span class="line">d = diff.tv_sec + (((<span class="type">double</span>)diff.tv_nsec)/<span class="number">1000000000</span>);</span><br><span class="line">out &lt;&lt; <span class="string">" diff_utc_mono="</span> &lt;&lt; std::fixed &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setprecision</span>(precision) &lt;&lt; d ;</span><br><span class="line">out &lt;&lt; <span class="string">"\\n"</span>;</span><br><span class="line"></span><br><span class="line">__allocations.<span class="built_in">beginIteration</span>();</span><br><span class="line"><span class="keyword">while</span> (__allocations.<span class="built_in">getNextPair</span>(&amp;info, &amp;p)) {</span><br><span class="line">d = info-&gt;timestamp.tv_sec + (((<span class="type">double</span>)info-&gt;timestamp.tv_nsec)/<span class="number">1000000000</span>);</span><br><span class="line">out &lt;&lt; <span class="string">"leak, "</span>;</span><br><span class="line">out &lt;&lt; <span class="string">"time="</span>  &lt;&lt; std::fixed &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setprecision</span>(precision) &lt;&lt;  std::<span class="built_in">setfill</span>(<span class="string">'0'</span>) &lt;&lt; std::<span class="built_in">setw</span>(maxsecwidth+<span class="number">1</span>+precision) &lt;&lt; d &lt;&lt; <span class="string">", "</span>; <span class="comment">// setw(16) ?</span></span><br><span class="line">out &lt;&lt; <span class="string">"stack="</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BACKTRACE_SYMBOLS_USED</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i_depth = <span class="number">0</span>; i_depth &lt; ALLOCATION_STACK_DEPTH; i_depth++) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;allocStack[i_depth] == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i_depth &gt; <span class="number">0</span>) out &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">out &lt;&lt; info-&gt;allocStack[i_depth];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line"><span class="type">char</span> **trace_symbols = (<span class="type">char</span> **)<span class="built_in">backtrace_symbols</span> (info-&gt;allocStack, i_depth);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != trace_symbols) {</span><br><span class="line"><span class="type">size_t</span> name_size = <span class="number">64</span>;</span><br><span class="line"><span class="type">char</span> *name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(name_size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; i_depth; j++) {</span><br><span class="line"><span class="type">char</span> *begin_name = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *begin_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *end_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> *p = trace_symbols[j]; *p; ++p) {</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">'('</span>) {</span><br><span class="line">begin_name = p;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'+'</span> &amp;&amp; begin_name) {</span><br><span class="line">begin_offset = p;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">')'</span> &amp;&amp; begin_offset) {</span><br><span class="line">end_offset = p;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (begin_name &amp;&amp; begin_offset &amp;&amp; end_offset ) {</span><br><span class="line">*begin_name++ = <span class="string">'\\0'</span>;</span><br><span class="line">*begin_offset++ = <span class="string">'\\0'</span>;</span><br><span class="line">*end_offset = <span class="string">'\\0'</span>;</span><br><span class="line"><span class="type">int</span> status = <span class="number">-4</span>;</span><br><span class="line"><span class="type">char</span> *ret = abi::__cxa_demangle(begin_name, name, &amp;name_size, &amp;status);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == status) {</span><br><span class="line">name = ret;</span><br><span class="line">out &lt;&lt; trace_symbols[j] &lt;&lt; <span class="string">":"</span> &lt;&lt; name &lt;&lt; <span class="string">"+"</span> &lt;&lt; begin_offset;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">out &lt;&lt; trace_symbols[j] &lt;&lt; <span class="string">":"</span> &lt;&lt; begin_name &lt;&lt; <span class="string">"()+"</span> &lt;&lt; begin_offset;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">out &lt;&lt; trace_symbols[j];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(trace_symbols);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; ALLOCATION_STACK_DEPTH; i++) {</span><br><span class="line"><span class="keyword">if</span> (info-&gt;allocStack[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) out &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">out &lt;&lt; info-&gt;allocStack[i];</span><br><span class="line">}</span><br><span class="line">out &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">out &lt;&lt; <span class="string">"size="</span> &lt;&lt; info-&gt;size &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"></span><br><span class="line">out &lt;&lt; <span class="string">"data="</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *data = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(p);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; PRINTED_DATA_BUFFER_SIZE &amp;&amp; i &lt; info-&gt;size; i++)</span><br><span class="line">out &lt;&lt; (<span class="built_in">isprint</span>(data[i]) ? data[i] : <span class="string">'.'</span>);</span><br><span class="line">out &lt;&lt; <span class="string">'\\n'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li></ul><p>整体来看 LeakTracer 的设计与实现都并不复杂，因而能够 trace 的 memory issue 也就有限。比如，LeakTracer 就无法 trace 多次释放等问题。但我们可以通过源码编写更强大的内存相关的 trace 工具。</p><p>💡 注意：对于应用，无论是静态链接或动态链接的库，若想能够生成 callstack，都需要添加-funwind-tables 重新编译一次 leak-analyze-addr2line 和 leak-analyze-gdb 在 libleaktracer.tar.gz 中，需要将其中的 addr2line 和 gdb 改成交叉编译工具链中的 arm-xxx-addr2line 和 arm-xxx-gdb。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 应用编程</title>
      <link href="/next/2019/Note/LinuxApplicationPrograms/"/>
      <url>/next/2019/Note/LinuxApplicationPrograms/</url>
      
        <content type="html"><![CDATA[<h1 id="文件-io">文件 IO</h1><p>系统调用进入内核</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO1.png"></p><p>内核的 sys_open、sys_read 做了什么：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO2.png"></p><span id="more"></span><h1 id="framebuffer-应用编程">Framebuffer 应用编程</h1><h2 id="lcd-操作原理">LCD 操作原理</h2><p>在 Linux 系统中通过 Framebuffer 驱动程序来控制 LCD。Frame 是帧的意思，buffer 是缓冲的意思，这意味着 Framebuffer 就是一块内存，里面保存着一帧图像。Framebuffer 中保存着一帧图像的每一个像素颜色值，假设 LCD 的分辨率是 1024x768，每一个像素的颜色用 32 位来表示，那么 Framebuffer 的大小就是：1024x768x32/8=3145728 字节。</p><p>简单介绍 LCD 的操作原理：</p><ul><li>驱动程序设置好 LCD 控制器：根据 LCD 的参数设置 LCD 控制器的时序、信号极性；根据 LCD 分辨率、BPP 分配 Framebuffer</li><li>APP 使用 ioctl 获得 LCD 分辨率、BPP</li><li>APP 通过 mmap 映射 Framebuffer，在 Framebuffer 中写入数据</li></ul><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO3.png"></p><p>假设需要设置 LCD 中坐标 (x,y) 处像素的颜色，首要要找到这个像素对应的内存，然后根据它的 BPP 值设置颜色。假设 fb_base 是 APP 执行 mmap 后得到的 Framebuffer 地址，如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO4.png"></p><p>可以用以下公式算出 (x,y) 坐标处像素对应的 Framebuffer 地址：(x，y) 像素起始地址=fb_base+(xres*bpp/8)_y + x_bpp/8</p><p>最后一个要解决的问题就是像素的颜色怎么表示？它是用 RGB 三原色（红、绿、蓝）来表示的，在不同的 BPP 格式中，用不同的位来分别表示 R、G、B，如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO5.png"></p><p>对于 32BPP，一般只设置其中的低 24 位，高 8 位表示透明度，一般的 LCD 都不支持。</p><p>对于 24BPP，硬件上为了方便处理，在 Framebuffer 中也是用 32 位来表示，效果跟 32BPP 是一样的。</p><p>对于 16BPP，常用的是 RGB565；很少的场合会用到 RGB555，这可以通过 ioctl 读取驱动程序中的 RGB 位偏移来确定使用哪一种格式。</p><h1 id="文字显示">文字显示</h1><h2 id="字符的编码方式区分编码和字体">字符的编码方式（区分编码和字体）</h2><p>在计算机上，我们看到的字符“A”可能长这样： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO6.png"></p><p>也可能长这样： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO7.png"></p><p>对于同一个 TXT 文件中的内容，你在 Notepad 上选择不同字体时，字符显示的形状不一样。</p><p>所以 TXT 文件中保存的是字符的核心：它的编码值。而 Notepad 上显示时，这些字符对应什么样的形状态，这是由字符文件决定的。编码值，字体是两个不一样的东西，比如 A 的编码值是 0x41，但是在屏幕上显示出来时可以使用不同的形状。</p><h3 id="ascii">ASCII</h3><p>是“American Standard Code for Information Interchange”的缩写，美国信息交换标准代码。 <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO8.png"></p><h3 id="ansi">ANSI</h3><p>使用记事本保存文件时，可以选择“ANSI”编码，却没有“ASCII”，各下图所示。怎么回事？</p><p>ASNI 是 ASCII 的扩展，向下包含 ASCII。对于 ASCII 字符仍以一个字节来表示，对于非 ASCII 字符则使用 2 字节来表示。并没有固定的 ASNI 编码，它跟“本地化”(locale) 密切相关。比如在中国大陆地区，ANSI 的默认编码是 GB2312；在港澳台地区默认编码是 BIG5。以数值“0xd0d6”为例，对于 GB2312 编码它表示“中”；对于 BIG5 编码它表示“笢”。所以对于 ANSI 编码的 TXT 文件，如果你打开它发现乱码，那么还得再次细分它的具体编码。</p><p>这仅仅是在中国地区就出现这些不兼容的问题。对于不同国家，它们默认的 ANSI 编码各不相同，所以同一个 TXT 文件在不同国家就很有可能出现乱码。</p><p>根本的原理在于没有“统一的编码”，那解决方法自然就是使用“统一的编码”：UNICODE。</p><h3 id="unicode">UNICODE</h3><p>在 ANSI 标准中，很多种文字都有自己的编码标准，汉字简体字有 GB2312、繁体字有 BIG5，这难免同一个数值对应不同字符。比如数值“0xd0d6”，对于 GB2312 编码它表示“中”；对于 BIG5 编码它表示“笢”。这造成了使用 ANSI 编码保存的文件，不适合跨地区交流。</p><p>UNICODE 编码就是解决这类问题：对于地球上任意一个字符，都给它一个唯一的数值。</p><p>UNICODE 仍然向下兼容 ASCII，但是对于其他字符会有对应的数值，比如对于“中”、“笢”，它们的数值分别是：0x4e2d、0x7b22</p><p>UNICODE 中的数值范围是 0x0000 至 0x10FFFF，有 1,114,111 即 100 多万个数值，可以表示 100 多万个字符，足够地球人使用了。</p><ul><li>UNICODE 编码实现</li></ul><p>所谓编码实现，就是对于一个数值，怎么表示它。这很奇怪，数值还能怎么表示？比如“中”的 UNICODE 值是 0x4e2d，在 TXT 文件中怎么表示 0x4e2d？直接写入 0x4e2d？不行！</p><p>比如在 TXT 文件中写入 2 字节数据“0x2d 0x4e”，它可以用来表示“中”字吗？不能！它们对应 ASCII 字符“-N”。</p><p>问题的关键在于：怎么断字。在 TXT 文件中，2 字节数据“0x2d 0x4e”是作为一个整体看待，还是拆成 2 部分看待？</p><p>所以，需要用一定的技巧来表示数值，这就对应不同的编码实现。</p><p>现在我们知道：</p><ul><li>ASCII 编码中使用一个字节来表示一个字符，只用到其中的 7 位，最高位恒为 0</li><li>ANSI 编码中，对于 ASCII 字符仍使用一个字节来表示 (BIT7 是 0)，对于非 ASCII 字符一般使用 2 个字节来表示，非 ASCII 字符的数值 BIT7 都是 1</li><li>UNICODE：这就有点复杂了，下面一一讲解</li></ul><p>先用记事本新建 3 个文件：utf-16_le.txt、utf-16_be.txt、utf-8.txt、bom_utf-8.txt，里面的内容都是“ab 中”，保存时编码分别选择“UTF-16 LE”、“UTF-16 BE”、“UTF-8”、“带有 BOM 的 UTF-8”，下图是其中一个例子： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO9.png"> 怎么表示一个 UNICODE 数值？</p><ul><li>使用 3 个字节表示一个 UNICODE</li></ul><p>不，太浪费。</p><p>UNICODE 的最大值是 0x10FFFF，那使用 3 个字节来表示一个 UNICODE 数值？这当然是很省事的方法，但是会造成浪费，比如字符 A 的 UNICOCDE 值是 0x41，难道也用“0x41 0x00 0x00”这 3 个字节来表示</p><ul><li>UCS-2 Little endian/UTF-16 LE</li></ul><p>每个 UNICODE 值用 3 字节来表示有点浪费，那只用 2 字节呢？它可以表示 2^16=65536 个字符，全世界常用的字符都可以表示了。</p><p>Little endian 表示小字节序，数值中权重低的字节放在前面，比如字符“A 中”在 TXT 文件中的数值如下，其中的“A”使用“0x41 0x00”两字节表示；“中”使用“0x2d 0x4e”两字节表示。文件开头的“0xff 0xfe”表示“UTF-16 LE”。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO10.png"></p><ul><li>UCS-2 Big endian/UTF-16 BE</li></ul><p>Big endian 表示大字节序，数值中权重低的字节放在后面，比如字符“ab 中”在 TXT 文件中的数值如下，其中的“A”使用“0x00 0x41”两字节表示；“中”使用“0x4e 0x2d”两字节表示。文件开头的“0xfe 0xff”表示“UTF-16 BE”。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO11.png"></p><ul><li>UTF8</li></ul><p>在上面 2 种方法中，每一个 UNICODE 使用 2 字节来表示，这有 3 个缺点：表示的字符数量有限、对于 ASCII 字符有空间浪费、如果文件中有某个字节丢失，这会使得后面所有字符都因为错位而无法显示。</p><p>使用 UTF8 可以解决上述所有问题。UTF8 是变长的编码方法，有 2 种 UTF8 格式的文件：带有头部、不带头部。先举例，看下图： <img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO12.png"></p><p>对于其中的 ASCII 字符，在 UTF8 文件中直接用其 ASCII 码来表示，比如上图中的 0x61 表示字符 a、0x62 表示字符 b。上图中的 3 个字节“0xe4 0xb8 0xad”表示的数值是 0x4e2d，对应“中”的 UNICODE 码。</p><p>对于非 ASCII 字符，使用变长的编码：每一个字节的高位都自带长度信息。请看下图</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO13.png"></p><p>上图中，0xe4 的二进制是“11100100”，高位有 3 个 1，表示从当前字节起有 3 字节参与表示 UNICODE；</p><p>0xb8 的二进制是“10111000”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；</p><p>0xad 的二进制是“10101101”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；</p><p>除去高位的“1110”、“10”、“10”后，剩下的二进制数组合起来得到“01001110001101”，它就是 0x4e2d，即“中”的 UNICODE 值。</p><p>使用 UTF8 编码时，即使 TXT 文件中丢失了某些数据，也只会影响到当前字符的显示，后面的字符不受影响</p><h2 id="ascii-字符的点阵显示">ASCII 字符的点阵显示</h2><p>要在 LCD 中显示一个 ASCII 字符，即英文字母这些字符，首先是要找到字符对应的点阵。在 Linux 内核源码中有这个文件：lib_8x16.c，里面以数组形式保存各个字符的点阵，比如：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO14.png"></p><p>数组里的数字是如何表示点阵的？以字符 A 为例，如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO15.png"></p><p>上图左侧有 16 行数值，每行 1 个字节。每一个节对应右侧一行中 8 个像素：像素从右边数起，bit0 对应第 0 个像素，bit1 对应第 1 个像素，……，bit7 对应第 7 个像素。某位的值为 1 时，表示对应的像素要被点亮；值为 0 时表示对应的像素要熄灭。</p><p>所以要显示某个字符时，根据它的 ASCII 码在 fontdata_8x16 数组中找到它的点阵，然后取出这 16 个字节去描画 16 行像素。</p><p>比如字符 A 的 ASCII 值是 0x41，那么从 fontdata_8x16[0x41*16] 开始取其点阵数据。</p><h3 id="矢量字体引入">矢量字体引入</h3><p>使用点阵字库显示英文字母、汉字时，大小固定，如果放大缩小则会模糊甚至有锯齿出现，为了解决这个问题，引用矢量字体。</p><p>矢量字体形成分三步：</p><ul><li>确定关键点</li><li>使用数学曲线（贝塞尔曲线）连接头键点</li><li>填充闭合区线内部空间</li></ul><p>什么是关键点？以字母“A”为例，它的的关键点如下图中的黄色所示。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO16.png"></p><p>如果需要放大或者缩小字体，关键点的相对位置是不变的，只要数学曲线平滑，字体就不会变形。</p><h3 id="freetype-介绍">Freetype 介绍</h3><p>Freetype 是开源的字体引擎库，它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的 API 接口，提供字体文件，就可以让 freetype 库帮我们取出关键点、实现闭合曲线，填充颜色，达到显示矢量字体的目的。</p><p>关键点 (glyph) 存在字体文件中，Windows 使用的字体文件在 c:目录下，扩展名为 TTF 的都是矢量字库，本次使用实验使用的是新宋字体 simsun.ttc。</p><p>给定一个字符，怎么在字体文件中找到它的关键点？</p><p>首先要确定该字符的编码值：比如 ASCII 码、GB2312 码、UNICODE 码。如果字体文件支持某种编码格式 (charset)，就可以使用这类编码值去找到该字符的关键点 (glyph)。有些字体文件支持多种编码格式 (charset)，这在文件中被称为 charmaps（注意：这个单词是复数，意味着可能支持多种 charset)。</p><p>以 simsun.ttc 为值，该字体文件的格如下：头部含有 charmaps，可以使用某种编码值去 charmaps 中找到它对应的关键点。下图中的“A、B、中、国、韦”等只是 glyph 的示意图，表示关键点。</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO17.png"></p><p>Charmaps 表示字符映射表，字体文件可能支持哪一些编码，GB2312、UNICODE、BIG5 或其他。如果字体文件支持该编码，使用编码值通过 charmap 就可以找到对应的 glyph，一般而言都支持 UNICODE 码。</p><p>有了以上基础，一个文字的显示过程可以概括如下：</p><ul><li>给定一个字符可以确定它的编码值 (ASCII、UNICODE、GB2312)</li><li>设置字体大小</li><li>根据编码值，从文件头部中通过 charmap 找到对应的关键点 (glyph)，它会根据字体大小调整关键点</li><li>把关键点转换为位图点阵</li><li>在 LCD 上显示出来</li></ul><p>使用：</p><ul><li>初始化：FT_InitFreetype</li><li>加载（打开）字体 Face：FT_New_Face</li><li>设置字体大小：FT_Set_Char_Sizes 或 FT_Set_Pixel_Sizes</li><li>选择 charmap：FT_Select_Charmap</li><li>根据编码值 charcode 找到 glyph_index：glyph_index = FT_Get_Char_Index（face，charcode）</li><li>根据 glyph_index 取出 glyph：FT_Load_Glyph（face，glyph_index）</li><li>转为位图：FT_Render_Glyph</li><li>移动或旋转：FT_Set_Transform</li><li>最后显示出来</li></ul><p>上面的⑤⑥⑦可以使用一个函数代替：FT_Load_Char(face, charcode, FT_LOAD_RENDER)，它就可以得到位图。</p><h1 id="输入系统应用编程">输入系统应用编程</h1><h2 id="输入系统框架及调试">输入系统框架及调试</h2><h3 id="框架概述">框架概述</h3><p>输入系统框架如下图所示：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO18.png"></p><p>假设用户程序直接访问/dev/input/event0 设备节点，或者使用 tslib 访问设备节点，数据的流程如下：</p><ul><li>APP 发起读操作，若无数据则休眠；</li><li>用户操作设备，硬件上产生中断；</li><li><p>输入系统驱动层对应的驱动程序处理中断：<br>读取到数据，转换为标准的输入事件，向核心层汇报。 所谓输入事件就是一个“struct input_event”结构体。</p></li><li><p>核心层可以决定把输入事件转发给上面哪个 handler 来处理：<br>从 handler 的名字来看，它就是用来处输入操作的。有多种 handler，比如：evdev_handler、kbd_handler、 joydev_handler 等等。</p><p>最常用的是 evdev_handler：它只是把 input_event 结构体保存在内核 buffer 等，APP 来读取时就原原本本地返回。它 支持多个 APP 同时访问输入设备，每个 APP 都可以获得同一份输入事件。</p><p>当 APP 正在等待数据时，evdev_handler 会把它唤醒，这样 APP 就可以返回数据。</p></li><li><p>APP 对输入事件的处理：<br>APP 获得数据的方法有 2 种：直接访问设备节点（比如/dev/input/event0,1,2,...)，或者通过 tslib、libinput 这类库来间接访问设备节点。这些库简化了对数据的处理。</p></li></ul><h3 id="编写-app-需要掌握的知识">编写 APP 需要掌握的知识</h3><h4 id="内核中怎么表示一个输入设备">内核中怎么表示一个输入设备？</h4><p>使用 input_dev 结构体来表示输入设备，它的内容如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO19.png"></p><h4 id="app-可以得到什么数据">APP 可以得到什么数据？</h4><p>可以得到一系列的输入事件，就是一个一个“struct input_event”，它定义如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO20.png"></p><p>每个输入事件 input_event 中都含有发生时间：timeval 表示的是“自系统启动以来过了多少时间”，它是一个结构体，含有“tv_sec、tv_usec”两项（即秒、微秒）。</p><p>输入事件 input_event 中更重要的是：type（哪类事件）、code（哪个事件）、value（事件值），细讲如下：</p><ul><li><p>type：表示哪类事件<br>比如 EV_KEY 表示按键类、EV_REL 表示相对位移（比如鼠标），EV_ABS 表示绝对位置（比如触摸屏）。有这几类事件（参考 Linux 内核头文件）：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO21.png"></p></li><li><p>code：表示该类事件下的哪一个事件<br>比如对于 EV_KEY（按键）类事件，它表示键盘。键盘上有很多按键，比如数字键 1、2、3，字母键 A、B、C 里等。所以可以 有这些事件：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/%20LinuxIO22.png"></p><p>对于触摸屏，它提供的是绝对位置信息，有 X 方向、Y 方向，还有压力值。所以 code 值有这些：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO23.png"></p></li><li><p>value：表示事件值<br>对于按键，它的 value 可以是 0（表示按键被按下）、1（表示按键被松开）、2（表示长按）； 对于触摸屏，它的 value 就是坐标值、压力值。</p></li><li><p>事件之间的界线<br>APP 读取数据时，可以得到一个或多个数据，比如一个触摸屏的一个触点会上报 X、Y 位置信息，也可能会上报压力值。</p><p>APP 怎么知道它已经读到了完整的数据？</p><p>驱动程序上报完一系列的数据后，会上报一个“同步事件”，表示数据上报完毕。APP 读到“同步事件”时，就知道已经读 完了当前的数据。</p><p>同步事件也是一个 input_event 结构体，它的 type、code、value 三项都是 0。</p></li></ul><h4 id="输入子系统支持完整的-api-操作">输入子系统支持完整的 API 操作</h4><p>支持这些机制：阻塞、非阻塞、POLL/SELECT、异步通知。</p><h3 id="调试技巧">调试技巧</h3><h4 id="确定设备信息">确定设备信息</h4><p>输入设备的设备节点名为/dev/input/eventX（也可能是/dev/eventX，X 表示 0、1、2 等数字）。</p><p>怎么知道这些设备节点对应什么硬件呢？可以在板子上执行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/bus/input/devices</span><br></pre></td></tr></tbody></table></figure><p>这条指令的含义就是获取与 event 对应的相关设备信息，可以看到类似以下的结果：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO24.png"></p><p>那么这里的 I、N、P、S、U、H、B 对应的每一行是什么含义呢？</p><ul><li><p>I:id of the device（设备 ID)<br>该参数由结构体 struct input_id 来进行描述，驱动程序中会定义这样的结构体：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO25.png"></p></li><li>N:name of the device 设备名称</li><li>P:physical path to the device in the system hierarchy 系统层次结构中设备的物理路径</li><li>S:sysfs path 位于 sys 文件系统的路径</li><li>U:unique identification code for the device(if device has it) 设备的唯一标识码</li><li>H:list of input handles associated with the device 与设备关联的输入句柄列表</li><li><p>B:bitmaps（位图）</p></li></ul><p>PROP:device properties and quirks（设备属性） EV:types of events supported by the device（设备支持的事件类型） KEY:keys/buttons this device has（此设备具有的键/按钮） MSC:miscellaneous events supported by the device（设备支持的其他事件） LED:leds present on the device（设备上的指示灯）</p><p>值得注意的是 B 位图，比如上图中“B: EV=b”用来表示该设备支持哪类输入事件。b 的二进制是 1011，bit0、1、3 为 1，表示该设备支持 0、1、3 这三类事件，即 EV_SYN、EV_KEY、EV_ABS。</p><p>再举一个例子，“B: ABS=2658000 3”如何理解？</p><p>它表示该设备支持 EV_ABS 这一类事件中的哪一些事件。这是 2 个 32 位的数字：0x2658000、0x3，高位在前低位在后，组成一个 64 位的数字：“0x2658000,00000003”，数值为 1 的位有：0、1、47、48、50、53、54，即：0、1、0x2f、0x30、0x32、0x35、0x36，对应以下这些宏：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO26.png"></p><p>即这款输入设备支持上述的 ABS_X、ABS_Y、ABS_MT_SLOT、ABS_MT_TOUCH_MAJOR、ABS_MT_WIDTH_MAJOR、ABS_MT_POSITION_X、ABS_MT_POSITION_Y 这些绝对位置事件</p><h4 id="使用命令读取数据">使用命令读取数据</h4><p>调试输入系统时，直接执行类似下面的命令，然后操作对应的输入设备即可读出数据：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump /dev/input/event0</span><br></pre></td></tr></tbody></table></figure><p>在开发板上执行上述命令之后，点击按键或是点击触摸屏，就会打印以下信息：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO27.png"></p><p>上图中的 type 为 3，对应 EV_ABS；code 为 0x35 对应 ABS_MT_POSITION_X；code 为 0x36 对应 ABS_MT_POSITION_Y。上图中还发现有 2 个同步事件：它的 type、code、value 都为 0。表示电容屏上报了 2 次完整的数据。</p><h2 id="不使用库的应用程序示例">不使用库的应用程序示例</h2><h3 id="输入系统支持完整的-api-操作">输入系统支持完整的 API 操作</h3><p>支持这些机制：阻塞、非阻塞、POLL/SELECT、异步通知。</p><h3 id="app-访问硬件的-4-种方式妈妈怎么知道孩子醒了">APP 访问硬件的 4 种方式：妈妈怎么知道孩子醒了</h3><ul><li><p>查询方式<br>APP 调用 open 函数时，传入“O_NONBLOCK”表示“非阻塞”。</p><p>APP 调用 read 函数读取数据时，如果驱动程序中有数据，那么 APP 的 read 函数会返回数据，否则也会立刻返回错误。</p></li><li><p>休眠-唤醒方式<br>APP 调用 open 函数时，不要传入“O_NONBLOCK”。</p><p>APP 调用 read 函数读取数据时，如果驱动程序中有数据，那么 APP 的 read 函数会返回数据；否则 APP 就会在内核态休眠，当有数据时驱动程序会把 APP 唤醒，read 函数恢复执行并返回数据给 APP。</p></li><li><p>POLL/SELECT 方式<br>POLL 机制、SELECT 机制是完全一样的，只是 APP 接口函数不一样。</p><p>简单地说，它们就是“定个闹钟”：在调用 poll、select 函数时可以传入“超时时间”。在这段时间内，条件合适时（比如有数据可读、有空间可写）就会立刻返回，否则等到“超时时间”结束时返回错误。</p><p>用法如下。</p><p>APP 先调用 open 函数时。</p><p>APP 不是直接调用 read 函数，而是先调用 poll 或 select 函数，这 2 个函数中可以传入“超时时间”。它们的作用是：如果 驱动程序中有数据，则立刻返回；否则就休眠。在休眠期间，如果有人操作了硬件，驱动程序获得数据后就会把 APP 唤 醒，导致 poll 或 select 立刻返回；如果在“超时时间”内无人操作硬件，则时间到后 poll 或 select 函数也会返回。APP 可 以根据函数的返回值判断返回原因：有数据？无数据超时返回？</p><p>APP 根据 poll 或 select 的返回值判断有数据之后，就调用 read 函数读取数据时，这时就会立刻获得数据。</p><p>poll/select 函数可以监测多个文件，可以监测多种事件：在调用 poll 函数时，要指明：</p><ul><li><p>你要监测哪一个文件：哪一个 fd</p></li><li><p>你想监测这个文件的哪种事件：是 POLLIN、还是 POLLOUT</p></li></ul><p>最后，在 poll 函数返回时，要判断状态。</p></li><li><p>异步通知方式<br>所谓异步通知，就是 APP 可以忙自己的事，当驱动程序用数据时它会主动给 APP 发信号，这会导致 APP 执行信号处理函数。</p></li></ul><h2 id="tslib">tslib</h2><h3 id="tslib-框架分析">tslib 框架分析</h3><p>tslib 的主要代码如下：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO30.png"></p><p>核心在于“plugins”目录里的“插件”，或称为“module”。这个目录下的每个文件都是一个 module，每个 module 都提供 2 个函数：read、read_mt，前者用于读取单点触摸屏的数据，后者用于读取多点触摸屏的数据</p><p>要分析 tslib 的框架，先看看示例程序怎么使用，我们参考 ts_test.c 和 ts_test_mt.c，前者用于一般触摸屏（比如电阻屏、单点电容屏），后者用于多点触摸屏。</p><p>一个图就可以弄清楚 tslib 的框架：</p><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Note/LinuxIO31.png"></p><h1 id="参考文献">参考文献</h1><p>《韦东山老师课程》</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kalibr</title>
      <link href="/next/2019/Note/kalibr/"/>
      <url>/next/2019/Note/kalibr/</url>
      
        <content type="html"><![CDATA[<h1 id="安装">安装</h1><h2 id="ros-安装">ros 安装</h2><p>设置 sources.list:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">'echo "deb &lt;http://packages.ros.org/ros/ubuntu&gt; $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'</span></span><br></pre></td></tr></tbody></table></figure><p>设置 keys:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></tbody></table></figure><p>安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></tbody></table></figure><p>设置环境：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/ros/kinetic/setup.bash"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">or</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/ros/kinetic/setup.zsh"</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></tbody></table></figure><p>安装依赖：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></tbody></table></figure><p>初始化 rosdep:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-rosdep</span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="编译安装-calibr">编译安装 calibr</h2><p>安装依赖：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-setuptools python-rosinstall ipython libeigen3-dev libboost-all-dev doxygen libopencv-dev ros-indigo-vision-opencv ros-indigo-image-transport-plugins ros-indigo-cmake-modules python-software-properties software-properties-common libpoco-dev python-matplotlib python-scipy python-git python-pip ipython libtbb-dev libblas-dev liblapack-dev python-catkin-tools libv4l-dev</span><br><span class="line"></span><br><span class="line">sudo pip install python-igraph --upgrade</span><br></pre></td></tr></tbody></table></figure><p>创建 catkin 工作空间：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/kalibr_workspace/src</span><br><span class="line"><span class="built_in">cd</span> ~/kalibr_workspace</span><br><span class="line"><span class="built_in">source</span> /opt/ros/kinect/setup.bash</span><br><span class="line">catkin init</span><br><span class="line">catkin config --extend /opt/ros/kinect</span><br><span class="line">catkin config --merge-devel <span class="comment"># Necessary for catkin_tools &gt;= 0.4.</span></span><br><span class="line">catkin config --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></tbody></table></figure><p>clone 源码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr_workspace/src</span><br><span class="line">git <span class="built_in">clone</span> &lt;https://github.com/ethz-asl/Kalibr.git&gt;</span><br></pre></td></tr></tbody></table></figure><p>编译：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr_workspace</span><br><span class="line">catkin build -DCMAKE_BUILD_TYPE=Release -j4</span><br></pre></td></tr></tbody></table></figure><p>设置环境：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/kalibr_workspace/devel/setup.bash</span><br></pre></td></tr></tbody></table></figure><h1 id="校准">校准</h1><h2 id="多相机校准">多相机校准</h2><p>准备数据集：在 dataset-dir 目录下创建 cam0、cam1... 目录，将每个摄像头的数据分别放到对应的目录下，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_bagcreater --folder dataset-dir/ --output-bag output.bag</span><br></pre></td></tr></tbody></table></figure><p>执行校准命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_calibrate_cameras --target april_6x6.yaml --bag output.bag --models pinhole-equi pinhole-equi --topics /cam0/image_raw /cam1/image_raw</span><br></pre></td></tr></tbody></table></figure><h2 id="相机-imu-校准">相机-IMU 校准</h2><p>准备数据集：在 dataset-dir 目录下创建 cam0、cam1... 目录，将每个摄像头的数据分别放到对应的目录下，准备 imu 数据以 csv 文件格式放入 dataset-dir 目录下以 imu0.csv 为文件名，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_bagcreater --folder dataset-dir/ --output-bag output.bag</span><br></pre></td></tr></tbody></table></figure><p>执行校准命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_calibrate_imu_camera --target april_6x6.yaml --cam camchain.yaml --imu imu_adis16448.yaml --bag output.bag --bag-from-to 5 45</span><br></pre></td></tr></tbody></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aHotYXNsL2thbGlici93aWtp">https://github.com/ethz-asl/kalibr/wiki<i class="fa fa-external-link-alt"></i></span></p><p>💡<br>1、csv 文件里不能有空格，时间参数以 ns 为单位共 19 位数<br>2、相机录像不要有镜像，否则会检测不到角点</p><h2 id="出错">出错</h2><p>💡 提示：“Spline Coefficient Buffer Exceeded. Set larger buffer margins ” 在标定命令最后添加 --timeoffset-padding 0.1</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 常用命令</title>
      <link href="/next/2019/Note/ffmpegUsage/"/>
      <url>/next/2019/Note/ffmpegUsage/</url>
      
        <content type="html"><![CDATA[<h1 id="合并文件">合并文件</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"concat:file_name1.ts | file_name2.ts"</span> -c copy_out.ts</span><br></pre></td></tr></tbody></table></figure><h1 id="在视频文件中提取图片">在视频文件中提取图片</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i output.ts <span class="string">'%d.png'</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="h264-转-yuv">H264 转 yuv</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i SampleEis2Venc.H264 -pix_fmt nv12 -vcodec rawvideo -an SampleRaw.yuv</span><br></pre></td></tr></tbody></table></figure><h1 id="单张图片生成-h264-视频">单张图片生成 H264 视频</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -ss 0 -t 16 -f lavfi -i color=c=0x000000:s=1920x1080:r=25  -i test.jpg -filter_complex  <span class="string">"[1:v]scale=1920:1080[v1];[0:v][v1]overlay=0:0[outv]"</span> -map [outv] -c:v libx264 SampleRaw.H264 -y</span><br></pre></td></tr></tbody></table></figure><h1 id="横向拼接两个视频">横向拼接两个视频</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -filter_complex <span class="string">"[0:v]pad=iw*2:ih*1[a];[a][1:v]overlay=w"</span> out.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># pad 是将合成的视频宽高，这里 iw 代表第一个视频的宽，iw*2 代表合成后的视频宽度加倍，ih 为第一个视频的高，合成的两个视频最好分辨率一致。overlay 是覆盖，[a][1:v]overlay=w，后面代表是覆盖位置 w:0</span></span><br></pre></td></tr></tbody></table></figure><h1 id="竖屏拼接两个视频">竖屏拼接两个视频</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -filter_complex <span class="string">"[0:v]pad=iw:ih*2[a];[a][1:v]overlay=0:h"</span> out.mp4</span><br></pre></td></tr></tbody></table></figure><h1 id="横向拼接三个视频">横向拼接三个视频</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -filter_complex <span class="string">"[0:v]pad=iw*3:ih*1[a];[a][1:v]overlay=w[b];[b][2:v]overlay=2.0*w"</span> out.mp4</span><br></pre></td></tr></tbody></table></figure><h1 id="竖向拼接三个视频">竖向拼接三个视频</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -filter_complex <span class="string">"[0:v]pad=iw:ih*3[a];[a][1:v]overlay=0:h[b];[b][2:v]overlay=0:2.0*h"</span> out.mp4</span><br></pre></td></tr></tbody></table></figure><h1 id="四个视频-2x2-排列拼接">四个视频 2x2 排列拼接</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.mp4 -i out2.mp4 -i out3.mp4 -i out4.mp4 -filter_complex <span class="string">"[0:v]pad=iw*2:ih*2[a];[a][1:v]overlay=w[b];[b][2:v]overlay=0:h[c];[c][3:v]overlay=w:h"</span> out.mp4</span><br></pre></td></tr></tbody></table></figure><h1 id="mp3-转-wav">MP3 转 WAV</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp3 -f s16le -acodec pcm_s16le -ac 2 -ar 48000 output.wav</span><br></pre></td></tr></tbody></table></figure><ul><li>-acodec pcm_s16le pcm_s16le 16bits 编码器</li><li>-f s16le 保存为 16bits pcm 格式</li><li>-ac 2 双声道</li><li>-ar 48000 48000 采样率</li></ul><h1 id="video-提取音频文件">Video 提取音频文件</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.rmvb -f wav -ar <span class="number">48000</span> audio.wav</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 语法</title>
      <link href="/next/2019/Note/MakefileSummery/"/>
      <url>/next/2019/Note/MakefileSummery/</url>
      
        <content type="html"><![CDATA[<h1 id="makefile-规则">Makefile 规则</h1><p>一个简单的 Makefile 文件包含一系列的“规则”，其样式如下：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标 (target)…: 依赖 (prerequiries)…&lt;tab&gt;命令 (command)</span><br></pre></td></tr></tbody></table></figure><ul><li>目标 (target) 通常是要生成的文件的名称，可以是可执行文件或 OBJ 文件，也可以是一个执行的动作名称，诸如`clean’。</li><li>依赖是用来产生目标的材料（比如源文件），一个目标经常有几个依赖。</li><li>命令是生成目标时执行的动作，一个规则可以含有几个命令，每个命令占一行。 注意：每个命令行前面必须是一个 Tab 字符，即命令行第一个字符是 Tab。</li></ul><p>通常，如果一个依赖发生了变化，就需要规则调用命令以更新或创建目标。但是并非所有的目标都有依赖，例如，目标“clern”的作用是清除文件，它没有依赖。 规则一般是用于解释怎样和何时重建目标。</p><p>make 首先调用命令处理依赖，进而才能创建或更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。一个 Makefile 文件可以包含规则以外的其他文本，但一个简单的 Makefile 文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但格式是完全一样的。</p><p>对于上面的 Makefile，执行“make”命令时，仅当 hello.c 文件比 hello 文件新时才会执行命令“arm-linux-gcc –o hello hello.c”生成可执行文件 hello；如果还没有 hello 文件，这个命令也会执行。 运行“make clean”时，由于目标 clean 没有依赖，它的命令“rm -f hello”将被强制执行。</p><span id="more"></span><h1 id="变量">变量</h1><h2 id="即时变量延时变量">即时变量、延时变量</h2><p>变量的定义语法形式如下：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A  =  xxx    // 延时变量，它的值在使用时才展开、才确定</span><br><span class="line">B  ?= xxx    // 延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效</span><br><span class="line">C  := xxx    // 立即变量</span><br><span class="line">D  += yyy    // 如果 D 在前面是延时变量，那么现在它还是延时变量；</span><br><span class="line">// 如果 D 在前面是立即变量，那么现在它还是立即变量</span><br></pre></td></tr></tbody></table></figure><h2 id="变量的导出-export">变量的导出 (export)</h2><p>在编译程序时，我们会不断地使用“make -C dir”切换到其他目录，执行其他目录里的 Makefile。如果想让某个变量的值在所有目录中都可见，要把它 export 出来。 比如“CC = $(CROSS_COMPILE)gcc”，这个 CC 变量表示编译器，在整个过程中都是一样的。定义它之后，要使用“export CC”把它导出来。</p><h2 id="makefile-中可以使用-shell-命令">Makefile 中可以使用 shell 命令</h2><p>比如：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br></pre></td></tr></tbody></table></figure><p>这是个立即变量，TOPDIR 等于 shell 命令 pwd 的结果。</p><h1 id="makefile-文件里的赋值方法">Makefile 文件里的赋值方法</h1><p>变量的定义语法形式如下：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediatedefine </span><br><span class="line">immediatedeferredendef</span><br></pre></td></tr></tbody></table></figure><p>在 GNU make 中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才扩展开，意即当真正使用时这个变量的值才确定；后者在定义时它的值就已经确定了。使用=, ?=定义或使用 define 指令定义的变量是延时变量；使用：=定义的变量是立即变量。需要注意的一点是，?=仅仅在变量还没有定义的情况下有效，即？=被用来定义第一次出现的延时变量。 对于附加操作符+=，右边变量如果在前面使用（:=）定义为立即变量则它也是立即变量，否则均为延时变量。</p><h1 id="目标">目标</h1><h2 id="在-makefile-中怎么放置第-1-个目标">在 Makefile 中怎么放置第 1 个目标</h2><p>执行 make 命令时如果不指定目标，那么它默认是去生成第 1 个目标。 所以“第 1 个目标”，位置很重要。有时候不太方便把第 1 个目标完整地放在文件前面，这时可以在文件的前面直接放置目标，在后面再完善它的依赖与命令。比如：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">First_target:   // 这句话放在前面．．．．  </span></span><br><span class="line">// 其他代码，比如 <span class="keyword">include</span> 其他文件得到后面的 xxx 变量</span><br><span class="line">First_target : <span class="variable">$(xxx)</span>   <span class="variable">$(yyy)</span>   // 在文件的后面再来完善    </span><br><span class="line">command</span><br></pre></td></tr></tbody></table></figure><h2 id="假想目标">假想目标</h2><p>我们的 Makefile 中有这样的目标：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:    rm -f $(shell find -name "*.o")    rm -f <span class="variable">$(TARGET)</span></span></span><br></pre></td></tr></tbody></table></figure><p>如果当前目录下恰好有名为“clean”的文件，那么执行“make clean”时它就不会执行那些删除命令。 这时我们需要把“clean”这个目标，设置为“假想目标”，这样可以确保执行“make clean”时那些删除命令肯定可以得到执行。 使用下面的语句把“clean”设置为假想目标：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></tbody></table></figure><h1 id="makefile-常用函数">Makefile 常用函数</h1><h2 id="字符串替换和分析函数">字符串替换和分析函数</h2><p><strong>$(subst from,to,text)</strong></p><p>在文本 text 中使用 to 替换每一处`from’。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span> <span class="comment">#结果为‘fEEt on the street’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(patsubst pattern,replacement,text)</strong></p><p>寻找 text’中符合格式 pattern’的字，用 replacement’替换它们。pattern’和 replacement’中可以使用通配符。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span> <span class="comment">#结果为：x.c.o bar.o</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(strip string)</strong></p><p>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a   b c )</span> <span class="comment">#结果为`a b c’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(findstring find,in)</strong></p><p>在字符串 in 中搜寻 find，如果找到，则返回值是`find’，否则返回值为空。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span> <span class="comment">#产生 a$(findstring a,b c)   #产生空</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(filter pattern…,text)</strong></p><p>返回在 text’中由空格隔开且匹配格式 pattern…’的字，去除不符合格式 pattern...’的字。 eg: <code>bash $(filter %.c %.s, foo.c bar.c baz.s ugh.h) #结果为 foo.c bar.c baz.s’</code></p><p><strong>$(filter-out pattern…,text)</strong></p><p>返回在 text’中由空格隔开且不匹配格式 pattern…’的字，去除符合格式 pattern...’的字。它是函数 filter 的反函数。 eg:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h) <span class="comment">#结果为 ugh.h </span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(sort list)</strong></p><p>将‘list’中的字按字母顺序排序，并去掉重复的字。输出由单个空格隔开的字的列表。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> foo bar lose)</span> <span class="comment"># 返回值是‘bar foo lose’</span></span><br></pre></td></tr></tbody></table></figure><h2 id="文件名函数">文件名函数</h2><p><strong>$(dir names…)</strong></p><p>抽取‘names…’中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠（含斜杠）之前的一切字符。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span> <span class="comment"># 结果为‘src/ ./’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(notdir names…)</strong></p><p>抽取‘names…’中每一个文件名中除路径部分外一切字符（真正的文件名）。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span> <span class="comment">#结果为‘foo.c hacks’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(suffix names…)</strong></p><p>抽取‘names…’中每一个文件名的后缀。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span> <span class="comment"># 结果为‘.c .c’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(basename names…)</strong></p><p>抽取‘names…’中每一个文件名中除后缀外一切字符。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar hacks)</span> <span class="comment">#结果为‘src/foo src-1.0/bar hacks’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(addsuffix suffix,names…)</strong></p><p>参数‘names…’是一系列的文件名，文件名之间用空格隔开；suffix 是一个后缀名。将 suffix（后缀）的值附加在每一个独立文件名的后面，完成后将文件名串联起来，它们之间用单个空格隔开。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c,foo bar)</span> <span class="comment"># 结果为‘foo.c bar.c’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(addprefix prefix,names…)</strong></p><p>参数‘names’是一系列的文件名，文件名之间用空格隔开；prefix 是一个前缀名。将 preffix（前缀）的值附加在每一个独立文件名的前面，完成后将文件名串联起来，它们之间用单个空格隔开。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/,foo bar)</span> <span class="comment"># 结果为‘src/foo src/bar’</span></span><br></pre></td></tr></tbody></table></figure><p><strong>$(wildcard pattern)</strong></p><p>参数‘pattern’是一个文件名格式，包含有通配符（通配符和 shell 中的用法一样）。函数 wildcard 的结果是一列和格式匹配的且真实存在的文件的名称，文件名之间用一个空格隔开。 eg: 若当前目录下有文件 1.c、2.c、1.h、2.h，则：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_src := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#结果为‘1.c 2.c’</span></span><br></pre></td></tr></tbody></table></figure><h2 id="其他函数">其他函数</h2><p><strong>$(foreach var,list,text)</strong></p><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。 eg:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objs := a.o b.odep_files := <span class="variable">$(<span class="built_in">foreach</span>  f,  <span class="variable">$(objs)</span>,  .<span class="variable">$(f)</span>.d)</span>  // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></tbody></table></figure><p><strong>$(if condition,then-part[,else-part])</strong></p><p>先把第一个参数‘condition’的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符串，则条件‘condition’为‘真’；如果扩展为空字符串，则条件‘condition’为‘假’。 如果条件‘condition’为‘真’, 那么计算第二个参数‘then-part’的值，并将该值作为整个函数 if 的值。 如果条件‘condition’为‘假’, 并且第三个参数存在，则计算第三个参数‘else-part’的值，并将该值作为整个函数 if 的值；如果第三个参数不存在，函数 if 将什么也不计算，返回空值。</p><p><strong>(<em>originvariable</em>)</strong></p><p>变量‘<em>variable</em>’是一个查询变量的名称_，不是对该变量的引用。所以不能采用‘’和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。</p><p>函数 origin 的结果是一个字符串，该字符串变量是这样定义的：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">'undefined'             ：如果变量‘variable’从没有定义；</span><br><span class="line">‘default'               ：变量‘variable’是缺省定义；</span><br><span class="line">‘environment'           ：变量‘variable’作为环境变量定义，选项‘-e’没有打开；</span><br><span class="line">‘environment <span class="keyword">override</span>'  ：变量‘variable’作为环境变量定义，选项‘-e’已打开；</span><br><span class="line">‘file'                  ：变量‘variable’在 Makefile 中定义；</span><br><span class="line">‘command line'          ：变量‘variable’在命令行中定义；</span><br><span class="line">‘<span class="keyword">override</span>'              ：变量‘variable’在 Makefile 中用 <span class="keyword">override</span> 指令定义；</span><br><span class="line">‘automatic'             ：变量‘variable’是自动变量</span><br></pre></td></tr></tbody></table></figure><p><strong>$(shell command arguments)</strong></p><p>函数 shell 是 make 与外部环境的通讯工具。函数 shell 的执行结果和在控制台上执行‘command arguments’的结果相似。不过如果‘command arguments’的结果含有换行符（和回车符），则在函数 shell 的返回结果中将把它们处理为单个空格，若返回结果最后是换行符（和回车符）则被去掉。 比如当前目录下有文件 1.c、2.c、1.h、2.h，则：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_src := <span class="variable">$(<span class="built_in">shell</span> ls *.c)</span> <span class="comment"># 结果为‘1.c 2.c’</span></span><br></pre></td></tr></tbody></table></figure><h1 id="make-命令的使用">make 命令的使用</h1><p>执行 make 命令时，它会去当前目录下查找名为“Makefile”的文件，并根据它的指示去执行操作，生成第一个目标。 我们可以使用“-f”选项指定文件，不再使用名为“Makefile”的文件，比如：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make  -f  Makefile.build </span><br></pre></td></tr></tbody></table></figure><p>我们可以使用“-C”选项指定目录，切换到其他目录里去，比如：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C  a/  -f  Makefile.build</span><br></pre></td></tr></tbody></table></figure><p>我们可以指定目标，不再默认生成第一个目标：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C  a/  -f  Makefile.build   other_target</span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《韦东山老师的课程及书籍》</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译流程</title>
      <link href="/next/2019/Note/CompilePipe/"/>
      <url>/next/2019/Note/CompilePipe/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc-编译流程">gcc 编译流程</h1><p>一个 C/C++文件要经过预处理 (preprocessing)、编译 (compilation)、汇编 (assembly) 和链接 (linking) 等 4 步才能变成可执行文件。</p><h2 id="预处理">预处理</h2><p>C/C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令“#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。预处理就是将要包含 (include) 的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一步处理。</p><h2 id="编译">编译</h2><p>编译就是把 C/C++代码（比如上述的“.i”文件）“翻译”成汇编代码，所用到的工具为 cc1（它的名字就是 cc1，x86 有自己的 cc1 命令，ARM 板也有自己的 cc1 命令）。</p><h2 id="汇编">汇编</h2><p>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在 Linux 系统上一般表现为 ELF 目标文件 (OBJ 文件），用到的工具为 as。x86 有自己的 as 命令，ARM 版也有自己的 as 命令，也可能是 xxxx-as（比如 arm-linux-as）。</p><h2 id="链接">链接</h2><p>链接就是将上步生成的 OBJ 文件和系统库的 OBJ 文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件，用到的工具为 ld 或 collect2。</p><p>编译程序时，加上-v 选项就可以看到这几个步骤</p><span id="more"></span><h1 id="gcc-常用编译选项">gcc 常用编译选项</h1><ul><li>E 预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</li><li>c 把预处理、编译、汇编都做了，但是不链接</li><li>o 指定输出文件</li><li>I 指定头文件目录</li><li>L 指定链接时库文件目录</li><li>l 指定链接哪一个库文件</li></ul><h1 id="gcc-总体选项-overall-option">GCC 总体选项 (Overall Option)</h1><ul><li><p><strong>-c</strong><br>预处理、编译和汇编源文件，但是不作链接，编译器根据源文件生成 OBJ 文件。缺省情况下，GCC 通过用。o'替换源文件名的后缀。c’，.i'，.s’等，产生 OBJ 文件名。可以使用-o 选项选择其他名字。GCC 忽略-c 选项后面任何无法识别的输入文件。</p></li><li><p><strong>S</strong><br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。缺省情况下，GCC 通过用。s 替换源文件名后缀。c，`.i’等等，产生汇编文件名。可以使用-o 选项选择其他名字。GCC 忽略任何不需要汇编的输入文件。</p></li><li><p><strong>E</strong><br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。</p></li><li><p><strong>-o file</strong><br>指定输出文件为 file。无论是预处理、编译、汇编还是链接，这个选项都可以使用。如果没有使用-o 选项，默认的输出结果是：可执行文件为 a.out；修改输入文件的名称是 source.suffix'，则它的 OBJ 文件是 source.o’，汇编文件是 `source.s’，而预处理后的 C 源代码送往标准输出。</p></li><li><p><strong>v</strong><br>显示制作 GCC 工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。</p></li></ul><h1 id="警告选项-warning-option">警告选项 (Warning Option)</h1><ul><li><strong>-Wall</strong><br>这个选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明之前就使用的函数、局部变量除了声明就没再使用等。</li></ul><h1 id="调试选项-debugging-option">调试选项 (Debugging Option)</h1><ul><li><p><strong>-g</strong><br>以操作系统的本地格式 (stabs，COFF，XCOFF，或 DWARF) 产生调试信息，GDB 能够使用这些调试信息。在大多数使用 stabs 格式的系统上，-g'选项加入只有 GDB 才使用的额外调试信息。可以使用下面的选项来生成额外的信息：-gstabs+‘，-gstabs'，-gxcoff+’，-gxcoff'，-gdwarf+‘或`-gdwarf’，具体用法请读者参考 GCC 手册。</p></li><li><p><strong>-O0</strong><br>不优化。</p></li><li><p><strong>-O 或-O1</strong><br>优化：对于大函数，优化编译的过程将占用稍微多的时间和相当大的内存。不使用-O'或-O1’选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的：如果在两条语句之间用断点中止程序，可以对任何变量重新赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确地获取你所期待的结果。 不使用-O'或-O1’选项时，只有声明了 register 的变量才分配使用寄存器。 使用了-O'或-O1’选项，编译器会试图减少目标码的大小和执行时间。如果指定了-O'或-O1’选项，-fthread-jumps'和-fdefer-pop’选项将被打开。在有 delay slot 的机器上，-fdelayed-branch'选项将被打开。在即使没有帧指针 (frame pointer) 也支持调试的机器上，-fomit-frame-pointer’选项将被打开。某些机器上还可能会打开其他选项。</p></li><li><p><strong>O2</strong><br>多优化一些。除了涉及空间和速度交换的优化选项，执行几乎所有的优化工作。例如不进行循环展开 (loop unrolling) 和函数内嵌 (inlining)。和-O'或-O1’选项比较，这个选项既增加了编译时间，也提高了生成代码的运行效果。</p></li><li><p><strong>O3</strong><br>优化的更多。除了打开-O2 所做的一切，它还打开了-finline-functions 选项。</p></li></ul><h1 id="链接器选项-linker-option">链接器选项 (Linker Option)</h1><ul><li><p><strong>-object-file-name</strong><br>如果某些文件没有特别明确的后缀 (a special recognized suffix)，GCC 就认为他们是 OBJ 文件或库文件（根据文件内容，链接器能够区分 OBJ 文件和库文件）。如果 GCC 执行链接操作，这些 OBJ 文件将成为链接器的输入文件。</p></li><li><p><strong>-llibrary</strong><br>链接名为 library 的库文件。 链接器在标准搜索目录中寻找这个库文件，库文件的真正名字是 liblibrary.a'。搜索目录除了一些系统标准目录外，还包括用户以-L’选项指定的路径。一般说来用这个方法找到的文件是库文件──即由 OBJ 文件组成的归档文件 (archive file)。链接器处理归档文件的方法是：扫描归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果链接器找到普通的 OBJ 文件，而不是库文件，就把这个 OBJ 文件按平常方式链接进来。指定-l'选项和指定文件名的唯一区别是，-l 选项用 lib 和。a 把 library 包裹起来，而且搜索一些目录。</p></li><li><p><strong>-nostartfiles</strong><br>不链接系统标准启动文件，而标准库文件仍然正常使用。</p></li><li><p><strong>-nostdlib</strong><br>不链接系统标准启动文件和标准库文件，只把指定的文件传递给链接器。这个选项常用于编译内核、bootloader 等程序，它们不需要启动文件、标准库文件。</p></li><li><p><strong>-static</strong><br>在支持动态链接 (dynamic linking) 的系统上，阻止链接共享库，当不使用-static 编译文件时，程序执行前要链接共享库文件，所以还需要将共享库文件放入文件系统中。</p></li><li><p><strong>-shared</strong><br>生成一个共享 OBJ 文件，它可以和其他 OBJ 文件链接产生可执行文件。只有部分系统支持该选项。 当不想以源代码发布程序时，可以使用-shared 选项生成库文件，比如对于 options 程序，可以如下制作库文件：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">gcc -shared -o libsub.so sub.o</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p><strong>-Xlinker option</strong><br>把选项 option 传递给链接器。可以用来传递系统特定的链接选项，GCC 无法识别这些选项。如果需要传递携带参数的选项，必须使用两次-Xlinker'，一次传递选项，另一次传递其参数。例如，如果传递-assert definitions’，要成-Xlinker -assert -Xlinker definitions'，而不能写成-Xlinker “-assert definitions”’，因为这样会把整个字符串当做一个参数传递，显然这不是链接器期待的。</p></li><li><p><strong>-Wl, option</strong><br>把选项 option 传递给链接器。如果 option 中含有逗号，就在逗号处分割成多个选项。链接器通常是通过 gcc、arm-linux-gcc 等命令间接启动的，要向它传入参数时，参数前面加上`-Wl,’。</p></li><li><p><strong>-u symbol</strong><br>使链接器认为取消了 symbol 的符号定义，从而链接库模块以取得定义。可以使用多个 `-u’选项，各自跟上不同的符号，使得链接器调入附加的库模块。</p></li></ul><h1 id="目录选项-directory-option">目录选项 (Directory Option)</h1><ul><li><p><strong>-Idir</strong><br>在头文件的搜索路径列表中添加 dir 目录。 头文件的搜索方法为：如果以“#include &lt; &gt;”包含文件，则只在标准库目录开始搜索（包括使用-Idir 选项定义的目录）；如果以“#include “”包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</p></li><li><p><strong>-I-</strong><br>任何在-I-'前面用-I’选项指定的搜索路径只适用于#include "file"'这种情况；它们不能用来搜索#include ’包含的头文件。如果用-I'选项指定的搜索路径位于-I-’选项后面，就可以在这些路径中搜索所有的#include'指令（一般说来-I 选项就是这么用的）。还有，-I-’选项能够阻止当前目录（存放当前输入文件的地方）成为搜索#include "file"'的第一选择。-I-’不影响使用系统标准目录，因此，-I-'和-nostdinc’是不同的选项。</p></li><li><p><strong>-Ldir</strong><br>在`-l’选项的搜索路径列表中添加 dir 目录。指定库文件路径。</p></li><li><p><strong>-Bprefix</strong><br>这个选项指出在何处寻找可执行文件，库文件，以及编译器自己的数据文件。编译器驱动程序需要使用某些工具，比如：cpp，cc1’ （或 C++的 cc1plus')，as’和 ld'。它把 prefix 当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。 对于要运行的工具，编译器驱动程序首先试着加上-B’前缀（如果存在），如果没有找到文件，或没有指定-B'选项，编译器接着会试验两个标准前缀/usr/lib/gcc/’和/usr/local/lib/gcc-lib/'。如果仍然没能够找到所需文件，编译器就在 PATH’环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时 (run-time) 支持文件 libgcc.a'也在-B’前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找，仅此而已。如果上述方法没有找到这个文件，就不链接它了。多数情况的多数机器上，libgcc.a'并非必不可少。 可以通过环境变量 GCC_EXEC_PREFIX 获得近似的效果；如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了-B’选项和 GCC_EXEC_PREFIX 变量，编译器首先使用`-B’选项，然后才尝试环境变量值。</p></li><li><p><strong>-ld/objdump/objcopy 选项</strong></p></li></ul><h1 id="制作使用动态库">制作使用动态库</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o  main.c</span><br><span class="line">gcc -c -o sub.o   sub.c</span><br><span class="line">gcc -shared  -o libsub.so  sub.o  sub2.o  sub3.o <span class="comment">#（可以使用多个。o 生成动态库）</span></span><br><span class="line">gcc -o <span class="built_in">test</span> main.o  -lsub  -L /libsub.so/所在目录/</span><br></pre></td></tr></tbody></table></figure><h1 id="制作使用静态库">制作使用静态库</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o  main.c</span><br><span class="line">gcc -c -o sub.o   sub.c</span><br><span class="line">ar  crs  libsub.a  sub.o  sub2.o  sub3.o <span class="comment">#（可以使用多个。o 生成静态库）</span></span><br><span class="line">gcc  -o  <span class="built_in">test</span>  main.o  libsub.a  <span class="comment">#（如果。a 不在当前目录下，需要指定它的绝对或相对路径）</span></span><br></pre></td></tr></tbody></table></figure><h1 id="参考文献">参考文献</h1><p>《韦东山老师的课程及书籍》</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令</title>
      <link href="/next/2019/Note/gitUsage/"/>
      <url>/next/2019/Note/gitUsage/</url>
      
        <content type="html"><![CDATA[<h1 id="常用">常用</h1><h2 id="git-与上游-保持同步">git 与上游 保持同步</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add src-zephyr &lt;https://github.com/zephyrproject-rtos/zephyr&gt;</span><br><span class="line">git pull src-zephyr master</span><br><span class="line">git push</span><br></pre></td></tr></tbody></table></figure><h2 id="git-合并分支">git 合并分支</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br><span class="line">git pull --rebase origin</span><br><span class="line">git pull --rebase origin release-v1.0</span><br></pre></td></tr></tbody></table></figure><p>如果有冲突：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 查看冲突文件并解决冲突</span></span><br><span class="line">git add <span class="comment"># 提交解决冲突后的文件</span></span><br><span class="line">git rebase --<span class="built_in">continue</span> <span class="comment"># 完成</span></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="免密操作">免密操作</h2><h3 id="方法一"><strong>方法一</strong></h3><p>进入用户主目录：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br></pre></td></tr></tbody></table></figure><p>建立文件 .git-credentials：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> .git-credentia</span><br></pre></td></tr></tbody></table></figure><p>编辑文件 .git-credentials：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi .git-credentials</span><br></pre></td></tr></tbody></table></figure><p>添加规则：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://username:password@gitlab.com&gt;</span><br></pre></td></tr></tbody></table></figure><p>执行命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></tbody></table></figure><h3 id="方法二"><strong>方法二</strong></h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper store</span><br><span class="line">$ git pull /git push</span><br></pre></td></tr></tbody></table></figure><p>第一次需要输入用户名密码，以后就不用了（本质上同上，会在用户目录下创建。git-credential 文件并将用户信息写入该文件）</p><h2 id="git-撤销修改">git 撤销修改</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file]</span><br><span class="line">git checkout .</span><br></pre></td></tr></tbody></table></figure><h2 id="git-撤销-add">git 撤销 add</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset [file]</span><br><span class="line">git reset <span class="comment"># 取消所有更改</span></span><br></pre></td></tr></tbody></table></figure><h2 id="git-撤销-commit">git 撤销 commit</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^ <span class="comment"># 不删除工作空间改动代码，撤销 commit，不撤销 git add .</span></span><br><span class="line">git reset --mixed HEAD^ <span class="comment"># 不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作 </span></span><br><span class="line">git reset HEAD^ <span class="comment"># 同 git reset --mixed HEAD^一样</span></span><br><span class="line">git reset --hard HEAD^ <span class="comment"># 删除工作空间改动代码，撤销 commit，撤销 git add .</span></span><br></pre></td></tr></tbody></table></figure><h2 id="合并多条-commit">合并多条 commit</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></tbody></table></figure><h1 id="关于-ssh-key">关于 ssh-key</h1><p><strong>创建 key</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"something"</span></span><br></pre></td></tr></tbody></table></figure><p>-t 指定密钥类型，默认是 rsa -C 设置注释文字，比如邮箱</p><p>该命令会生成两个秘钥文件将 id_rsa.pub 文件内容复制到 github 或 gitlab 就可以通过 ssh 传输文件 对于 http 协议传输需要修改。git 目录下 config 文件格式为</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://username:password@github.com&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>git 不能 clone 代码，证书问题</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.sslverify <span class="literal">true</span></span><br><span class="line">$ git config --global http.sslCAPath /etc/pki/tls/certs</span><br></pre></td></tr></tbody></table></figure><h1 id="其他">其他</h1><p>Git 标签： 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息。</p><h2 id="创建标签-附注标签">创建标签： 附注标签</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m <span class="string">'my version 1.4'</span></span><br></pre></td></tr></tbody></table></figure><p>轻量标签：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4-lw</span><br></pre></td></tr></tbody></table></figure><p>后期打标签：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.29fceb02 (29fceb02 是一次提交的校验）</span><br></pre></td></tr></tbody></table></figure><p>共享标签 将标签提交到远程服务器：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.5</span><br></pre></td></tr></tbody></table></figure><p>一次性推送很多标签：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></tbody></table></figure><p>Git 别名 通过 git config 文件来轻松地为每一个命令设置一个别名。例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.ci commit</span><br></pre></td></tr></tbody></table></figure><p>这意味着，当要输入 git commit 时，只需要输入 git ci。</p><p>查询是否使用代理：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy</span><br></pre></td></tr></tbody></table></figure><p>取消代理：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></tbody></table></figure><p>使用代理</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:7891'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:7891'</span></span><br></pre></td></tr></tbody></table></figure><h1 id="git-提交规范">git 提交规范</h1><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">feat: 新功能（feature）</span><br><span class="line">fix: 修补 bug</span><br><span class="line">docs: 文档（documentation）</span><br><span class="line">style: 格式（不影响代码运行的变动）</span><br><span class="line">refactor: 重构（即不是新增功能，也不是修改 bug 的代码变动）</span><br><span class="line">chore: 构建过程或辅助工具的变动</span><br><span class="line">revert: 撤销，版本回退</span><br><span class="line">perf: 性能优化</span><br><span class="line"><span class="built_in">test</span>：测试</span><br><span class="line">improvement: 改进</span><br><span class="line">build: 打包</span><br><span class="line">ci: 持续集成</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
