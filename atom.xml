<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matrix</title>
  <icon>http://carlyleliu.vip/images/favicon_200x200.png</icon>
  <subtitle>CarlyleLiu‘s Blog</subtitle>
  <link href="http://carlyleliu.vip/atom.xml" rel="self"/>
  
  <link href="http://carlyleliu.vip/"/>
  <updated>2024-08-26T14:22:08.844Z</updated>
  <id>http://carlyleliu.vip/</id>
  
  <author>
    <name>CarlyleLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Odriver 之测速</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/odriverSpeed/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/odriverSpeed/</id>
    <published>2024-08-26T13:05:19.824Z</published>
    <updated>2024-08-26T14:22:08.844Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;传感器&quot;&gt;传感器&lt;/h1&gt;
&lt;h2 id=&quot;绝对磁编码器&quot;&gt;绝对磁编码器&lt;/h2&gt;
&lt;p&gt;绝对磁编码器比较简单，直接读寄存器就可以。实际使用中需要配合径向冲磁的磁铁使用，且最好能远离其他可能造成磁场变化的器件；其次需要注意角度更新频率，动态特性等参数。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Motor" scheme="http://carlyleliu.vip/tags/Motor/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Odriver" scheme="http://carlyleliu.vip/tags/Odriver/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
  </entry>
  
  <entry>
    <title>openshoe 算法</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/openshoe/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/openshoe/</id>
    <published>2024-08-26T13:05:19.824Z</published>
    <updated>2024-08-26T14:22:44.464Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;openshoe 是一种通过惯性测量元件 (IMU) 来对运动进行积分以得到路径的控制算法。算法的核心是 ZUPT（零速度更新算法），在只有 IMU 惯性测量元件的情况下获得路径只能通过对加速度积分得到速度，再将速度对时间进行积分得到路径，这里如果不能对积分得到的速度进行有效的校正那么这个速度误差会时刻对时间进行积分，导致路径完全失效，因此必须采取有效手段及时对速度误差进行校正以得到较为准确的路径信息，ZUPT 就是一种基于检测零速度进行路径积分校正的算法。该算法的关键是对零速度的准确检测。&lt;/p&gt;
&lt;h1 id=&quot;零速度检测算法&quot;&gt;零速度检测算法&lt;/h1&gt;
&lt;p&gt;openshoe 采用广义似然检测算法对零速度进行检测，以判断 IMU 是否处于静止状态。&lt;/p&gt;
&lt;h2 id=&quot;广义似然检测原理&quot;&gt;广义似然检测原理&lt;/h2&gt;
&lt;p&gt;要理解广义似然检测原理需要先熟悉几个概率论中相关的概念，详细如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
    <category term="IMU" scheme="http://carlyleliu.vip/tags/IMU/"/>
    
  </entry>
  
  <entry>
    <title>odriver 之 SVM</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/odriverSVM/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/odriverSVM/</id>
    <published>2024-08-26T13:05:19.814Z</published>
    <updated>2024-08-26T14:22:27.564Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;源码&quot;&gt;源码&lt;/h1&gt;
&lt;p&gt;SVM 函数的 alpha 和 beta 的值是经过了标幺化，基准值为 （最大相电压），也就是说 alpha 和 beta 的范围是 [-1,1]。约束：alpha-beta 向量的大小不得大于 $  $。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Motor" scheme="http://carlyleliu.vip/tags/Motor/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Odriver" scheme="http://carlyleliu.vip/tags/Odriver/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
  </entry>
  
  <entry>
    <title>foc 相关算法</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/focRelatedAlgorithms/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/focRelatedAlgorithms/</id>
    <published>2024-08-26T13:05:19.804Z</published>
    <updated>2024-08-26T14:21:08.144Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;mtpa&quot;&gt;MTPA&lt;/h1&gt;
&lt;h2 id=&quot;为什么要用-mtpa&quot;&gt;为什么要用 MTPA&lt;/h2&gt;
&lt;p&gt;当电机采用 id=0 的控制策略，这种控制方法忽略了磁阻转矩的作用，电磁转钜方程如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;tau _e = &#92;frac{3}{2}p[k_e &#92;cdot i_q + (L_d - L_q)&#92;cdot i_d &#92;cdot i_q]
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;转矩分为永磁转矩 Tr 和磁阻转矩 Tm，而 id=0 只剩下 Tr。这会导致电流的利用率不高，系统的效率降低。所以 id=0 的控制比较适用于隐极式电机（Ld=Lq），而对于凸极式电机并不最优，所以需要重新考虑控制策略。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Motor" scheme="http://carlyleliu.vip/tags/Motor/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
    <category term="FOC" scheme="http://carlyleliu.vip/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>IMU 姿态解算</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/imuAttitudeCalculation/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/imuAttitudeCalculation/</id>
    <published>2024-08-26T13:05:19.804Z</published>
    <updated>2024-08-26T14:21:20.884Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;imu-通过加速度计解算姿态角&quot;&gt;IMU 通过加速度计解算姿态角&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Image/imuOrigin.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过三角函数可以将加速度计三个轴的角速度解算为姿态角，其中 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha&#92;)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;beta&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;gamma&#92;)&lt;/span&gt;（ &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;gamma&#92;)&lt;/span&gt; 是 z 轴与重力加速度之间的夹角）与三个轴之间的关系如上图所示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
&amp;amp;&#92;beta = arcsin(&#92;frac{a_x}{g}) &#92;&#92;
&amp;amp;&#92;gamma  = arcsin(&#92;frac{a_y}{g})
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中重力加速度 $ g $ 的取值使用三轴角速度的矢量和即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
g = &#92;sqrt{a_x^{2} + a_y^{2} + a_z^{2}}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将 g 的值带入上式可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
&#92;begin{aligned}
&amp;amp;&#92;beta = arctan(&#92;frac{a_x}{&#92;sqrt{a_y^{2} + a_z^{2}}}) &#92;&#92;
&amp;amp;&#92;gamma  = arctan(&#92;frac{a_y}{&#92;sqrt{a_x^{2} + a_z^{2}}})
&#92;end{aligned}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 α 为俯仰角 pitch，β 为滚转角 roll，其中航向角 yaw 是没有办法通过加速度计来计算的。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Image" scheme="http://carlyleliu.vip/categories/Technology-Blog/Image/"/>
    
    <category term="Stabilization" scheme="http://carlyleliu.vip/categories/Technology-Blog/Image/Stabilization/"/>
    
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="IMU" scheme="http://carlyleliu.vip/tags/IMU/"/>
    
    <category term="EIS" scheme="http://carlyleliu.vip/tags/EIS/"/>
    
    <category term="Image" scheme="http://carlyleliu.vip/tags/Image/"/>
    
  </entry>
  
  <entry>
    <title>IMU 误差模型及校准</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/imuCalibration/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/imuCalibration/</id>
    <published>2024-08-26T13:05:19.804Z</published>
    <updated>2024-08-26T14:21:47.864Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;传感器误差模型&quot;&gt;传感器误差模型&lt;/h1&gt;
&lt;p&gt;对于理想的 IMU 三轴加速度计两两正交，构成一个正交的三轴直角坐标系，加速度计每一轴单独测量该轴的加速度，而陀螺仪则测量该轴的角速度。在实际的真实 IMU 中由于制造工艺的误差，三个坐标轴不可能完全两两正交，加速度计与陀螺仪的坐标系也不会完全重合，并且单个传感器也不是完全精确的。在实际器件中将数字输出量转化为实际物理量的 scale 参数在不同轴上是不同的，但是设备生产商都会提供一个默认的 scale 参数用于转换所有轴的数据，而且数字量的输出还会受到零偏（传感器在静止情况下也会有微小量的输出）的影响，这些就是造成 IMU 传感器的系统误差。&lt;/p&gt;
&lt;p&gt;我们取实际器件的加速度计坐标系为 AF, 陀螺仪坐标系为 GF，根据 AF 和 GF 分别建立对应的正交坐标系 AOF 和 GOF，其建立约束为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 的 x 轴与 AF 的 x 轴重合。&lt;/li&gt;
&lt;li&gt;AOF 的 y 轴位于 AF 的 x 与 y 轴的平面中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 GOF 的建立约束与 AOF 的约束类比建立。最后再建立一个正交机体坐标系 BF，BF 通常与 AF 和 GF 之间有一个小角度的偏差。在非正交坐标系（AF 或 GF）中测量得到的物理量&lt;span class=&quot;math inline&quot;&gt;&#92;(s^S&#92;)&lt;/span&gt;可以转换到机体坐标系 BF 中得到&lt;span class=&quot;math inline&quot;&gt;&#92;(s^B&#92;)&lt;/span&gt;于是得到下式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
s^B = Ts^S, 
T = &#92;begin{bmatrix}
1 &amp;amp; -&#92;beta_{yz}  &amp;amp; &#92;beta_{zy} &#92;&#92; 
&#92;beta_{xz} &amp;amp; 1 &amp;amp; -&#92;beta_{zx} &#92;&#92; 
-&#92;beta_{xy} &amp;amp; &#92;beta_{yx} &amp;amp; 1 
&#92;end{bmatrix}   &#92;tag{1}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(s^B 和 s^S&#92;)&lt;/span&gt; 表示加速度或角速度在机体坐标系 BF 和加速度坐标系 AF 或陀螺仪坐标系 GF 下测量表示量，&lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;beta_{ij}&#92;)&lt;/span&gt; 表示加速度或陀螺仪的 i 轴绕机体坐标系 BF 的 j 轴的旋转角度。如图二所示： &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Image/imuErr.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Image" scheme="http://carlyleliu.vip/categories/Technology-Blog/Image/"/>
    
    <category term="Stabilization" scheme="http://carlyleliu.vip/categories/Technology-Blog/Image/Stabilization/"/>
    
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="IMU" scheme="http://carlyleliu.vip/tags/IMU/"/>
    
    <category term="EIS" scheme="http://carlyleliu.vip/tags/EIS/"/>
    
    <category term="Image" scheme="http://carlyleliu.vip/tags/Image/"/>
    
  </entry>
  
  <entry>
    <title>FOC 电流采样</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/FOCCurrentSampling/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/FOCCurrentSampling/</id>
    <published>2024-08-26T13:05:19.794Z</published>
    <updated>2024-08-26T14:20:38.034Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;采样点&quot;&gt;采样点&lt;/h1&gt;
&lt;p&gt;在基尔霍夫定律下，三相电流的合应该等于 0，因此只需要获取亮相电流就可以重构出完整的三相电流。&lt;/p&gt;
&lt;p&gt;对于 STM32 一般通过高级定时器的 channel4 作为 ADC 的触发源，对于下桥臂电流采样，需要在下桥臂 MOS 管导筒的时候才能去采样，而且需要在 MOS 管导通时间以及电流稳定后才能采样到比较可靠的电流。 &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Algorithm/r3_2_1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Motor" scheme="http://carlyleliu.vip/tags/Motor/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
    <category term="FOC" scheme="http://carlyleliu.vip/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>FOC 原理</title>
    <link href="http://carlyleliu.vip/2024/Algorithm/focPrinciple/"/>
    <id>http://carlyleliu.vip/2024/Algorithm/focPrinciple/</id>
    <published>2024-08-26T13:05:19.794Z</published>
    <updated>2024-08-26T14:20:51.364Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;物理学基础概念&quot;&gt;物理学基础概念&lt;/h1&gt;
&lt;h2 id=&quot;左手定则&quot;&gt;左手定则&lt;/h2&gt;
&lt;p&gt;将左手的食指，中指和拇指伸直，使其在空间内相互垂直。食指方向代表磁场的方向（从 N 级到 S 级），中指代表电流的方向（从正极到负极），那拇指所指的方向就是受力的方向。可用于判断安培力（运动导体所受到的力）和洛伦兹力（运动电荷所受的力）。 &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Algorithm/leftHandRule.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;右手定则&quot;&gt;右手定则&lt;/h2&gt;
&lt;p&gt;伸开右手，使拇指与其余四个手指垂直，并且都与手掌在同一平面内；让磁感线垂直于手心进入，并使拇指指向导线运动方向，这时四指所指的方向就是感应电流的方向。用于判断导体在做切割磁场时产生的电流方向。 &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Algorithm/rightHandRule.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/categories/Technology-Blog/Robot/Actuator/"/>
    
    
    <category term="Motor" scheme="http://carlyleliu.vip/tags/Motor/"/>
    
    <category term="Robot" scheme="http://carlyleliu.vip/tags/Robot/"/>
    
    <category term="Actuator" scheme="http://carlyleliu.vip/tags/Actuator/"/>
    
    <category term="FOC" scheme="http://carlyleliu.vip/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>Encryption Algorithm</title>
    <link href="http://carlyleliu.vip/2024/Embedded/EncryptionAlgorithm/"/>
    <id>http://carlyleliu.vip/2024/Embedded/EncryptionAlgorithm/</id>
    <published>2024-08-23T12:22:04.000Z</published>
    <updated>2024-08-26T13:05:19.954Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;aes&quot;&gt;AES&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86&quot;&gt;AES（Advanced Encryption Standard）&lt;/a&gt;，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES。其密钥长度则可以是128，192或256比特。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/TEE/aes1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="TEE" scheme="http://carlyleliu.vip/categories/Technology-Blog/TEE/"/>
    
    
    <category term="TEE" scheme="http://carlyleliu.vip/tags/TEE/"/>
    
  </entry>
  
  <entry>
    <title>Secure Boot</title>
    <link href="http://carlyleliu.vip/2024/Embedded/SecureBoot/"/>
    <id>http://carlyleliu.vip/2024/Embedded/SecureBoot/</id>
    <published>2024-08-19T02:22:04.000Z</published>
    <updated>2024-08-26T13:05:19.994Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;目的&lt;/h1&gt;
&lt;p&gt;安全启动的根本目的是为了防止消费者从软硬件层面对产品的部分关键系统进行读写、调试等高权限的操作。以限制消费者的能力，来达到保护产品的商业机密、知识产权等厂家权益的目的。当然，厂家是不会这样宣传 Secure Boot 的。他们的文案通常都是通过这项技术保护用户的隐私，防止恶意软件修改系统软硬件等等。&lt;/p&gt;
&lt;p&gt;可以说，&lt;strong&gt;Secure Boot&lt;/strong&gt;&amp;nbsp;的安全模型建立在消费者是攻击者这一假设上。消费者在物理上拥有产品硬件，可以对产品进行物理连接、拆机、改装等等物理上的操作，比较专业的消费者甚至可以使用数字示波器监听 CPU 和 RAM 、eMMC 之间的数据传输来读取非常底层的数据传输。可以说跟传统的安全模型中的攻击者相比根本不在一个层面上。&lt;/p&gt;
&lt;p&gt;消费者作为攻击者的目的，一般常见的有刷机安装自定义的操作系统（Mod）、绕过厂家封闭的支付平台（IAP）和应用商城安装自定义的应用程序、绕过版权保护系统（DRM）达到复制厂家保护的数字产品内容等等。这些操作往往都会直接影响厂家的利益，因此需要一种能抵抗消费者攻击的安全机制。&lt;/p&gt;
&lt;p&gt;而且像 eMMC 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 eMMC 编程工具来读写上面的内容。&lt;/p&gt;
&lt;p&gt;Secure Boot 安全机制的原理，就是将最为核心的安全机制整合到最关键的主 CPU 中。因此就算攻击者可以监听电路板上的线路，甚至拆装个别芯片单独调试，也无法破坏 Secure Boot 的安全机制。&lt;/p&gt;
&lt;h1 id=&quot;ta的安全性&quot;&gt;TA的安全性&lt;/h1&gt;
&lt;p&gt;保证TA的安全需要做到三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一性：由设备厂商发布，确保是由设备厂商自己发布的，而不是经过客户自己替换的&lt;/li&gt;
&lt;li&gt;完整性：除了要保证TA是由设备厂商发布外还需要确保其内容没有经过改动，被用户修改了TA里面的内容&lt;/li&gt;
&lt;li&gt;保密性：内容经过加密，别人从系统中导出TA固件也无法获取真实的信息，无法解密&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="TEE" scheme="http://carlyleliu.vip/categories/Technology-Blog/TEE/"/>
    
    
    <category term="TEE" scheme="http://carlyleliu.vip/tags/TEE/"/>
    
  </entry>
  
  <entry>
    <title>TEE 软件交互流程</title>
    <link href="http://carlyleliu.vip/2024/Embedded/TEESoftPipeLine/"/>
    <id>http://carlyleliu.vip/2024/Embedded/TEESoftPipeLine/</id>
    <published>2024-08-17T02:22:04.000Z</published>
    <updated>2024-08-26T13:05:20.004Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;tee软件框架&quot;&gt;TEE软件框架&lt;/h1&gt;
&lt;p&gt;TEE 系统软件从整体上包含 REE 和 TEE 两部分，各自对应的基础组件如下图所示。 &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/TEE/tee_soft1.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REE 部分 Client Applications（CA） 一般是指指纹录入，支付应用等上层应用，其通过调用 TEE Client API 接口来与 TEE 环境的 Trusted OS 进行交互，这里的 TEE Client API 包括 TEE 厂商自定义的一些接口或 GlobalPlatform（GP） 全球组织定义的通用 API，其目的是制定一套标准的编程接口，方便开发者在不同软硬件平台下使用同一套代码实现其功能。&lt;/li&gt;
&lt;li&gt;TEE Client API 通过 ioctl 系统调用对 TEE Driver 进行操作，TEE Driver 是沟通 REE 和 TEE 的桥梁，其通过 SMC 指令，实现将上层的 OpenSession，InvokeCommand，CloseSession 等标准调用的请求转发到 TEE 环境，同时其也会处理来自 TEE 的请求，将请求转发到 TEE Helper Daemon 让其处理。&lt;/li&gt;
&lt;li&gt;TEE Helper Daemon 是一个辅助进程，用于 TEE 请求 REE 的资源。 一般来说，TEE 需要获得存储在 EMMC 的数据文件（例如安全加密文件，TA 可执行镜像文件等），而读写 EMMC 操作需要复杂的内核驱动的支持，显然如果把读写 EMMC 的驱动放到 TEE 侧运行会使软件复杂度会变得很高，因此 REE 需要一个可以访问这些资源的辅助进程支持，这就是 TEE Helper Daemon 的基本功能。TEE Helper Daemon 在软件逻辑实现上比较简单，以 OP-TEE 的 tee-supplicant 辅助进程为例，整体上是一个循环流程: 其首先通过 ioctl 接口查询是否有来自 TEE 的请求，如果没有，则进入睡眠等待状态，等待 TEE Driver 的唤醒信号，当 TEE Driver 收到来自 TEE 的请求后，会唤醒 tee-supplicant 辅助进程，然后根据请求号进行相应处理（读写数据文件，读写 EMMC 设备分区等），最后返回结果到 TEE Driver，完成一次循环，具体实现可参照《OP-TEE 中 tee-supplicant 执行流程》&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="TEE" scheme="http://carlyleliu.vip/categories/Technology-Blog/TEE/"/>
    
    
    <category term="TEE" scheme="http://carlyleliu.vip/tags/TEE/"/>
    
  </entry>
  
  <entry>
    <title>RPMB 简介</title>
    <link href="http://carlyleliu.vip/2024/Embedded/RPMB/"/>
    <id>http://carlyleliu.vip/2024/Embedded/RPMB/</id>
    <published>2024-08-15T02:22:04.000Z</published>
    <updated>2024-08-26T13:05:19.974Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;信息安全&quot;&gt;信息安全&lt;/h1&gt;
&lt;p&gt;信息安全的三个基本目标是机密性，完整性和可用性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机密性意味着只有授权实体才能阅读和理解保密的信息。没有访问权限的其他人无法阅读或理解机密信息；&lt;/li&gt;
&lt;li&gt;完整性意味着能够确保信息受到保护，以防止未经授权的更改，修改或删除。信息的完整性包括使用识别和认证等方法的起源，完整性和正确性；&lt;/li&gt;
&lt;li&gt;可用性意味着信息始终可供授权用户使用。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="TEE" scheme="http://carlyleliu.vip/categories/Technology-Blog/TEE/"/>
    
    
    <category term="TEE" scheme="http://carlyleliu.vip/tags/TEE/"/>
    
  </entry>
  
  <entry>
    <title>TEE 实现原理</title>
    <link href="http://carlyleliu.vip/2024/Embedded/TEEImplementationPrinciple/"/>
    <id>http://carlyleliu.vip/2024/Embedded/TEEImplementationPrinciple/</id>
    <published>2024-08-14T02:22:04.000Z</published>
    <updated>2024-08-26T13:05:20.004Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;trustzone&quot;&gt;TrustZone&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/TEE/tee1.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何区分当前访问状态是安全状态下的访问还是非安全状态下的访问&quot;&gt;如何区分当前访问状态是安全状态下的访问还是非安全状态下的访问？&lt;/h2&gt;
&lt;p&gt;CPU发出的地址都是虚拟地址，需要经过页表转换才能得到物理地址，其中在pte页表中低12bit（针对4k大小的页表）为控制位，用来控制页表的访问属性，也就是说在页表建立的时候就确定了访问状态是安全状态还是非安全状态，其pte低12bit如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/TEE/tee2.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="TEE" scheme="http://carlyleliu.vip/categories/Technology-Blog/TEE/"/>
    
    
    <category term="TEE" scheme="http://carlyleliu.vip/tags/TEE/"/>
    
  </entry>
  
  <entry>
    <title>Blog 搭建</title>
    <link href="http://carlyleliu.vip/2024/Tools/HexoNextUsage/"/>
    <id>http://carlyleliu.vip/2024/Tools/HexoNextUsage/</id>
    <published>2024-07-14T03:59:43.000Z</published>
    <updated>2024-08-26T13:05:20.484Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;安装-hexo&quot;&gt;安装 hexo&lt;/h1&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h1&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用 pandoc 渲染器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm un hexo-renderer-marked&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm i hexo-renderer-pandoc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm un hexo-renderer-pandoc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm i hexo-renderer-markdown-it-plus&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install pandoc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install prism&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# rss&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;卸载 hexo 默认 markdown 渲染器，安装 pandoc markdown 渲染器。hexo 默认的 markdown 渲染器不支持 Mathjax，不支持插件扩展，不支持 emoji 表情。pandoc markdown 渲染器支持 Mathjax 语法，不仅可以渲染 markdown，还支持 textile，reStructedText 和许多其他格式，仍然不支持 emoji 表情。&lt;/p&gt;
&lt;p&gt;此外还有其他 markdown 渲染器，hexo-renderer-markdown-it 支持 Mathjax 语法（支持不太好），支持 Markdown 以及 CommonMark 语法，渲染速度比 hexo-renderer-marked 快，支持插件配置，支持标题带安全的 id 信息，支持脚注（上标，下标，下划线）。 hexo-renderer-markdown-it-plus 支持 Katex 插件并默认启用，默认启用插件列表：markdown-it-emoji，markdown-it-sub，markdown-it-sup，markdown-it-deflist，markdown-it-abbr，markdown-it-footnote，markdown-it-ins，markdown-it-mark，&lt;span class=&quot;citation&quot; data-cites=&quot;iktakahiro/markdown-it-katex&quot;&gt;@iktakahiro/markdown-it-katex&lt;/span&gt;，markdown-it-toc-and-anchor。&lt;/p&gt;
&lt;p&gt;这里要吐槽一下各版本的 markdown 渲染器，对 latex 语法的支持真是一言难尽，pandoc 用了一段时间发现某些特性不支持打算换一个，然后 latex 公式各种崩，😔毁灭吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://carlyleliu.vip/categories/Share/"/>
    
    <category term="Tools" scheme="http://carlyleliu.vip/categories/Share/Tools/"/>
    
    
    <category term="Tools" scheme="http://carlyleliu.vip/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>NAS 有趣的 Docker 推荐</title>
    <link href="http://carlyleliu.vip/2024/Tools/NasDockerUsage/"/>
    <id>http://carlyleliu.vip/2024/Tools/NasDockerUsage/</id>
    <published>2024-07-01T03:59:43.000Z</published>
    <updated>2024-08-26T13:05:20.484Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;已迁移到notion page，请访问:&lt;a href=&quot;https://carlyleliu.notion.site/Docker-View-0db8f6c4c57241b2ab7e98a7c98660a7&quot;&gt;NAS 有趣的 Docker</summary>
        
      
    
    
    
    <category term="Share" scheme="http://carlyleliu.vip/categories/Share/"/>
    
    <category term="Tools" scheme="http://carlyleliu.vip/categories/Share/Tools/"/>
    
    
    <category term="Tools" scheme="http://carlyleliu.vip/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>UAC（九）UAC 常见问题</title>
    <link href="http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACCommonIssue/"/>
    <id>http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACCommonIssue/</id>
    <published>2024-06-30T05:15:01.000Z</published>
    <updated>2024-08-26T13:05:20.244Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;修改uac配置参数后无法正常通信&quot;&gt;修改UAC配置参数后无法正常通信&lt;/h1&gt;
&lt;p&gt;如果修改了UAC的配置后出现UAC无法正常通信的问题，可以通过修改设备的idVendor和idProduct来解决，只有设备的idVendor和idProduct发生改变Windows才会重新读取设备的配置描述符。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="USB" scheme="http://carlyleliu.vip/categories/Technology-Blog/USB/"/>
    
    
    <category term="USB" scheme="http://carlyleliu.vip/tags/USB/"/>
    
    <category term="UAC" scheme="http://carlyleliu.vip/tags/UAC/"/>
    
  </entry>
  
  <entry>
    <title>UAC（八）PPM 评估</title>
    <link href="http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACASYNCPPM/"/>
    <id>http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACASYNCPPM/</id>
    <published>2024-06-28T05:15:01.000Z</published>
    <updated>2024-08-26T13:05:20.244Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;usb-sof统计方法&quot;&gt;USB sof统计方法&lt;/h1&gt;
&lt;h2 id=&quot;打时间戳方式&quot;&gt;打时间戳方式&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;ktime_get_raw_ns()&lt;/strong&gt; Linux标准接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;meson_timestamp()&lt;/strong&gt; Amlogic实现的硬件定时器接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;sof打时间戳的时机&quot;&gt;sof打时间戳的时机&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;直接在SOF中断handle里打时间戳，然后将其保存到一个fifo里。&lt;/li&gt;
&lt;li&gt;通过一个hrtimer，主动查询SOF中断寄存器查看是否有SOF包，如果有SOF包则打上时间戳保存到fifo里。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;sof时间戳导出到应用层&quot;&gt;sof时间戳导出到应用层&lt;/h2&gt;
&lt;p&gt;通过seq file创建一个proc（/proc/sof_ts）文件，应用通过读取该文件来获取sof时间戳。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="USB" scheme="http://carlyleliu.vip/categories/Technology-Blog/USB/"/>
    
    
    <category term="USB" scheme="http://carlyleliu.vip/tags/USB/"/>
    
    <category term="UAC" scheme="http://carlyleliu.vip/tags/UAC/"/>
    
  </entry>
  
  <entry>
    <title>UAC（七）Async Feedback</title>
    <link href="http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACASYNCFeedback/"/>
    <id>http://carlyleliu.vip/2024/LinuxDriver/LinuxUSBUACASYNCFeedback/</id>
    <published>2024-06-19T05:15:01.000Z</published>
    <updated>2024-08-26T13:05:20.244Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;buffer-统计&quot;&gt;buffer 统计&lt;/h1&gt;
&lt;p&gt;采样间隔 1ms、采样 buffer 里的数据长度 &lt;img src=&quot;http://carlyleliu.com:11313/ImageHosting/TechnologyBlog/Linux/AudioBufferUsage.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="USB" scheme="http://carlyleliu.vip/categories/Technology-Blog/USB/"/>
    
    
    <category term="USB" scheme="http://carlyleliu.vip/tags/USB/"/>
    
    <category term="UAC" scheme="http://carlyleliu.vip/tags/UAC/"/>
    
  </entry>
  
  <entry>
    <title>Linux 驱动之基础（二）DMA-API</title>
    <link href="http://carlyleliu.vip/2024/LinuxDriver/LinuxDriverBaseDMA-API/"/>
    <id>http://carlyleliu.vip/2024/LinuxDriver/LinuxDriverBaseDMA-API/</id>
    <published>2024-05-02T15:20:16.000Z</published>
    <updated>2024-08-26T13:05:20.094Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;there-are-two-types-of-dma-mappings&quot;&gt;😊 There are two types of DMA mappings&lt;/h1&gt;
&lt;p&gt;Consistent DM（硬件保证 cache 一致性） mappings which are usually mapped at driver initialization, unmapped at the end and for which the hardware should guarantee that the device and the CPU can access the data in parallel and will see updates made by each other without any explicit software flushing.&lt;/p&gt;
&lt;p&gt;Streaming DMA（需要软件来维护 cache 一致性） mappings which are usually mapped for one DMA transfer, unmapped right after it (unless you use dma_sync_* below) and for which hardware can optimize for sequential accesses.&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Linux" scheme="http://carlyleliu.vip/categories/Technology-Blog/Linux/"/>
    
    <category term="Driver" scheme="http://carlyleliu.vip/categories/Technology-Blog/Linux/Driver/"/>
    
    
    <category term="Linux" scheme="http://carlyleliu.vip/tags/Linux/"/>
    
    <category term="Driver" scheme="http://carlyleliu.vip/tags/Driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux 驱动之基础（一）Device-I/O</title>
    <link href="http://carlyleliu.vip/2024/LinuxDriver/LinuxDriverBaseDeviceIO/"/>
    <id>http://carlyleliu.vip/2024/LinuxDriver/LinuxDriverBaseDeviceIO/</id>
    <published>2024-04-22T13:23:06.000Z</published>
    <updated>2024-08-26T13:05:20.094Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;memory-mapped-io&quot;&gt;Memory Mapped IO&lt;/h1&gt;
&lt;h2 id=&quot;getting-access-to-the-device&quot;&gt;Getting Access to the Device&lt;/h2&gt;
&lt;p&gt;This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap(). An address suitable for accessing the device will be returned to you.&lt;/p&gt;
&lt;p&gt;After you&#39;ve finished using the device (say, in your module&#39;s exit routine), call iounmap() in order to return the address space to the kernel. Most architectures allocate new address space each time you call ioremap(), and they can run out unless you call iounmap().&lt;/p&gt;</summary>
    
    
    
    <category term="Technology Blog" scheme="http://carlyleliu.vip/categories/Technology-Blog/"/>
    
    <category term="Linux" scheme="http://carlyleliu.vip/categories/Technology-Blog/Linux/"/>
    
    <category term="Driver" scheme="http://carlyleliu.vip/categories/Technology-Blog/Linux/Driver/"/>
    
    
    <category term="Linux" scheme="http://carlyleliu.vip/tags/Linux/"/>
    
    <category term="Driver" scheme="http://carlyleliu.vip/tags/Driver/"/>
    
  </entry>
  
</feed>
